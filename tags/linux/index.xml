<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>Linux - 标签 - This Cute World</title><link>https://thiscute.world/tags/linux/</link><description>Linux - 标签 - This Cute World</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaoyin_c@qq.com (ryan4yin)</managingEditor><webMaster>xiaoyin_c@qq.com (ryan4yin)</webMaster><lastBuildDate>Sun, 15 Aug 2021 19:11:29 +0800</lastBuildDate><atom:link href="https://thiscute.world/tags/linux/" rel="self" type="application/rss+xml"/><item><title>iptables 及 docker 容器网络分析</title><link>https://thiscute.world/posts/iptables-and-container-networks/</link><pubDate>Sun, 15 Aug 2021 19:11:29 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/iptables-and-container-networks/</guid><description><![CDATA[<blockquote>
<p>本文仅针对 ipv4 网络</p>
</blockquote>
<p>本文先介绍 iptables 的基本概念及常用命令，然后分析 docker/podman 是如何利用 iptables 和 Linux 虚拟网络接口实现的单机容器网络。</p>
<h1 id="一iptables">一、iptables</h1>
<p><a href="https://www.netfilter.org/projects/iptables/index.html" target="_blank" rel="noopener noreferrer">iptables</a> 提供了包过滤、NAT 以及其他的包处理能力，iptables 应用最多的两个场景是 firewall 和 NAT</p>
<p>iptables 及新的 nftables 都是基于 netfilter 开发的，是 netfilter 的子项目。</p>
<p>但是 eBPF 社区目前正在开发旨在取代 netfilter 的新项目 bpfilter，他们的目标之一是兼容 iptables/nftables 规则，让我们拭目以待吧。</p>
<h2 id="iptables-基础概念---四表五链">iptables 基础概念 - 四表五链</h2>
<blockquote>
<p>实际上还有张 SELinux 相关的 security 表（应该是较新的内核新增的，但是不清楚是哪个版本加的），但是我基本没接触过，就略过了。</p>
</blockquote>
<p>详细的说明参见 <a href="https://www.zsythink.net/archives/1199" target="_blank" rel="noopener noreferrer">iptables详解（1）：iptables概念 - 朱双印</a>，这篇文章写得非常棒！把 iptables 讲清楚了。</p>
<p>默认情况下，iptables 提供了四张表（不考虑 security 的话）和五条链，数据在这四表五链中的处理流程如下图所示：</p>
<blockquote>
<p>在这里的介绍中，可以先忽略掉图中 link layer 层的链路，它属于 ebtables 的范畴。另外 <code>conntrack</code> 也暂时忽略，在下一小节会详细介绍 conntrack 的功能。</p>
</blockquote>
<p><figure><a class="lightgallery" href="/images/netfilter/netfilter-packet-flow.png" title="/images/netfilter/netfilter-packet-flow.png" data-thumbnail="/images/netfilter/netfilter-packet-flow.png" data-sub-html="<h2>netfilter 数据包处理流程，来自 wikipedia</h2>">
        
    </a><figcaption class="image-caption">netfilter 数据包处理流程，来自 wikipedia</figcaption>
    </figure></p>
<p>对照上图，对于发送到某个用户层程序的数据而言，流量顺序如下：</p>
<ul>
<li>首先进入 PREROUTING 链，依次经过这三个表： raw -&gt; mangle -&gt; nat</li>
<li>然后进入 INPUT 链，这个链上也有三个表，处理顺序是：mangle -&gt; nat -&gt; filter</li>
<li>过了 INPUT 链后，数据才会进入内核协议栈，最终到达用户层程序。</li>
</ul>
<p>用户层程序发出的报文，则依次经过这几个表：OUTPUT -&gt; POSTROUTING</p>
<p>从图中也很容易看出，如果数据 dst ip 不是本机任一接口的 ip，那它通过的几个链依次是：PREROUTEING -&gt; FORWARD -&gt; POSTROUTING</p>
<p>五链的功能和名称完全一致，应该很容易理解。下面按优先级分别介绍下链中的四个表：</p>
<ul>
<li>raw: 对收到的数据包在连接跟踪前进行处理。一般用不到，可以忽略
<ul>
<li>一旦用户使用了 raw raw 表处理完后，将跳过 nat 表和 ip_conntrack 处理，即不再做地址转换和数据包的链接跟踪处理了</li>
</ul>
</li>
<li>mangle: 用于修改报文、给报文打标签</li>
<li>nat: 主要用于做网络地址转换，SNAT 或者 DNAT</li>
<li>filter: 主要用于过滤数据包</li>
</ul>
<p>数据在按优先级经过四个表的处理时，一旦在某个表中匹配到一条规则 A,下一条处理规则就由规则 A 的 target 参数指定，<strong>后续的所有表</strong>都会被忽略。target 有如下几种类型：</p>
<ul>
<li>ACCEPT: 直接允许数据包通过</li>
<li>DROP: 直接丢弃数据包，对程序而言就是 100% 丢包</li>
<li>REJECT: 丢弃数据包，但是会给程序返回  RESET。这个对程序更友好，但是存在安全隐患，通常不使用。</li>
<li>MASQUERADE: （伪装）将 src ip 改写为网卡 ip，和 SNAT 的区别是它会自动读取网卡 ip。路由设备必备。</li>
<li>SNAT/DNAT: 顾名思义，做网络地址转换</li>
<li>REDIRECT: 在本机做端口映射</li>
<li>LOG: 在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。
<ul>
<li>只有这个 target 特殊一些，匹配它的数据仍然可以匹配后续规则，不会直接跳过。</li>
</ul>
</li>
<li>其他类型，可以用到的时候再查</li>
</ul>
<p>理解了上面这张图，以及四个表的用途，就很容易理解 iptables 的命令了。</p>
<h2 id="常用命令">常用命令</h2>
<blockquote>
<p><strong>注意</strong>: 下面提供的 iptables 命令做的修改是未持久化的，重启就会丢失！在下一节会简单介绍持久化配置的方法。</p>
</blockquote>
<p>命令格式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">iptables <span class="o">[</span>-t table<span class="o">]</span> <span class="o">{</span>-A<span class="p">|</span>-C<span class="p">|</span>-D<span class="o">}</span> chain <span class="o">[</span>-m matchname <span class="o">[</span>per-match-options<span class="o">]]</span> -j targetname <span class="o">[</span>per-target-options<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>其中 table 默认为 <code>filter</code> 表，其中系统管理员实际使用最多的是 INPUT 链，用于设置防火墙。</p>
<p>以下简单介绍在 INPUT 链上添加、修改规则，来设置防火墙：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># --add 允许 80 端口通过</span>
iptables -A INPUT -p tcp --dport <span class="m">80</span> -j ACCEPT

<span class="c1"># --list-rules 查看所有规则</span>
iptables -S

<span class="c1"># --list-rules 查看 INPUT 表中的所有规则</span>
iptables -S INPUT
<span class="c1"># 查看 iptables 中的所有规则（比 -L 更详细）</span>

<span class="c1"># ---delete 通过编号删除规则</span>
iptables -D <span class="m">1</span>
<span class="c1"># 或者通过完整的规则参数来删除规则</span>
iptables -D INPUT -p tcp --dport <span class="m">80</span> -j ACCEPT

<span class="c1"># --replace 通过编号来替换规则内容</span>
iptables -R INPUT <span class="m">1</span> -s 192.168.0.1 -j DROP

<span class="c1"># --insert 在指定的位置插入规则，可类比链表的插入</span>
iptables -I INPUT <span class="m">1</span> -p tcp --dport <span class="m">80</span> -j ACCEPT

<span class="c1"># 在匹配条件前面使用感叹号表示取反</span>
<span class="c1"># 如下规则表示接受所有来自 docker0，但是目标接口不是 docker0 的流量</span>
iptables -A FORWARD -i docker0 ! -o docker0 -j ACCEPT

<span class="c1"># --policy 设置某个链的默认规则</span>
<span class="c1"># 很多系统管理员会习惯将连接公网的服务器，默认规则设为 DROP，提升安全性，避免错误地开放了端口。</span>
<span class="c1"># 但是也要注意，默认规则设为 DROP 前，一定要先把允许 ssh 端口的规则加上，否则就尴尬了。</span>
iptables -P INPUT DROP

<span class="c1"># --flush 清空 INPUT 表上的所有规则</span>
iptables -F INPUT
</code></pre></td></tr></table>
</div>
</div><hr>
<blockquote>
<p>本文后续分析时，假设用户已经清楚 linux bridge、veth 等虚拟网络接口相关知识。
如果你还缺少这些前置知识，请先阅读文章 <a href="https://thiscute.world/posts/linux-virtual-network-interfaces/" target="_blank" rel="noopener noreferrer">Linux 中的虚拟网络接口</a>。</p>
</blockquote>
<h2 id="conntrack-连接跟踪与-nat">conntrack 连接跟踪与 NAT</h2>
<p>在讲 conntrack 之间，我们再回顾下前面给出过的 netfilter 数据处理流程图：</p>
<p><figure><a class="lightgallery" href="/images/netfilter/netfilter-packet-flow.png" title="/images/netfilter/netfilter-packet-flow.png" data-thumbnail="/images/netfilter/netfilter-packet-flow.png" data-sub-html="<h2>netfilter 数据包处理流程，来自 wikipedia</h2>">
        
    </a><figcaption class="image-caption">netfilter 数据包处理流程，来自 wikipedia</figcaption>
    </figure></p>
<p>上一节中我们忽略了图中的 conntrack，它就是本节的主角——netfilter 的连接跟踪（connection tracking）模块。</p>
<p>netfilter/conntrack 是 iptables 实现 SNAT/DNAT/MASQUERADE 的前提条件，上面的流程图显示， conntrack 在 PREROUTEING 和 OUTPUT 链的 raw 表之后生效。</p>
<p>下面以 docker 默认的 bridge 网络为例详细介绍下 conntrack 的功能。</p>
<p>首先，这是我在「Linux 的虚拟网络接口」文中给出过的 docker0 网络架构图:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">+-----------------------------------------------+-----------------------------------+-----------------------------------+
|                      Host                     |           Container A             |           Container B             |
|                                               |                                   |                                   |
|   +---------------------------------------+   |    +-------------------------+    |    +-------------------------+    |
|   |       Network Protocol Stack          |   |    |  Network Protocol Stack |    |    |  Network Protocol Stack |    |
|   +----+-------------+--------------------+   |    +-----------+-------------+    |    +------------+------------+    |
|        ^             ^                        |                ^                  |                 ^                 |
|........|.............|........................|................|..................|.................|.................|
|        v             v  ↓                     |                v                  |                 v                 |
|   +----+----+  +-----+------+                 |          +-----+-------+          |           +-----+-------+         |
|   | .31.101 |  | 172.17.0.1 |      +------+   |          | 172.17.0.2  |          |           |  172.17.0.3 |         |
|   +---------+  +-------------&lt;----&gt;+ veth |   |          +-------------+          |           +-------------+         |
|   |  eth0   |  |   docker0  |      +--+---+   |          | eth0(veth)  |          |           | eth0(veth)  |         |
|   +----+----+  +-----+------+         ^       |          +-----+-------+          |           +-----+-------+         |
|        ^             ^                |       |                ^                  |                 ^                 |
|        |             |                +------------------------+                  |                 |                 |
|        |             v                        |                                   |                 |                 |
|        |          +--+---+                    |                                   |                 |                 |
|        |          | veth |                    |                                   |                 |                 |
|        |          +--+---+                    |                                   |                 |                 |
|        |             ^                        |                                   |                 |                 |
|        |             +------------------------------------------------------------------------------+                 |
|        |                                      |                                   |                                   |
|        |                                      |                                   |                                   |
+-----------------------------------------------+-----------------------------------+-----------------------------------+
         v
    Physical Network  (192.168.31.0/24)
</code></pre></td></tr></table>
</div>
</div><p>docker 会在 iptables 中为 docker0 网桥添加如下规则：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">-t nat -A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE

-t filter -P DROP
-t filter -A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
</code></pre></td></tr></table>
</div>
</div><p>这几行规则使 docker 容器能正常访问外部网络。<code>MASQUERADE</code> 在请求出网时，会自动做 <code>SNAT</code>，将 src ip 替换成出口网卡的 ip.
这样数据包能正常出网，而且对端返回的数据包现在也能正常回到出口网卡。</p>
<p>现在问题就来了：<strong>出口网卡收到返回的数据包后，还能否将数据包转发到数据的初始来源端——某个 docker 容器</strong>？难道 docker 还额外添加了与 MASQUERADE 对应的 dst ip 反向转换规则？</p>
<p>实际上这一步依赖的是本节的主角——iptables 提供的 conntrack 连接跟踪功能（在「参考」中有一篇文章详细介绍了此功能）。</p>
<p>连接跟踪对 NAT 的贡献是：在做 NAT 转换时，无需手动添加额外的规则来执行<strong>反向转换</strong>以实现数据的双向传输。netfilter/conntrack 系统会记录 NAT 的连接状态，NAT 地址的反向转换是根据这个状态自动完成的。</p>
<p>比如上图中的 <code>Container A</code> 通过 bridge 网络向 baidu.com 发起了 N 个连接，这时数据的处理流程如下：</p>
<ul>
<li>首先 <code>Container A</code> 发出的数据包被 MASQUERADE 规则处理，将 src ip 替换成 eth0 的 ip，然后发送到物理网络 <code>192..168.31.0/24</code>。
<ul>
<li>conntrack 系统记录此连接被 NAT 处理前后的状态信息，并将其状态设置为 NEW，表示这是新发起的一个连接</li>
</ul>
</li>
<li>对端 baidu.com 返回数据包后，会首先到达 eth0 网卡</li>
<li>conntrack 查表，发现返回数据包的连接已经记录在表中并且状态为 NEW，于是它将连接的状态修改为 ESTABLISHED，并且将 dst_ip 改为 <code>172.17.0.2</code> 然后发送出去
<ul>
<li>注意，这个和 tcp 的 ESTABLISHED 没任何关系</li>
</ul>
</li>
<li>经过路由匹配，数据包会进入到 docker0，然后匹配上 iptables 规则：<code>-t filter -A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</code>，数据直接被放行</li>
<li>数据经过 veth 后，最终进入到 <code>Container A</code> 中，交由容器的内核协议栈处理。</li>
<li>数据被 <code>Container A</code> 的内核协议栈发送到「发起连接的应用程序」。</li>
</ul>
<h3 id="实际测试-conntrack">实际测试 conntrack</h3>
<p>现在我们来实际测试一下，看看是不是这么回事：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 使用 tcpdump 分别在出口网卡 wlp4s0 （相当于 eth0）和 dcoker0 网桥上抓包，后面会用来分析</span>
❯ sudo tcpdump -i wlp4s0 -n &gt; wlp4s0.dump   <span class="c1"># 窗口一，抓 wlp4s0 的包</span>
❯ sudo tcpdump -i docker0 -n &gt; docker0.dump  <span class="c1"># 窗口二，抓 docker0 的包</span>
</code></pre></td></tr></table>
</div>
</div><p>现在新建窗口三，启动一个容器，通过 curl 命令低速下载一个视频文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">❯ docker run --rm --name curl -it curlimages/curl &#34;https://media.w3.org/2010/05/sintel/trailer.mp4&#34; -o /tmp/video.mp4 --limit-rate 100k
</code></pre></td></tr></table>
</div>
</div><p>然后新建窗口四，在宿主机查看 conntrack 状态</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">❯ sudo zypper in conntrack-tools  <span class="c1"># 这个记得先提前安装好</span>
❯ sudo conntrack -L <span class="p">|</span> grep 172.17
<span class="c1"># curl 通过 NAT 网络发起了一个 dns 查询请求，DNS 服务器是网关上的 192.168.31.1</span>
udp      <span class="m">17</span> <span class="m">22</span> <span class="nv">src</span><span class="o">=</span>172.17.0.4 <span class="nv">dst</span><span class="o">=</span>192.168.31.1 <span class="nv">sport</span><span class="o">=</span><span class="m">59423</span> <span class="nv">dport</span><span class="o">=</span><span class="m">53</span> <span class="nv">src</span><span class="o">=</span>192.168.31.1 <span class="nv">dst</span><span class="o">=</span>192.168.31.228 <span class="nv">sport</span><span class="o">=</span><span class="m">53</span> <span class="nv">dport</span><span class="o">=</span><span class="m">59423</span> <span class="o">[</span>ASSURED<span class="o">]</span> <span class="nv">mark</span><span class="o">=</span><span class="m">0</span> <span class="nv">use</span><span class="o">=</span><span class="m">1</span>
<span class="c1"># curl 通过 NAT 网络向 media.w3.org 发起了 tcp 连接</span>
tcp      <span class="m">6</span> <span class="m">298</span> ESTABLISHED <span class="nv">src</span><span class="o">=</span>172.17.0.4 <span class="nv">dst</span><span class="o">=</span>198.18.5.130 <span class="nv">sport</span><span class="o">=</span><span class="m">54636</span> <span class="nv">dport</span><span class="o">=</span><span class="m">443</span> <span class="nv">src</span><span class="o">=</span>198.18.5.130 <span class="nv">dst</span><span class="o">=</span>192.168.31.228 <span class="nv">sport</span><span class="o">=</span><span class="m">443</span> <span class="nv">dport</span><span class="o">=</span><span class="m">54636</span> <span class="o">[</span>ASSURED<span class="o">]</span> <span class="nv">mark</span><span class="o">=</span><span class="m">0</span> <span class="nv">use</span><span class="o">=</span><span class="m">1</span>
</code></pre></td></tr></table>
</div>
</div><p>等 curl 命令跑个十来秒，然后关闭所有窗口及应用程序，接下来进行数据分析：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 前面查到的，本地发起请求的端口是 54636，下面以此为过滤条件查询数据</span>

<span class="c1"># 首先查询 wlp4s0/eth0 进来的数据，可以看到本机的 dst_ip 为 192.168.31.228.54636</span>
❯ cat wlp4s0.dump <span class="p">|</span> grep <span class="m">54636</span> <span class="p">|</span> head -n <span class="m">15</span>
18:28:28.349321 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>S<span class="o">]</span>, seq 750859357, win 64240, options <span class="o">[</span>mss 1460,sackOK,TS val <span class="m">3365688110</span> ecr 0,nop,wscale 7<span class="o">]</span>, length <span class="m">0</span>
18:28:28.350757 IP 198.18.5.130.443 &gt; 192.168.31.228.54636: Flags <span class="o">[</span>S.<span class="o">]</span>, seq 2381759932, ack 750859358, win 28960, options <span class="o">[</span>mss 1460,sackOK,TS val <span class="m">22099541</span> ecr 3365688110,nop,wscale 5<span class="o">]</span>, length <span class="m">0</span>
18:28:28.350814 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>.<span class="o">]</span>, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688111</span> ecr 22099541<span class="o">]</span>, length <span class="m">0</span>
18:28:28.357345 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 1:518, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688118</span> ecr 22099541<span class="o">]</span>, length <span class="m">517</span>
18:28:28.359253 IP 198.18.5.130.443 &gt; 192.168.31.228.54636: Flags <span class="o">[</span>.<span class="o">]</span>, ack 518, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099542</span> ecr 3365688118<span class="o">]</span>, length <span class="m">0</span>
18:28:28.726544 IP 198.18.5.130.443 &gt; 192.168.31.228.54636: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 1:2622, ack 518, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099579</span> ecr 3365688118<span class="o">]</span>, length <span class="m">2621</span>
18:28:28.726616 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>.<span class="o">]</span>, ack 2622, win 482, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688487</span> ecr 22099579<span class="o">]</span>, length <span class="m">0</span>
18:28:28.727652 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 518:598, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">80</span>
18:28:28.727803 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 598:644, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">46</span>
18:28:28.727828 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 644:693, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">49</span>
18:28:28.727850 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 693:728, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">35</span>
18:28:28.727875 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 728:812, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">84</span>
18:28:28.729241 IP 198.18.5.130.443 &gt; 192.168.31.228.54636: Flags <span class="o">[</span>.<span class="o">]</span>, ack 598, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099579</span> ecr 3365688488<span class="o">]</span>, length <span class="m">0</span>
18:28:28.729245 IP 198.18.5.130.443 &gt; 192.168.31.228.54636: Flags <span class="o">[</span>.<span class="o">]</span>, ack 644, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099579</span> ecr 3365688488<span class="o">]</span>, length <span class="m">0</span>
18:28:28.729247 IP 198.18.5.130.443 &gt; 192.168.31.228.54636: Flags <span class="o">[</span>.<span class="o">]</span>, ack 693, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099579</span> ecr 3365688488<span class="o">]</span>, length <span class="m">0</span>


<span class="c1"># 然后再查询 docker0 上的数据，能发现本地的地址为 172.17.0.4.54636</span>
❯ cat docker0.dump <span class="p">|</span> grep <span class="m">54636</span> <span class="p">|</span> head -n <span class="m">20</span>
18:28:28.349299 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>S<span class="o">]</span>, seq 750859357, win 64240, options <span class="o">[</span>mss 1460,sackOK,TS val <span class="m">3365688110</span> ecr 0,nop,wscale 7<span class="o">]</span>, length <span class="m">0</span>
18:28:28.350780 IP 198.18.5.130.443 &gt; 172.17.0.4.54636: Flags <span class="o">[</span>S.<span class="o">]</span>, seq 2381759932, ack 750859358, win 28960, options <span class="o">[</span>mss 1460,sackOK,TS val <span class="m">22099541</span> ecr 3365688110,nop,wscale 5<span class="o">]</span>, length <span class="m">0</span>
18:28:28.350812 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>.<span class="o">]</span>, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688111</span> ecr 22099541<span class="o">]</span>, length <span class="m">0</span>
18:28:28.357328 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 1:518, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688118</span> ecr 22099541<span class="o">]</span>, length <span class="m">517</span>
18:28:28.359281 IP 198.18.5.130.443 &gt; 172.17.0.4.54636: Flags <span class="o">[</span>.<span class="o">]</span>, ack 518, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099542</span> ecr 3365688118<span class="o">]</span>, length <span class="m">0</span>
18:28:28.726578 IP 198.18.5.130.443 &gt; 172.17.0.4.54636: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 1:2622, ack 518, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099579</span> ecr 3365688118<span class="o">]</span>, length <span class="m">2621</span>
18:28:28.726610 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>.<span class="o">]</span>, ack 2622, win 482, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688487</span> ecr 22099579<span class="o">]</span>, length <span class="m">0</span>
18:28:28.727633 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 518:598, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">80</span>
18:28:28.727798 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 598:644, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">46</span>
18:28:28.727825 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 644:693, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">49</span>
18:28:28.727847 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 693:728, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">35</span>
18:28:28.727871 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 728:812, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">84</span>
18:28:28.729308 IP 198.18.5.130.443 &gt; 172.17.0.4.54636: Flags <span class="o">[</span>.<span class="o">]</span>, ack 598, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099579</span> ecr 3365688488<span class="o">]</span>, length <span class="m">0</span>
18:28:28.729324 IP 198.18.5.130.443 &gt; 172.17.0.4.54636: Flags <span class="o">[</span>.<span class="o">]</span>, ack 644, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099579</span> ecr 3365688488<span class="o">]</span>, length <span class="m">0</span>
18:28:28.729328 IP 198.18.5.130.443 &gt; 172.17.0.4.54636: Flags <span class="o">[</span>.<span class="o">]</span>, ack 693, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099579</span> ecr 3365688488<span class="o">]</span>, length <span class="m">0</span>
</code></pre></td></tr></table>
</div>
</div><p>能看到数据确实在进入 docker0 网桥前，dst_ip 确实被从 <code>192.168.31.228</code>（wlp4s0 的 ip）被修改为了 <code>172.17.0.4</code>（<code>Container A</code> 的 ip）.</p>
<h3 id="nat-如何分配端口">NAT 如何分配端口？</h3>
<p>上一节我们实际测试发现，docker 容器的流量在经过 iptables 的 MASQUERADE 规则处理后，只有 src ip 被修改了，而 port 仍然是一致的。</p>
<p>但是如果 NAT 不修改连接的端口，实际上是会有问题的。如果有两个容器同时向 <code>ip: 198.18.5.130, port: 443</code> 发起请求，又恰好使用了同一个 src port，在宿主机上就会出现端口冲突！
因为这两个请求被 SNAT 时，如果只修改 src ip，那它们映射到的将是主机上的同一个连接！</p>
<p>这个问题 NAT 是如何解决的呢？我想如果遇到这种情况，NAT 应该会通过一定的规则选用一个不同的端口。</p>
<p>有空可以翻一波源码看看这个，待续&hellip;</p>
<h2 id="如何持久化-iptables-配置">如何持久化 iptables 配置</h2>
<p>首先需要注意的是，centos7/opensuse 15 都已经切换到了 firewalld 作为防火墙配置软件，
而 ubuntu18.04 lts 也换成了 ufw 来配置防火墙。</p>
<p>包括 docker 应该也是在启动的时候动态添加 iptables 配置。</p>
<p>对于上述新系统，还是建议直接使用 firewalld/ufw 配置防火墙吧，或者网上搜下关闭 ufw/firewalld、启用 iptables 持久化的解决方案。</p>
<p>本文主要目的在于理解 docker 容器网络的原理，以及为后面理解 kubernetes 网络插件 calico/flannel 打好基础，因此就不多介绍持久化了。</p>
<h2 id="如何使用-iptables--bridge--veth-实现容器网络">如何使用 iptables + bridge + veth 实现容器网络</h2>
<p>Docker/Podman 默认使用的都是 bridge 网络，它们的底层实现完全类似。下面以 docker 为例进行分析（Podman 的分析流程也基本一样）。</p>
<h3 id="通过-docker-run-运行容器">通过 docker run 运行容器</h3>
<p>首先，使用 <code>docker run</code> 运行几个容器，检查下网络状况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 运行一个 debian 容器和一个 nginx</span>
❯ docker run -dit --name debian --rm debian:buster sleep <span class="m">1000000</span>
❯ docker run -dit --name nginx --rm nginx:1.19-alpine 

<span class="c1">#　查看网络接口，有两个 veth 接口（而且都没设 ip 地址），分别连接到两个容器的 eth0（dcoker0 网络架构图前面给过了，可以往前面翻翻对照下）</span>
❯ ip addr ls
...
5: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default 
    link/ether 02:42:42:c7:12:ba brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:42ff:fec7:12ba/64 scope link 
       valid_lft forever preferred_lft forever
100: veth16b37ea@if99: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master docker0 state UP group default 
    link/ether 42:af:34:ae:74:ae brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">0</span>
    inet6 fe80::40af:34ff:feae:74ae/64 scope link 
       valid_lft forever preferred_lft forever
102: veth4b4dada@if101: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master docker0 state UP group default 
    link/ether 9e:f1:58:1a:cf:ae brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">1</span>
    inet6 fe80::9cf1:58ff:fe1a:cfae/64 scope link 
       valid_lft forever preferred_lft forever

<span class="c1"># 两个 veth 接口都连接到了 docker0 上面，说明两个容器都使用了 docker 默认的 bridge 网络</span>
❯ sudo brctl show
bridge name     bridge id               STP enabled     interfaces
docker0         8000.024242c712ba       no              veth16b37ea
                                                        veth4b4dada

<span class="c1"># 查看路由规则</span>
❯ ip route ls
default via 192.168.31.1 dev wlp4s0 proto dhcp metric <span class="m">600</span>
<span class="c1">#下列路由规则将 `172.17.0.0/16` 网段的所有流量转发到 docker0</span>
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown 
192.168.31.0/24 dev wlp4s0 proto kernel scope link src 192.168.31.228 metric <span class="m">600</span> 

<span class="c1"># 查看　iptables 规则</span>
<span class="c1"># NAT 表</span>
❯ sudo iptables -t nat -S
-P PREROUTING ACCEPT
-P INPUT ACCEPT
-P OUTPUT ACCEPT
-P POSTROUTING ACCEPT
-N DOCKER
<span class="c1"># 所有目的地址在本机的，都先交给 DOCKER 链处理一波</span>
-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER
<span class="c1"># （容器访问外部网络）所有出口不为 docker0 的流量，都做下 SNAT，把 src ip 换成出口接口的 ip 地址</span>
-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE
-A DOCKER -i docker0 -j RETURN

<span class="c1"># filter 表</span>
❯ sudo iptables -t filter -S
-P INPUT ACCEPT
-P FORWARD DROP
-P OUTPUT ACCEPT
-N DOCKER
-N DOCKER-ISOLATION-STAGE-1
-N DOCKER-ISOLATION-STAGE-2
-N DOCKER-USER
<span class="c1"># 所有流量都必须先经过如下两个链的处理，没问题才能继续往下走</span>
-A FORWARD -j DOCKER-ISOLATION-STAGE-1
-A FORWARD -j DOCKER-USER
<span class="c1"># （容器访问外部网络）出去的流量走了 MASQUERADE，回来的流量会被 conntrack 识别并转发回来，这里允许返回的数据包通过。</span>
<span class="c1"># 这里直接 ACCEPT 被 conntrack 识别到的流量</span>
-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
<span class="c1"># 将所有访问 docker0 的流量都转给自定义链 DOCKER 处理</span>
-A FORWARD -o docker0 -j DOCKER
<span class="c1"># 允许所有来自 docker0 的流量通过，不论下一跳是否是 docker0</span>
-A FORWARD -i docker0 ! -o docker0 -j ACCEPT
-A FORWARD -i docker0 -o docker0 -j ACCEPT
<span class="c1"># 下面三个链目前啥规则也没有，就是简单的 RETURN，交给后面的表继续处理</span>
-A DOCKER-ISOLATION-STAGE-1 -j RETURN
-A DOCKER-ISOLATION-STAGE-2 -j RETURN
-A DOCKER-USER -j RETURN
</code></pre></td></tr></table>
</div>
</div><p>接下来使用如下 docker-compose 配置启动一个 caddy　容器，添加自定义 network 和端口映射，待会就能验证 docker 是如何实现这两种网络的了。</p>
<p><code>docker-compose.yml</code> 内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;3.3&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">caddy</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;caddy:2.2.1-alpine&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;caddy&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">always</span><span class="w">
</span><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l">caddy file-server --browse --root /data/static</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;8081:80&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;/home/ryan/Downloads:/data/static&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="l">caddy-1</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">caddy-1</span><span class="p">:</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>现在先用上面的配置启动 caddy 容器，然后再查看网络状况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 启动 caddy</span>
❯ docker-compose up -d
<span class="c1"># 查下 caddy 容器的 ip</span>
&gt; docker inspect caddy <span class="p">|</span> grep IPAddress
...
    <span class="s2">&#34;IPAddress&#34;</span>: <span class="s2">&#34;172.18.0.2&#34;</span>,

<span class="c1"># 查看网络接口，可以看到多了一个网桥，它就是上一行命令创建的 caddy-1 网络</span>
<span class="c1"># 还多了一个 veth，它连接到了 caddy 容器的 eth0(veth) 接口</span>
❯ ip addr ls
...
5: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default 
    link/ether 02:42:42:c7:12:ba brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:42ff:fec7:12ba/64 scope link 
       valid_lft forever preferred_lft forever
100: veth16b37ea@if99: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master docker0 state UP group default 
    link/ether 42:af:34:ae:74:ae brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">0</span>
    inet6 fe80::40af:34ff:feae:74ae/64 scope link 
       valid_lft forever preferred_lft forever
102: veth4b4dada@if101: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master docker0 state UP group default 
    link/ether 9e:f1:58:1a:cf:ae brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">1</span>
    inet6 fe80::9cf1:58ff:fe1a:cfae/64 scope link 
       valid_lft forever preferred_lft forever
103: br-ac3e0514d837: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default 
    link/ether 02:42:7d:95:ba:7e brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.1/16 brd 172.18.255.255 scope global br-ac3e0514d837
       valid_lft forever preferred_lft forever
    inet6 fe80::42:7dff:fe95:ba7e/64 scope link 
       valid_lft forever preferred_lft forever
105: veth0c25c6f@if104: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master br-ac3e0514d837 state UP group default 
    link/ether 9a:03:e1:f0:26:ea brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">2</span>
    inet6 fe80::9803:e1ff:fef0:26ea/64 scope link 
       valid_lft forever preferred_lft forever


<span class="c1"># 查看网桥，能看到 caddy 容器的 veth 接口连在了 caddy-1 这个网桥上，没有加入到 docker0 网络</span>
❯ sudo brctl show
bridge name     bridge id               STP enabled     interfaces
br-ac3e0514d837         8000.02427d95ba7e       no              veth0c25c6f
docker0         8000.024242c712ba       no              veth16b37ea
                                                        veth4b4dada

<span class="c1"># 查看路由，能看到新网桥使用的地址段是 172.18.0.0/16，是 docker0 递增上来的 </span>
❯ ip route ls
default via 192.168.31.1 dev wlp4s0 proto dhcp metric <span class="m">600</span> 
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 
<span class="c1"># 多了一个网桥的</span>
172.18.0.0/16 dev br-ac3e0514d837 proto kernel scope link src 172.18.0.1 
192.168.31.0/24 dev wlp4s0 proto kernel scope link src 192.168.31.228 metric <span class="m">600</span> 

<span class="c1"># iptables 中也多了 caddy-1 网桥的 MASQUERADE 规则，以及端口映射的规则</span>
❯ sudo iptables -t nat -S
-P PREROUTING ACCEPT
-P INPUT ACCEPT
-P OUTPUT ACCEPT
-P POSTROUTING ACCEPT
-N DOCKER
-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER
-A POSTROUTING -s 172.18.0.0/16 ! -o br-ac3e0514d837 -j MASQUERADE
-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE
<span class="c1"># 端口映射过来的入网流量，都做下 SNAT，把 src ip 换成出口 docker0 的 ip 地址</span>
-A POSTROUTING -s 172.18.0.2/32 -d 172.18.0.2/32 -p tcp -m tcp --dport <span class="m">80</span> -j MASQUERADE
-A DOCKER -i br-ac3e0514d837 -j RETURN
-A DOCKER -i docker0 -j RETURN
<span class="c1"># 主机上所有其他接口进来的 tcp 流量，只要目标端口是 8081，就转发到 caddy 容器去（端口映射）</span>
<span class="c1"># DOCKER 是被 PREROUTEING 链的 target，因此这会导致流量直接走了 FORWARD 链，直接绕过了通常设置在 INPUT 链的主机防火墙规则！</span>
-A DOCKER ! -i br-ac3e0514d837 -p tcp -m tcp --dport <span class="m">8081</span> -j DNAT --to-destination 172.18.0.2:80

❯ sudo iptables -t filter -S
-P INPUT ACCEPT
-P FORWARD DROP
-P OUTPUT ACCEPT
-N DOCKER
-N DOCKER-ISOLATION-STAGE-1
-N DOCKER-ISOLATION-STAGE-2
-N DOCKER-USER
-A FORWARD -j DOCKER-USER
-A FORWARD -j DOCKER-ISOLATION-STAGE-1
<span class="c1"># 给 caddy-1 bridge 网络添加的转发规则，与 docker0 的规则完全一一对应，就不多介绍了。</span>
-A FORWARD -o br-ac3e0514d837 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -o br-ac3e0514d837 -j DOCKER
-A FORWARD -i br-ac3e0514d837 ! -o br-ac3e0514d837 -j ACCEPT
-A FORWARD -i br-ac3e0514d837 -o br-ac3e0514d837 -j ACCEPT
-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -o docker0 -j DOCKER
-A FORWARD -i docker0 ! -o docker0 -j ACCEPT
-A FORWARD -i docker0 -o docker0 -j ACCEPT
<span class="c1"># 这一条仍然是端口映射相关的规则，接受所有从其他接口过来的，请求 80 端口且出口是 caddy-1 网桥的流量</span>
-A DOCKER -d 172.18.0.2/32 ! -i br-ac3e0514d837 -o br-ac3e0514d837 -p tcp -m tcp --dport <span class="m">80</span> -j ACCEPT
<span class="c1"># 当存在多个 bridge 网络的时候，docker 就会在下面两个 STAGE 链中处理将它们隔离开，禁止互相访问</span>
-A DOCKER-ISOLATION-STAGE-1 -i br-ac3e0514d837 ! -o br-ac3e0514d837 -j DOCKER-ISOLATION-STAGE-2
-A DOCKER-ISOLATION-STAGE-1 -i docker0 ! -o docker0 -j DOCKER-ISOLATION-STAGE-2
-A DOCKER-ISOLATION-STAGE-1 -j RETURN
<span class="c1"># 这里延续上面 STAGE-1 的处理，彻底隔离两个网桥的流量</span>
-A DOCKER-ISOLATION-STAGE-2 -o br-ac3e0514d837 -j DROP
-A DOCKER-ISOLATION-STAGE-2 -o docker0 -j DROP
-A DOCKER-ISOLATION-STAGE-2 -j RETURN
-A DOCKER-USER -j RETURN
</code></pre></td></tr></table>
</div>
</div><p>到这里，我们简单地分析了下 docker 如何通过 iptables 实现 bridge 网络和端口映射。
有了这个基础，后面就可以尝试深入分析 kubernetes 网络插件 flannel/calico/cilium 了哈哈。</p>
<h2 id="dockerpodman-的-macvlanipvlan-模式">Docker/Podman 的 macvlan/ipvlan 模式</h2>
<blockquote>
<p>注意：macvlan 和 wifi 好像不兼容，测试时不要使用无线网络的接口！</p>
</blockquote>
<p>我在前面介绍 Linux 虚拟网络接口的文章中，有介绍过 macvlan 和 ipvlan 两种新的虚拟接口。</p>
<p>目前 Podman/Docker 都支持使用 macvlan 来构建容器网络，这种模式下创建的容器直连外部网络，容器可以拥有独立的外部 IP，不需要端口映射，也不需要借助 iptables.</p>
<p>这和虚拟机的 Bridge 模式就很类似，主要适用于希望容器拥有独立外部 IP 的情况。</p>
<p>下面详细分析下 Docker 的 macvlan 网络（Podman 应该也完全类似）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 首先创建一个 macvlan 网络</span>
<span class="c1"># subnet/gateway 的参数需要和物理网络一致</span>
<span class="c1"># 通过 -o parent 设定父接口，我本机的以太网口名称为 eno1</span>
$ docker network create -d macvlan <span class="se">\
</span><span class="se"></span>  --subnet<span class="o">=</span>192.168.31.0/24 <span class="se">\
</span><span class="se"></span>  --gateway<span class="o">=</span>192.168.31.1 <span class="se">\
</span><span class="se"></span>  -o <span class="nv">parent</span><span class="o">=</span>eno1 <span class="se">\
</span><span class="se"></span>  macnet0

<span class="c1"># 现在使用 macvlan 启动一个容器试试</span>
<span class="c1"># 建议和我一样，通过 --ip 手动配置静态 ip 地址，当然不配也可以，DHCP 会自动分配 IP</span>
$ docker run --network macnet0 --ip<span class="o">=</span>192.168.31.233 --rm -it buildpack-deps:buster-curl /bin/bash
<span class="c1"># 在容器中查看网络接口状况，能看到 eth0 是一个 macvlan 接口</span>
root@4319488cb5e7:/# ip -d addr ls
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="m">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity <span class="m">0</span> minmtu <span class="m">0</span> maxmtu <span class="m">0</span> numtxqueues <span class="m">1</span> numrxqueues <span class="m">1</span> gso_max_size <span class="m">65536</span> gso_max_segs <span class="m">65535</span> 
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
8: eth0@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default 
    link/ether 02:42:c0:a8:1f:e9 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">0</span> promiscuity <span class="m">0</span> minmtu <span class="m">68</span> maxmtu <span class="m">9194</span> 
    macvlan mode bridge numtxqueues <span class="m">1</span> numrxqueues <span class="m">1</span> gso_max_size <span class="m">64000</span> gso_max_segs <span class="m">64</span> 
    inet 192.168.31.233/24 brd 192.168.31.255 scope global eth0
       valid_lft forever preferred_lft forever
<span class="c1"># 路由表，默认 gateway 被自动配置进来了</span>
root@4319488cb5e7:/# ip route ls
default via 192.168.31.1 dev eth0 
192.168.31.0/24 dev eth0 proto kernel scope link src 192.168.31.233 

<span class="c1"># 可以正常访问 baidu</span>
root@4319488cb5e7:/# curl baidu.com
&lt;html&gt;
&lt;meta http-equiv<span class="o">=</span><span class="s2">&#34;refresh&#34;</span> <span class="nv">content</span><span class="o">=</span><span class="s2">&#34;0;url=http://www.baidu.com/&#34;</span>&gt;
&lt;/html&gt;
</code></pre></td></tr></table>
</div>
</div><p>Docker 支持的另一种网络模式是 ipvlan（ipvlan 和 macvlan 的区别我在前一篇文章中已经介绍过，不再赘言），创建命令和 macvlan 几乎一样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 首先创建一个 macvlan 网络</span>
<span class="c1"># subnet/gateway 的参数需要和物理网络一致</span>
<span class="c1"># 通过 -o parent 设定父接口，我本机的以太网口名称为 eno1</span>
<span class="c1"># ipvlan_mode 默认为 l2，表示工作在数据链路层。</span>
$ docker network create -d ipvlan <span class="se">\
</span><span class="se"></span>  --subnet<span class="o">=</span>192.168.31.0/24 <span class="se">\
</span><span class="se"></span>  --gateway<span class="o">=</span>192.168.31.1 <span class="se">\
</span><span class="se"></span>  -o <span class="nv">parent</span><span class="o">=</span>eno1 <span class="se">\
</span><span class="se"></span>  -o <span class="nv">ipvlan_mode</span><span class="o">=</span>l2 <span class="se">\
</span><span class="se"></span>  ipvnet0

<span class="c1"># 现在使用 macvlan 启动一个容器试试</span>
<span class="c1"># 建议和我一样，通过 --ip 手动配置静态 ip 地址，当然不配也可以，DHCP 会自动分配 IP</span>
$ docker run --network ipvnet0 --ip<span class="o">=</span>192.168.31.234 --rm -it buildpack-deps:buster-curl /bin/bash
<span class="c1"># 在容器中查看网络接口状况，能看到 eth0 是一个 ipvlan 接口</span>
root@d0764ebbbf42:/# ip -d addr ls
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="m">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity <span class="m">0</span> minmtu <span class="m">0</span> maxmtu <span class="m">0</span> numtxqueues <span class="m">1</span> numrxqueues <span class="m">1</span> gso_max_size <span class="m">65536</span> gso_max_segs <span class="m">65535</span> 
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
12: eth0@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UNKNOWN group default 
    link/ether 38:f3:ab:a3:e6:71 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">0</span> promiscuity <span class="m">0</span> minmtu <span class="m">68</span> maxmtu <span class="m">65535</span> 
    ipvlan  mode l2 bridge numtxqueues <span class="m">1</span> numrxqueues <span class="m">1</span> gso_max_size <span class="m">64000</span> gso_max_segs <span class="m">64</span> 
    inet 192.168.31.234/24 brd 192.168.31.255 scope global eth0
       valid_lft forever preferred_lft forever
<span class="c1"># 路由表，默认 gateway 被自动配置进来了</span>
root@d0764ebbbf42:/# ip route ls
default via 192.168.31.1 dev eth0 
192.168.31.0/24 dev eth0 proto kernel scope link src 192.168.31.234 

<span class="c1"># 可以正常访问 baidu</span>
root@d0764ebbbf42:/# curl baidu.com
&lt;html&gt;
&lt;meta http-equiv<span class="o">=</span><span class="s2">&#34;refresh&#34;</span> <span class="nv">content</span><span class="o">=</span><span class="s2">&#34;0;url=http://www.baidu.com/&#34;</span>&gt;
&lt;/html&gt;
</code></pre></td></tr></table>
</div>
</div><h2 id="rootless-容器的网络实现">Rootless 容器的网络实现</h2>
<p>如果容器运行时也在 Rootless 模式下运行，那它就没有权限在宿主机添加 bridge/veth 等虚拟网络接口，这种情况下，我们前面描述的容器网络就无法设置了。</p>
<p>那么 podman/containerd(nerdctl) 目前是如何在 Rootless 模式下构建容器网络的呢？</p>
<p>查看文档，发现它们都用到了 rootlesskit 相关的东西，而 rootlesskit 提供了 rootless 网络的几个实现，文档参见 <a href="https://github.com/rootless-containers/rootlesskit/blob/master/docs/network.md" target="_blank" rel="noopener noreferrer">rootlesskit/docs/network.md</a></p>
<p>其中目前推荐使用，而且 podman/containerd(nerdctl) 都默认使用的方案，是 <a href="https://github.com/rootless-containers/slirp4netns" target="_blank" rel="noopener noreferrer">rootless-containers/slirp4netns</a></p>
<p>以 containerd(nerdctl) 为例，按官方文档安装好后，随便启动几个容器，然后在宿主机查 <code>iptables</code>/<code>ip addr ls</code>，会发现啥也没有。
这显然是因为 rootless 模式下 containerd 改不了宿主机的 iptables 配置和虚拟网络接口。但是可以查看到宿主机 slirp4netns 在后台运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">❯ ps aux <span class="p">|</span> grep tap
ryan     <span class="m">11644</span>  0.0  0.0   <span class="m">5288</span>  <span class="m">3312</span> ?        S    00:01   0:02 slirp4netns --mtu <span class="m">65520</span> -r <span class="m">3</span> --disable-host-loopback --enable-sandbox --enable-seccomp <span class="m">11625</span> tap0
</code></pre></td></tr></table>
</div>
</div><p>但是我看半天文档，只看到怎么使用 <code>rootlesskit</code>/<code>slirp4netns</code> 创建新的名字空间，没看到有介绍如何进入一个已存在的 <code>slirp4netns</code> 名字空间&hellip;</p>
<p>使用 <code>nsenter -a -t 11644</code> 也一直报错，任何程序都是 <code>no such binary</code>&hellip;</p>
<p>以后有空再重新研究一波&hellip;</p>
<p>总之能确定的是，它通过在虚拟的名字空间中创建了一个 <code>tap</code> 虚拟接口来实现容器网络，性能相比前面介绍的网络多少是要差一点的。</p>
<h2 id="nftables">nftables</h2>
<p>前面介绍了 iptables 以及其在 docker 和防火墙上的应用。但是实际上目前各大 Linux 发行版都已经不建议使用 iptables 了，甚至把 iptables 重命名为了 <code>iptables-leagacy</code>.</p>
<p>目前 opensuse/debian/opensuse 都已经预装了并且推荐使用 nftables，<strong>而且 firewalld 已经默认使用 nftables 作为它的后端了</strong>。</p>
<p>我在 opensuse tumbleweed 上实测，firewalld 添加的是 nftables 配置，而 docker 仍然在用旧的 iptables，也就是说我现在的机器上有两套 netfilter 工具并存：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># 查看 iptables 数据
&gt; iptables -S
-P INPUT ACCEPT
-P FORWARD DROP
-P OUTPUT ACCEPT
-N DOCKER
-N DOCKER-ISOLATION-STAGE-1
-N DOCKER-ISOLATION-STAGE-2
-N DOCKER-USER
-A FORWARD -j DOCKER-ISOLATION-STAGE-1
-A FORWARD -o br-e3fbbb7a1b3a -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -o br-e3fbbb7a1b3a -j DOCKER
...

# 确认下是否使用了 nftables 的兼容层，结果提示请我使用 iptables-legacy
&gt; iptables-nft -S
# Warning: iptables-legacy tables present, use iptables-legacy to see them
-P INPUT ACCEPT
-P FORWARD ACCEPT
-P OUTPUT ACCEPT

# 查看 nftables 规则，能看到三张 firewalld 生成的 table
&gt; nft list ruleset
table inet firewalld {
    ...
}
table ip firewalld {
    ...
}
table ip6 firewalld {
    ...
}
</code></pre></td></tr></table>
</div>
</div><p>但是现在 kubernetes/docker 都还是用的 iptables，nftables 我学了用处不大，以后有空再补充。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.zsythink.net/archives/1199" target="_blank" rel="noopener noreferrer">iptables详解（1）：iptables概念</a></li>
<li><a href="https://linux.cn/article-13364-1.html" target="_blank" rel="noopener noreferrer">网络地址转换（NAT）之报文跟踪</a></li>
<li><a href="https://developer.aliyun.com/article/700923" target="_blank" rel="noopener noreferrer">容器安全拾遗 - Rootless Container初探</a></li>
<li><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener noreferrer">netfilter - wikipedia</a></li>
</ul>
]]></description></item><item><title>Linux 中的虚拟网络接口</title><link>https://thiscute.world/posts/linux-virtual-network-interfaces/</link><pubDate>Sat, 14 Aug 2021 11:13:03 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/linux-virtual-network-interfaces/</guid><description><![CDATA[<blockquote>
<p>本文用到的字符画工具：<a href="https://github.com/zenghongtu/vscode-asciiflow2" target="_blank" rel="noopener noreferrer">vscode-asciiflow2</a></p>
</blockquote>
<blockquote>
<p>注意: 本文中使用 <code>ip</code> 命令创建或修改的任何网络配置，都是未持久化的，主机重启即消失。</p>
</blockquote>
<p>Linux 具有强大的虚拟网络能力，这也是 openstack 网络、docker 容器网络以及 kubernetes 网络等虚拟网络的基础。</p>
<p>这里介绍 Linux 常用的虚拟网络接口类型：TUN/TAP、bridge、veth、ipvlan/macvlan、vlan 以及 vxlan/geneve.</p>
<h2 id="一tuntap-虚拟网络接口">一、tun/tap 虚拟网络接口</h2>
<p>tun/tap 是操作系统内核中的虚拟网络设备，他们为用户层程序提供数据的接收与传输。</p>
<p>普通的物理网络接口如 eth0，它的两端分别是内核协议栈和外面的物理网络。</p>
<p>而对于 TUN/TAP 虚拟接口如 tun0，它的一端一定是连接的用户层程序，另一端则视配置方式的不同而变化，可以直连内核协议栈，也可以是某个 bridge（后面会介绍）。
Linux 通过内核模块 TUN 提供 tun/tap 功能，该模块提供了一个设备接口 <code>/dev/net/tun</code> 供用户层程序读写，用户层程序通过 <code>/dev/net/tun</code> 读写主机内核协议栈的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">&gt; modinfo tun
filename:       /lib/modules/5.13.6-1-default/kernel/drivers/net/tun.ko.xz
alias:          devname:net/tun
alias:          char-major-10-200
license:        GPL
author:         (C) 1999-2004 Max Krasnyansky &lt;maxk@qualcomm.com&gt;
description:    Universal TUN/TAP device driver
...

&gt; ls /dev/net/tun
/dev/net/tun
</code></pre></td></tr></table>
</div>
</div><p>一个 TUN 设备的示例图如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">             
+----------------------------------------------------------------------+
|                                                                      |
|  +--------------------+      +--------------------+                  |
|  | User Application A |      | User Application B +&lt;-----+           |
|  +------------+-------+      +-------+------------+      |           |
|               | 1                    | 5                 |           |
|...............+......................+...................|...........|
|               ↓                      ↓                   |           |
|         +----------+           +----------+              |           |
|         | socket A |           | socket B |              |           |
|         +-------+--+           +--+-------+              |           |
|                 | 2               | 6                    |           |
|.................+.................+......................|...........|
|                 ↓                 ↓                      |           |
|             +------------------------+          +--------+-------+   |
|             | Network Protocol Stack |          |  /dev/net/tun  |   |
|             +--+-------------------+-+          +--------+-------+   |
|                | 7                 | 3                   ^           |
|................+...................+.....................|...........|
|                ↓                   ↓                     |           |
|        +----------------+    +----------------+        4 |           |
|        |      eth0      |    |      tun0      |          |           |
|        +-------+--------+    +-----+----------+          |           |
|    10.32.0.11  |                   |   192.168.3.11      |           |
|                | 8                 +---------------------+           |
|                |                                                     |
+----------------+-----------------------------------------------------+
                 ↓
         Physical Network
</code></pre></td></tr></table>
</div>
</div><p>因为 TUN/TAP 设备的一端是内核协议栈，显然流入 tun0 的数据包是先经过本地的路由规则匹配的。</p>
<p>路由匹配成功，数据包被发送到 tun0 后，tun0 发现另一端是通过 <code>/dev/net/tun</code> 连接到应用程序 B，就会将数据丢给应用程序 B。</p>
<p>应用程序对数据包进行处理后，可能会构造新的数据包，通过物理网卡发送出去。比如常见的 VPN 程序就是把原来的数据包封装/加密一遍，再发送给 VPN 服务器。</p>
<h3 id="c-语言编程测试-tun-设备">C 语言编程测试 TUN 设备</h3>
<p>为了使用 tun/tap 设备，用户层程序需要通过系统调用打开 <code>/dev/net/tun</code> 获得一个读写该设备的文件描述符(FD)，并且调用 <code>ioctl()</code> 向内核注册一个 TUN 或 TAP 类型的虚拟网卡(实例化一个 tun/tap 设备)，其名称可能是 <code>tun0/tap0</code> 等。</p>
<p>此后，用户程序可以通过该 TUN/TAP 虚拟网卡与主机内核协议栈（或者其他网络设备）交互。当用户层程序关闭后，其注册的 TUN/TAP 虚拟网卡以及自动生成的路由表相关条目都会被内核释放。</p>
<p>可以把用户层程序看做是网络上另一台主机，他们通过 tun/tap 虚拟网卡相连。</p>
<p>一个简单的 C 程序示例如下，它每次收到数据后，都只单纯地打印一下收到的字节数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/if.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/if_tun.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/ioctl.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">tun_alloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>

    <span class="k">struct</span> <span class="n">ifreq</span> <span class="n">ifr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">clonedev</span> <span class="o">=</span> <span class="s">&#34;/dev/net/tun&#34;</span><span class="p">;</span>

    <span class="c1">// 打开 tun 文件，获得 fd
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">clonedev</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ifr</span><span class="p">));</span>
    <span class="n">ifr</span><span class="p">.</span><span class="n">ifr_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

    <span class="c1">// 向内核注册一个 TUN 网卡，并与前面拿到的 fd 关联起来
</span><span class="c1"></span>    <span class="c1">// 程序关闭时，注册的 tun 网卡及自动生成的相关路由策略，会被自动释放
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">TUNSETIFF</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Open tun/tap device: %s for reading...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>

    <span class="kt">int</span> <span class="n">tun_fd</span><span class="p">,</span> <span class="n">nread</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1500</span><span class="p">];</span>

    <span class="cm">/* Flags: IFF_TUN   - TUN device (no Ethernet headers)
</span><span class="cm">     *        IFF_TAP   - TAP device
</span><span class="cm">     *        IFF_NO_PI - Do not provide packet information
</span><span class="cm">     */</span>
    <span class="n">tun_fd</span> <span class="o">=</span> <span class="n">tun_alloc</span><span class="p">(</span><span class="n">IFF_TUN</span> <span class="o">|</span> <span class="n">IFF_NO_PI</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tun_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;Allocating interface&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">tun_fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">perror</span><span class="p">(</span><span class="s">&#34;Reading from interface&#34;</span><span class="p">);</span>
            <span class="n">close</span><span class="p">(</span><span class="n">tun_fd</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Read %d bytes from tun/tap device</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">nread</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>接下来开启三个终端窗口来测试上述程序，分别运行上面的 tun 程序、tcpdump 和 iproute2 指令。</p>
<p>首先通过编译运行上述 c 程序，程序会阻塞住，等待数据到达：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># 编译，请忽略部分 warning
&gt; gcc mytun.c -o mytun

# 创建并监听 tun 设备需要 root 权限
&gt; sudo mytun 
Open tun/tap device: tun0 for reading...
</code></pre></td></tr></table>
</div>
</div><p>现在使用 iproute2 查看下链路层设备：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># 能发现最后面有列出名为 tun0 的接口，但是状态为 down
❯ ip addr ls
......
3: wlp4s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000
    link/ether c0:3c:59:36:a4:16 brd ff:ff:ff:ff:ff:ff
    inet 192.168.31.228/24 brd 192.168.31.255 scope global dynamic noprefixroute wlp4s0
       valid_lft 41010sec preferred_lft 41010sec
    inet6 fe80::4ab0:130f:423b:5d37/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
7: tun0: &lt;POINTOPOINT,MULTICAST,NOARP&gt; mtu 1500 qdisc noop state DOWN group default qlen 500
    link/none 

# 为 tun0 设置 ip 地址，注意不要和其他接口在同一网段，会导致路由冲突
&gt; sudo ip addr add 172.21.22.23/24 dev tun0
# 启动 tun0 这个接口，这一步会自动向路由表中添加将 172.21.22.23/24 路由到 tun0 的策略
&gt; sudo ip link set tun0 up
#确认上一步添加的路由策略是否存在
❯ ip route ls
default via 192.168.31.1 dev wlp4s0 proto dhcp metric 600 
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown 
172.21.22.0/24 dev tun0 proto kernel scope link src 172.21.22.23 
192.168.31.0/24 dev wlp4s0 proto kernel scope link src 192.168.31.228 metric 600 

# 此时再查看接口，发现 tun0 状态为 unknown
&gt; ip addr ls
......
8: tun0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN group default qlen 500
    link/none 
    inet 172.21.22.23/24 scope global tun0
       valid_lft forever preferred_lft forever
    inet6 fe80::3d52:49b5:1cf3:38fd/64 scope link stable-privacy 
       valid_lft forever preferred_lft forever

# 使用 tcpdump 尝试抓下 tun0 的数据，会阻塞在这里，等待数据到达
&gt; tcpdump -i tun0
</code></pre></td></tr></table>
</div>
</div><p>现在再启动第三个窗口发点数据给 tun0，持续观察前面 <code>tcpdump</code> 和 <code>mytun</code> 的日志:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># 直接 ping tun0 的地址，貌似有问题，数据没进 mytun 程序，而且还有响应
❯ ping -c 4 172.21.22.23
PING 172.21.22.23 (172.21.22.23) 56(84) bytes of data.
64 bytes from 172.21.22.23: icmp_seq=1 ttl=64 time=0.167 ms
64 bytes from 172.21.22.23: icmp_seq=2 ttl=64 time=0.180 ms
64 bytes from 172.21.22.23: icmp_seq=3 ttl=64 time=0.126 ms
64 bytes from 172.21.22.23: icmp_seq=4 ttl=64 time=0.141 ms

--- 172.21.22.23 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3060ms
rtt min/avg/max/mdev = 0.126/0.153/0.180/0.021 ms

# 但是 ping 该网段下的其他地址，流量就会被转发给 mytun 程序，因为 mytun 啥数据也没回，自然丢包率 100%
# tcpdump 和 mytun 都会打印出相关日志
❯ ping -c 4 172.21.22.26
PING 172.21.22.26 (172.21.22.26) 56(84) bytes of data.

--- 172.21.22.26 ping statistics ---
4 packets transmitted, 0 received, 100% packet loss, time 3055ms
</code></pre></td></tr></table>
</div>
</div><p>下面给出 mytun 的输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Read 84 bytes from tun/tap device
Read 84 bytes from tun/tap device
Read 84 bytes from tun/tap device
Read 84 bytes from tun/tap device
</code></pre></td></tr></table>
</div>
</div><p>以及 tcpdump 的输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">00:22:03.622684 IP (tos 0x0, ttl 64, id 37341, offset 0, flags [DF], proto ICMP (1), length 84)
    172.21.22.23 &gt; 172.21.22.26: ICMP echo request, id 11, seq 1, length 64
00:22:04.633394 IP (tos 0x0, ttl 64, id 37522, offset 0, flags [DF], proto ICMP (1), length 84)
    172.21.22.23 &gt; 172.21.22.26: ICMP echo request, id 11, seq 2, length 64
00:22:05.653356 IP (tos 0x0, ttl 64, id 37637, offset 0, flags [DF], proto ICMP (1), length 84)
    172.21.22.23 &gt; 172.21.22.26: ICMP echo request, id 11, seq 3, length 64
00:22:06.677341 IP (tos 0x0, ttl 64, id 37667, offset 0, flags [DF], proto ICMP (1), length 84)
    172.21.22.23 &gt; 172.21.22.26: ICMP echo request, id 11, seq 4, length 64
</code></pre></td></tr></table>
</div>
</div><p>更复杂的 tun 程序，可以参考</p>
<ul>
<li><a href="https://github.com/gregnietsky/simpletun" target="_blank" rel="noopener noreferrer">simpletun</a></li>
<li><a href="https://github.com/marywangran/simpletun" target="_blank" rel="noopener noreferrer">marywangran/simpletun</a></li>
<li><a href="https://github.com/marywangran/gotun-tunnel/blob/main/tun/tun.go" target="_blank" rel="noopener noreferrer">tun go 语言版</a></li>
</ul>
<h3 id="tun-与-tap-的区别">TUN 与 TAP 的区别</h3>
<p>TUN 和 TAP 的区别在于工作的网络层次不同，用户程序通过 TUN 设备只能读写网络层的 IP 数据包，而 TAP 设备则支持读写链路层的数据包（通常是以太网数据包，带有 Ethernet headers）。</p>
<p>TUN 与 TAP 的关系，就类似于 socket 和 raw socket.</p>
<p>TUN/TAP 应用最多的场景是 VPN 代理，比如:</p>
<ol>
<li><a href="https://github.com/ryan4yin/clash" target="_blank" rel="noopener noreferrer">clash</a>: 一个支持各种规则的隧道，也支持 TUN 模式</li>
<li><a href="https://github.com/xjasonlyu/tun2socks/wiki" target="_blank" rel="noopener noreferrer">tun2socks</a>: 一个全局透明代理，和 VPN 的工作模式一样，它通过创建虚拟网卡+修改路由表，在第三层网络层代理系统流量。</li>
</ol>
<h2 id="二veth">二、veth</h2>
<p>veth 接口总是成对出现，一对 veth 接口就类似一根网线，从一端进来的数据会从另一端出去。</p>
<p>同时 veth 又是一个虚拟网络接口，因此它和 TUN/TAP 或者其他物理网络接口一样，也都能配置 mac/ip 地址（但是并不是一定得配 mac/ip 地址）。</p>
<p>其主要作用就是连接不同的网络，比如在容器网络中，用于将容器的 namespace 与 root namespace 的网桥 br0 相连。
容器网络中，容器侧的 veth 自身设置了 ip/mac 地址并被重命名为 eth0，作为容器的网络接口使用，而主机侧的 veth 则直接连接在 docker0/br0 上面。</p>
<p>使用 veth 实现容器网络，需要结合下一小节介绍的 bridge，在下一小节将给出容器网络结构图。</p>
<h2 id="三bridge">三、bridge</h2>
<p>Linux Bridge 是工作在链路层的网络交换机，由 Linux 内核模块 <code>brige</code> 提供，它负责在所有连接到它的接口之间转发链路层数据包。</p>
<p>添加到 Bridge 上的设备被设置为只接受二层数据帧并且转发所有收到的数据包到 Bridge 中。
在 Bridge 中会进行一个类似物理交换机的查MAC端口映射表、转发、更新MAC端口映射表这样的处理逻辑，从而数据包可以被转发到另一个接口/丢弃/广播/发往上层协议栈，由此 Bridge 实现了数据转发的功能。</p>
<p>如果使用 tcpdump 在 Bridge 接口上抓包，可以抓到网桥上所有接口进出的包，因为这些数据包都要通过网桥进行转发。</p>
<p>与物理交换机不同的是，Bridge 本身可以设置 IP 地址，可以认为当使用 <code>brctl addbr br0</code> 新建一个 br0 网桥时，系统自动创建了一个同名的隐藏 <code>br0</code> 网络接口。<code>br0</code> 一旦设置 IP 地址，就意味着这个隐藏的 br0 接口可以作为路由接口设备，参与 IP 层的路由选择(可以使用 <code>route -n</code> 查看最后一列 <code>Iface</code>)。因此只有当 <code>br0</code> 设置 <code>IP</code> 地址时，Bridge 才有可能将数据包发往上层协议栈。</p>
<p>但被添加到 Bridge 上的网卡是不能配置 IP 地址的，他们工作在数据链路层，对路由系统不可见。</p>
<p>它常被用于在虚拟机、主机上不同的 namepsaces 之间转发数据。</p>
<h3 id="虚拟机场景桥接模式">虚拟机场景（桥接模式）</h3>
<p>以 qemu-kvm 为例，在虚拟机的桥接模式下，qemu-kvm 会为每个虚拟机创建一个 tun/tap 虚拟网卡并连接到 br0 网桥。
虚拟机内部的网络接口 <code>eth0</code> 是 qemu-kvm 软件模拟的，实际上虚拟机内网络数据的收发都会被 qemu-kvm 转换成对 <code>/dev/net/tun</code> 的读写。</p>
<p>以发送数据为例，整个流程如下：</p>
<ul>
<li>虚拟机发出去的数据包先到达 qemu-kvm 程序</li>
<li>数据被用户层程序 qemu-kvm 写入到 <code>/dev/net/tun</code>，到达 tap 设备</li>
<li>tap 设备把数据传送到 br0 网桥</li>
<li>br0 把数据交给 eth0 发送出去</li>
</ul>
<p>整个流程跑完，数据包都不需要经过宿主机的协议栈，效率高。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">+------------------------------------------------+-----------------------------------+-----------------------------------+
|                       Host                     |           VirtualMachine1         |           VirtualMachine2         |
|                                                |                                   |                                   |
|    +--------------------------------------+    |    +-------------------------+    |    +-------------------------+    |
|    |         Network Protocol Stack       |    |    |  Network Protocol Stack |    |    |  Network Protocol Stack |    |
|    +--------------------------------------+    |    +-------------------------+    |    +-------------------------+    |
|                       ↑                        |                ↑                  |                 ↑                 |
|.......................|........................|................|..................|.................|.................|
|                       ↓                        |                ↓                  |                 ↓                 |
|                  +--------+                    |            +-------+              |             +-------+             |
|                  | .3.101 |                    |            | .3.102|              |             | .3.103|             |
|     +------+     +--------+     +-------+      |            +-------+              |             +-------+             |
|     | eth0 |&lt;---&gt;|   br0  |&lt;---&gt;|tun/tap|      |            | eth0  |              |             | eth0  |             |
|     +------+     +--------+     +-------+      |            +-------+              |             +-------+             |
|         ↑             ↑             ↑      +--------+           ↑                  |                 ↑                 |
|         |             |             +------|qemu-kvm|-----------+                  |                 |                 |
|         |             ↓                    +--------+                              |                 |                 |
|         |         +-------+                    |                                   |                 |                 |
|         |         |tun/tap|                    |                                   |                 |                 |
|         |         +-------+                    |                                   |                 |                 |
|         |             ↑                        |            +--------+             |                 |                 |
|         |             +-------------------------------------|qemu-kvm|-------------|-----------------+                 |
|         |                                      |            +--------+             |                                   |
|         |                                      |                                   |                                   |
+---------|--------------------------------------+-----------------------------------+-----------------------------------+
          ↓
    Physical Network  (192.168.3.0/24)
</code></pre></td></tr></table>
</div>
</div><h3 id="跨-namespace-通信场景容器网络nat-模式">跨 namespace 通信场景（容器网络，NAT 模式）</h3>
<blockquote>
<p>docker/podman 提供的 bridge 网络模式，就是使用 veth+bridge+iptalbes 实现的。我会在下一篇文章详细介绍「容器网络」。</p>
</blockquote>
<p>由于容器运行在自己单独的 network namespace 里面，所以和虚拟机一样，它们也都有自己单独的协议栈。</p>
<p>容器网络的结构和虚拟机差不多，但是它改用了 NAT 网络，并把 tun/tap 换成了 veth，导致 docker0 过来的数据，要先经过宿主机协议栈，然后才进入 veth 接口。</p>
<p>多了一层 NAT，以及多走了一层宿主机协议栈，都会导致性能下降。</p>
<p>示意图如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">+-----------------------------------------------+-----------------------------------+-----------------------------------+
|                      Host                     |           Container 1             |           Container 2             |
|                                               |                                   |                                   |
|   +---------------------------------------+   |    +-------------------------+    |    +-------------------------+    |
|   |       Network Protocol Stack          |   |    |  Network Protocol Stack |    |    |  Network Protocol Stack |    |
|   +----+-------------+--------------------+   |    +-----------+-------------+    |    +------------+------------+    |
|        ^             ^                        |                ^                  |                 ^                 |
|........|.............|........................|................|..................|.................|.................|
|        v             v  ↓                     |                v                  |                 v                 |
|   +----+----+  +-----+------+                 |          +-----+-------+          |           +-----+-------+         |
|   | .31.101 |  | 172.17.0.1 |      +------+   |          | 172.17.0.2  |          |           |  172.17.0.3 |         |
|   +---------+  +-------------&lt;----&gt;+ veth |   |          +-------------+          |           +-------------+         |
|   |  eth0   |  |   docker0  |      +--+---+   |          | eth0(veth)  |          |           | eth0(veth)  |         |
|   +----+----+  +-----+------+         ^       |          +-----+-------+          |           +-----+-------+         |
|        ^             ^                |       |                ^                  |                 ^                 |
|        |             |                +------------------------+                  |                 |                 |
|        |             v                        |                                   |                 |                 |
|        |          +--+---+                    |                                   |                 |                 |
|        |          | veth |                    |                                   |                 |                 |
|        |          +--+---+                    |                                   |                 |                 |
|        |             ^                        |                                   |                 |                 |
|        |             +------------------------------------------------------------------------------+                 |
|        |                                      |                                   |                                   |
|        |                                      |                                   |                                   |
+-----------------------------------------------+-----------------------------------+-----------------------------------+
         v
    Physical Network  (192.168.31.0/24)
</code></pre></td></tr></table>
</div>
</div><p>每创建一个新容器，都会在容器的 namespace 里新建一个 veth 接口并命令为 eth0，同时在主 namespace 创建一个 veth，将容器的 eth0 与 docker0 连接。</p>
<p>可以在容器中通过 iproute2 查看到， eth0 的接口类型为 <code>veth</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">❯ docker run -it --rm debian:buster bash
root@5facbe4ddc1e:/# ip --details addr ls
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="m">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity <span class="m">0</span> minmtu <span class="m">0</span> maxmtu <span class="m">0</span> numtxqueues <span class="m">1</span> numrxqueues <span class="m">1</span> gso_max_size <span class="m">65536</span> gso_max_segs <span class="m">65535</span> 
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
20: eth0@if21: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">0</span> promiscuity <span class="m">0</span> minmtu <span class="m">68</span> maxmtu <span class="m">65535</span> 
    veth numtxqueues <span class="m">1</span> numrxqueues <span class="m">1</span> gso_max_size <span class="m">65536</span> gso_max_segs <span class="m">65535</span> 
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
</code></pre></td></tr></table>
</div>
</div><p>同时在宿主机中能看到对应的 veth 设备是绑定到了 docker0 网桥的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">❯ sudo brctl show
bridge name     bridge id               STP enabled     interfaces
docker0         8000.0242fce99ef5       no              vethea4171a
</code></pre></td></tr></table>
</div>
</div><h2 id="四macvlan">四、macvlan</h2>
<blockquote>
<p>目前 docker/podman 都支持创建基于 macvlan 的 Linux 容器网络。</p>
</blockquote>
<blockquote>
<p>注意 macvlan 和 WiFi 存在兼容问题，如果使用笔记本测试，可能会遇到麻烦。</p>
</blockquote>
<blockquote>
<p>参考文档：<a href="https://cizixs.com/2017/02/14/network-virtualization-macvlan/" target="_blank" rel="noopener noreferrer">linux 网络虚拟化： macvlan</a></p>
</blockquote>
<p>macvlan 是比较新的 Linux 特性，需要内核版本 &gt;= 3.9，它被用于在主机的网络接口（父接口）上配置多个虚拟子接口，这些子接口都拥有各自独立的 mac 地址，也可以配上 ip 地址进行通讯。</p>
<p>macvlan 下的虚拟机或者容器网络和主机在同一个网段中，共享同一个广播域。macvlan 和 bridge 比较相似，但因为它省去了 bridge 的存在，所以配置和调试起来比较简单，而且效率也相对高。除此之外，macvlan 自身也完美支持 VLAN。</p>
<p>如果希望容器或者虚拟机放在主机相同的网络中，享受已经存在网络栈的各种优势，可以考虑 macvlan。</p>
<p>我会在下一篇文章对 docker 的 macvlan/ipvlan 做个分析，这里先略过了&hellip;</p>
<h2 id="五ipvlan">五、ipvlan</h2>
<blockquote>
<p><a href="https://cizixs.com/2017/02/17/network-virtualization-ipvlan/" target="_blank" rel="noopener noreferrer">linux 网络虚拟化： ipvlan</a></p>
</blockquote>
<blockquote>
<p>cilium 1.9 已经提供了基于 ipvlan 的网络（beta 特性），用于替换传统的 veth+bridge 容器网络。详见 <a href="https://docs.cilium.io/en/v1.9/gettingstarted/ipvlan/" target="_blank" rel="noopener noreferrer">IPVLAN based Networking (beta) - Cilium 1.9 Docs</a></p>
</blockquote>
<p>ipvlan 和 macvlan 的功能很类似，也是用于在主机的网络接口（父接口）上配置出多个虚拟的子接口。但不同的是，ipvlan 的各子接口没有独立的 mac 地址，它们和主机的父接口共享 mac 地址。</p>
<blockquote>
<p>因为 mac 地址共享，所以如果使用 DHCP，就要注意不能使用 mac 地址做 DHCP，需要额外配置唯一的 clientID.</p>
</blockquote>
<p>如果你遇到以下的情况，请考虑使用 ipvlan：</p>
<ul>
<li>父接口对 mac 地址数目有限制，或者在 mac 地址过多的情况下会造成严重的性能损失</li>
<li>工作在 802.11(wireless)无线网络中（macvlan 无法和无线网络共同工作）</li>
<li>希望搭建比较复杂的网络拓扑（不是简单的二层网络和 VLAN），比如要和 BGP 网络一起工作</li>
</ul>
<p>基于 ipvlan/macvlan 的容器网络，比 veth+bridge+iptables 的性能要更高。</p>
<p>我会在下一篇文章对 docker 的 macvlan/ipvlan 做个分析，这里先略过了&hellip;</p>
<h2 id="六vlan">六、vlan</h2>
<p>vlan 即虚拟局域网，是一个链路层的广播域隔离技术，可以用于切分局域网，解决广播泛滥和安全性问题。被隔离的广播域之间需要上升到第三层才能完成通讯。</p>
<p>常用的企业路由器如 ER-X 基本都可以设置 vlan，Linux 也直接支持了 vlan.</p>
<p>以太网数据包有一个专门的字段提供给 vlan 使用，vlan 数据包会在该位置记录它的 VLAN ID，交换机通过该 ID 来区分不同的 VLAN，只将该以太网报文广播到该 ID 对应的 VLAN 中。</p>
<h2 id="七vxlangeneve">七、vxlan/geneve</h2>
<blockquote>
<p><a href="https://datatracker.ietf.org/doc/html/rfc8926" target="_blank" rel="noopener noreferrer">rfc8926 - Geneve: Generic Network Virtualization Encapsulation</a>
<a href="https://datatracker.ietf.org/doc/html/rfc7348" target="_blank" rel="noopener noreferrer">rfc7348 - Virtual eXtensible Local Area Network (VXLAN)</a></p>
</blockquote>
<blockquote>
<p><a href="https://cizixs.com/2017/09/28/linux-vxlan/" target="_blank" rel="noopener noreferrer">linux 上实现 vxlan 网络</a></p>
</blockquote>
<p>在介绍 vxlan 前，先说明下两个名词的含义：</p>
<ul>
<li><strong>underlay 网络</strong>：即物理网络</li>
<li><strong>overlay 网络</strong>：指在现有的物理网络之上构建的虚拟网络。其实就是一种隧道技术，将原生态的二层数据帧报文进行封装后通过隧道进行传输。</li>
</ul>
<p>vxlan 与 geneve 都是 overlay 网络协议，它俩都是使用 UDP 包来封装链路层的以太网帧。</p>
<p>vxlan 在 2014 年标准化，而 geneve 在 2020 年底才通过草案阶段，目前尚未形成最终标准。但是目前 linux/cilium 都已经支持了 geneve.</p>
<p>geneve 相对 vxlan 最大的变化，是它更灵活——它的 header 长度是可变的。</p>
<p>目前所有 overlay 的跨主机容器网络方案，几乎都是基于 vxlan 实现的（例外：cilium 也支持 geneve）。</p>
<blockquote>
<p>我们在学习单机的容器网络时，不需要接触到 vxlan，但是在学习跨主机容器网络方案如 flannel/calico/cilium 时，那 vxlan(overlay) 及 BGP(underlay) 就不可避免地要接触了。</p>
</blockquote>
<p>先介绍下 vxlan 的数据包结构：</p>
<p><figure><a class="lightgallery" href="/images/linux-virtual-interfaces/vxlan-frame.png" title="/images/linux-virtual-interfaces/vxlan-frame.png" data-thumbnail="/images/linux-virtual-interfaces/vxlan-frame.png" data-sub-html="<h2>VXLAN 栈帧结构</h2>">
        
    </a><figcaption class="image-caption">VXLAN 栈帧结构</figcaption>
    </figure></p>
<p>在创建 vxlan 的 vtep 虚拟设备时，我们需要手动设置图中的如下属性：</p>
<ul>
<li>VXLAN 目标端口：即接收方 vtep 使用的端口，这里 IANA 定义的端口是 4789，但是只有 calico 的 vxlan 模式默认使用该端口 calico，而 cilium/flannel 的默认端口都是 Linux 默认的 8472.</li>
<li>VNID: 每个 VXLAN 网络接口都会被分配一个独立的 VNID</li>
</ul>
<p>一个点对点的 vxlan 网络架构图如下:</p>
<p><figure><a class="lightgallery" href="/images/linux-virtual-interfaces/vxlan-architecture.gif" title="/images/linux-virtual-interfaces/vxlan-architecture.gif" data-thumbnail="/images/linux-virtual-interfaces/vxlan-architecture.gif" data-sub-html="<h2>VXLAN 点对点网络架构</h2>">
        
    </a><figcaption class="image-caption">VXLAN 点对点网络架构</figcaption>
    </figure></p>
<p>可以看到每台虚拟机 VM 都会被分配一个唯一的 VNID，然后两台物理机之间通过 VTEP 虚拟网络设备建立了 VXLAN 隧道，所有 VXLAN 网络中的虚拟机，都通过 VTEP 来互相通信。</p>
<p>有了上面这些知识，我们就可以通过如下命令在两台 Linux 机器间建立一个<strong>点对点的 VXLAN 隧道</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 在主机 A 上创建 VTEP 设备 vxlan0</span>
<span class="c1"># 与另一个 vtep 接口 B（192.168.8.101）建立隧道</span>
<span class="c1"># 将 vxlan0 自身的 IP 地址设为 192.168.8.100</span>
<span class="c1"># 使用的 VXLAN 目标端口为 4789(IANA 标准)</span>
ip link add vxlan0 <span class="nb">type</span> vxlan <span class="se">\
</span><span class="se"></span>    id <span class="m">42</span> <span class="se">\
</span><span class="se"></span>    dstport <span class="m">4789</span> <span class="se">\
</span><span class="se"></span>    remote 192.168.8.101 <span class="se">\
</span><span class="se"></span>    <span class="nb">local</span> 192.168.8.100 <span class="se">\
</span><span class="se"></span>    dev enp0s8
<span class="c1"># 为我们的 VXLAN 网络设置虚拟网段，vxlan0 就是默认网关</span>
ip addr add 10.20.1.2/24 dev vxlan0
<span class="c1"># 启用我们的 vxlan0 设备，这会自动生成路由规则</span>
ip link <span class="nb">set</span> vxlan0 up

<span class="c1"># 现在在主机 B 上运行如下命令，同样创建一个 VTEP 设备 vxlan0，remote 和 local 的 ip 与前面用的命令刚好相反。</span>
<span class="c1"># 注意 VNID 和 dstport 必须和前面完全一致</span>
ip link add vxlan0 <span class="nb">type</span> vxlan <span class="se">\
</span><span class="se"></span>    id <span class="m">42</span> <span class="se">\
</span><span class="se"></span>    dstport <span class="m">4789</span> <span class="se">\
</span><span class="se"></span>    remote 192.168.8.100 <span class="se">\
</span><span class="se"></span>    <span class="nb">local</span> 192.168.8.101 <span class="se">\
</span><span class="se"></span>    dev enp0s8
<span class="c1"># 为我们的 VXLAN 网络设置虚拟网段，vxlan0 就是默认网关</span>
ip addr add 10.20.1.3/24 dev vxlan0
ip link <span class="nb">set</span> vxlan0 up

<span class="c1"># 到这里，两台机器就完成连接，可以通信了。可以在主机 B 上 ping 10.20.1.2 试试，应该能收到主机 A 的回应。</span>
ping 10.20.1.2
</code></pre></td></tr></table>
</div>
</div><p>点对点的 vxlan 隧道实际用处不大，如果集群中的每个节点都互相建 vxlan 隧道，代价太高了。</p>
<p>一种更好的方式，是使用 <strong>「组播模式」的 vxlan 隧道</strong>，这种模式下一个 vtep 可以一次与组内的所有 vtep 建立隧道。
示例命令如下（这里略过了如何设置组播地址 <code>239.1.1.1</code> 的信息）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">ip link add vxlan0 <span class="nb">type</span> vxlan <span class="se">\
</span><span class="se"></span>    id <span class="m">42</span> <span class="se">\
</span><span class="se"></span>    dstport <span class="m">4789</span> <span class="se">\
</span><span class="se"></span>    group 239.1.1.1 <span class="se">\
</span><span class="se"></span>    dev enp0s8 
ip addr add 10.20.1.2/24 dev vxlan0
ip link <span class="nb">set</span> vxlan0 up
</code></pre></td></tr></table>
</div>
</div><p>可以看到，只需要简单地把 local_ip/remote_ip 替换成一个组播地址就行。组播功能会将收到的数据包发送给组里的所有 vtep 接口，但是只有 VNID 能对上的 vtep 会处理该报文，其他 vtep 会直接丢弃数据。</p>
<p>接下来，为了能让所有的虚拟机/容器，都通过 vtep 通信，我们再添加一个 bridge 网络，充当 vtep 与容器间的交换机。架构如下：</p>
<p><figure><a class="lightgallery" href="/images/linux-virtual-interfaces/linux-vxlan-with-bridge.jpg" title="/images/linux-virtual-interfaces/linux-vxlan-with-bridge.jpg" data-thumbnail="/images/linux-virtual-interfaces/linux-vxlan-with-bridge.jpg" data-sub-html="<h2>VXLAN 多播网络架构</h2>">
        
    </a><figcaption class="image-caption">VXLAN 多播网络架构</figcaption>
    </figure></p>
<p>使用 ip 命令创建网桥、网络名字空间、veth pairs 组成上图中的容器网络：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 创建 br0 并将 vxlan0 绑定上去</span>
ip link add br0 <span class="nb">type</span> bridge
ip link <span class="nb">set</span> vxlan0 master bridge
ip link <span class="nb">set</span> vxlan0 up
ip link <span class="nb">set</span> br0 up

<span class="c1"># 模拟将容器加入到网桥中的操作</span>
ip netns add container1

<span class="c1">## 创建 veth pair，并把一端加到网桥上</span>
ip link add veth0 <span class="nb">type</span> veth peer name veth1
ip link <span class="nb">set</span> dev veth0 master br0
ip link <span class="nb">set</span> dev veth0 up

<span class="c1">## 配置容器内部的网络和 IP</span>
ip link <span class="nb">set</span> dev veth1 netns container1
ip netns <span class="nb">exec</span> container1 ip link <span class="nb">set</span> lo up

ip netns <span class="nb">exec</span> container1 ip link <span class="nb">set</span> veth1 name eth0
ip netns <span class="nb">exec</span> container1 ip addr add 10.20.1.11/24 dev eth0
ip netns <span class="nb">exec</span> container1 ip link <span class="nb">set</span> eth0 up
</code></pre></td></tr></table>
</div>
</div><p>然后在另一台机器上做同样的操作，并创建新容器，两个容器就能通过 vxlan 通信啦~</p>
<h3 id="比组播更高效的-vxlan-实现">比组播更高效的 vxlan 实现</h3>
<p>组播最大的问题在于，因为它不知道数据的目的地，所以每个 vtep 都发了一份。如果每次发数据时，如果能够精确到对应的 vtep，就能节约大量资源。</p>
<p>另一个问题是 ARP 查询也会被组播，要知道 vxlan 本身就是个 overlay 网络，ARP 的成本也很高。</p>
<p>上述问题都可以通过一个中心化的注册中心（如 etcd）来解决，所有容器、网络的注册与变更，都写入到这个注册中心，然后由程序自动维护 vtep 之间的隧道、fdb 表及 ARP 表.</p>
<h2 id="八虚拟网络接口的速率">八、虚拟网络接口的速率</h2>
<p>Loopback 和本章讲到的其他虚拟网络接口一样，都是一种软件模拟的网络设备。
他们的速率是不是也像物理链路一样，存在链路层（比如以太网）的带宽限制呢？</p>
<p>比如目前很多老旧的网络设备，都是只支持到百兆以太网，这就决定了它的带宽上限。
即使是较新的设备，目前基本也都只支持到千兆，也就是 1GbE 以太网标准，那本文提到的虚拟网络接口单纯在本机内部通信，是否也存在这样的制约呢？是否也只能跑到 1GbE?</p>
<p>使用 ethtool 检查：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># docker 容器的 veth 接口速率
&gt; ethtool vethe899841 | grep Speed
        Speed: 10000Mb/s

# 网桥看起来没有固定的速率
&gt; ethtool docker0 | grep Speed
        Speed: Unknown!

# tun0 设备的默认速率貌似是 10Mb/s ?
&gt; ethtool tun0 | grep Speed
        Speed: 10Mb/s

# 此外 ethtool 无法检查 lo 以及 wifi 的速率
</code></pre></td></tr></table>
</div>
</div><h3 id="网络性能实测">网络性能实测</h3>
<p>接下来实际测试一下，先给出机器参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">❯ cat /etc/os-release 
NAME=&#34;openSUSE Tumbleweed&#34;
# VERSION=&#34;20210810&#34;
...

❯ uname -a
Linux legion-book 5.13.8-1-default #1 SMP Thu Aug 5 08:56:22 UTC 2021 (967c6a8) x86_64 x86_64 x86_64 GNU/Linux


❯ lscpu
Architecture:                    x86_64
CPU(s):                          16
Model name:                      AMD Ryzen 7 5800H with Radeon Graphics
...

# 内存，单位 MB
❯ free -m
               total        used        free      shared  buff/cache   available
Mem:           27929        4482       17324         249        6122       22797
Swap:           2048           0        2048
</code></pre></td></tr></table>
</div>
</div><p>使用 iperf3 测试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 启动服务端</span>
iperf3 -s

-------------
<span class="c1"># 新窗口启动客户端，通过 loopback 接口访问 iperf3-server，大概 49Gb/s</span>
❯ iperf3 -c 127.0.0.1
Connecting to host 127.0.0.1, port <span class="m">5201</span>
<span class="o">[</span>  5<span class="o">]</span> <span class="nb">local</span> 127.0.0.1 port <span class="m">48656</span> connected to 127.0.0.1 port <span class="m">5201</span>
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr  Cwnd
<span class="o">[</span>  5<span class="o">]</span>   0.00-1.00   sec  4.46 GBytes  38.3 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   1.00-2.00   sec  4.61 GBytes  39.6 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   2.00-3.00   sec  5.69 GBytes  48.9 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   3.00-4.00   sec  6.11 GBytes  52.5 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   4.00-5.00   sec  6.04 GBytes  51.9 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   5.00-6.00   sec  6.05 GBytes  52.0 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   6.00-7.00   sec  6.01 GBytes  51.6 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   7.00-8.00   sec  6.05 GBytes  52.0 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   8.00-9.00   sec  6.34 GBytes  54.5 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   9.00-10.00  sec  5.91 GBytes  50.8 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
- - - - - - - - - - - - - - - - - - - - - - - - -
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  57.3 GBytes  49.2 Gbits/sec    <span class="m">0</span>             sender
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  57.3 GBytes  49.2 Gbits/sec                  receiver

<span class="c1"># 客户端通过 wlp4s0 wifi 网卡(192.168.31.228)访问 iperf3-server，实际还是走的本机，但是速度要比 loopback 快一点，可能是默认设置的问题</span>
❯ iperf3 -c 192.168.31.228
Connecting to host 192.168.31.228, port <span class="m">5201</span>
<span class="o">[</span>  5<span class="o">]</span> <span class="nb">local</span> 192.168.31.228 port <span class="m">43430</span> connected to 192.168.31.228 port <span class="m">5201</span>
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr  Cwnd
<span class="o">[</span>  5<span class="o">]</span>   0.00-1.00   sec  5.12 GBytes  43.9 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   1.00-2.00   sec  5.29 GBytes  45.5 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   2.00-3.00   sec  5.92 GBytes  50.9 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   3.00-4.00   sec  6.00 GBytes  51.5 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   4.00-5.00   sec  5.98 GBytes  51.4 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   5.00-6.00   sec  6.05 GBytes  52.0 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   6.00-7.00   sec  6.16 GBytes  52.9 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   7.00-8.00   sec  6.08 GBytes  52.2 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   8.00-9.00   sec  6.00 GBytes  51.6 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   9.00-10.00  sec  6.01 GBytes  51.6 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
- - - - - - - - - - - - - - - - - - - - - - - - -
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  58.6 GBytes  50.3 Gbits/sec    <span class="m">0</span>             sender
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  58.6 GBytes  50.3 Gbits/sec                  receiver

<span class="c1"># 从容器中访问宿主机的 iperf3-server，速度几乎没区别</span>
❯ docker run  -it --rm --name<span class="o">=</span>iperf3-server networkstatic/iperf3 -c 192.168.31.228
Connecting to host 192.168.31.228, port <span class="m">5201</span>
<span class="o">[</span>  5<span class="o">]</span> <span class="nb">local</span> 172.17.0.2 port <span class="m">43436</span> connected to 192.168.31.228 port <span class="m">5201</span>
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr  Cwnd
<span class="o">[</span>  5<span class="o">]</span>   0.00-1.00   sec  4.49 GBytes  38.5 Gbits/sec    <span class="m">0</span>    <span class="m">403</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   1.00-2.00   sec  5.31 GBytes  45.6 Gbits/sec    <span class="m">0</span>    <span class="m">544</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   2.00-3.00   sec  6.14 GBytes  52.8 Gbits/sec    <span class="m">0</span>    <span class="m">544</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   3.00-4.00   sec  5.85 GBytes  50.3 Gbits/sec    <span class="m">0</span>    <span class="m">544</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   4.00-5.00   sec  6.14 GBytes  52.7 Gbits/sec    <span class="m">0</span>    <span class="m">544</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   5.00-6.00   sec  5.99 GBytes  51.5 Gbits/sec    <span class="m">0</span>    <span class="m">544</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   6.00-7.00   sec  5.86 GBytes  50.4 Gbits/sec    <span class="m">0</span>    <span class="m">544</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   7.00-8.00   sec  6.05 GBytes  52.0 Gbits/sec    <span class="m">0</span>    <span class="m">544</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   8.00-9.00   sec  5.99 GBytes  51.5 Gbits/sec    <span class="m">0</span>    <span class="m">544</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   9.00-10.00  sec  6.12 GBytes  52.5 Gbits/sec    <span class="m">0</span>    <span class="m">544</span> KBytes       
- - - - - - - - - - - - - - - - - - - - - - - - -
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  58.0 GBytes  49.8 Gbits/sec    <span class="m">0</span>             sender
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  58.0 GBytes  49.8 Gbits/sec                  receiver
</code></pre></td></tr></table>
</div>
</div><p>把 iperf3-server 跑在容器里再测一遍：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 在容器中启动 iperf3-server，并映射到宿主机端口 6201</span>
&gt; docker run  -it --rm --name<span class="o">=</span>iperf3-server -p 6201:5201 networkstatic/iperf3 -s
&gt; docker inspect --format <span class="s2">&#34;{{ .NetworkSettings.IPAddress }}&#34;</span> iperf3-server
172.17.0.2
-----------------------------
<span class="c1"># 测试容器之间互访的速度，ip 为 iperf3-server 的容器 ip，速度要慢一些。</span>
<span class="c1"># 毕竟过了 veth -&gt; veth -&gt; docker0 -&gt; veth -&gt; veth 五层虚拟网络接口</span>
❯ docker run  -it --rm networkstatic/iperf3 -c 172.17.0.2
Connecting to host 172.17.0.2, port <span class="m">5201</span>
<span class="o">[</span>  5<span class="o">]</span> <span class="nb">local</span> 172.17.0.3 port <span class="m">40776</span> connected to 172.17.0.2 port <span class="m">5201</span>
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr  Cwnd
<span class="o">[</span>  5<span class="o">]</span>   0.00-1.00   sec  4.74 GBytes  40.7 Gbits/sec    <span class="m">0</span>    <span class="m">600</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   1.00-2.00   sec  4.48 GBytes  38.5 Gbits/sec    <span class="m">0</span>    <span class="m">600</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   2.00-3.00   sec  5.38 GBytes  46.2 Gbits/sec    <span class="m">0</span>    <span class="m">600</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   3.00-4.00   sec  5.39 GBytes  46.3 Gbits/sec    <span class="m">0</span>    <span class="m">600</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   4.00-5.00   sec  5.42 GBytes  46.6 Gbits/sec    <span class="m">0</span>    <span class="m">600</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   5.00-6.00   sec  5.39 GBytes  46.3 Gbits/sec    <span class="m">0</span>    <span class="m">600</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   6.00-7.00   sec  5.38 GBytes  46.2 Gbits/sec    <span class="m">0</span>    <span class="m">635</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   7.00-8.00   sec  5.37 GBytes  46.1 Gbits/sec    <span class="m">0</span>    <span class="m">667</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   8.00-9.00   sec  6.01 GBytes  51.7 Gbits/sec    <span class="m">0</span>    <span class="m">735</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   9.00-10.00  sec  5.74 GBytes  49.3 Gbits/sec    <span class="m">0</span>    <span class="m">735</span> KBytes       
- - - - - - - - - - - - - - - - - - - - - - - - -
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  53.3 GBytes  45.8 Gbits/sec    <span class="m">0</span>             sender
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  53.3 GBytes  45.8 Gbits/sec                  receiver

<span class="c1"># 本机直接访问容器 ip，走的是 docker0 网桥，居然还挺快</span>
❯ iperf3 -c 172.17.0.2
Connecting to host 172.17.0.2, port <span class="m">5201</span>
<span class="o">[</span>  5<span class="o">]</span> <span class="nb">local</span> 172.17.0.1 port <span class="m">56486</span> connected to 172.17.0.2 port <span class="m">5201</span>
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr  Cwnd
<span class="o">[</span>  5<span class="o">]</span>   0.00-1.00   sec  5.01 GBytes  43.0 Gbits/sec    <span class="m">0</span>    <span class="m">632</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   1.00-2.00   sec  5.19 GBytes  44.6 Gbits/sec    <span class="m">0</span>    <span class="m">703</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   2.00-3.00   sec  6.46 GBytes  55.5 Gbits/sec    <span class="m">0</span>    <span class="m">789</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   3.00-4.00   sec  6.80 GBytes  58.4 Gbits/sec    <span class="m">0</span>    <span class="m">789</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   4.00-5.00   sec  6.82 GBytes  58.6 Gbits/sec    <span class="m">0</span>    <span class="m">913</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   5.00-6.00   sec  6.79 GBytes  58.3 Gbits/sec    <span class="m">0</span>   <span class="m">1007</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   6.00-7.00   sec  6.63 GBytes  56.9 Gbits/sec    <span class="m">0</span>   1.04 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   7.00-8.00   sec  6.75 GBytes  58.0 Gbits/sec    <span class="m">0</span>   1.04 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   8.00-9.00   sec  6.19 GBytes  53.2 Gbits/sec    <span class="m">0</span>   1.04 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   9.00-10.00  sec  6.55 GBytes  56.3 Gbits/sec    <span class="m">0</span>   1.04 MBytes       
- - - - - - - - - - - - - - - - - - - - - - - - -
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  63.2 GBytes  54.3 Gbits/sec    <span class="m">0</span>             sender
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  63.2 GBytes  54.3 Gbits/sec                  receiver

<span class="c1"># 如果走本机 loopback 地址 + 容器端口映射，速度就慢了好多</span>
<span class="c1"># 或许是因为用 iptables 做端口映射导致的？</span>
❯ iperf3 -c 127.0.0.1 -p <span class="m">6201</span>
Connecting to host 127.0.0.1, port <span class="m">6201</span>
<span class="o">[</span>  5<span class="o">]</span> <span class="nb">local</span> 127.0.0.1 port <span class="m">48862</span> connected to 127.0.0.1 port <span class="m">6201</span>
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr  Cwnd
<span class="o">[</span>  5<span class="o">]</span>   0.00-1.00   sec  2.71 GBytes  23.3 Gbits/sec    <span class="m">0</span>   1.37 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   1.00-2.00   sec  3.64 GBytes  31.3 Gbits/sec    <span class="m">0</span>   1.37 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   2.00-3.00   sec  4.08 GBytes  35.0 Gbits/sec    <span class="m">0</span>   1.37 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   3.00-4.00   sec  3.49 GBytes  30.0 Gbits/sec    <span class="m">0</span>   1.37 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   4.00-5.00   sec  5.50 GBytes  47.2 Gbits/sec    <span class="m">2</span>   1.37 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   5.00-6.00   sec  4.06 GBytes  34.9 Gbits/sec    <span class="m">0</span>   1.37 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   6.00-7.00   sec  4.12 GBytes  35.4 Gbits/sec    <span class="m">0</span>   1.37 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   7.00-8.00   sec  3.99 GBytes  34.3 Gbits/sec    <span class="m">0</span>   1.37 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   8.00-9.00   sec  3.49 GBytes  30.0 Gbits/sec    <span class="m">0</span>   1.37 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   9.00-10.00  sec  5.51 GBytes  47.3 Gbits/sec    <span class="m">0</span>   1.37 MBytes       
- - - - - - - - - - - - - - - - - - - - - - - - -
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  40.6 GBytes  34.9 Gbits/sec    <span class="m">2</span>             sender
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  40.6 GBytes  34.9 Gbits/sec                  receiver

<span class="c1"># 可走 wlp4s0 + 容器端口映射，速度也不慢啊</span>
❯ iperf3 -c 192.168.31.228 -p <span class="m">6201</span>
Connecting to host 192.168.31.228, port <span class="m">6201</span>
<span class="o">[</span>  5<span class="o">]</span> <span class="nb">local</span> 192.168.31.228 port <span class="m">54582</span> connected to 192.168.31.228 port <span class="m">6201</span>
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr  Cwnd
<span class="o">[</span>  5<span class="o">]</span>   0.00-1.00   sec  4.34 GBytes  37.3 Gbits/sec    <span class="m">0</span>    <span class="m">795</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   1.00-2.00   sec  4.78 GBytes  41.0 Gbits/sec    <span class="m">0</span>    <span class="m">834</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   2.00-3.00   sec  6.26 GBytes  53.7 Gbits/sec    <span class="m">0</span>    <span class="m">834</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   3.00-4.00   sec  6.30 GBytes  54.1 Gbits/sec    <span class="m">0</span>    <span class="m">875</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   4.00-5.00   sec  6.26 GBytes  53.8 Gbits/sec    <span class="m">0</span>    <span class="m">875</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   5.00-6.00   sec  5.75 GBytes  49.4 Gbits/sec    <span class="m">0</span>    <span class="m">875</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   6.00-7.00   sec  5.49 GBytes  47.2 Gbits/sec    <span class="m">0</span>    <span class="m">966</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   7.00-8.00   sec  5.72 GBytes  49.1 Gbits/sec    <span class="m">2</span>    <span class="m">966</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   8.00-9.00   sec  4.81 GBytes  41.3 Gbits/sec    <span class="m">2</span>    <span class="m">966</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   9.00-10.00  sec  5.98 GBytes  51.4 Gbits/sec    <span class="m">0</span>    <span class="m">966</span> KBytes       
- - - - - - - - - - - - - - - - - - - - - - - - -
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  55.7 GBytes  47.8 Gbits/sec    <span class="m">4</span>             sender
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  55.7 GBytes  47.8 Gbits/sec                  receiver
</code></pre></td></tr></table>
</div>
</div><p>总的来看，loopback、bridge、veth 这几个接口基本上是没被限速的，veth 有查到上限为 10000Mb/s（10Gb/s） 感觉也是个假数字，
实际上测出来的数据基本在 35Gb/s 到 55Gb/s 之间，视情况浮动。</p>
<p>性能的变化和虚拟网络设备的链路和类型有关，或许和默认配置的区别也有关系。</p>
<p>另外 TUN 设备这里没有测，<code>ethtool tun0</code> 查到的值是比较离谱的 10Mb/s，但是感觉不太可能这么慢，有时间可以再测一波看看。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://segmentfault.com/a/1190000009249039" target="_blank" rel="noopener noreferrer">Linux虚拟网络设备之tun/tap</a></li>
<li><a href="https://segmentfault.com/a/1190000009251098" target="_blank" rel="noopener noreferrer">Linux虚拟网络设备之veth</a></li>
<li><a href="https://opengers.github.io/openstack/openstack-base-virtual-network-devices-bridge-and-vlan/" target="_blank" rel="noopener noreferrer">云计算底层技术-虚拟网络设备(Bridge,VLAN)</a></li>
<li><a href="https://opengers.github.io/openstack/openstack-base-virtual-network-devices-tuntap-veth/" target="_blank" rel="noopener noreferrer">云计算底层技术-虚拟网络设备(tun/tap,veth)</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/networking/tuntap.txt" target="_blank" rel="noopener noreferrer">Universal TUN/TAP device driver - Kernel Docs</a></li>
<li><a href="https://backreference.org/2010/03/26/tuntap-interface-tutorial/" target="_blank" rel="noopener noreferrer">Tun/Tap interface tutorial</a></li>
<li><a href="https://stackoverflow.com/questions/5832308/linux-loopback-performance-with-tcp-nodelay-enabled" target="_blank" rel="noopener noreferrer">Linux Loopback performance with TCP_NODELAY enabled</a></li>
</ul>
]]></description></item><item><title>Linux 网络工具中的瑞士军刀 - socat &amp; netcat</title><link>https://thiscute.world/posts/socat-netcat/</link><pubDate>Sun, 11 Apr 2021 16:38:13 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/socat-netcat/</guid><description><![CDATA[<blockquote>
<p>文中的命令均在 macOS Big Sur 和 Opensuse Tumbleweed 上测试通过</p>
</blockquote>
<h2 id="socat--netcat">socat &amp; netcat</h2>
<p>netcat(network cat) 是一个历史悠久的网络工具包，被称作 TCP/IP 的瑞士军刀，各大 Linux 发行版都有默认安装 openbsd 版本的 netcat，它的命令行名称为 <code>nc</code>.</p>
<p>而 socat(socket cat)，官方文档描述它是 <code>&quot;netcat++&quot; (extended design, new implementation)</code>，项目比较活跃，kubernetes-client(kubectl) 底层就是使用的它做各种流量转发。</p>
<p>在不方便安装 socat 的环境中，我们可以使用系统自带的 netcat.
而在其他环境，可以考虑优先使用 socat.</p>
<h2 id="一简介">一、简介</h2>
<p>socat 的基本命令格式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">socat <span class="o">[</span>参数<span class="o">]</span> 地址1 地址2
</code></pre></td></tr></table>
</div>
</div><p>给 socat 提供两个地址，socat 干的活就是把两个地址的流对接起来。左边地址的输出传给右边，同时又把右边地址的输出传给左边，也就是一个<strong>双向的数据管道</strong>。</p>
<p>听起来好像没啥特别的，但是实际上计算机网络干的活也就是数据传输而已，却影响了整个世界，不可小觑它的功能。</p>
<p>socat 支持非常多的地址类型：<code>-</code>/stdio，TCP, TCP-LISTEN, UDP, UDP-LISTEN, OPEN, EXEC, SOCKS, PROXY 等等，可用于端口监听、链接，文件和进程读写，代理桥接等等。</p>
<p>socat 的功能就是这么简单，命令行参数也很简洁，唯一需要花点精力学习的就是它各种地址的定义和搭配写法。</p>
<p>而 netcat 定义貌似没这么严谨，可以简单的理解为网络版的 cat 命令 2333</p>
<h2 id="二安装方法">二、安装方法</h2>
<p>各发行版都自带 netcat，包名通常为 <code>nc-openbsd</code>，因此这里只介绍 socat 的安装方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Debian/Ubuntu</span>
sudo apt install socat

<span class="c1"># CentOS/RedHat</span>
sudo yum install socat

<span class="c1"># macOS</span>
brew install socat
</code></pre></td></tr></table>
</div>
</div><p>其他发行版基本也都可以使用包管理器安装 socat</p>
<h2 id="三常用命令">三、常用命令</h2>
<h3 id="1-网络调试">1. 网络调试</h3>
<h4 id="11-检测远程端口的可连接性确认防火墙没问题">1.1 检测远程端口的可连接性（确认防火墙没问题）</h4>
<blockquote>
<p>以前你可能学过如何用 telnet 来做这项测试，不过现在很多发行版基本都不自带 telnet 了，还需要额外安装。
telnet 差不多已经快寿终正寝了，还是建议使用更专业的 socat/netcat</p>
</blockquote>
<p>使用 socat/netcat 检测远程端口的可连接性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># -d[ddd] 增加日志详细程度，-dd  Prints fatal, error, warning, and notice messages.</span>
socat -dd - TCP:192.168.1.252:3306

<span class="c1"># -v 显示详细信息</span>
<span class="c1"># -z 不发送数据，效果为立即关闭连接，快速得出结果</span>
nc -vz 192.168.1.2 <span class="m">8080</span>

<span class="c1"># -vv 显示更详细的内容</span>
<span class="c1"># -w2 超时时间设为 2 秒</span>
<span class="c1"># 使用 nc 做简单的端口扫描</span>
nc -vv -w2 -z 192.168.1.2 20-500
</code></pre></td></tr></table>
</div>
</div><h4 id="12-测试本机端口是否能正常被外部访问检测防火墙路由">1.2 测试本机端口是否能正常被外部访问（检测防火墙、路由）</h4>
<p>在本机监听一个 TCP 端口，接收到的内容传到 stdout，同时将 stdin 的输入传给客户端：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 服务端启动命令，socat/nc 二选一</span>
socat TCP-LISTEN:7000 -
<span class="c1"># -l --listening</span>
nc -l <span class="m">7000</span>

<span class="c1"># 客户端连接命令，socat/nc 二选一</span>
socat TCP:192.168.31.123:7000 -
nc 192.168.11.123 <span class="m">7000</span>
</code></pre></td></tr></table>
</div>
</div><p>UDP 协议的测试也非常类似，使用 netcat 的示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 服务端，只监听 ipv4</span>
nc -u -l <span class="m">8080</span>

<span class="c1"># 客户端</span>
nc -u 192.168.31.123 <span class="m">8080</span>
<span class="c1"># 客户端本机测试，注意 localhost 会被优先解析为 ipv6! 这会导致服务端(ipv4)的 nc 接收不到数据！</span>
nc -u localhost <span class="m">8080</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 socat 的 UDP 测试示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">socat UDP-LISTEN:7000 -

socat UDP:192.168.31.123:7000 -
</code></pre></td></tr></table>
</div>
</div><h4 id="13-调试-tls-协议">1.3 调试 TLS 协议</h4>
<blockquote>
<p>参考 socat 官方文档：<a href="http://www.dest-unreach.org/socat/doc/socat-openssltunnel.html" target="_blank" rel="noopener noreferrer">Securing Traffic Between two Socat Instances Using SSL</a></p>
</blockquote>
<blockquote>
<p>测试证书及私钥的生成参见 <a href="https://thiscute.world/posts/about-tls-cert/" rel="">TLS 协议、TLS 证书、TLS 证书的配置方法、TLS 加密的破解手段</a></p>
</blockquote>
<p>模拟一个 mTLS 服务器，监听 4433 端口，接收到的数据同样输出到 stdout：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># socat 需要使用同时包含证书和私钥的 pem 文件，生成方法如下</span>
cat server.key server.crt &gt; server.pem
cat client.key client.crt &gt; client.pem

<span class="c1"># 服务端启动命令</span>
socat openssl-listen:4433,reuseaddr,cert<span class="o">=</span>server.pem,cafile<span class="o">=</span>client.crt -

<span class="c1"># 客户端连接命令</span>
socat - openssl-connect:192.168.31.123:4433,cert<span class="o">=</span>client.pem,cafile<span class="o">=</span>server.crt
<span class="c1"># 或者使用 curl 连接(我们知道 ca.crt 和 server.crt 都能被用做 cacert/cafile)</span>
curl -v --cacert ca.crt --cert client.crt --key client.key --tls-max 1.2 https://192.168.31.123:4433
</code></pre></td></tr></table>
</div>
</div><p>上面的命令使用了 mTLS 双向认证的协议，可通过设定 <code>verify=0</code> 来关掉客户端认证，示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">
<span class="c1"># socat 需要使用同时包含证书和私钥的 pem 文件，生成方法如下</span>
cat server.key server.crt &gt; server.pem

<span class="c1"># 服务端启动命令</span>
socat openssl-listen:4433,reuseaddr,cert<span class="o">=</span>server.pem,verify<span class="o">=</span><span class="m">0</span> -

<span class="c1"># 客户端连接命令，如果 ip/域名不受证书保护，就也需要添加 verify=0</span>
socat - openssl-connect:192.168.31.123:4433,cafile<span class="o">=</span>server.crt
<span class="c1"># 或者使用 curl 连接，证书无效请添加 -k 跳过证书验证</span>
curl -v --cacert server.crt https://192.168.31.123:4433
</code></pre></td></tr></table>
</div>
</div><h2 id="2-数据传输">2. 数据传输</h2>
<p>通常传输文件时，我都习惯使用 scp/ssh/rsync，但是 socat 其实也可以传输文件。</p>
<p>以将 demo.tar.gz 从主机 A 发送到主机 B 为例，
首先在数据发送方 A 执行如下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># -u 表示数据只从左边的地址单向传输给右边（socat 默认是一个双向管道）</span>
<span class="c1"># -U 和 -u 相反，数据只从右边单向传输给左边</span>
socat -u open:demo.tar.gz tcp-listen:2000,reuseaddr
</code></pre></td></tr></table>
</div>
</div><p>然后在数据接收方 B 执行如下命令，就能把文件接收到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">socat -u tcp:192.168.1.252:2000 open:demo.tar.gz,create
<span class="c1"># 如果觉得太繁琐，也可以直接通过 stdout 重定向</span>
socat -u tcp:192.168.1.252:2000 - &gt; demo.tar.gz
</code></pre></td></tr></table>
</div>
</div><p>使用 netcat 也可以实现数据传输：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 先在接收方启动服务端</span>
nc -l -p <span class="m">8080</span> &gt; demo.tar.gz
<span class="c1"># 再在发送方启动客户端发送数据</span>
nc 192.168.1.2 <span class="m">8080</span> &lt; demo.tar.gz
</code></pre></td></tr></table>
</div>
</div><h2 id="3-担当临时的-web-服务器">3. 担当临时的 web 服务器</h2>
<p>使用 <code>fork</code> <code>reuseaddr</code> <code>SYSTEM</code> 三个命令，再用 <code>systemd</code>/<code>supervisor</code> 管理一下，就可以用几行命令实现一个简单的后台服务器。</p>
<p>下面的命令将监听 8080 端口，并将数据流和 web.py 的 stdio 连接起来，可以直接使用浏览器访问 <code>http://&lt;ip&gt;:8080</code> 来查看效果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">socat TCP-LISTEN:8080,reuseaddr,fork SYSTEM:<span class="s2">&#34;python3 web.py&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>假设 <code>web.py</code> 的内容为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;hello world&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>那 <code>curl localhost:8080</code> 就应该会输出 <code>hello world</code></p>
<h2 id="4-端口转发">4. 端口转发</h2>
<p>监听 8080 端口，建立该端口与 <code>baidu.com:80</code> 之间的双向管道:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">socat TCP-LISTEN:8080,fork,reuseaddr  TCP:baidu.com:80
</code></pre></td></tr></table>
</div>
</div><p>拿 curl 命令测试一下，应该能正常访问到百度：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 注意指定 Host</span>
curl -v -H <span class="s1">&#39;Host: baidu.com&#39;</span> localhost:8080
</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/347722248" target="_blank" rel="noopener noreferrer">新版瑞士军刀：socat - 韦易笑 - 知乎</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/83959309" target="_blank" rel="noopener noreferrer">用好你的瑞士军刀/netcat - 韦易笑 - 知乎</a></li>
<li><a href="http://www.dest-unreach.org/socat/" target="_blank" rel="noopener noreferrer">socat - Multipurpose relay</a></li>
</ul>
]]></description></item><item><title>openSUSE 使用指南</title><link>https://thiscute.world/posts/opensuse-instruction/</link><pubDate>Mon, 04 Jan 2021 08:42:21 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/opensuse-instruction/</guid><description><![CDATA[<p>openSUSE 是一个基于 RPM 的发行版，这和 RHEL/CentOS 一致。
但是它的官方包管理器是专有的 zypper，挺好用的，软件也很新。</p>
<p>我最近从 <a href="https://thiscute.world/posts/manjaro-instruction/" rel="">Manjaro</a> 切换到了 openSUSE，发现 KDE 桌面确实比 Manjaro 更丝滑，而且社区源 OBS 体验下来比 AUR 更舒服。</p>
<p>尤其是容器/Kubernetes 方面，源里面的东西比 AUR 更丰富，而且是官方维护的。
本文算是对迁移流程做的一个总结。</p>
<blockquote>
<p>本文以 openSUSE Tumbleweed 为基础编写，这是一个和 Manjaro/Arch 一样的滚动发行版，软件源都很新。
openSUSE 社区的大部分用户都是使用的 Tumbleweed.
它的硬件兼容性也要比 openSUSE Leap（稳定版）好——实测小米游戏本安装 Leap，休眠后 Touchpad 会失灵。</p>
</blockquote>
<h2 id="一zypper-的基础命令">一、zypper 的基础命令</h2>
<p>zypper 的源在国内比较慢，但实际上下载的时候，zypper 会智能选择最快的镜像源下载软件包，比如国内的清华源等。</p>
<p>但是我发现官方的源索引更新太慢，甚至经常失败。因此没办法，还是得手动设置镜像源：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 禁用原有的官方软件源</span>
sudo zypper mr --disable repo-oss repo-non-oss repo-update repo-update-non-oss repo-debug
<span class="c1"># 添加北外镜像源</span>
sudo zypper ar -fcg https://mirrors.bfsu.edu.cn/opensuse/tumbleweed/repo/oss/ bfsu-oss
sudo zypper ar -fcg https://mirrors.bfsu.edu.cn/opensuse/tumbleweed/repo/non-oss/ bfsu-non-oss
</code></pre></td></tr></table>
</div>
</div><p>然后就是 zypper 的常用命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">sudo zypper refresh  <span class="c1"># refresh all repos</span>
sudo zypper update   <span class="c1"># update all softwares</span>

sudo zypper search --installed-only  &lt;package-name&gt;  <span class="c1"># 查找本地安装的程序</span>
sudo zypper search &lt;package-name&gt;  <span class="c1"># 查找本地和软件源中的程序</span>

sudo zypper install &lt;package-name&gt;  <span class="c1"># 安装程序</span>
sudo zypper remove --clean-deps &lt;package-name&gt;  <span class="c1"># 卸载程序，注意添加 --clean-deps 或者 -u，否则不会卸载依赖项！</span>

sudo zypper clean  <span class="c1"># 清理本地的包缓存</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="install-softwares">Install Softwares</h2>
<blockquote>
<p>这里需要用到 <a href="https://mirrors.openSUSE.org/list/bs.html" target="_blank" rel="noopener noreferrer">OBS(Open Build Service, 类似 arch 的 AUR，但是是预编译的包)</a>，因为 OBS 东西太多了，因此不存在完整的国内镜像，平均速度大概 300kb/s。
建议有条件可以在路由器上加智能代理提速。</p>
</blockquote>
<p>安装需要用到的各类软件:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 启用 Packman 仓库，使用北交镜像源</span>
sudo zypper ar -cfp <span class="m">90</span> <span class="s1">&#39;https://mirror.bjtu.edu.cn/packman/suse/openSUSE_Tumbleweed/&#39;</span> packman-bjtu

<span class="c1"># install video player and web browser</span>
sudo zypper install mpv ffmpeg-4 chromium firefox

<span class="c1"># install screenshot and other utils</span>
<span class="c1"># 安装好后可以配个截图快捷键 alt+a =&gt; `flameshot gui`</span>
sudo zypper install flameshot peek nomacs

<span class="c1"># install git clang/make/cmake</span>
sudo zypper install git gcc clang make cmake

<span class="c1"># install wireshark</span>
sudo zypper install wireshark
sudo gpasswd --add <span class="nv">$USER</span> wireshark  <span class="c1">#  将你添加到 wireshark 用户组中</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="ide--编程语言">IDE + 编程语言</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># install vscode: https://en.openSUSE.org/Visual_Studio_Code</span>
sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc
sudo zypper addrepo https://packages.microsoft.com/yumrepos/vscode vscode
sudo zypper refresh
sudo zypper install code

<span class="c1"># 安装 dotnet 5: https://docs.microsoft.com/en-us/dotnet/core/install/linux-openSUSE#openSUSE-15-</span>
sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc
sudo zypper addrepo https://packages.microsoft.com/openSUSE/15/prod/ microsoft-prod
sudo zypper refresh
sudo zypper install dotnet-sdk-5.0

<span class="c1"># 安装新版本的 go（源中的版本比较低，更建议从 go 官网下载安装）</span>
sudo zypper install go
</code></pre></td></tr></table>
</div>
</div><p>通过 tarball/script 安装：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># rustup，rust 环境管理器</span>
curl --proto <span class="s1">&#39;=https&#39;</span> --tlsv1.2 -sSf https://sh.rustup.rs <span class="p">|</span> sh

<span class="c1"># jetbrains toolbox app，用于安装和管理 pycharm/idea/goland/android studio 等 IDE</span>
<span class="c1"># 参见：https://www.jetbrains.com/toolbox-app/</span>

<span class="c1"># 不使用系统 python，改用 miniconda 装 python3.8</span>
<span class="c1"># 参考：https://github.com/ContinuumIO/docker-images/blob/master/miniconda3/debian/Dockerfile</span>
wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O /tmp/miniconda.sh
sudo /bin/bash /tmp/miniconda.sh -b -p /opt/conda
rm /tmp/miniconda.sh
sudo /opt/conda/bin/conda clean -tipsy
sudo ln -s /opt/conda/etc/profile.d/conda.sh /etc/profile.d/conda.sh
<span class="nb">echo</span> <span class="s2">&#34;. /opt/conda/etc/profile.d/conda.sh&#34;</span> &gt;&gt; ~/.bashrc
<span class="nb">echo</span> <span class="s2">&#34;conda activate base&#34;</span> &gt;&gt; ~/.bashrc
<span class="c1"># miniconda 的 entrypoint 默认安装在如下目录，添加到 PATH 中</span>
<span class="nb">echo</span> <span class="s2">&#34;export PATH=\$PATH:\$HOME/.local/bin&#34;</span> &gt;&gt; ~/.bashrc
</code></pre></td></tr></table>
</div>
</div><p>接下来安装 VSCode 插件，下列是我的插件列表：</p>
<ol>
<li>语言：
<ol>
<li>python/go/rust/c#/julia/flutter</li>
<li>xml/yaml/toml</li>
<li>vscode proto3</li>
</ol>
</li>
<li>ansible/terraform</li>
<li>markdown all in one + Markdown Preview Enhanced</li>
<li>美化：
<ol>
<li>community material theme</li>
<li>vscode icons</li>
<li>glasslt-vsc</li>
</ol>
</li>
<li>docker/kubernetes</li>
<li>IntelliJ IDEA Keybindings</li>
<li>gitlens</li>
<li>prettier</li>
<li>utils
<ol>
<li>comment translate</li>
<li>path intellisense</li>
<li>svg</li>
<li>visual studio intellicode</li>
</ol>
</li>
<li>antlr4</li>
<li>remote ssh + remote containers</li>
<li>rest client</li>
<li>vscode databases</li>
</ol>
<h3 id="容器--kubernetes">容器 + Kubernetes</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 时髦的新容器套装: https://documentation.suse.com/sles/15-SP2/html/SLES-all/cha-podman-overview.html</span>
sudo zypper in podman kompose skopeo buildah katacontainers
<span class="c1"># 安装 kubernetes 相关工具，tumbleweed 官方仓库的包都非常新！很舒服</span>
sudo zypper in helm k9s kubernetes-client

<span class="c1"># 本地测试目前还是 docker-compose 最方便，docker 仍有必要安装</span>
sudo zypper in docker
sudo gpasswd --add <span class="nv">$USER</span> docker
sudo systemctl <span class="nb">enable</span> docker
sudo systemctl start docker

<span class="c1"># 简单起见，直接用 pip 安装 docker-compose 和 podman-compose</span>
sudo pip install docker-compose podman-compose
</code></pre></td></tr></table>
</div>
</div><h3 id="办公音乐聊天">办公、音乐、聊天</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 添加 openSUSE_zh 源：https://build.opensuse.org/project/show/home:opensuse_zh</span>
sudo zypper addrepo <span class="s1">&#39;https://download.opensuse.org/repositories/home:/opensuse_zh/openSUSE_Tumbleweed&#39;</span> openSUSE_zh
sudo zypper refresh
sudo zypper install wps-office netease-cloud-music

<span class="c1"># linux qq: https://im.qq.com/linuxqq/download.html</span>
<span class="c1"># 虽然简陋但也够用，发送文件比 KDE Connect 要方便一些。</span>
sudo rpm -ivh linux_qq.rpm
</code></pre></td></tr></table>
</div>
</div><h3 id="安装输入法">安装输入法</h3>
<p>我用的输入法是小鹤音形，首先安装 fcitx-rime:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 添加 m17n obs 源：https://build.openSUSE.org/repositories/M17N</span>
sudo zypper addrepo <span class="s1">&#39;https://download.opensuse.org/repositories/M17N/openSUSE_Tumbleweed&#39;</span> m17n
sudo zypper refresh
sudo zypper install fcitx5 fcitx5-configtool fcitx5-qt5 fcitx5-rime
</code></pre></td></tr></table>
</div>
</div><p>然后，从 <a href="http://flypy.ys168.com/" target="_blank" rel="noopener noreferrer">http://flypy.ys168.com/</a> 下载最新的鼠须管（MacOS）配置文件，将解压得到的 rime 文件夹拷贝到 ~/.local/share/fcitx5/ 下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">mv rime ~/.local/share/fcitx5/
</code></pre></td></tr></table>
</div>
</div><p>现在重启系统，在 fcitx5 配置里面添加 rime「中州韵」，就可以正常使用小鹤音形了。</p>
<h3 id="qemukvm">QEMU/KVM</h3>
<p>不得不说，openSUSE 安装 KVM 真的超方便，纯 GUI 操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># see: https://doc.openSUSE.org/documentation/leap/virtualization/html/book-virt/cha-vt-installation.html</span>
sudo yast2 virtualization
<span class="c1"># enter to terminal ui, select kvm + kvm tools, and then install it.</span>
</code></pre></td></tr></table>
</div>
</div><p>KVM 的详细文档参见 <a href="../../virutal%20machine/KVM/README.md" rel="">KVM/README.md</a></p>
<h3 id="kde-connect">KDE Connect</h3>
<p>KDE Connect 是一个 PC 手机协同工具，可以在电脑和手机之间共享剪切版、远程输入、发送文件、共享文件夹、通知同步等等。
总而言之非常好用，只要手机和 PC 处于同一个局域网就行，不需要什么数据线。</p>
<p>如果安装系统时选择了打开防火墙，KDE Connect 是连不上的，需要手动开放端口号：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># see: https://userbase.kde.org/KDEConnect#firewalld</span>
<span class="c1"># 还可以使用 --add-source=xx.xx.xx.xx/xx 设置 ip 白名单</span>
sudo firewall-cmd --zone<span class="o">=</span>public --permanent --add-port<span class="o">=</span>1714-1764/tcp
sudo firewall-cmd --zone<span class="o">=</span>public --permanent --add-port<span class="o">=</span>1714-1764/udp
sudo systemctl restart firewalld.service
</code></pre></td></tr></table>
</div>
</div><p>然后手机（Android）安装好 KDE Connect，就能开始享受了。</p>
<p>目前存在的 Bug:</p>
<ul>
<li><i class="far fa-square fa-fw"></i> Android 10 禁止了后台应用读取剪切版，这导致 KDE Connect 只能从 PC 同步到手机，而无法反向同步。
<ul>
<li>如果你有 ROOT 权限，可以参考 <a href="https://szclsya.me/posts/android/fix-clipboard-android-10/" target="_blank" rel="noopener noreferrer">Fix clipboard permission on Android 10</a> 的方法，安装 ClipboardWhitelist 来打开权限。</li>
<li>否则，貌似就只能使用手机端的「远程输入」模块来手动传输文本了。</li>
</ul>
</li>
</ul>
<h3 id="qv2ray-代理">Qv2ray 代理</h3>
<p>Qv2ray 是我用过的比较好用的 GUI 代理工具，通过插件可支持常见的所有代理协议。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># see: https://build.openSUSE.org/repositories/home:zzndb</span>
sudo zypper addrepo <span class="s1">&#39;https://download.opensuse.org/repositories/home:/zzndb/openSUSE_Tumbleweed&#39;</span> qv2ray
sudo zypper refresh
sudo zypper install Qv2ray QvPlugin-Trojan QvPlugin-SS
</code></pre></td></tr></table>
</div>
</div><h3 id="vpn-连接与防火墙">VPN 连接与防火墙</h3>
<p>防火墙默认会禁用 pptp 等 vpn 协议的端口，需要手动打开.</p>
<p>允许使用 PPTP 协议：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 允许 gre 数据包流入网络</span>
sudo firewall-cmd --permanent --zone<span class="o">=</span>public --direct --add-rule ipv4 filter INPUT <span class="m">0</span> -p gre -j ACCEPT
sudo firewall-cmd --permanent --zone<span class="o">=</span>public --direct --add-rule ipv6 filter INPUT <span class="m">0</span> -p gre -j ACCEPT

<span class="c1"># masquerade: 自动使用 interface 地址伪装所有流量（将主机当作路由器使用，vpn 是虚拟网络，需要这个功能）</span>
sudo firewall-cmd --permanent --zone<span class="o">=</span>public --add-masquerade
<span class="c1"># pptp 客户端使用固定端口 1723/tcp 通信</span>
firewall-cmd --add-port<span class="o">=</span>1723/tcp --permanent

sudo firewall-cmd --reload
</code></pre></td></tr></table>
</div>
</div><p>允许使用 wireguard 协议，此协议只使用 tcp 协议，而且可以端口号可以自定义。不过 wireguard 自身的配置文件 <code>/etc/wireguard/xxx.conf</code> 就能配置 iptables 参数放行相关端口，这里就不赘述了。</p>
<h2 id="其他设置">其他设置</h2>
<p>从 Windows 带过来的习惯是单击选中文件，双击才打开，这个可以在「系统设置」-「工作空间行为」-「常规行为」-「点击行为」中修改。</p>]]></description></item><item><title>Manjaro 使用指南</title><link>https://thiscute.world/posts/manjaro-instruction/</link><pubDate>Sat, 13 Jul 2019 20:38:24 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/manjaro-instruction/</guid><description><![CDATA[<p>Manjaro 是一个基于 Arch Linux 的 Linux 滚动发行版，用着挺舒服的。
最大的特点，是包仓库很丰富，而且都很新。代价是偶尔会出些小毛病。</p>
<blockquote>
<p>2021-09-22 更新：今天被群友科普，可能我下面列举的几个滚挂事件，可能都和我使用了 archlinuxcn 这个源有关，这确实有可能。</p>
</blockquote>
<p>我一年多的使用中，遇到过 qv2-ray 动态链接库炸掉的问题，没专门去找修复方法，好像是等了一两个月，升级了两个大版本才恢复。
另一个就是 <a href="https://github.com/microsoft/vscode/issues/110322" target="_blank" rel="noopener noreferrer">VSCode - Incorrect locale &lsquo;en-US&rsquo; used everywhere</a></p>
<p>还遇到过 <code>libguestfs</code> 的一个问题：<code>vrit-v2v</code>/<code>virt-p2v</code> 两个工具被拆分出去，导致 manjaro 只能通过源码安装这俩货。这貌似目前仍旧没有解决。</p>
<p>总的来说体验很不错，能很及时地用上各种新版本的软件。</p>
<h2 id="一pacmanyay-的基础命令">一、pacman/yay 的基础命令</h2>
<p>Manjaro 装好后，需要运行的第一条命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">sudo pacman -Syy <span class="c1">## 强制更新 package 目录</span>
sudo pacman-mirrors --interactive --country China  <span class="c1"># 列出所有国内的镜像源，并提供交互式的界面手动选择镜像源</span>
sudo pacman -Syyu  <span class="c1"># 强制更新 package 目录，并尝试更新已安装的所有 packages.</span>
sudo pacman -S yay  <span class="c1"># 安装 yay</span>
</code></pre></td></tr></table>
</div>
</div><p>pacman 是 arch/manjaro 的官方包管理器，而刚刚安装的 yay，则是一个能查询 arch linux 的 aur 仓库的第三方包管理器，非常流行。</p>
<p>pacman 的常用命令语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">pacman -S package_name        <span class="c1"># 安装软件  </span>
pacman -S extra/package_name  <span class="c1"># 安装不同仓库中的版本</span>
pacman -Syu                   <span class="c1"># 升级整个系统，y是更新数据库，yy是强制更新，u是升级软件</span>
pacman -Ss string             <span class="c1"># 在包数据库中查询软件</span>
pacman -Si package_name       <span class="c1"># 显示软件的详细信息</span>
pacman -Sc                    <span class="c1"># 清除软件缓存，即/var/cache/pacman/pkg目录下的文件</span>
pacman -R package_name        <span class="c1"># 删除单个软件</span>
pacman -Rs package_name       <span class="c1"># 删除指定软件及其没有被其他已安装软件使用的依赖关系</span>
pacman -Qs string             <span class="c1"># 查询已安装的软件包</span>
pacman -Qi package_name       <span class="c1"># 查询本地安装包的详细信息</span>
pacman -Ql package_name       <span class="c1"># 获取已安装软件所包含的文件的列表</span>
pacman -U package.tar.zx      <span class="c1"># 从本地文件安装</span>
pactree package_name          <span class="c1"># 显示软件的依赖树</span>
</code></pre></td></tr></table>
</div>
</div><p>yay 的用法和 pacman 完全类似，上述所有 <code>pacman xxx</code> 命令，均可替换成 <code>yay xxx</code> 执行。</p>
<p>此外，还有一条 <code>yay</code> 命令值得记一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">yay -c  <span class="c1"># 卸载所有无用的依赖。类比 apt-get autoremove</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="常用软件与配置">常用软件与配置</h2>
<h3 id="1-添加-archlinux-中文社区仓库">1. 添加 archlinux 中文社区仓库</h3>
<p><a href="https://www.archlinuxcn.org/archlinux-cn-repo-and-mirror/" target="_blank" rel="noopener noreferrer">Arch Linux 中文社区仓库</a> 是由 Arch Linux 中文社区驱动的非官方用户仓库，包含一些额外的软件包以及已有软件的 git 版本等变种。部分软件包的打包脚本来源于 AUR。</p>
<p>一些国内软件，如果直接从 aur 安装，那就会有一个编译过程，有点慢。而 archlinuxcn 有已经编译好的包，可以直接安装。更新速度也很快，推荐使用。</p>
<p>配置方法见 <a href="https://github.com/archlinuxcn/repo" target="_blank" rel="noopener noreferrer">Arch Linux Chinese Community Repository</a>。</p>
<h3 id="2-安装常用软件">2. 安装常用软件</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">sudo pacman -S google-chrome  firefox         <span class="c1"># 浏览器</span>
sudo pacman -S netease-cloud-music     <span class="c1"># 网易云音乐</span>
sudo pacman -S noto-fonts-cjk wqy-bitmapfont wqy-microhei wqy-zenhei   <span class="c1"># 中文字体：思源系列、文泉系列</span>
sudo pacman -S wps-office ttf-wps-fonts

sudo pacman -S vim                     <span class="c1"># 命令行编辑器</span>
sudo pacman -S git                     <span class="c1"># 版本管理工具</span>
sudo pacman -S clang make cmake gdb    <span class="c1"># 编译调试环境</span>
sudo pacman -S visual-studio-code-bin  <span class="c1"># 代码编辑器</span>

sudo pacman -S wireshark-qt  mitmproxy         <span class="c1"># 抓包工具</span>
sudo pacman -S docker  <span class="c1"># docker 容器</span>
</code></pre></td></tr></table>
</div>
</div><p>其中 docker 和 wireshark 需要额外配置，否则会要求管理员权限：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">sudo groupadd wireshark
sudo gpasswd --add <span class="nv">$USER</span> wireshark  <span class="c1">#  将你添加到 wireshark 用户组中</span>

sudo groupadd docker
sudo gpasswd --add <span class="nv">$USER</span> docker  <span class="c1"># 同上</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="3-中文输入法">3. 中文输入法</h3>
<p>有两个选择：<a href="https://rime.im/" target="_blank" rel="noopener noreferrer">中州韵（rime）</a>和<a href="https://aur.archlinux.org/packages/fcitx-sogoupinyin/" target="_blank" rel="noopener noreferrer">搜狗拼音（sogoupinyin）</a>。</p>
<p>简单省事用搜狗，要用特殊的输入方案（五笔、音形、二笔等等）就只有 rime 可选了。</p>
<h4 id="31-fcitx5-rime-配置小鹤音形">3.1 fcitx5-rime 配置小鹤音形</h4>
<p>首先安装 fcitx5-rime, 注意这些组件一个都不能省略：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">sudo pacman -S fcitx5  fcitx5-chinese-addons fcitx5-gtk  fcitx5-qt  kcm-fcitx5 fcitx5-rime
</code></pre></td></tr></table>
</div>
</div><p>第二步是修改环境变量，将 fcitx5-rime 设为默认输入法并自动启动。</p>
<p>添加 <code>~/.pam_environment</code> 文件，内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">INPUT_METHOD  DEFAULT=fcitx5
GTK_IM_MODULE DEFAULT=fcitx5
QT_IM_MODULE  DEFAULT=fcitx5
XMODIFIERS    DEFAULT=@im=fcitx5
</code></pre></td></tr></table>
</div>
</div><p><a href="https://wiki.archlinux.org/index.php/PAM_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29" target="_blank" rel="noopener noreferrer">pam-env</a> 模块会在所有登录会话中读取上面的配置文件，包括 X11 会话和 Wayland 会话。</p>
<p>添加自动启动：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># ~/.xprofile 是 x11 GUI 的环境变量配置文件</span>
<span class="nb">echo</span> <span class="s1">&#39;fcitx5 &amp;&#39;</span> &gt;&gt; ~/.xprofile
</code></pre></td></tr></table>
</div>
</div><p>然后，从 <a href="http://flypy.ys168.com/" target="_blank" rel="noopener noreferrer">http://flypy.ys168.com/</a> 下载最新的鼠须管（MacOS）配置文件，将解压得到的 rime 文件夹拷贝到 ~/.local/share/fcitx5/ 下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">mv rime ~/.local/share/fcitx5/
</code></pre></td></tr></table>
</div>
</div><p>现在重启系统，在 fcitx5 配置里面添加 rime，就可以正常使用小鹤音形了。</p>
<h2 id="坑">坑</h2>
<p>使用过程中，我也遇到了一些坑：</p>
<ol>
<li>安装软件包时，无法在线安装旧版本！除非你本地有旧版本的安装包没清除，才可以通过缓存安装旧版本。
<ul>
<li>这种问题没遇到时好说，但有时候新版本有问题，旧安装包也清理掉了无法回退，就非常麻烦。</li>
<li>而且就算你回退了版本，一升级它就又更新了。。</li>
</ul>
</li>
</ol>
<h2 id="彻底删除-manjaro-及其引导项">彻底删除 Manjaro 及其引导项</h2>
<p>最近(2021-01)切换到了 OpenSUSE，体验很好，于是决定删除掉 Manjaro。</p>
<p>一番操作，总结出的删除流程如下（以下命令均需要 root 权限）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 1. 删除 EFI 引导项</span>
<span class="c1">## 查看 efi 的所有启动项，找到 Manjaro 的编号</span>
efibootmgr
<span class="c1">## 删除掉 Manjaro 启动项</span>
sudo efibootmgr --delete-bootnum -b <span class="m">2</span>

<span class="c1"># 2. 删除 manjaro 的 bootloader</span>
<span class="c1">## 我使用了 manjaro 默认的安装策略，bootloader 被安装在了和 windows 相同的 EFI 分区下</span>
<span class="c1">## 首先通过 opnsuse 的分区工具，找到 EFI 分区的设备号，然后挂载它</span>
mkdir efi
mount /dev/nvme0n1p1 efi
<span class="c1"># 删除 Manjaro bootloader</span>
rm -r EFI/Manjaro

<span class="c1"># 3. 重建 grub2 引导项</span>
grub2-mkconfig &gt;  /boot/grub2/grub.cfg

<span class="c1"># 4. 最后，通过分区工具删除 Manjaro 的所有分区，我是 SSD，只有一个分区</span>

<span class="c1"># 5. 重启系统，所有东西就全删除干净了。</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<ul>
<li><a href="https://wiki.archlinux.org/index.php/Main_page_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29" target="_blank" rel="noopener noreferrer">Arch Linux Wiki - 中文</a></li>
<li><a href="https://aur.archlinux.org/packages" target="_blank" rel="noopener noreferrer">AUR 仓库</a></li>
<li><a href="https://www.archlinuxcn.org/archlinux-cn-repo-and-mirror/" target="_blank" rel="noopener noreferrer">Arch Linux 中文社区仓库</a></li>
<li><a href="https://github.com/Jguer/yay" target="_blank" rel="noopener noreferrer">yay - Yet another Yogurt - An AUR Helper written in Go </a></li>
<li><a href="https://panqiincs.me/2019/06/05/after-installing-manjaro/" target="_blank" rel="noopener noreferrer">安装Manjaro之后的配置 </a></li>
<li><a href="https://wiki.archlinux.org/index.php/Fcitx5_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29" target="_blank" rel="noopener noreferrer">Arch Linux Wiki - Fcitx5</a></li>
</ul>]]></description></item><item><title>通过 systemctl 设置自定义 Service</title><link>https://thiscute.world/posts/systemd-basics/</link><pubDate>Mon, 28 Jan 2019 20:13:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/systemd-basics/</guid><description><![CDATA[<h2 id="前言">前言</h2>
<p>如果要在Linux 上设置一个开机自启，出现问题自动重启，并且有良好日志的程序，比较流行的方法有 <code>supervisord</code>、<code>systemd</code>，除此之外，还有 upstart、runit 等类似的工具。
但是自从 systemd 被 ubuntu、centos 等主流 Linux 发行版应用以来，systemd 渐渐成为主流方案。</p>
<p>如果你需要跨平台(Linux/MacOSX/FreeBSD)的方案，那么建议使用 <code>supervisord</code>，如果只需要支持 Linux 则建议选用 <code>systemd</code>.</p>
<h3 id="配置说明">配置说明</h3>
<p>要自定义一个服务，需要在 <code>/usr/lib/systemd/system/</code> 下添加一个配置文件：<code>&lt;software-name&gt;.service</code></p>
<blockquote>
<p>如果 <code>/usr/lib/systemd/system/</code> 不存在，可考虑使用 <code>/lib/systemd/system/</code> 或 <code>/etc/systemd/system/</code></p>
</blockquote>
<blockquote>
<p><code>ExecXXX</code> 中的命令，均可以正常使用转义字符以及环境变量插值语法，比如用 <code>\</code> 结尾表示换行，用 $Xxx 获取环境变量。</p>
</blockquote>
<p>配置文件的内容说明：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">Unit</span><span class="p">]</span><span class="err">:</span> <span class="err">服务的启动顺序与依赖关系</span>
<span class="nx">Description</span><span class="err">:</span> <span class="err">当前服务的简单描述</span>
<span class="nx">After</span><span class="err">:</span> <span class="err">当前服务（&lt;</span><span class="nx">software-name</span><span class="err">&gt;</span><span class="p">.</span><span class="nx">service</span><span class="err">）需要在这些服务启动后，才启动</span>
<span class="nx">Before</span><span class="err">:</span> <span class="err">和</span> <span class="nx">After</span> <span class="err">相反，当前服务需要在这些服务启动前，先启动</span>
<span class="nx">Wants</span><span class="err">：表示当前服务</span><span class="s2">&#34;弱依赖&#34;</span><span class="err">于这些服务。即当前服务依赖于它们，但是没有它们，当前服务也能正常运行。</span>
<span class="nx">Requires</span><span class="err">:</span> <span class="err">表示</span><span class="s2">&#34;强依赖&#34;</span><span class="err">关系，即如果该服务启动失败或异常退出，那么当前服务也必须退出。</span>


<span class="p">[</span><span class="nx">Service</span><span class="p">]</span> <span class="err">服务运行参数的设置</span>
<span class="nx">Type</span><span class="p">=</span><span class="nx">forking</span>  <span class="err">后台运行的形式</span>
<span class="nx">PIDFile</span><span class="p">=</span><span class="err">/</span><span class="nx">software-name</span><span class="err">/</span><span class="nx">pid</span>   <span class="nx">pid</span><span class="err">文件路径</span>
<span class="nx">EnvironmentFile</span><span class="p">=</span><span class="err">/</span><span class="nx">xxx</span><span class="err">/</span><span class="nx">prod</span><span class="p">.</span><span class="nx">env</span>  <span class="err">通过文件设定环境变量，注意这东西不支持环境变量的插值语法</span> <span class="err">$</span><span class="p">{</span><span class="nx">xxx</span><span class="p">}</span>
<span class="nx">WorkingDirectory</span><span class="p">=</span><span class="err">/</span><span class="nx">xxx</span><span class="err">/</span><span class="nx">xxx</span>    <span class="err">工作目录</span>
<span class="nx">ExecStartPre</span>  <span class="err">为启动做准备的命令</span>
<span class="nx">ExecStart</span>  <span class="err">服务的具体运行命令（对非</span> <span class="nx">workingdirectory</span> <span class="err">的文件，必须用绝对路径！</span>
<span class="nx">ExecReload</span>  <span class="err">重载命令，如果程序支持</span> <span class="nx">HUP</span> <span class="err">信号的话，通常将此项设为</span> <span class="err">`/</span><span class="nx">bin</span><span class="err">/</span><span class="nx">kill</span> <span class="nx">-HUP</span> <span class="err">$</span><span class="nx">MAINPID</span><span class="err">`</span>
<span class="nx">ExecStop</span>  <span class="err">停止命令</span>
<span class="nx">ExecStartPre</span><span class="err">：启动服务之前执行的命令</span>
<span class="nx">ExecStartPost</span><span class="err">：启动服务之后执行的命令</span>
<span class="nx">ExecStopPost</span><span class="err">：停止服务之后执行的命令</span>
<span class="nx">RuntimeDirectory</span><span class="p">=</span><span class="nx">xxxx</span>
<span class="nx">RuntimeDirectoryMode</span><span class="p">=</span><span class="mi">0775</span>
<span class="nx">PrivateTmp</span><span class="p">=</span><span class="nx">True</span>  <span class="err">表示给服务分配独立的临时空间</span>
<span class="nx">RestartSec</span>  <span class="err">自动重启当前服务间隔的秒数</span>
<span class="nx">Restart</span>  <span class="err">定义何种情况</span> <span class="nx">Systemd</span> <span class="err">会自动重启当前服务，可能的值包括</span><span class="nx">always</span><span class="err">（总是重启）、</span><span class="nx">on-success</span><span class="err">、</span><span class="nx">on-failure</span> <span class="err">等</span>
<span class="c"># 程序的 user 和 group</span>
<span class="nx">User</span><span class="p">=</span><span class="nx">ryan</span>
<span class="nx">Group</span><span class="p">=</span><span class="nx">ryan</span>


<span class="err">注意：启动、重载、停止命令全部要求使用绝对路径</span>

<span class="p">[</span><span class="nx">Install</span><span class="p">]</span> <span class="err">定义如何安装这个配置文件，即怎样做到开机启动。</span>
<span class="c"># Target的含义是服务组，表示一组服务。</span>
<span class="nx">WantedBy</span><span class="p">=</span><span class="nx">multi-user</span><span class="p">.</span><span class="nx">target</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>注意，service 文件不支持行内注释！！！注释必须单独一行</strong></p>
<h3 id="type-说明">Type 说明</h3>
<p>Type 感觉是整个配置文件里面最不好理解的一个配置项，它的实际作用就是：<strong>告诉 systemd 你的 Service 是如何启动的</strong></p>
<ol>
<li>
<p><code>Type=simple</code>（默认值）：<code>ExecStart</code> 命令会立即启动你的服务，并且持续运行，不会退出。</p>
</li>
<li>
<p><code>Type=forking</code>：<code>ExecStart</code> 命令会 fork 出你的服务主进程，然后正常退出。使用此 Type 时应同时指定 <code>PIDFile=</code>，systemd 使用它跟踪服务的主进程。</p>
</li>
<li>
<p><code>Type=oneshot</code>：<code>ExecStart</code> 命令。可能需要同时设置 <code>RemainAfterExit=yes</code> 使得 <code>systemd</code> 在服务进程退出之后仍然认为服务处于激活状态</p>
</li>
<li>
<p><code>Type=notify</code>：与 <code>Type=simple</code> 相同，但约定服务会在就绪后向 systemd 发送一个信号，以表明自己已经启动成功。</p>
<ul>
<li>细节：systemd 会创建一个 unix socket，并将地址通过 $NOTIFY_SOCKET 环境变量提供给服务，同时监听该 socket 上的信号。服务可以使用 systemd 提供的 C 函数 <code>sd_notify()</code> 或者命令行工具 <code>systemd-notify</code> 发送信号给 systemd.</li>
<li>因为多了个 notify 信号，所以这一 Type 要比 simple 更精确一点。但是需要服务的配合，</li>
</ul>
</li>
<li>
<p><code>Type=dbus</code>：若以此方式启动，当指定的 BusName 出现在 DBus 系统总线上时，systemd 认为服务就绪。</p>
</li>
<li>
<p><code>Type=idle</code>：没搞明白，不过通常也用不到。</p>
</li>
</ol>
<p>更详细的见 <a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener noreferrer">Systemd 入门教程：命令篇 - 阮一峰</a>。</p>
<h3 id="配置举例">配置举例</h3>
<p>比如 shadsocks Server Service，的配置文件 <code>ss-server.service</code> 的内容为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">Unit</span><span class="p">]</span>
<span class="nx">Description</span><span class="p">=</span><span class="nx">shadsocks</span> <span class="nx">server</span>
<span class="nx">After</span><span class="p">=</span><span class="nx">network</span><span class="p">.</span><span class="nx">target</span> <span class="nx">auditd</span><span class="p">.</span><span class="nx">service</span>

<span class="p">[</span><span class="nx">Service</span><span class="p">]</span>
<span class="nx">Type</span><span class="p">=</span><span class="nx">forking</span>
<span class="nx">ExecStart</span><span class="p">=</span><span class="err">/</span><span class="nx">usr</span><span class="err">/</span><span class="nx">local</span><span class="err">/</span><span class="nx">bin</span><span class="err">/</span><span class="nx">ssserver</span> <span class="nx">-c</span> <span class="err">/</span><span class="nx">etc</span><span class="err">/</span><span class="nx">shadsocks</span><span class="p">.</span><span class="nx">json</span> <span class="nx">--user</span> <span class="nx">shadsocks</span> <span class="nx">--pid-file</span> <span class="err">/</span><span class="nx">var</span><span class="err">/</span><span class="nx">run</span><span class="err">/</span><span class="nx">shadsocks</span><span class="p">.</span><span class="nx">pid</span> <span class="nx">-d</span> <span class="nx">start</span>
<span class="nx">ExecStop</span><span class="p">=</span><span class="err">/</span><span class="nx">usr</span><span class="err">/</span><span class="nx">local</span><span class="err">/</span><span class="nx">bin</span><span class="err">/</span><span class="nx">ssserver</span> <span class="nx">-c</span> <span class="err">/</span><span class="nx">etc</span><span class="err">/</span><span class="nx">shadsocks</span><span class="p">.</span><span class="nx">json</span> <span class="nx">--user</span> <span class="nx">shadsocks</span> <span class="nx">--pid-file</span> <span class="err">/</span><span class="nx">var</span><span class="err">/</span><span class="nx">run</span><span class="err">/</span><span class="nx">shadsocks</span><span class="p">.</span><span class="nx">pid</span> <span class="nx">-d</span> <span class="nx">stop</span>
<span class="nx">PIDFile</span><span class="p">=</span><span class="err">/</span><span class="nx">var</span><span class="err">/</span><span class="nx">run</span><span class="err">/</span><span class="nx">shadsocks</span><span class="p">.</span><span class="nx">pid</span>
<span class="nx">Restart</span><span class="p">=</span><span class="nx">always</span>
<span class="nx">RestartSec</span><span class="p">=</span><span class="mi">4</span>

<span class="p">[</span><span class="nx">Install</span><span class="p">]</span>
<span class="nx">WantedBy</span><span class="p">=</span><span class="nx">multi-user</span><span class="p">.</span><span class="nx">target</span>
</code></pre></td></tr></table>
</div>
</div><p>而 enginx 的配置文件 <code>nginx.service</code> 的内容是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">Unit</span><span class="p">]</span>
<span class="nx">Description</span><span class="p">=</span><span class="nx">The</span> <span class="nx">NGINX</span> <span class="nx">HTTP</span> <span class="nx">and</span> <span class="nx">reverse</span> <span class="nx">proxy</span> <span class="nx">server</span>
<span class="nx">After</span><span class="p">=</span><span class="nx">syslog</span><span class="p">.</span><span class="nx">target</span> <span class="nx">network-online</span><span class="p">.</span><span class="nx">target</span> <span class="nx">remote-fs</span><span class="p">.</span><span class="nx">target</span> <span class="nx">nss-lookup</span><span class="p">.</span><span class="nx">target</span>
<span class="nx">Wants</span><span class="p">=</span><span class="nx">network-online</span><span class="p">.</span><span class="nx">target</span>

<span class="p">[</span><span class="nx">Service</span><span class="p">]</span>
<span class="nx">Type</span><span class="p">=</span><span class="nx">forking</span>
<span class="nx">PIDFile</span><span class="p">=</span><span class="err">/</span><span class="nx">run</span><span class="err">/</span><span class="nx">nginx</span><span class="p">.</span><span class="nx">pid</span>
<span class="nx">ExecStartPre</span><span class="p">=</span><span class="err">/</span><span class="nx">usr</span><span class="err">/</span><span class="nx">sbin</span><span class="err">/</span><span class="nx">nginx</span> <span class="nx">-t</span>
<span class="nx">ExecStart</span><span class="p">=</span><span class="err">/</span><span class="nx">usr</span><span class="err">/</span><span class="nx">sbin</span><span class="err">/</span><span class="nx">nginx</span>
<span class="nx">ExecReload</span><span class="p">=</span><span class="err">/</span><span class="nx">usr</span><span class="err">/</span><span class="nx">sbin</span><span class="err">/</span><span class="nx">nginx</span> <span class="nx">-s</span> <span class="nx">reload</span>
<span class="nx">ExecStop</span><span class="p">=</span><span class="err">/</span><span class="nx">bin</span><span class="err">/</span><span class="nx">kill</span> <span class="nx">-s</span> <span class="nx">QUIT</span> <span class="err">$</span><span class="nx">MAINPID</span>
<span class="nx">PrivateTmp</span><span class="p">=</span><span class="kc">true</span>

<span class="p">[</span><span class="nx">Install</span><span class="p">]</span>
<span class="nx">WantedBy</span><span class="p">=</span><span class="nx">multi-user</span><span class="p">.</span><span class="nx">target</span>
</code></pre></td></tr></table>
</div>
</div><p>为了使用环境变量插值，而使用 sh 启动的 etcd 服务，它的 <code>etcd.service</code> 配置如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">Unit</span><span class="p">]</span>
<span class="nx">Description</span><span class="p">=</span><span class="nx">etcd</span> <span class="nx">key-value</span> <span class="nx">store</span>
<span class="nx">Documentation</span><span class="p">=</span><span class="nx">https</span><span class="err">://</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="err">/</span><span class="nx">etcd-io</span><span class="err">/</span><span class="nx">etcd</span>
<span class="nx">After</span><span class="p">=</span><span class="nx">network</span><span class="p">.</span><span class="nx">target</span>

<span class="p">[</span><span class="nx">Service</span><span class="p">]</span>
<span class="nx">Type</span><span class="p">=</span><span class="nx">simple</span>
<span class="c"># EnvironmentFile 不支持使用 ${xxx} 变量插值，这里不适合使用</span>
<span class="c"># EnvironmentFile=/data/etcd.env</span>
<span class="c"># -a 表示传递环境变量</span>
<span class="nx">ExecStart</span><span class="p">=</span><span class="err">/</span><span class="nx">bin</span><span class="err">/</span><span class="nx">bash</span> <span class="nx">-ac</span> <span class="s1">&#39;. /data/etcd.env; /data/bin/etcd&#39;</span>
<span class="nx">Restart</span><span class="p">=</span><span class="nx">always</span>
<span class="nx">RestartSec</span><span class="p">=</span><span class="mi">5</span><span class="nx">s</span>
<span class="nx">LimitNOFILE</span><span class="p">=</span><span class="mi">40000</span>

<span class="p">[</span><span class="nx">Install</span><span class="p">]</span>
<span class="nx">WantedBy</span><span class="p">=</span><span class="nx">multi-user</span><span class="p">.</span><span class="nx">target</span>
</code></pre></td></tr></table>
</div>
</div><p>如果你不需要在 <code>/data/etcd.env</code> 中使用环境变量的插值语法，那可以这样写:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">Unit</span><span class="p">]</span>
<span class="nx">Description</span><span class="p">=</span><span class="nx">etcd</span> <span class="nx">key-value</span> <span class="nx">store</span>
<span class="nx">Documentation</span><span class="p">=</span><span class="nx">https</span><span class="err">://</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="err">/</span><span class="nx">etcd-io</span><span class="err">/</span><span class="nx">etcd</span>
<span class="nx">After</span><span class="p">=</span><span class="nx">network</span><span class="p">.</span><span class="nx">target</span>

<span class="p">[</span><span class="nx">Service</span><span class="p">]</span>
<span class="nx">Type</span><span class="p">=</span><span class="nx">notify</span>
<span class="nx">EnvironmentFile</span><span class="p">=</span><span class="err">/</span><span class="nx">data</span><span class="err">/</span><span class="nx">etcd</span><span class="p">.</span><span class="nx">env</span>
<span class="c"># ExecXXX 的命令中是可以使用 ${Xxx} 插值语法的</span>
<span class="nx">ExecStart</span><span class="p">=</span><span class="err">/</span><span class="nx">data</span><span class="err">/</span><span class="nx">bin</span><span class="err">/</span><span class="nx">etcd</span> <span class="err">\</span>
    <span class="nx">--initial-advertise-peer-urls</span> <span class="nx">http</span><span class="err">://$</span><span class="p">{</span><span class="nx">THIS_IP</span><span class="p">}</span><span class="err">:</span><span class="mi">2380</span> <span class="err">\</span>
    <span class="nx">--listen-peer-urls</span> <span class="nx">http</span><span class="err">://$</span><span class="p">{</span><span class="nx">THIS_IP</span><span class="p">}</span><span class="err">:</span><span class="mi">2380</span> <span class="err">\</span>
    <span class="nx">--advertise-client-urls</span> <span class="nx">http</span><span class="err">://$</span><span class="p">{</span><span class="nx">THIS_IP</span><span class="p">}</span><span class="err">:</span><span class="mi">2379</span> <span class="err">\</span>
    <span class="nx">--listen-client-urls</span> <span class="nx">http</span><span class="err">://$</span><span class="p">{</span><span class="nx">THIS_IP</span><span class="p">}</span><span class="err">:</span><span class="mi">2379</span> <span class="err">\</span>
    <span class="nx">--initial-cluster</span> <span class="s2">&#34;${NAME_1}=http://${HOST_1}:2380,${NAME_2}=http://${HOST_2}:2380,${NAME_3}=http://${HOST_3}:2380&#34;</span>
<span class="nx">Restart</span><span class="p">=</span><span class="nx">always</span>
<span class="nx">RestartSec</span><span class="p">=</span><span class="mi">5</span><span class="nx">s</span>
<span class="nx">LimitNOFILE</span><span class="p">=</span><span class="mi">40000</span>

<span class="p">[</span><span class="nx">Install</span><span class="p">]</span>
<span class="nx">WantedBy</span><span class="p">=</span><span class="nx">multi-user</span><span class="p">.</span><span class="nx">target</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="服务的启动关闭">服务的启动、关闭</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">systemctl enable ss-server.service  # 启用服务，即开机自动启动
systemctl disable ss-server.service  # 取消服务，取消开机启动

systemctl start ss-server.service   # 启动服务
systemctl stop ss-server.service   # 停止服务

systemctl restart ss-server.service   # 重启服务(stop + start)
systemctl reload ss-server.service   # 服务不 stop，直接加载配置更新等（对应 ExecReload）

# 检查状态
systemctl status ss-server.service -l

systemctl list-units --type=service  # 查看所有服务
</code></pre></td></tr></table>
</div>
</div><h3 id="参考">参考</h3>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener noreferrer">Systemd 入门教程：命令篇 - 阮一峰</a></li>
<li><a href="http://www.jinbuguo.com/systemd/systemd.exec.html" target="_blank" rel="noopener noreferrer">systemd.exec 中文手册</a></li>
</ul>
]]></description></item><item><title>常见压缩格式的区别，及 Linux 下的压缩相关指令</title><link>https://thiscute.world/posts/compression-related-instructions-under-linux/</link><pubDate>Mon, 14 Jan 2019 19:51:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/compression-related-instructions-under-linux/</guid><description><![CDATA[<blockquote>
<p>可先浏览加粗部分</p>
</blockquote>
<h2 id="一常见压缩档">一、常见压缩档</h2>
<pre><code>*.zip        |    zip 程序压缩打包的档案；  （很常见，但是因为不包含文档名编码信息，跨平台可能会乱码）
*.rar        |    rar 程序压缩打包的档案；（在windows上很常见，但是是商业软件。）
*.gz         |   gzip 程序压缩的档案； （linux目前使用最广泛的压缩格式）
*.bz2        |   bzip2 程序压缩的档案；
*.xz         |    xz 程序压缩的档案；
*.tar        |    tar 程序打包的资料，并没有压缩过；
*.tar.gz     |    tar 程序打包的档案，其中并且经过 gzip 的压缩 （最常见）
*.tar.bz2    |   tar 程序打包的档案，其中并且经过 bzip2 的压缩 
*.tar.xz     |   tar 程序打包的档案，其中并且经过 xz 的压缩 （新一代压缩选择）
*.7z         |  7zip 程序压缩打包的档案。
</code></pre>
<p>目前最常见的是 <code>tar.gz</code> <code>tar.xz</code> <code>tar.7z</code> 这三种格式。</p>
<h2 id="二以能否压缩多文档分类">二、以能否压缩多文档分类</h2>
<ol>
<li>
<p><code>gzip</code> <code>bzip2</code> <code>xz</code> 这三个压缩格式都<strong>只能压缩单个文档</strong>。（换而言之，该进程的输入输出都是流，不包含文档树信息。）
因此如果要用它们压缩多个文档或目录，需要使用另一个软件来先将要压缩的文档打包成一个文档（包含文档树信息），这个命令就是 <code>tar</code>.
先使用 <code>tar</code> 归档要压缩的多文档，再对生成的 <code>*.tar</code> 使用 上述压缩指令（或者直接使用管道重定向），Linux 下是这样实现多文档压缩的。</p>
</li>
<li>
<p>而 <code>7z</code> 和 <code>zip</code>，以及 <code>rar</code> 格式，都<strong>同时具有了 归档(tar) 和 压缩 两个功能</strong>，（也就是该格式包含了文档树信息咯）也就是说它们可以直接压缩多个文档。</p>
</li>
</ol>
<h2 id="三各格式使用的算法差别">三、各格式使用的算法差别</h2>
<ol>
<li><code>gzip</code> 成熟的格式，使用的算法基于 DEFLATE。（压缩比适中）</li>
<li><code>7z</code> 新一代格式，使用的压缩算法可替换，默认是使用的 lzma/lzma2 算法，使用 AES-256 作为加密算法。</li>
<li><code>xz</code> 同样使用的 lzma/lzma2 算法，不过只能压缩一个文档。（压缩比很高，相对的用时也更多）</li>
<li><code>zip</code> 同样是支持多种算法的压缩格式，默认应该是使用的 DEFLATE 算法。诞生较早，有很多缺陷。（跨平台乱码、容易被破解等）</li>
<li><code>rar</code> 使用 类DEFLATE 的专有算法，使用 AES 加密。(rar5.0 以后使用 AES-256CBC)</li>
</ol>
<p>不过 <code>zip</code> 被广泛应用在安卓的 <code>apk</code> 格式、<code>java</code> 的 <code>jar</code>、电子书的 <code>epub</code>，还有 github、云硬盘的多文档下载中，原因嘛大概是 <code>zip</code> 很流行，所以不用担心目标平台没解压软件吧。</p>
<h2 id="四如何选用压缩方案">四、如何选用压缩方案</h2>
<ol>
<li><code>tar.gz</code> 在 linux 上最常见，在压缩率和压缩时间上拥有良好的平衡。如果有任何疑惑，就选用它吧，不会错。</li>
<li><code>tar.xz</code> 是新一代的压缩格式，虽然拥有更好的压缩率，压缩/解压速度相对要慢很多倍。一般在电脑性能足够好的时候，可选用它。</li>
<li><code>7z</code> 和 xz 同为新一代压缩格式，它更复杂，支持多文档压缩。而且更适合跨平台，推荐使用。</li>
<li><code>zip</code> 因为跨平台容易导致文档名乱码，不建议使用。（虽然有这样的缺陷，但是却意外的用得很广泛，在前一节有说过）</li>
<li><code>rar</code> 性能不差，但是是商业格式，不开源，不建议使用。（<strong>做得比较好的是它的 recovery records，在网络环境不好，容易导致包损坏时，这个功能就特别棒</strong>）</li>
<li><code>tar.bz2</code> 算是 linux 压缩历史上，过渡时期的产物，性能也介于 gz 和 xz 之间，一般来说不需要考虑它。</li>
</ol>
<p>总的来说，就是 Windows 上推荐使用 <code>7z</code>，而 Linux 上 推荐使用 <code>tar.gz</code> <code>tar.xz</code> <code>7z</code> 之一。此外 <code>rar</code> 的损坏很容易修复，<code>zip</code> 受众多（要注意乱码问题），也可以考虑。</p>
<h2 id="五linux-上的压缩相关指令">五、Linux 上的压缩相关指令</h2>
<h3 id="1-tar-指令">1. tar 指令</h3>
<p>通过之前的介绍，可以看出常用的就是 tar gzip xz 等，如果要压缩多个文档，需要先使用tar，再用管道重定向到 gzip 或 xz，比较麻烦，而这几个指令又很常用。于是后来对tar做了增强。
tar 最初只是一个归档进程，而压缩则由其他的压缩软件来完成（一个进程只干一件事）。后来为了方便，丧心病狂地集成了各种压缩指令。因此这里就只介绍这一个命令了（它囊括了所有）。
tar 的选项与参数非常的多！我们只讲几个常用的选项，更多选项您可以自行 man tar 查询啰！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>dmtsai@study ~<span class="o">]</span>$ tar <span class="o">[</span>-z<span class="p">|</span>-j<span class="p">|</span>-J<span class="o">]</span> <span class="o">[</span>cv<span class="o">]</span> <span class="o">[</span>-f 待创建的新档名<span class="o">]</span> filename... &lt;<span class="o">==</span>打包与压缩
<span class="o">[</span>dmtsai@study ~<span class="o">]</span>$ tar <span class="o">[</span>-z<span class="p">|</span>-j<span class="p">|</span>-J<span class="o">]</span> <span class="o">[</span>tv<span class="o">]</span> <span class="o">[</span>-f 既有的 tar档名<span class="o">]</span>             &lt;<span class="o">==</span>察看档名
<span class="o">[</span>dmtsai@study ~<span class="o">]</span>$ tar <span class="o">[</span>-z<span class="p">|</span>-j<span class="p">|</span>-J<span class="o">]</span> <span class="o">[</span>xv<span class="o">]</span> <span class="o">[</span>-f 既有的 tar档名<span class="o">]</span> <span class="o">[</span>-C 目录<span class="o">]</span>   &lt;<span class="o">==</span>解压缩
</code></pre></td></tr></table>
</div>
</div><h4 id="选项与参数">选项与参数</h4>
<pre><code>-c  ：创建打包档案，可搭配 -v 来察看过程中被打包的档名(filename)
-t  ：察看打包档案的内容含有哪些档名，重点在察看『档名』就是了；
-x  ：解打包或解压缩的功能，可以搭配 -C (大写) 在特定目录解开
      特别留意的是， -c, -t, -x 不可同时出现在一串指令列中。
-z  ：透过 gzip  的支持进行压缩/解压缩：此时档名最好为 *.tar.gz
-j  ：透过 bzip2 的支持进行压缩/解压缩：此时档名最好为 *.tar.bz2
-J  ：透过 xz    的支持进行压缩/解压缩：此时档名最好为 *.tar.xz
      特别留意， -z, -j, -J 不可以同时出现在一串指令列中
-v  ：在压缩/解压缩的过程中，将正在处理的档名显示出来！
-f filename：-f 后面要立刻接要被处理的档名！建议 -f 单独写一个选项啰！(比较不会忘记)
-C 目录    ：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。
</code></pre>
<p>其他后续练习会使用到的选项介绍：</p>
<blockquote>
<p>-p(小写) ：保留备份资料的原本权限与属性，常用于备份(-c)重要的设定档
-P(大写) ：保留绝对路径，亦即允许备份资料中含有根目录存在之意；
&ndash;exclude=FILE：在压缩的过程中，不要将 FILE 打包！</p>
</blockquote>
<h4 id="其实最简单的使用-tar-就只要记忆底下的方式即可">其实最简单的使用 tar 就只要记忆底下的方式即可</h4>
<ul>
<li><strong>压　缩：<code>tar -zcv -f filename.tar.gz &lt;要被压缩的档案或目录名称&gt;</code></strong></li>
<li><strong>查看文档树：<code>tar -ztv -f filename.tar.gz</code></strong></li>
<li><strong>解压缩：<code>tar -zxv -f filename.tar.gz -C</code> &lt;欲解压缩的目录&gt;`</strong></li>
</ul>
<p>上面的命令需要根据压缩格式的不同，选用 <code>-z</code> <code>-j</code> <code>-J</code> 选项，而实际上文档的后缀就已经表明了它的压缩格式，不免让人觉得多余。
因此就有这幺一条通用的压缩/解压 option</p>
<pre><code>-a, --auto-compress
              Use archive suffix to determine the compression program.
</code></pre>
<p>使用这个，便有了<strong>通用的解压指令</strong>：</p>
<blockquote>
<p><strong><font color=#0099ff size=4>tar -axv -f file.tar.* </font> （它适用于上述三种压缩格式）</strong></p>
</blockquote>
<h4 id="仅解压指定的文档">仅解压指定的文档</h4>
<ol>
<li>先查看文档树找到需要解压的文档的文档名</li>
<li>tar -zxv -f 打包档.tar.gz 待解开档名</li>
</ol>
<h4 id="打包某目录但不含该目录下的某些档案之作法">打包某目录，但不含该目录下的某些档案之作法</h4>
<p>使用 &ndash;exclude=FILE 选项（支持文档名的模式匹配，而且可重复）</p>
<pre><code>tar -zcv -f filename.tar.gz directory --exclude=FILE1 --exclude=func*
</code></pre>
<h5 id="只打包目录中比指定时刻更新的文档">只打包目录中比指定时刻更新的文档</h5>
<p>使用 <code>--newer-mtime=&quot;2015/06/17&quot;</code> 选项。</p>
<h5 id="tarfile-tarball">tarfile, tarball</h5>
<pre><code>tarfile  |  纯打包、未压缩的 tar 文档
tarball  |  压缩了的 tar 文档
</code></pre>
<h4 id="2-zip格式linux-一般也会自带详细的请man">2. zip格式（linux 一般也会自带，详细的请man）</h4>
<ol>
<li>
<p>压缩命令：<code>zip</code></p>
<ul>
<li>压缩目录：<code>zip -r filename.zip directory</code>
<ul>
<li><code>r</code> 表示递归压缩，压缩包会包含这个目录</li>
</ul>
</li>
</ul>
</li>
<li>
<p>解压命令：<code>unzip</code></p>
<ul>
<li>解压到某目录：<code>unzip -d directory filename.zip</code>    (<code>-d dir</code> 表示将内容解压到dir目录内)
<ul>
<li>-t 测试压缩档的完整性</li>
<li>-x filename 排除某文档</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="3-7z格式需要p7zipdeepin自带更多的请man">3. 7z格式（需要p7zip，deepin自带，更多的请man）</h4>
<ol>
<li>查看目录树：<code>7z l file.7z</code>    (List contents of archive)</li>
<li>压缩：<code>7z a file.7z file1 directory1</code>   (a 为创建压缩档或向压缩档中添加文档/目录，一次可指定多个要压缩的文档或目录)</li>
<li>解压：<code>7z x file.7z -o directory</code>    (解压到指定目录)</li>
<li>测试完整性： <code>7z t file.7z</code></li>
</ol>
<p><code>p7zip</code> 安装好后，会提供 <code>7z</code>、<code>7za</code>、<code>7zr</code> 三个指令，一般来说直接用 <code>7z</code> 就行。</p>
<blockquote>
<p>P.S. <code>7z</code> 不会保存 Linux 文档的用户、用户组信息，因此不能直接用于 <code>Linux</code> 系统备份，此时建议用 <code>tar.xz</code> 或 <code>tar.7z</code>（也就是先用tar打包）</p>
</blockquote>
<h4 id="4-rar格式还是那句话更多的请man">4. rar格式（还是那句话，更多的请man）</h4>
<p><code>rar</code> 是非开源的格式，Linux 默认是不会包含 <code>rar</code> 压缩软件的，但是它的解压软件是开源的，<code>deepin</code> 自带 <code>unrar</code>，顺便 <code>7zip</code> 也可解压 <code>rar</code> 文档。
若想用linux创建rar压缩档，需要从<a href="https://www.rarlab.com" target="_blank" rel="noopener noreferrer">rarlab</a>上下载 Linux 版，（deepin源自带）不过要注意的是该 linux 版是 40 天试用版，要长期使用的话，可能需要破解。（rar 的 key 网上一搜一大把）</p>
<ol>
<li>压缩：<code>rar a file.rar file</code>  （这个是试用的）</li>
<li>解压：<code>unrar x file.rar</code>      （这个开源免费）</li>
</ol>
<p>其实我挺中意 <code>rar</code> 的修复功能的，不知道为啥 <code>7z</code> <code>xz</code> 这样的新格式没有添加类似的 <code>recorvery records</code>。上次下个 <code>idea</code> 的 <code>tarball</code>，下了四五次才下到一个完整的，要是用 <code>rar</code> 的话，大概一键修复就好了，可 <code>tar.gz</code> 我不知道怎幺修复，只好一遍遍重复下载。。</p>
<h3 id="六参考">六、参考</h3>
<ul>
<li><a href="http://linux.vbird.org/linux_basic/0240tarcompress.php" target="_blank" rel="noopener noreferrer">档案与档案系统的压缩,打包与备份</a></li>
<li>维基百科</li>
<li><a href="https://www.zhihu.com/question/26026741/answer/31869734" target="_blank" rel="noopener noreferrer">rar tar gz zip 7z 有什幺区别? - 知乎</a></li>
<li><a href="https://www.zhihu.com/question/37019479/answer/70054550" target="_blank" rel="noopener noreferrer">为什幺linux的包都是.tar.gz？要解压两次 - 知乎</a></li>
</ul>
]]></description></item></channel></rss>