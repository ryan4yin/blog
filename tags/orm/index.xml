<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>ORM - 标签 - This Cute World</title><link>https://thiscute.world/tags/orm/</link><description>ORM - 标签 - This Cute World</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 21 May 2019 22:19:00 +0800</lastBuildDate><atom:link href="https://thiscute.world/tags/orm/" rel="self" type="application/rss+xml"/><item><title>SQLAlchemy 学习笔记（三）：ORM 中的关系构建</title><link>https://thiscute.world/posts/sqlalchemy-notes-3-relationship-and-foreignkey/</link><pubDate>Tue, 21 May 2019 22:19:00 +0800</pubDate><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/sqlalchemy-notes-3-relationship-and-foreignkey/</guid><description><![CDATA[<blockquote>
<p>个人笔记，不保证正确。</p>
</blockquote>
<h2 id="一关系构建foreignkey-与-relationship">一、关系构建：<code>ForeignKey</code> 与 <code>relationship</code></h2>
<p>关系构建的重点，在于搞清楚这两个函数的用法。<code>ForeignKey</code> 的用法已经在 <a href="https://www.cnblogs.com/kirito-c/p/10269485.html#%E8%A1%A8%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%BA%A6%E6%9D%9F" target="_blank" rel="noopener noreferrer">SQL表达式语言 - 表定义中的约束</a> 讲过了。主要是 <code>ondelete</code> 和 <code>onupdate</code> 两个参数的用法。</p>
<h2 id="二relationship">二、<code>relationship</code></h2>
<p><code>relationship</code> 函数在 ORM 中用于构建表之间的关联关系。与 <code>ForeignKey</code> 不同的是，它定义的关系不属于表定义，而是动态计算的。
用它定义出来的属性，相当于 SQL 中的视图。</p>
<p>这个函数有点难用，一是因为它的有几个参数不太好理解，二是因为它的参数非常丰富，让人望而却步。下面通过<strong>一对多</strong>、<strong>多对一</strong>、<strong>多对多</strong>几个场景下 <code>relationship</code> 的使用，来一步步熟悉它的用法。</p>
<p>首先初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">relationship</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="kn">import</span> <span class="n">declarative_base</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="1-一对多">1. 一对多</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># 因为 Child 中有 Parent 的 ForeignKey，这边的声明不需要再额外指定什么。</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">)</span>  <span class="c1"># children 的集合，相当于一个视图。</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;child&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;parent.id&#39;</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>一个 <code>Parent</code> 可以有多个 <code>Children</code>，通过 <code>relationship</code>，我们就能直接通过 <code>parent.children</code> 得到结果，免去繁琐的 query 语句。</p>
<h4 id="11-反向引用">1.1 反向引用</h4>
<h5 id="111-backref-与-back_populates">1.1.1 <code>backref</code> 与 <code>back_populates</code></h5>
<p>那如果我们需要得知 <code>child</code> 的 <code>parent</code> 对象呢？能不能直接访问 <code>child.parent</code>？</p>
<p>为了实现这个功能，SQLAlchemy 提供了 <code>backref</code> 和 <code>back_populates</code> 两个参数。</p>
<p>两个参数的效果完全一致，区别在于，<code>backref</code> 只需要在 <code>Parent</code> 类中声明 <code>children</code>，<code>Child.parent</code> 会被动态创建。</p>
<p>而 <code>back_populates</code> 必须在两个类中显式地使用 <code>back_populates</code>，更显繁琐。（但是也更清晰？）</p>
<p>先看 <code>backref</code> 版：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">,</span>
                            <span class="n">backref</span><span class="o">=</span><span class="s2">&#34;parent&#34;</span><span class="p">)</span>  <span class="c1"># backref 表示，在 Child 类中动态创建 parent 属性，指向当前类。</span>

<span class="c1"># Child 类不需要修改</span>
</code></pre></td></tr></table>
</div>
</div><p>再看 <code>back_populates</code> 版：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&#34;parent&#34;</span><span class="p">)</span>  <span class="c1"># back_populates </span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;child&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;parent.id&#39;</span><span class="p">))</span>

    <span class="c1"># 这边也必须声明，不能省略！</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Parent&#34;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&#34;children&#34;</span><span class="p">)</span>  <span class="c1"># parent 不是集合，是属性！</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>NOTE：声明的两个 <code>relationship</code> 不需要多余的说明，SQLAlchemy 能自动识别到 <code>parent.children</code> 是 collection，<code>child.parent</code> 是 attribute.</strong></p>
<h4 id="112-反向引用的参数sqlalchemyormbackrefname-kwargs">1.1.2. 反向引用的参数：<code>sqlalchemy.orm.backref(name, **kwargs)</code></h4>
<p>使用 <code>back_populates</code> 时，我们可以很方便地在两个 <code>relationship</code> 函数中指定各种参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&#34;parent&#34;</span><span class="p">,</span> 
                                        <span class="n">lazy</span><span class="o">=</span><span class="s1">&#39;dynamic&#39;</span><span class="p">)</span>  <span class="c1"># 指定 lazy 的值</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;child&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;parent.id&#39;</span><span class="p">))</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Parent&#34;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&#34;children&#34;</span><span class="p">,</span> 
                                      <span class="n">lazy</span><span class="o">=</span><span class="s1">&#39;dynamic&#39;</span><span class="p">)</span>  <span class="c1"># 指定 lazy 的值</span>
</code></pre></td></tr></table>
</div>
</div><p>但是如果使用 <code>backref</code>，因为我们只有一个 <code>relationship</code> 函数，<code>Child.parent</code> 是被隐式创建的，我们该如何指定这个属性的参数呢？</p>
<p>答案就是 <code>backref()</code> 函数，使用它替代 <code>backref</code> 参数的值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">backref</span>

<span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">,</span>
                            <span class="n">backref</span><span class="o">=</span><span class="n">backref</span><span class="p">(</span><span class="s2">&#34;parent&#34;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="s1">&#39;dynamic&#39;</span><span class="p">))</span>  <span class="c1"># 使用 backref() 函数，指定 Child.parent 属性的参数</span>

<span class="c1"># Child 类不需要修改</span>
</code></pre></td></tr></table>
</div>
</div><p><code>backref()</code> 的参数会被传递给 <code>relationship()</code>，因此它俩的参数也完全一致。</p>
<h3 id="2-多对一">2. 多对一</h3>
<p>A many-to-one is similar to a one-to-many relationship. The difference is that this relationship is looked at from the &ldquo;many&rdquo; side.</p>
<h3 id="3-一对一">3. 一对一</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">child</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">,</span> 
                                    <span class="n">uselist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>   <span class="c1"># 不使用 collection！这是关键</span>
                                    <span class="n">back_populates</span><span class="o">=</span><span class="s2">&#34;parent&#34;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;child&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;parent.id&#39;</span><span class="p">))</span>

     <span class="c1"># 包含 ForeignKey 的类，此属性默认为 attribute，因此不需要 uselist=False</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Parent&#34;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&#34;child&#34;</span><span class="p">)</span> 
</code></pre></td></tr></table>
</div>
</div><h3 id="4-多对多">4. 多对多</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 多对多，必须要使用一个关联表！</span>
<span class="n">association_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;association&#39;</span><span class="p">,</span> <span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;left_id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;left.id&#39;</span><span class="p">)),</span>  <span class="c1"># 约定俗成的规矩，左边是 parent</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;right_id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;right.id&#39;</span><span class="p">))</span>  <span class="c1"># 右边是 child</span>
<span class="p">)</span>

<span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">,</span>
                    <span class="n">secondary</span><span class="o">=</span><span class="n">association_table</span><span class="p">)</span>  <span class="c1"># 专用参数 secondary，用于指定使用的关联表</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>要添加反向引用时，同样可以使用 <code>backref</code> 或 <code>back_populates</code>.</p>
<h4 id="41-user2user">4.1 user2user</h4>
<p>如果多对多关系中的两边都是 user，即都是同一个表时，该怎么声明？</p>
<p>例如用户的「关注」与「粉丝」，你是 user，你的粉丝是 user，你关注的账号也是 user。</p>
<p>这个时候，关联表 <code>association_table</code> 的两个键都是 <code>user</code>，<strong>SQLAlchemy 无法区分主次，需要手动指定</strong>，为此需要使用 <code>primaryjoin</code> 和 <code>secondaryjoin</code> 两个参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 关联表，左侧的 user 正在关注右侧的 user</span>
<span class="n">followers</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s1">&#39;followers&#39;</span><span class="p">,</span>
    <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="s1">&#39;follower_id&#39;</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;user.id&#39;</span><span class="p">)),</span>  <span class="c1"># 左侧</span>
    <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="s1">&#39;followed_id&#39;</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;user.id&#39;</span><span class="p">))</span>  <span class="c1"># 右侧，被关注的 user</span>
<span class="p">)</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">UserMixin</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="mi">120</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">password_hash</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># 我关注的 users</span>
    <span class="n">followed</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">relationship</span><span class="p">(</span>
        <span class="s1">&#39;User&#39;</span><span class="p">,</span>
        <span class="n">secondary</span><span class="o">=</span><span class="n">followers</span><span class="p">,</span>  <span class="c1"># 指定多对多关联表</span>
        <span class="n">primaryjoin</span><span class="o">=</span><span class="p">(</span><span class="n">followers</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">follower_id</span> <span class="o">==</span> <span class="nb">id</span><span class="p">),</span>  <span class="c1"># 左侧，用于获取「我关注的 users」的 join 条件</span>
        <span class="n">secondaryjoin</span><span class="o">=</span><span class="p">(</span><span class="n">followers</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">followed_id</span> <span class="o">==</span> <span class="nb">id</span><span class="p">),</span>  <span class="c1"># 右侧，用于获取「我的粉丝」的 join 条件</span>
        <span class="n">lazy</span><span class="o">=</span><span class="s1">&#39;dynamic&#39;</span><span class="p">,</span>  <span class="c1"># 延迟求值，这样才能用 filter_by 等过滤函数</span>
        <span class="n">backref</span><span class="o">=</span><span class="n">db</span><span class="o">.</span><span class="n">backref</span><span class="p">(</span><span class="s1">&#39;followers&#39;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="s1">&#39;dynamic&#39;</span><span class="p">))</span>  <span class="c1"># followers 也要延迟求值</span>
</code></pre></td></tr></table>
</div>
</div><p>这里比较绕的，就是容易搞混 <code>primaryjoin</code> 和 <code>secondaryjoin</code> 两个参数。</p>
<ol>
<li>primaryjoin：（多对多中）用于从子对象查询其父对象的 condition（child.parents），默认只考虑外键。</li>
<li>secondaryjoin：（多对多中）用于从父对象查询其所有子对象的 condition（parent.children），同样的，默认情况下只考虑外键。</li>
</ol>
<h2 id="三orm-层-的-delete-cascade-vs-foreign-key-层的-on-delete-cascade">三、ORM 层 的 “delete” cascade vs. FOREIGN KEY 层的 “ON DELETE” cascade</h2>
<p>之前有讲过 Table 定义中的级联操作：<code>ON DELETE</code> 和 <code>ON UPDATE</code>，可以通过 <code>ForeignKey</code> 的参数指定为 <code>CASCADE</code>.</p>
<p>可 SQLAlchemy 还有一个 <code>relationship</code> 生成 SQL 语句时的配置参数 <code>cascade</code>，另外 <code>passive_deletes</code> 也可以指定为 <code>cascade</code>。</p>
<p>有这么多的 cascade，我真的是很懵。这三个 cascade 到底有何差别呢？</p>
<p>外键约束中的 <code>ON DELETE</code> 和 <code>ON UPDATE</code>，与 ORM 层的 <code>CASCADE</code> 在功能上，确实有很多重叠的地方。
但是也有很多不同：</p>
<ol>
<li>数据库层面的 <code>ON DELETE</code> 级联能高效地处理 <strong>many-to-one</strong> 的关联；我们在 <code>many</code> 方定义外键，也在这里添加 <code>ON DELETE</code> 约束。而在 ORM 层，就<strong>刚好相反</strong>。SQLAlchemy 在 <code>one</code> 方处理 <code>many</code> 方的删除操作，这意味着它更适合处理 <strong>one-to-many</strong> 的关联。</li>
<li>数据库层面上，不带 <code>ON DELETE</code> 的外键常用于防止父数据被删除，而导致子数据成为无法被索引到的垃圾数据。如果要在一个 one-to-many 映射上实现这个行为，SQLAlchemy 将外键设置为 NULL 的默认行为可以通过以下两种方式之一捕获：
<ol>
<li>最简单也最常用的方法，当然是将外键定义为 <strong>NOT NULL</strong>. 尝试将该列设为 NULL 会触发 NOT NULL constraint exception.</li>
<li>另一种更特殊的方法，是将 <code>passive_deletes</code> 标志设置为字 <code>all</code>. 这会完全禁用 SQLAlchemy 将外键列设置为 NULL 的行为，并且 DELETE 父数据而不会对子数据产生任何影响。这样才能触发数据库层面的 <code>ON DELETE</code> 约束，或者其他的触发器。</li>
<li>数据库层面的 <code>ON DELETE</code> 级联 比 ORM 层面的级联更高效。数据库可以同时在多个 relationship 中链接一系列级联操作。</li>
<li>SQLAlchemy 不需要这么复杂，因为我们通过将 passive_deletes 选项与正确配置的外键约束结合使用，提供与数据库的 <code>ON DELETE</code> 功能的平滑集成。</li>
</ol>
</li>
</ol>
<h3 id="方法一orm-层的-cascade-实现">方法一：ORM 层的 cascade 实现</h3>
<p><code>relationship</code> 的 <code>cascade</code> 参数决定了修改父表时，什么时候子表要进行级联操作。它的可选项有（str，选项之间用逗号分隔）：</p>
<ol>
<li><code>save-update</code>：默认选项之一。在 add（对应 SQL 的 insert 或 update）一个对象的时候，会 add 所有它相关联的对象。</li>
<li><code>merge</code>：默认选项之一。在 merge（相当字典的update操作，有就替换掉，没有就合并）一个对象的时候，会 merge 所有和它相关联的对象。</li>
<li><code>expunge</code> ：移除操作的时候，会将相关联的对象也进行移除。这个操作只是从session中移除，并不会真正的从数据库中删除。</li>
<li><code>delete</code>：删除父表数据时，同时删除与它关联的数据。</li>
<li><code>delete-orphan</code>：当子对象与父对象解除关系时，删除掉此子对象（孤儿）。（其实还是没懂。。）</li>
<li><code>refresh-expire</code>：不常用。</li>
<li><code>all</code>：表示选中除 <code>delete-orphan</code> 之外的所有选项。（因此 <code>all, delete-orphan</code> 很常用，它才是真正的 <code>all</code>）</li>
</ol>
<p>默认属性是 &ldquo;save-update, merge&rdquo;.</p>
<p>这只是简略的说明，上述几个参数的详细文档见 <a href="https://docs.sqlalchemy.org/en/13/orm/cascades.html#unitofwork-cascades" target="_blank" rel="noopener noreferrer">SQLAlchemy - Cascades</a></p>
<h3 id="方法二数据库层的-cascade-实现">方法二：数据库层的 cascade 实现</h3>
<ol>
<li>将 <code>ForeignKey</code> 的 <code>ondelete</code> 和 <code>onupdate</code> 参数指定为 <code>CASCADE</code>，实现数据库层面的级联。</li>
<li>为 <code>relationship</code> 添加关键字参数 <code>passive_deletes=&quot;all&quot;</code>，这样就完全禁用 SQLAlchemy 将外键列设置为 NULL 的行为，并且 DELETE 父数据不会对子数据产生任何影响。</li>
</ol>
<p>这样 DELETE 操作时，就会触发数据库的 <code>ON DELETE</code> 约束，从而级联删除子数据。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://docs.sqlalchemy.org/en/13/orm/relationships.html" target="_blank" rel="noopener noreferrer">SQLAlchemy - Relationship Configuration</a></li>
<li><a href="https://docs.sqlalchemy.org/en/13/orm/cascades.html#unitofwork-cascades" target="_blank" rel="noopener noreferrer">SQLAlchemy - Cascades</a></li>
<li><a href="https://ia.jifangcheng.com/p/46" target="_blank" rel="noopener noreferrer">SQLAlchemy 中的 backref 和 back_populates</a></li>
<li><a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-viii-followers" target="_blank" rel="noopener noreferrer">The Flask Mega-Tutorial Part VIII: Followers</a></li>
<li><a href="https://github.com/hackersandslackers/sqlalchemy-tutorial" target="_blank" rel="noopener noreferrer">hackersandslackers/sqlalchemy-tutorial</a></li>
</ul>
]]></description></item><item><title>SQLAlchemy 学习笔记（二）：ORM 基础</title><link>https://thiscute.world/posts/sqlalchemy-notes-2-orm-basics/</link><pubDate>Mon, 11 Feb 2019 19:52:00 +0800</pubDate><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/sqlalchemy-notes-2-orm-basics/</guid><description><![CDATA[<p>照例先看层次图</p>
<p><figure><a class="lightgallery" href="/images/sqlalchemy-notes/sqlalchemy-arch.png" title="/images/sqlalchemy-notes/sqlalchemy-arch.png" data-thumbnail="/images/sqlalchemy-notes/sqlalchemy-arch.png" data-sub-html="<h2>SQLAlchemy 层次结构</h2>">
        
    </a><figcaption class="image-caption">SQLAlchemy 层次结构</figcaption>
    </figure></p>
<h3 id="一声明映射关系">一、声明映射关系</h3>
<p>使用 ORM 时，我们首先需要定义要操作的表（通过 <code>Table</code>），然后再定义该表对应的 Python class，并声明两者之间的映射关系（通过 <code>Mapper</code>）。</p>
<p>方便起见，SQLAlchemy 提供了 Declarative 系统来一次完成上述三个步骤，Declarative 系统提供 base class，这个 base class 会为继承了它的 Python class（可称作 model）创建 Table，并维护两者的映射关系。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="kn">import</span> <span class="n">declarative_base</span>
<span class="kn">from</span> <span class="nn">SQLAlchemy</span> <span class="kn">import</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>  <span class="c1"># 拿到 Base 类</span>


<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># 添加 index 提升搜索效率</span>
    <span class="n">fullname</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
    <span class="n">password</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span>  <span class="c1"># 真实情况下一般只存 hash</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&#34;&lt;User </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2">&gt;&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>这样就声明好了一个对象-关系映射，上一篇文章说过所有的 Table 都在某个 MetaData 中，可以通过 <code>Base.metadata</code> 获取它。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>  <span class="c1"># 通过 metadata 创建表（或者说生成模式 schema）</span>
</code></pre></td></tr></table>
</div>
</div><p>engine 的创建请见上篇文档 <a href="https://www.cnblogs.com/kirito-c/p/10269485.html" target="_blank" rel="noopener noreferrer">SQLAlchemy 学习笔记（一）：Engine 与 SQL 表达式语言</a></p>
<h4 id="约束条件">约束条件</h4>
<blockquote>
<p>可参考 <a href="https://www.cnblogs.com/kirito-c/p/10295693.html" target="_blank" rel="noopener noreferrer">SQL 基础笔记（三）：约束</a> 与 <a href="https://www.cnblogs.com/kirito-c/p/10269485.html#%E8%A1%A8%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%BA%A6%E6%9D%9F" target="_blank" rel="noopener noreferrer">SQLAlchemy 学习笔记（一）：Engine 与 SQL 表达式语言 - 表定义中的约束</a></p>
</blockquote>
<p>使用 ORM 来定义约束条件，与直接使用 SQL 表达式语言定义很类似，也有两种方法：</p>
<ol>
<li>直接将约束条件作为 <code>Column</code>、<code>ForeignKey</code> 的参数传入。这种方式最简洁，也最常用。</li>
<li>使用 <code>UniqueConstraint</code>、<code>CheckConstraint</code> 等类构造约束，然后放入 <code>__table_args__</code> 属性中。举例：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># 添加 index 提升搜索效率</span>
    <span class="n">fullname</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
    <span class="n">password</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span>  <span class="c1"># 真实情况下一般只存 hash</span>

    <span class="c1"># 顾名思义，这是 `Table` 类的参数的序列。里面的约束条件会被用于构建 __table__</span>
    <span class="n">__table_args__</span> <span class="o">=</span> <span class="p">(</span><span class="n">UniqueConstraint</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;c_user&#39;</span><span class="p">),)</span>  <span class="c1"># username 的唯一性约束</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&#34;&lt;User </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2">&gt;&#34;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="二获取-session">二、获取 session</h3>
<p>上一节讲 engine 时，我们是通过 connection 来与数据库交互，而在 ORM 中我们使用 Session 访问数据库。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">sessionmaker</span>

<span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>  <span class="c1"># 获取 session</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="三增删改查">三、增删改查</h3>
<p>直接使用 SQL 表达式语言时，我们使用 insert()、select()、update()、delete() 四个函数构造 SQL，使用 where() 添加条件，使用 model.join(another_model) 进行 join 操作。
而使用 ORM 时，数据库操作不再与 SQL 直接对应。我们现在是通过操作 Python 对象来操作数据库了。</p>
<p>现在，我们通过 db.session.add()、db.session.delete() 进行添加与删除，使用 db.session.query(Model) 进行查询，通过 filter 和 filter_by 添加过滤条件。
而修改，则是先查询出对应的 row 对象，直接修改这个对象，然后 commit 就行。</p>
<ol>
<li>增添：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">ed_user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="s1">&#39;edspassword&#39;</span><span class="p">)</span>  <span class="c1"># 用构造器构造对象</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ed_user</span><span class="p">)</span>  <span class="c1"># 添加，此外还有批量添加 add_all([user1, user2...])</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># 必须手动 commit</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>修改：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">ed_user</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>  <span class="c1"># 先获取到 User 对象</span>
<span class="n">ed_user</span><span class="o">.</span><span class="n">password</span> <span class="o">=</span> <span class="s1">&#39;f8s7ccs&#39;</span>  <span class="c1"># 改了密码</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># 提交</span>

<span class="c1"># 批量修改</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">home</span><span class="o">==</span><span class="s1">&#39;shanghai&#39;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">User</span><span class="o">.</span><span class="n">login_num</span><span class="p">:</span><span class="mi">0</span><span class="p">})</span>  <span class="c1"># 将所有上海的用户的 login_num 设为 0</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>删除：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">ed_user</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>  <span class="c1"># 先获取到 User 对象</span>
<span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ed_user</span><span class="p">)</span>  <span class="c1"># 直接删除（session 知道 ed_user 属于哪个表）</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># 提交</span>

<span class="c1"># 批量删除</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">home</span><span class="o">==</span><span class="s1">&#39;shanghai&#39;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">delete</span><span class="p">()</span>  <span class="c1"># 删除所有上海的用户</span>

<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>同样的，也可以在外面检查异常，然后调用 <code>session.rollback()</code> 实现失败回滚。</p>
<h3 id="四进阶查询">四、进阶查询</h3>
<ol>
<li>filter_by：使用关键字参数进行过滤，前面的演示中已经用过多次了。</li>
<li>filter：它对应 SQL 表达式语言中的 where，支持各种复杂的 SQL 语法。</li>
<li>group_by: 通过指定 column 分组</li>
<li>distinct(): 去重</li>
<li>join(): 关联</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ed&#39;</span><span class="p">)</span>  <span class="c1"># 这个等同于 filter_by，但是更繁琐</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;ed&#39;</span><span class="p">)</span>  <span class="c1"># 不等于，这个就是 filter_by 无法做到的了</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">d%&#39;</span><span class="p">))</span>  <span class="c1"># SQL like 的 like 语法</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="s1">&#39;jack&#39;</span><span class="p">]))</span>  <span class="c1"># 包含</span>

<span class="c1"># 查询还可以嵌套</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">in_</span><span class="p">(</span>
    <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">d%&#39;</span><span class="p">))</span>
<span class="p">))</span>

<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">~</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="s1">&#39;jack&#39;</span><span class="p">]))</span>  <span class="c1"># 不包含</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># NULL 对应 Python 的 None</span>

<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">or_</span><span class="p">,</span> <span class="n">and_</span><span class="p">,</span> <span class="n">in_</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">or_</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;wendy&#39;</span><span class="p">))</span>  <span class="c1"># OR 语法</span>

<span class="n">query</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># 分组</span>
<span class="n">query</span><span class="o">.</span><span class="n">distinct</span><span class="p">()</span>  <span class="c1"># 去重</span>

<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">func</span>  <span class="c1"># SQL 函数包</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">))</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">xxx</span><span class="o">=</span><span class="n">xxx</span><span class="p">)</span>  <span class="c1"># 使用 count 函数</span>

<span class="c1"># join 关联</span>
<span class="c1"># 默认使用内联（inner），即只取两表的交集</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="o">==</span><span class="n">Address</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>  <span class="c1"># 方法一</span>

<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span>\  <span class="c1"># 方法二</span>
    <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">==</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">)</span>

<span class="c1"># 外联 outer join，将另一表的列联结到主表，没有的行为 NULL</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">outerjoin</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">==</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="执行查询获取数据">执行查询，获取数据</h4>
<p>查询返回 query 对象，但 SQL 还没有被执行，直到你调用下列几个方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 构造 query 对象</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">d&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

<span class="c1"># 1. all 返回所有结果的列表</span>
<span class="n">res_list</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="c1"># 2. first 先在 SQL 中加入限制 `limit 1`，然后执行。</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>

<span class="c1"># 3. one 执行 sql 并获取所有结果</span>
<span class="c1"># 如果结果不止一行，抛出 MultipleResultsFound Error！！！</span>
<span class="c1"># 如果结果为空，抛出 NoResultFound Error ！！！</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>

<span class="mf">4.</span> <span class="n">one_or_none</span> <span class="n">差别在于结果为空</span><span class="err">，</span><span class="n">它不抛出异常</span><span class="err">，</span><span class="n">而是返回</span> <span class="kc">None</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">one_or_none</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="参考">参考</h3>
<ul>
<li><a href="https://docs.sqlalchemy.org/en/latest/orm/tutorial.html" target="_blank" rel="noopener noreferrer">SQLAlchemy 对象关系入门</a></li>
<li><a href="https://docs.sqlalchemy.org/en/latest/orm/basic_relationships.html" target="_blank" rel="noopener noreferrer">SQLAlchemy ORM 的关联映射定义：一对多、多对多</a></li>
<li><a href="https://github.com/hackersandslackers/sqlalchemy-tutorial" target="_blank" rel="noopener noreferrer">hackersandslackers/sqlalchemy-tutorial</a></li>
</ul>
]]></description></item><item><title>SQLAlchemy 学习笔记（一）：Engine 与 SQL 表达式语言</title><link>https://thiscute.world/posts/sqlalchemy-notes-1-engine-and-sql-expression-language/</link><pubDate>Mon, 21 Jan 2019 14:02:00 +0800</pubDate><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/sqlalchemy-notes-1-engine-and-sql-expression-language/</guid><description><![CDATA[<blockquote>
<p>个人笔记，如有错误烦请指正。</p>
</blockquote>
<p>SQLAlchemy 是一个用 Python 实现的 ORM （Object Relational Mapping）框架，它由多个组件构成，这些组件可以单独使用，也能独立使用。它的组件层次结构如下：</p>
<p><figure><a class="lightgallery" href="/images/sqlalchemy-notes/sqlalchemy-arch.png" title="/images/sqlalchemy-notes/sqlalchemy-arch.png" data-thumbnail="/images/sqlalchemy-notes/sqlalchemy-arch.png" data-sub-html="<h2>SQLAlchemy 层次结构</h2>">
        
    </a><figcaption class="image-caption">SQLAlchemy 层次结构</figcaption>
    </figure></p>
<p>其中最常用的组件，应该是 <strong>ORM</strong> 和 <strong>SQL 表达式语言</strong>，这两者既可以独立使用，也能结合使用。</p>
<p><strong>ORM</strong> 的好处在于它</p>
<ol>
<li>自动处理了数据库和 Python 对象之间的映射关系，屏蔽了两套系统之间的差异。程序员不需要再编写复杂的 SQL 语句，直接操作 Python 对象就行。</li>
<li>屏蔽了各数据库之间的差异，更换底层数据库不需要修改 SQL 语句，改下配置就行。</li>
<li>使数据库结构文档化，models 定义很清晰地描述了数据库的结构。</li>
<li>避免了不规范、冗余、风格不统一的 SQL 语句，可以避免很多人为 Bug，也方便维护。</li>
</ol>
<p>但是 ORM 需要消耗额外的性能来处理对象关系映射，此外用 ORM 做多表关联查询或复杂 SQL 查询时，效率低下。因此它适用于场景不太复杂，性能要求不太苛刻的场景。</p>
<p>都说 ORM 学习成本高，我自己也更倾向于直接使用 SQL 语句（毕竟更熟悉），因此这一篇笔记不涉及 ORM 部分，只记录 SQLAlchemy 的 Engine 与 SQL 表达式语言。</p>
<h2 id="一直接使用-enginehttpsdocssqlalchemyorgenlatestcoreengineshtmlsqlalchemycreate_engine-和-connections">一、直接使用 <a href="https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine" target="_blank" rel="noopener noreferrer">Engine</a> 和 Connections</h2>
<p>第一步是创建数据库引擎实例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite:///:memory:&#39;</span><span class="p">,</span> 
                    <span class="n">echo</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># echo=True 表示打印出自动生成的 SQL 语句（通过 logging）</span>
                    <span class="n">pool_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>  <span class="c1"># 连接池容量，默认为 5，生产环境下太小，需要修改。</span>
                    <span class="c1"># 下面是 connection 回收的时间限制，默认 -1 不回收</span>
                    <span class="n">pool_recycle</span><span class="o">=</span><span class="mi">7200</span><span class="p">)</span>   <span class="c1"># 超过 2 小时就重新连接（MySQL 默认的连接最大闲置时间为 8 小时）</span>
</code></pre></td></tr></table>
</div>
</div><p><code>create_engine</code> 接受的第一个参数是数据库 URI，格式为 <code>dialect+driver://username:password@host:port/database</code>，dialect 是具体的数据库名称，driver 是驱动名称。key-value 是可选的参数。举例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># PostgreSQL</span>
postgresql+psycopg2://scott:tiger@localhost/dbtest

<span class="c1"># MySQL + PyMySQL（或者用更快的  mysqlclient）</span>
mysql+pymysql://scott:tiger@localhost/dbtest

<span class="c1"># sqlite 内存数据库</span>
<span class="c1"># 注意 sqlite 要用三个斜杠，表示不存在 hostname，sqlite://&lt;nohostname&gt;/&lt;path&gt;</span>
sqlite:///:memory:

<span class="c1"># sqlite 文件数据库</span>
<span class="c1"># 四个斜杠是因为文件的绝对路径以 / 开头：/home/ryan/Codes/Python/dbtest.db</span>
sqlite:////home/ryan/Codes/Python/dbtest.db

<span class="c1"># SQL Server + pyodbc</span>
<span class="c1"># 首选基于 dsn 的连接，dsn 的配置请搜索hhh</span>
mssql+pyodbc://scott:tiger@some_dsn
</code></pre></td></tr></table>
</div>
</div><p>如果你的密码中含有 &lsquo;@&rsquo; 等特殊字符，就不能直接放入 URI 中，必须使用 <code>urllib.parse.quote_plus</code> 编码，然后再插入 URI.</p>
<p>引擎创建后，我们就可以直接获取 connection，然后执行 SQL 语句了。这种用法相当于把 SQLAlchemy 当成带 log 的数据库连接池使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&#34;select username from users&#34;</span><span class="p">)</span>  <span class="c1"># 无参直接使用</span>

    <span class="c1"># 使用问号作占位符，前提是下层的 DBAPI 支持。更好的方式是使用 text()，这个后面说</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&#34;INSERT INTO table (id, value) VALUES (?, ?)&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&#34;v1&#34;</span><span class="p">)</span>  <span class="c1"># 参数不需要包装成元组</span>

    <span class="c1"># 查询返回的是 ResultProxy 对象，有和 dbapi 相同的 fetchone()、fetchall()、first() 等方法，还有一些拓展方法</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;username:&#34;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><p>但是要注意的是，connection 的 execute 是自动提交的（autocommit），这就像在 shell 里打开一个数据库客户端一样，分号结尾的 SQL 会被自动提交。
只有在 <code>BEGIN TRANSACTION</code> 内部，<code>AUTOCOMMIT</code> 会被临时设置为 <code>FALSE</code>，可以通过如下方法开始一个内部事务：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">transaction_a</span><span class="p">(</span><span class="n">connection</span><span class="p">):</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>  <span class="c1"># 开启一个 transaction</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># do sthings</span>
        <span class="n">trans</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># 这里需要手动提交</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">trans</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>  <span class="c1"># 出现异常则 rollback</span>
        <span class="k">raise</span>
<span class="c1"># do other things</span>

<span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="n">transaction_a</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="1-使用-texthttpsdocssqlalchemyorgenlatestcoresqlelementhtmlsqlalchemysqlexpressiontext-构建-sql">1. 使用 <a href="https://docs.sqlalchemy.org/en/latest/core/sqlelement.html#sqlalchemy.sql.expression.text" target="_blank" rel="noopener noreferrer">text()</a> 构建 SQL</h3>
<p>相比直接使用 string，text() 的优势在于它：</p>
<ol>
<li>提供了统一的参数绑定语法，与具体的 DBAPI 无关。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 1. 参数绑定语法</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">text</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
            <span class="c1"># 使用 :key 做占位符</span>
            <span class="n">text</span><span class="p">(</span><span class="s1">&#39;select * from table where id &lt; :id and typeName=:type&#39;</span><span class="p">),</span>
            <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span><span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="s1">&#39;USER_TABLE&#39;</span><span class="p">})</span>  <span class="c1"># 用 dict 传参数，更易读</span>

<span class="c1"># 2. 参数类型指定</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">DateTime</span>

<span class="n">date_param</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">today</span><span class="p">()</span><span class="o">+</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=-</span><span class="mi">1</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span>
<span class="n">sql</span><span class="o">=</span><span class="s2">&#34;delete from caw_job_alarm_log  where alarm_time &lt; :alarm_time_param&#34;</span>

<span class="c1"># bindparams 是 bindparam 的列表，bindparam 则提供参数的一些额外信息（类型、值、限制等）</span>
<span class="n">t</span><span class="o">=</span><span class="n">text</span><span class="p">(</span><span class="n">sql</span><span class="p">,</span> <span class="n">bindparams</span><span class="o">=</span><span class="p">[</span><span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;alarm_time_param&#39;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">DateTime</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">)])</span>
<span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">{</span><span class="s2">&#34;alarm_time_param&#34;</span><span class="p">:</span> <span class="n">date_param</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>可以很方便地转换 Result 中列的类型</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">stmt = text(&#34;SELECT * FROM table&#34;,
            # 使用 typemap 指定将 id 列映射为 Integer 类型，name 映射为 String 类型
            typemap={&#39;id&#39;: Integer, &#39;name&#39;: String},
          )
result = connection.execute(stmt)
# 对多个查询结果，可以用 for obj in result 遍历
# 也可用 fetchone() 只获取一个
</code></pre></td></tr></table>
</div>
</div><h2 id="二sql-表达式语言">二、SQL 表达式语言</h2>
<blockquote>
<p>复杂的 SQL 查询可以直接用 raw sql 写，而增删改一般都是单表操作，用 SQL 表达式语言最方便。</p>
</blockquote>
<p>SQLAlchemy 表达式语言是一个使用 Python 结构表示关系数据库结构和表达式的系统。</p>
<h3 id="1-定义并创建表">1. 定义并创建表</h3>
<p>SQL 表达式语言使用 Table 来定义表，而表的列则用 Column 定义。Column 总是关联到一个 Table 对象上。</p>
<p>一组 Table 对象以及它们的子对象的集合就被称作「数据库元数据（database metadata）」。metadata 就像你的网页分类收藏夹，相关的 Table 放在一个 metadata 中。</p>
<p>下面是创建元数据（一组相关联的表）的例子，：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">ForeignKey</span>

<span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>  <span class="c1"># 先创建元数据（收藏夹）</span>

<span class="n">users</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>  <span class="c1"># 创建 user 表，并放到 metadata 中</span>
              <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
              <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">),</span>
              <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;fullname&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span>
             <span class="p">)</span>

<span class="n">addresses</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;user_id&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;user.id&#39;</span><span class="p">)),</span>  <span class="c1"># 外键约束，引用 user 表的 id 列</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;email_address&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                 <span class="p">)</span>

<span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>  <span class="c1"># 使用 engine 创建 metadata 内的所有 Tables（会检测表是否已经存在，所以可以重复调用）</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="表定义中的约束">表定义中的约束</h4>
<blockquote>
<p>应该给所有的约束命名，即为 <code>name</code> 参数指定一个不冲突的列名。详见 <a href="https://alembic.sqlalchemy.org/en/latest/naming.html" target="_blank" rel="noopener noreferrer">The Importance of Naming Constraints</a></p>
</blockquote>
<p>表还有一个属性：<a href="https://www.cnblogs.com/kirito-c/p/10295693.html" target="_blank" rel="noopener noreferrer">约束条件</a>。下面一一进行说明。</p>
<ol>
<li><strong>外键约束</strong>：用于在删除或更新某个值或行时，对主键/外键关系中一组数据列强制进行的操作限制。
<ol>
<li>用法一：<code>Column('user_id', None, ForeignKey('user.id'))</code>，直接在 <code>Column</code> 中指定。这也是最常用的方法</li>
<li>用法二：通过 <code>ForeignKeyConstraint(columns, refcolumns)</code> 构建约束，作为参数传给 <code>Table</code>.</li>
</ol>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">item</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;item&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>  <span class="c1"># 商品 table</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;invoice_id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>  <span class="c1"># 发票 id，是外键</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;ref_num&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
    <span class="n">ForeignKeyConstraint</span><span class="p">([</span><span class="s1">&#39;invoice_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ref_num&#39;</span><span class="p">],</span>  <span class="c1"># 当前表中的外键名称</span>
                         <span class="p">[</span><span class="s1">&#39;invoice.id&#39;</span><span class="p">,</span> <span class="s1">&#39;invoice.ref_num&#39;</span><span class="p">])</span>  <span class="c1"># 被引用的外键名称的序列（被引用的表）</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li><code>on delete</code> 与 <code>on update</code>：<strong>外键约束的两个约束条件</strong>，通过 <code>ForeignKey()</code> 或 <code>ForeignKeyConstraint()</code> 的关键字参数 <code>ondelete/onupdate</code> 传入。
可选值有：
<ol>
<li><strong>默认行为 <code>NO ACTION</code></strong>：什么都不做，直接报错。</li>
<li><code>CASCADE</code>：删除/更新 父表数据时，<strong>从表数据会同时被 删除/更新</strong>。（无报错）</li>
<li><code>RESTRICT</code>：<strong>不允许直接 删除/更新 父表数据</strong>，直接报错。（和默认行为基本一致）</li>
<li><code>SET NULL</code> or <code>SET DEFAULT</code>：删除/更新 父表数据时，将对应的从表数据重置为 <code>NULL</code> 或者默认值。</li>
</ol>
</li>
<li><strong>唯一性约束</strong>：<code>UniqueConstraint('col2', 'col3', name='uix_1')</code>，作为参数传给 <code>Table</code>.</li>
<li><strong>CHECK 约束</strong>：<code>CheckConstraint('col2 &gt; col3 + 5', name='check1')</code>， 作为参数传给 <code>Table</code>.</li>
<li>主键约束：不解释
<ol>
<li>方法一：通过 <code>Column('id', Integer, primary_key=True)</code> 指定主键。（参数 <code>primary_key</code> 可在多个 <code>Column</code> 上使用）</li>
<li>方法二：使用 <code>PrimaryKeyConstraint</code></li>
</ol>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">PrimaryKeyConstraint</span>

<span class="n">my_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;mytable&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
            <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">),</span>
            <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;version_id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">),</span>
            <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">)),</span>
            <span class="n">PrimaryKeyConstraint</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;version_id&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;mytable_pk&#39;</span><span class="p">)</span>
        <span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="2-增删改查语句">2. 增删改查语句</h3>
<ol>
<li><strong>增</strong>:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 方法一，使用 values 传参</span>
<span class="n">ins</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&#34;Jack&#34;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s2">&#34;Jack Jones&#34;</span><span class="p">)</span>  <span class="c1"># 可以通过 str(ins) 查看自动生成的 sql</span>
<span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>

<span class="c1"># 方法二，参数传递给 execute()</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Wendy Williams&#39;</span><span class="p">)</span>

<span class="c1"># 方法三，批量 INSERT，相当于 executemany</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="p">[</span>  <span class="c1"># 插入到 addresses 表</span>
    <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span><span class="p">:</span> <span class="s1">&#39;jack@yahoo.com&#39;</span><span class="p">},</span>  <span class="c1"># 传入 dict 列表</span>
    <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span><span class="p">:</span> <span class="s1">&#39;jack@msn.com&#39;</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span><span class="p">:</span> <span class="s1">&#39;www@www.org&#39;</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span><span class="p">:</span> <span class="s1">&#39;wendy@aol.com&#39;</span><span class="p">}</span>
<span class="p">])</span>

<span class="c1"># 此外，通过使用 bindparam，INSERT 还可以执行更复杂的操作</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span> \ 
         <span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&#34; .. name&#34;</span><span class="p">)</span>  <span class="c1"># string 拼接</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="p">[</span>
        <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;_name&#39;</span><span class="p">:</span><span class="s1">&#39;name1&#39;</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;_name&#39;</span><span class="p">:</span><span class="s1">&#39;name2&#39;</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;_name&#39;</span><span class="p">:</span><span class="s1">&#39;name3&#39;</span><span class="p">},</span>
     <span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li><strong>删</strong>：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">_table</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span> \
        <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">f1</span><span class="o">==</span><span class="n">value1</span><span class="p">)</span> \
        <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">f2</span><span class="o">==</span><span class="n">value2</span><span class="p">)</span>  <span class="c1"># where 指定条件</span>
</code></pre></td></tr></table>
</div>
</div><ol start="3">
<li><strong>改</strong>：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 举例</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">()</span> \
             <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;jack&#39;</span><span class="p">)</span> \
             <span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;tom&#39;</span><span class="p">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>

<span class="c1"># 批量更新</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">()</span> \
             <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;oldname&#39;</span><span class="p">))</span> \
             <span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;newname&#39;</span><span class="p">))</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="p">[</span>
     <span class="p">{</span><span class="s1">&#39;oldname&#39;</span><span class="p">:</span><span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="s1">&#39;newname&#39;</span><span class="p">:</span><span class="s1">&#39;ed&#39;</span><span class="p">},</span>
     <span class="p">{</span><span class="s1">&#39;oldname&#39;</span><span class="p">:</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="s1">&#39;newname&#39;</span><span class="p">:</span><span class="s1">&#39;mary&#39;</span><span class="p">},</span>
     <span class="p">{</span><span class="s1">&#39;oldname&#39;</span><span class="p">:</span><span class="s1">&#39;jim&#39;</span><span class="p">,</span> <span class="s1">&#39;newname&#39;</span><span class="p">:</span><span class="s1">&#39;jake&#39;</span><span class="p">},</span>
     <span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，所有的条件都是通过 <code>where</code> 指定的，它和后面 ORM 的 filter 接受的参数是一样的。（详细的会在第二篇文章里讲）</p>
<ol start="4">
<li><strong>查</strong></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">select</span>

<span class="c1"># 1. 字段选择</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">])</span>  <span class="c1"># 相当于 select * from users</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">])</span>  <span class="c1"># 这个就是只 select 一部分</span>

<span class="c1"># 2. 添加过滤条件</span>
<span class="n">s3</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">])</span> \
    <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span> 

<span class="n">res</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
<span class="c1"># 可用 for row in res 遍历结果集，也可用 fetchone() 只获取一行</span>
</code></pre></td></tr></table>
</div>
</div><p>查询返回的是 ResultProxy 对象，这是 SQLAlchemy 对 Python DB-API 的 cursor 的一个封装类，要从中获取结果行，主要有下列几个方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">row1</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>  <span class="c1"># 对应 cursor.fetchone()</span>
<span class="n">row2</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>  <span class="c1"># 对应 cursor.fetchall()</span>
<span class="n">row3</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fetchmany</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># 对应 cursor.fetchmany(size=3)</span>

<span class="n">row4</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>  <span class="c1"># 获取一行，然后立即调用 result 的 close() 方法</span>

<span class="n">col</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">mytable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">mycol</span><span class="p">]</span> <span class="c1"># 获取 mycol 这一列</span>

<span class="n">result</span><span class="o">.</span><span class="n">rowcount</span>  <span class="c1"># 结果集的行数</span>

<span class="n">同时</span><span class="err">，</span><span class="n">result</span> <span class="n">也实现了</span> <span class="nb">next</span> <span class="n">protocol</span><span class="err">，</span><span class="n">因此可以直接用</span> <span class="k">for</span> <span class="n">循环遍历</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="where-进阶">where 进阶</h3>
<p>通过使用 or_、and_、in_ model.join 等方法，where 可以构建更复杂的 SQL 语句。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">and_</span><span class="p">,</span> <span class="n">or_</span><span class="p">,</span> <span class="n">not_</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span> <span class="o">+</span>
               <span class="s2">&#34;, &#34;</span> <span class="o">+</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span>
                <span class="n">label</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">)])</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">))</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span>
               <span class="n">or_</span><span class="p">(</span>
                  <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@aol.com&#39;</span><span class="p">),</span>
                  <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">)</span>
               <span class="p">)</span>
        <span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="链接">链接</h2>
<ul>
<li><a href="https://docs.sqlalchemy.org/en/latest/core/connections.html" target="_blank" rel="noopener noreferrer">使用 Engines 和 Connections</a></li>
<li><a href="https://docs.sqlalchemy.org/en/latest/core/tutorial.html" target="_blank" rel="noopener noreferrer">SQL 表达式语言入门</a></li>
<li><a href="https://docs.sqlalchemy.org/en/13/core/constraints.html" target="_blank" rel="noopener noreferrer">SQLAlchemy - 定义约束</a></li>
<li><a href="https://www.cnblogs.com/harrychinese/archive/2012/09/12/My_Own_Tutorial_For_SqlAlchemy.html" target="_blank" rel="noopener noreferrer">SQLAlchemy个人学习笔记完整汇总</a></li>
<li><a href="https://github.com/hackersandslackers/sqlalchemy-tutorial" target="_blank" rel="noopener noreferrer">hackersandslackers/sqlalchemy-tutorial</a></li>
</ul>
]]></description></item></channel></rss>