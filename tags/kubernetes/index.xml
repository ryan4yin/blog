<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>Kubernetes - 标签 - Ryan4Yin's Space</title><link>https://ryan4yin.space/tags/kubernetes/</link><description>Kubernetes - 标签 - Ryan4Yin's Space</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaoyin_c@qq.com (ryan4yin)</managingEditor><webMaster>xiaoyin_c@qq.com (ryan4yin)</webMaster><lastBuildDate>Mon, 06 Apr 2020 21:48:26 +0800</lastBuildDate><atom:link href="https://ryan4yin.space/tags/kubernetes/" rel="self" type="application/rss+xml"/><item><title>使用 Istio 进行 JWT 身份验证（充当 API 网关）</title><link>https://ryan4yin.space/posts/use-istio-for-jwt-auth/</link><pubDate>Mon, 06 Apr 2020 21:48:26 +0800</pubDate><author>
ryan4yin</author><guid>https://ryan4yin.space/posts/use-istio-for-jwt-auth/</guid><description><![CDATA[<blockquote>
<p>本文基于 Istio1.5 编写测试</p>
</blockquote>
<p>Istio 支持使用 JWT 对终端用户进行身份验证（Istio End User Authentication），支持多种 JWT 签名算法。</p>
<p>目前主流的 JWT 算法是 RS256/ES256。（请忽略 HS256，该算法不适合分布式 JWT 验证）</p>
<p>这里以 RSA256 算法为例进行介绍，ES256 的配置方式也是一样的。</p>
<h3 id="1-介绍-jwk-与-jwks">1. 介绍 JWK 与 JWKS</h3>
<p>Istio 要求提供 JWKS 格式的信息，用于 JWT 签名验证。因此这里得先介绍一下 JWK 和 JWKS.</p>
<p>JWKS ，也就是 JWK Set，json 结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">{
&#34;keys&#34;: [
  &lt;jwk-1&gt;,
  &lt;jwk-2&gt;,
  ...
]}
</code></pre></td></tr></table>
</div>
</div><p>JWKS 描述一组 JWK 密钥。它能同时描述多个可用的公钥，应用场景之一是密钥的 Rotate.</p>
<p>而 JWK，全称是 Json Web Key，它描述了一个加密密钥（公钥或私钥）的各项属性，包括密钥的值。</p>
<p>Istio 使用 JWK 描述验证 JWT 签名所需要的信息。在使用 RSA 签名算法时，JWK 描述的应该是用于验证的 RSA 公钥。</p>
<p>一个 RSA 公钥的 JWK 描述如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">{
    &#34;alg&#34;: &#34;RS256&#34;,  # 算法「可选参数」
    &#34;kty&#34;: &#34;RSA&#34;,    # 密钥类型
    &#34;use&#34;: &#34;sig&#34;,    # 被用于签名「可选参数」
    &#34;kid&#34;: &#34;NjVBRjY5MDlCMUIwNzU4RTA2QzZFMDQ4QzQ2MDAyQjVDNjk1RTM2Qg&#34;,  # key 的唯一 id
    &#34;n&#34;: &#34;yeNlzlub94YgerT030codqEztjfU_S6X4DbDA_iVKkjAWtYfPHDzz_sPCT1Axz6isZdf3lHpq_gYX4Sz-cbe4rjmigxUxr-FgKHQy3HeCdK6hNq9ASQvMK9LBOpXDNn7mei6RZWom4wo3CMvvsY1w8tjtfLb-yQwJPltHxShZq5-ihC9irpLI9xEBTgG12q5lGIFPhTl_7inA1PFK97LuSLnTJzW0bj096v_TMDg7pOWm_zHtF53qbVsI0e3v5nmdKXdFf9BjIARRfVrbxVxiZHjU6zL6jY5QJdh1QCmENoejj_ytspMmGW7yMRxzUqgxcAqOBpVm0b-_mW3HoBdjQ&#34;,
    &#34;e&#34;: &#34;AQAB&#34;
}
</code></pre></td></tr></table>
</div>
</div><p>RSA 是基于大数分解的加密/签名算法，上述参数中，<code>e</code> 是公钥的模数(modulus)，<code>n</code> 是公钥的指数(exponent)，两个参数都是 base64 字符串。</p>
<p>JWK 中 RSA 公钥的具体定义参见 <a href="https://tools.ietf.org/html/rfc7518#page-30" target="_blank" rel="noopener noreferrer">RSA Keys - JSON Web Algorithms (JWA)</a></p>
<h3 id="2-jwk-的生成">2. JWK 的生成</h3>
<p>要生成 JWK 公钥，需要先生成私钥，生成方法参见 <a href="/posts/jwt-algorithm-key-generation/#使用-openssl-生成-rsaecc-公私钥" rel="">JWT 签名算法 HS256、RS256 及 ES256 及密钥生成</a>。</p>
<blockquote>
<p>公钥不需要用上述方法生成，因为我们需要的是 JWK 格式的公钥。后面会通过 python 生成出 JWK 公钥。</p>
</blockquote>
<p>上面的命令会将生成出的 RSA 私钥写入 key.pem 中，查看一下私钥内容。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">ryan@RYAN-MI-DESKTOP:~/istio$ cat key.pem
-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEAt1cKkQqPh8iOv5BhKh7Rx6A2+1ldpO/jczML/0GBKu4X+lHr
Y8YbJrt29jyAXlWM8vHC7tXsqgUG+WziRD0D8nhnh10XC14SeH+3mVuBqph+TqhX
TWsh9gtAIbeUHJjEI4I79QK4/wquPHHIGZBQDQQnuMh6vAS3VaUYJdEIoKvUBnAy
Y35kJZgyJSbrxLsEExL2zujUD/OY+/In2bq/3rFtDGNlgHyC7Gu2zXSXvfOA4O5m
9BBXOc7eEqj7PoOKNaTxLN3YcuRtgR6NIXL4KLb6oyvIzoeiprt4+9q7sc3Dnkc5
EV9kwWlEW2DHzhP6VYca0WXIIXc53U1AM3ewxwIDAQABAoIBABIKhaaqJF+XM7zU
B0uuxrPfJynqrFVbqcUfQ9H1bzF7Rm7CeuhRiUBxeA5Y+8TMpFcPxT/dWzGL1xja
RxWx715/zKg8V9Uth6HF55o2r/bKlLtGw3iBz1C34LKwrul1eu+HlEDS6MNoGKco
BynE0qvFOedsCu/Pgv7xhQPLow60Ty1uM0AhbcPgi6yJ5ksRB1XjtEnW0t+c8yQS
nU3mU8k230SdMhf4Ifud/5TPLjmXdFpyPi9uYiVdJ5oWsmMWEvekXoBnHWDDF/eT
VkVMiTBorT4qn+Ax1VjHL2VOMO5ZbXEcpbIc3Uer7eZAaDQ0NPZK37IkIn9TiZ21
cqzgbCkCgYEA5enHZbD5JgfwSNWCaiNrcBhYjpCtvfbT82yGW+J4/Qe/H+bY/hmJ
RRTKf0kVPdRwZzq7GphVMWIuezbOk0aFGhk/SzIveW8QpLY0FV/5xFnGNjV9AuNc
xrmgVshUsyQvr1TFkbdkC6yuvNgQfXfnbEoaPsXYEMCii2zqdF5lWGUCgYEAzCR2
6g8vEQx0hdRS5d0zD2/9IRYNzfP5oK0+F3KHH2OuwlmQVIo7IhCiUgqserXNBDef
hj+GNcU8O/yXLomAXG7VG/cLWRrpY8d9bcRMrwb0/SkNr0yNrkqHiWQ/PvR+2MLk
viWFZTTp8YizPA+8pSC/oFd1jkZF0UhKVAREM7sCgYB5+mfxyczFopyW58ADM7uC
g0goixXCnTuiAEfgY+0wwXVjJYSme0HaxscQdOOyJA1ml0BBQeShCKgEcvVyKY3g
ZNixunR5hrVbzdcgKAVJaR/CDuq+J4ZHYKByqmJVkLND4EPZpWSM1Rb31eIZzw2W
5FG8UBbr/GfAdQ6GorY+CQKBgQCzWQHkBmz6VG/2t6AQ9LIMSP4hWEfOfh78q9dW
MDdIO4JomtkzfLIQ7n49B8WalShGITwUbLDTgrG1neeQahsMmg6+X99nbD5JfBTV
H9WjG8CWvb+ZF++NhUroSNtLyu+6LhdaeopkbQVvPwMArG62wDu6ebv8v/5MrG8o
uwrUSwKBgQCxV43ZqTRnEuDlF7jMN+2JZWhpbrucTG5INoMPOC0ZVatePszZjYm8
LrmqQZHer2nqtFpyslwgKMWgmVLJTH7sVf0hS9po0+iSYY/r8e/c85UdUreb0xyT
x8whrOnMMODCAqu4W/Rx1Lgf2vXIx0pZmlt8Df9i2AVg/ePR6jO3Nw==
-----END RSA PRIVATE KEY-----
</code></pre></td></tr></table>
</div>
</div><p>接下来通过 Python 编程生成 RSA Public Key 和 JWK（jwk 其实就是公钥的另一个表述形式而已）:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># 需要先安装依赖: pip install jwcrypto
from jwcrypto.jwk import JWK
from pathlib import Path

private_key = Path(&#34;key.pem&#34;).read_bytes()
jwk = JWK.from_pem(private_key)

# 导出公钥 RSA Public Key
public_key = jwk.public().export_to_pem()
print(public_key)

print(&#34;=&#34;*30)

# 导出 JWK
jwk_bytes = jwk.public().export()
print(jwk_bytes)
</code></pre></td></tr></table>
</div>
</div><p>Istio 需要 JWK 进行 JWT 验证，而我们手动验证 JWT 时一般需要用到 Public Key. 方便起见，上述代码把这两个都打印了出来。内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># Public Key 内容，不包含这行注释
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAt1cKkQqPh8iOv5BhKh7R
x6A2+1ldpO/jczML/0GBKu4X+lHrY8YbJrt29jyAXlWM8vHC7tXsqgUG+WziRD0D
8nhnh10XC14SeH+3mVuBqph+TqhXTWsh9gtAIbeUHJjEI4I79QK4/wquPHHIGZBQ
DQQnuMh6vAS3VaUYJdEIoKvUBnAyY35kJZgyJSbrxLsEExL2zujUD/OY+/In2bq/
3rFtDGNlgHyC7Gu2zXSXvfOA4O5m9BBXOc7eEqj7PoOKNaTxLN3YcuRtgR6NIXL4
KLb6oyvIzoeiprt4+9q7sc3Dnkc5EV9kwWlEW2DHzhP6VYca0WXIIXc53U1AM3ew
xwIDAQAB
-----END PUBLIC KEY-----
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># jwk 内容
{
 &#39;e&#39;: &#39;AQAB&#39;,
 &#39;kid&#39;: &#39;oyYwZSLCLVVPHdVp0jXIcLNpGn6dMCumlY-6wSenmFo&#39;,
 &#39;kty&#39;: &#39;RSA&#39;,
 &#39;n&#39;: &#39;t1cKkQqPh8iOv5BhKh7Rx6A2-1ldpO_jczML_0GBKu4X-lHrY8YbJrt29jyAXlWM8vHC7tXsqgUG-WziRD0D8nhnh10XC14SeH-3mVuBqph-TqhXTWsh9gtAIbeUHJjEI4I79QK4_wquPHHIGZBQDQQnuMh6vAS3VaUYJdEIoKvUBnAyY35kJZgyJSbrxLsEExL2zujUD_OY-_In2bq_3rFtDGNlgHyC7Gu2zXSXvfOA4O5m9BBXOc7eEqj7PoOKNaTxLN3YcuRtgR6NIXL4KLb6oyvIzoeiprt4-9q7sc3Dnkc5EV9kwWlEW2DHzhP6VYca0WXIIXc53U1AM3ewxw&#39;
}
</code></pre></td></tr></table>
</div>
</div><h3 id="4-测试密钥可用性">4. 测试密钥可用性</h3>
<p>接下来在 <a href="https://jwt.io" target="_blank" rel="noopener noreferrer">jwt.io</a> 中填入测试用的公钥私钥，还有 Header/Payload。一是测试公私钥的可用性，二是生成出 JWT 供后续测试 Istio JWT 验证功能的可用性。
</p>
<p>可以看到左下角显示「Signature Verified」，成功地生成出了 JWT。后续可以使用这个 JWT 访问 Istio 网关，测试 Istio JWT 验证功能。</p>
<h3 id="5-启用-istio-的身份验证">5. 启用 Istio 的身份验证</h3>
<p>编写 istio 配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;security.istio.io/v1beta1&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;RequestAuthentication&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;jwt-example&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">istio-system </span><span class="w"> </span><span class="c"># istio-system 名字空间中的配置，默认情况下会应用到所有名字空间</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">istio</span><span class="p">:</span><span class="w"> </span><span class="l">ingressgateway</span><span class="w">
</span><span class="w">  </span><span class="nt">jwtRules</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="c"># issuer 即签发者，需要和 JWT payload 中的 iss 属性完全一致。</span><span class="w">
</span><span class="w">  </span>- <span class="nt">issuer</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;testing@secure.istio.io&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">jwks</span><span class="p">:</span><span class="w"> </span><span class="p">|</span><span class="sd">
</span><span class="sd">    {
</span><span class="sd">        &#34;keys&#34;: [
</span><span class="sd">            {
</span><span class="sd">                &#34;e&#34;: &#34;AQAB&#34;,
</span><span class="sd">                &#34;kid&#34;: &#34;oyYwZSLCLVVPHdVp0jXIcLNpGn6dMCumlY-6wSenmFo&#34;,  # kid 需要与 jwt header 中的 kid 完全一致。
</span><span class="sd">                &#34;kty&#34;: &#34;RSA&#34;,
</span><span class="sd">                &#34;n&#34;: &#34;t1cKkQqPh8iOv5BhKh7Rx6A2-1ldpO_jczML_0GBKu4X-lHrY8YbJrt29jyAXlWM8vHC7tXsqgUG-WziRD0D8nhnh10XC14SeH-3mVuBqph-TqhXTWsh9gtAIbeUHJjEI4I79QK4_wquPHHIGZBQDQQnuMh6vAS3VaUYJdEIoKvUBnAyY35kJZgyJSbrxLsEExL2zujUD_OY-_In2bq_3rFtDGNlgHyC7Gu2zXSXvfOA4O5m9BBXOc7eEqj7PoOKNaTxLN3YcuRtgR6NIXL4KLb6oyvIzoeiprt4-9q7sc3Dnkc5EV9kwWlEW2DHzhP6VYca0WXIIXc53U1AM3ewxw&#34;
</span><span class="sd">            }
</span><span class="sd">        ]
</span><span class="sd">    }
</span><span class="sd">      # jwks 或 jwksUri 二选其一
</span><span class="sd">      # jwksUri: &#34;http://nginx.test.local/istio/jwks.json&#34;</span><span class="w">    
</span></code></pre></td></tr></table>
</div>
</div><p>现在 <code>kubectl apply</code> 一下，JWT 验证就添加到全局了。</p>
<p>可以看到 jwtRules 是一个列表，因此可以为每个 issuers 配置不同的 jwtRule.</p>
<p>对同一个 issuers（jwt 签发者），可以通过 jwks 设置多个公钥，以实现JWT签名密钥的轮转。
JWT 的验证规则是：</p>
<ol>
<li>JWT 的 payload 中有 issuer 属性，首先通过 issuer 匹配到对应的 istio 中配置的 jwks。</li>
<li>JWT 的 header 中有 kid 属性，第二步在 jwks 的公钥列表中，中找到 kid 相同的公钥。</li>
<li>使用找到的公钥进行 JWT 签名验证。</li>
</ol>
<h3 id="6-启用-payload-转发authorization-转发">6. 启用 Payload 转发/Authorization 转发</h3>
<p>默认情况下，Istio 在完成了身份验证之后，会去掉 Authorization 请求头再进行转发。
这将导致我们的后端服务获取不到对应的 Payload，无法判断 End User 的身份。
因此我们需要启用 Istio 的 Authorization 请求头的转发功能，在前述的 <code>RequestAuthentication</code> yaml 配置中添加一个参数就行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;security.istio.io/v1beta1&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;RequestAuthentication&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;jwt-example&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">istio-system</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">istio</span><span class="p">:</span><span class="w"> </span><span class="l">ingressgateway</span><span class="w">
</span><span class="w">  </span><span class="nt">jwtRules</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">issuer</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;testing@secure.istio.io&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">jwks</span><span class="p">:</span><span class="w"> </span><span class="p">|</span><span class="sd">
</span><span class="sd">    {
</span><span class="sd">        &#34;keys&#34;: [
</span><span class="sd">            {
</span><span class="sd">                &#34;e&#34;: &#34;AQAB&#34;,
</span><span class="sd">                &#34;kid&#34;: &#34;oyYwZSLCLVVPHdVp0jXIcLNpGn6dMCumlY-6wSenmFo&#34;,
</span><span class="sd">                &#34;kty&#34;: &#34;RSA&#34;,
</span><span class="sd">                &#34;n&#34;: &#34;t1cKkQqPh8iOv5BhKh7Rx6A2-1ldpO_jczML_0GBKu4X-lHrY8YbJrt29jyAXlWM8vHC7tXsqgUG-WziRD0D8nhnh10XC14SeH-3mVuBqph-TqhXTWsh9gtAIbeUHJjEI4I79QK4_wquPHHIGZBQDQQnuMh6vAS3VaUYJdEIoKvUBnAyY35kJZgyJSbrxLsEExL2zujUD_OY-_In2bq_3rFtDGNlgHyC7Gu2zXSXvfOA4O5m9BBXOc7eEqj7PoOKNaTxLN3YcuRtgR6NIXL4KLb6oyvIzoeiprt4-9q7sc3Dnkc5EV9kwWlEW2DHzhP6VYca0WXIIXc53U1AM3ewxw&#34;
</span><span class="sd">            }
</span><span class="sd">        ]
</span><span class="sd">    }</span><span class="w">    
</span><span class="w"></span><span class="c"># ===================== 添加如下参数===========================</span><span class="w">
</span><span class="w">    </span><span class="nt">forwardOriginalToken</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">  </span><span class="c"># 转发 Authorization 请求头</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>加了转发后，流程图如下（需要 mermaid 渲染）：</p>
<div class="mermaid" id="id-1"></div>
<h2 id="其他问题">其他问题</h2>
<h3 id="1-authorizationpolicy">1. AuthorizationPolicy</h3>
<p>Istio 的 JWT 验证规则，默认情况下会直接忽略不带 Authorization 请求头的流量，因此这类流量能直接进入网格内部。如果需要禁止不带 Authorization 头的流量，需要额外配置 AuthorizationPolicy 策略。</p>
<p>RequestsAuthentication 验证失败的请求，Istio 会返回 401 状态码。
AuthorizationPolicy 验证失败的请求，Istio 会返回 403 状态码。</p>
<p>这会导致在使用 AuthorizationPolicy 禁止了不带 Authorization 头的流量后，这类请求会直接被返回 403。。。在使用 RESTful API 时，这种情况可能会造成一定的问题。</p>
<h3 id="2-response-headers">2. Response Headers</h3>
<p>RequestsAuthentication 不支持自定义响应头信息，这导致对于前后端分离的 Web API 而言，
一旦 JWT 失效，Istio 会直接将 401 返回给前端 Web 页面。
因为响应头中不包含 <code>Access-Crontrol-Allow-Origin</code>，响应将被浏览器拦截！</p>
<p>这可能需要通过 EnvoyFilter 自定义响应头，添加跨域信息。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://auth0.com/docs/tokens/references/jwks-properties" target="_blank" rel="noopener noreferrer">JSON Web Key Set Properties - Auth0</a></li>
<li><a href="https://tools.ietf.org/html/rfc7517" target="_blank" rel="noopener noreferrer">JWK - RFC7517</a></li>
<li><a href="https://github.com/istio/istio/tree/master/security/tools/jwt/samples" target="_blank" rel="noopener noreferrer">Sample JWT and JWKS data for demo - Istio Security</a></li>
<li><a href="https://istio.io/docs/tasks/security/authentication/authn-policy/#end-user-authentication" target="_blank" rel="noopener noreferrer">End User Authentication - Istio</a></li>
<li><a href="https://istio.io/docs/reference/config/security/jwt/" target="_blank" rel="noopener noreferrer">JWTRule - Istio</a></li>
<li><a href="https://jwt.io/" target="_blank" rel="noopener noreferrer">jwt.io - 动态生成 jwt</a></li>
</ul>]]></description></item><item><title>Kubernetes 常见错误、原因及处理方法</title><link>https://ryan4yin.space/posts/common-kubernetes-errors-causes-and-solutions/</link><pubDate>Sun, 24 Nov 2019 19:26:54 +0800</pubDate><author>
ryan4yin</author><guid>https://ryan4yin.space/posts/common-kubernetes-errors-causes-and-solutions/</guid><description><![CDATA[<ol>
<li>OOMKilled: Pod 的内存使用超出了 resources.limits 中的限制，被强制杀死。</li>
<li>CrashLoopBackoff: Pod 进入 <strong>崩溃-重启</strong>循环，重启间隔时间从 10 20 40 80 一直翻倍到上限 300 秒，然后以 300 秒为间隔无限重启。</li>
<li>Pod 一直 Pending: 这说明没有任何节点能满足 Pod 的要求，容器无法被调度。比如端口被别的容器用 hostPort 占用，节点有污点等。</li>
<li><a href="" rel="">FailedCreateSandBox: Failed create pod sandbox: rpc error: code = DeadlineExceeded desc = context deadline exceeded</a>：很可能是 CNI 网络插件的问题（比如 ip 地址溢出），</li>
<li><a href="https://cloud.tencent.com/developer/article/1411527" target="_blank" rel="noopener noreferrer">SandboxChanged: Pod sandbox changed, it will be killed and re-created</a>: 很可能是由于内存限制导致容器被 OOMKilled，或者其他资源不足</li>
<li><a href="https://github.com/kubernetes/kubernetes/issues/55094" target="_blank" rel="noopener noreferrer">FailedSync: error determining status: rpc error: code = DeadlineExceeded desc = context deadline exceeded</a>: 常和前两个错误先后出现，很可能是 CNI 网络插件的问题。</li>
<li>开发集群，一次性部署所有服务时，各 Pod 互相争抢资源，导致 Pod 生存探针失败，不断重启，重启进一步加重资源使用。恶性循环。
<ul>
<li><strong>需要给每个 Pod 加上 resources.requests，这样资源不足时，后续 Pod 会停止调度，直到资源恢复正常。</strong></li>
</ul>
</li>
<li>Pod 出现大量的 Failed 记录，Deployment 一直重复建立 Pod: 通过 <code>kubectl describe/edit pod &lt;pod-name&gt;</code> 查看 pod <code>Events</code> 和 <code>Status</code>，一般会看到失败信息，如节点异常导致 Pod 被驱逐。</li>
<li><a href="https://zhuanlan.zhihu.com/p/70031676" target="_blank" rel="noopener noreferrer">Kubernetes 问题排查：Pod 状态一直 Terminating</a></li>
<li>创建了 Deployment 后，却没有自动创建 Pod: 缺少某些创建 Pod 必要的东西，比如设定的 ServiceAccount 不存在。</li>
<li>Pod 运行失败，状态为 MatchNodeSelector: 对主节点进行关机、迁移等操作，导致主调度器下线时，会在一段时间内导致 Pod 调度失败，调度失败会报这个错。</li>
<li>Pod 仍然存在，但是 <code>Service</code> 的 Endpoints 却为空，找不到对应的 Pod IPs: 遇到过一次，是因为时间跳变（从未来的时间改回了当前时间）导致的问题。</li>
<li>Pod 状态一直 ContainerCreating，Error syncing pod: 可能是节点的内存碎片化严重，导致无法创建pod。临时解决：<code>echo 3 &gt; /proc/sys/vm/drop_caches</code>
<ul>
<li>详细分析参见 <a href="https://zhuanlan.zhihu.com/p/227728280" target="_blank" rel="noopener noreferrer">容器创建失败(runc_page allocation failure)排查</a></li>
</ul>
</li>
</ol>
<p>收集的其他故障解决文章：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1487051" target="_blank" rel="noopener noreferrer">TKE操作指南 - TKE K8S问题排查（十八）</a></li>
</ul>
<h3 id="pod-无法删除">Pod 无法删除</h3>
<p>可能是某些资源无法被GC，这会导致容器已经 Exited 了，但是 Pod 一直处于 Terminating 状态。</p>
<p>这个问题在网上能搜到很多案例,但大都只是提供了如下的强制清理命令，未分析具体原因：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">kubectl delete pods &lt;pod&gt; --grace-period<span class="o">=</span><span class="m">0</span> --force
</code></pre></td></tr></table>
</div>
</div><p>最近找到几篇详细的原因分析文章，值得一看：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1680612" target="_blank" rel="noopener noreferrer">腾讯云原生 -【Pod Terminating原因追踪系列】之 containerd 中被漏掉的 runc 错误信息</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1680613" target="_blank" rel="noopener noreferrer">腾讯云原生 -【Pod Terminating原因追踪系列之二】exec连接未关闭导致的事件阻塞</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1689486" target="_blank" rel="noopener noreferrer">腾讯云原生 -【Pod Terminating原因追踪系列之三】让docker事件处理罢工的cancel状态码</a></li>
<li><a href="https://www.likakuli.com/posts/docker-pod-terminating/" target="_blank" rel="noopener noreferrer">Pod terminating - 问题排查 - KaKu Li</a></li>
</ul>
<p>大致总结一下，主要原因来自 docker 18.06 以及 kubernetes 的 docker-shim 运行时的底层逻辑，已经在新版本被修复了。</p>
<h2 id="节点常见错误">节点常见错误</h2>
<ol>
<li><a href="https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/#node-conditions" target="_blank" rel="noopener noreferrer">DiskPressure</a>：节点的可用空间不足。（通过<code>df -h</code> 查看，保证可用空间不小于 15%）</li>
<li>The node was low on resource: ephemeral-storage: 同上，节点的存储空间不够了。</li>
</ol>
<h2 id="网络常见错误">网络常见错误</h2>
<h3 id="1-ingressistio-gateway-返回值">1. Ingress/Istio Gateway 返回值</h3>
<ol>
<li>404：不存在该 Service/Istio Gateway</li>
<li>503：服务不可用。原因基本都是 Service 对应的 Pods NotReady</li>
<li>504：网关请求下游超时。主要有两种可能
<ol>
<li>考虑是不是 Ingress Controller 的 IP 表未更新，将请求代理到了不存在的 Pod ip，导致得不到响应。</li>
<li>Pod 响应太慢，代码问题。</li>
</ol>
</li>
</ol>
<p>Ingress 相关网络问题的排查流程：</p>
<ol>
<li>Which ingress controller?</li>
<li>Timeout between client and ingress controller, or between ingress controller and backend service/pod?</li>
<li>HTTP/504 generated by the ingress controller, proven by logs from the ingress controller?</li>
<li>If you port-forward to skip the internet between client and ingress controller, does the timeout still happen?</li>
</ol>
<h2 id="名字空间常见错误">名字空间常见错误</h2>
<h3 id="名字空间无法删除">名字空间无法删除</h3>
<p>这通常是某些资源如 CR(custom resources)/存储等资源无法释放导致的。
比如常见的 monitoring 名字空间无法删除，应该就是 CR 无法 GC 导致的。</p>
<p>可手动删除 namespace 配置中的析构器（spec.finalizer，在名字空间生命周期结束前会生成的配置项），这样名字空间就会直接跳过 GC 步骤：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 编辑名字空间的配置</span>
kubectl edit namespace &lt;ns-name&gt;
<span class="c1"># 将 spec.finalizers 改成空列表 []</span>
</code></pre></td></tr></table>
</div>
</div><p>如果上述方法也无法删除名字空间，也找不到具体的问题，就只能直接从 etcd 中删除掉它了(有风险，谨慎操作！)。方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 登录到 etcd 容器中，执行如下命令：</span>
<span class="nb">export</span> <span class="nv">ETCDCTL_API</span><span class="o">=</span><span class="m">3</span>
<span class="nb">cd</span> /etc/kubernetes/pki/etcd/
<span class="c1"># 列出所有名字空间</span>
etcdctl --cacert ca.crt --cert peer.crt --key peer.key get /registry/namespaces --prefix --keys-only

<span class="c1"># （谨慎操作！！！）强制删除名字空间 `monitoring`。这可能导致相关资源无法被 GC！</span>
etcdctl --cacert ca.crt --cert peer.crt --key peer.key del /registry/namespaces/monitoring
</code></pre></td></tr></table>
</div>
</div><h2 id="kubectlistioctl-等客户端工具异常">kubectl/istioctl 等客户端工具异常</h2>
<ol>
<li><code>socat not found</code>: kubectl 使用 <code>socat</code> 进行端口转发，集群的所有节点，以及本机都必须安装有 <code>socat</code> 工具。</li>
</ol>
<h2 id="批量清理-evicted-记录">批量清理 Evicted 记录</h2>
<p>有时候 Pod 因为节点选择器的问题，被不断调度到有问题的 Node 上，就会不断被 Evicted，导致出现大量的 Evicted Pods。
排查完问题后，需要手动清理掉这些 Evicted Pods.</p>
<p>批量删除 Evicted 记录:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">kubectl get pods <span class="p">|</span> grep Evicted <span class="p">|</span> awk <span class="s1">&#39;{print $1}&#39;</span> <span class="p">|</span> xargs kubectl delete pod
</code></pre></td></tr></table>
</div>
</div><h2 id="容器镜像gcpod驱逐以及节点压力">容器镜像GC、Pod驱逐以及节点压力</h2>
<p>节点压力 DiskPressure 会导致 Pod 被驱逐，也会触发容器镜像的 GC。</p>
<p>根据官方文档 <a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/out-of-resource" target="_blank" rel="noopener noreferrer">配置资源不足时的处理方式</a>，Kubelet 提供如下用于配置容器 GC 及 Evicetion 的阈值：</p>
<ol>
<li><code>--eviction-hard</code> 和 <code>eviction-soft</code>: 对应旧参数 <code>--image-gc-high-threshold</code>，这两个参数配置镜像 GC 及驱逐的触发阈值。磁盘使用率的阈值默认为 85%
<ol>
<li>区别在于 <code>eviction-hard</code> 是立即驱逐，而 <code>eviction-soft</code> 在超过 <code>eviction-soft-grace-period</code> 之后才驱逐。</li>
</ol>
</li>
<li><code>--eviction-minimum-reclaim</code>: 对应旧参数 <code>--image-gc-low-threshold</code>。这是进行资源回收（镜像GC、Pod驱逐等）后期望达到的磁盘使用率百分比。磁盘使用率的阈值默认值为 80%。</li>
</ol>
<p>问：能否为 ImageGC 设置一个比 DiskPressure 更低的阈值？因为我们希望能自动进行镜像 GC，但是不想立即触发 Pod 驱逐。</p>
<p>答：这应该可以通过设置 <code>eviction-soft</code> 和长一点的 <code>eviction-soft-grace-period</code> 来实现。
另外 <code>--eviction-minimum-reclaim</code> 也可以设小一点，清理得更干净。示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">--eviction-soft<span class="o">=</span>memory.available&lt;1Gi,nodefs.available&lt;2Gi,imagefs.available&lt;200Gi
--eviction-soft-grace-period<span class="o">=</span>3m
--eviction-minimum-reclaim<span class="o">=</span>memory.available<span class="o">=</span>0Mi,nodefs.available<span class="o">=</span>1Gi,imagefs.available<span class="o">=</span>2Gi
</code></pre></td></tr></table>
</div>
</div><h2 id="其他问题">其他问题</h2>
<h3 id="如何重新运行一个-job">如何重新运行一个 Job？</h3>
<p>我们有一个 Job 因为外部原因运行失败了，修复好后就需要重新运行它。</p>
<p>方法是：删除旧的 Job，再使用同一份配置重建 Job.</p>
<p>如果你使用的是 fluxcd 这类 GitOps 工具，就只需要手工删除旧 Pod，fluxcd 会定时自动 apply 所有配置，这就完成了 Job 的重建。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://yq.aliyun.com/articles/703971?type=2" target="_blank" rel="noopener noreferrer">Kubernetes管理经验</a></li>
<li><a href="https://www.reddit.com/r/kubernetes/comments/ced0py/504_gateway_timeout_when_accessing_workload_via/" target="_blank" rel="noopener noreferrer">504 Gateway Timeout when accessing workload via ingress</a></li>
<li><a href="https://k8s.af/" target="_blank" rel="noopener noreferrer">Kubernetes Failure Stories</a></li>
</ul>
]]></description></item></channel></rss>