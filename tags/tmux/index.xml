<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>tmux - 标签 - This Cute World</title><link>https://thiscute.world/tags/tmux/</link><description>tmux - 标签 - This Cute World</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaoyin_c@qq.com (ryan4yin)</managingEditor><webMaster>xiaoyin_c@qq.com (ryan4yin)</webMaster><lastBuildDate>Sun, 13 Feb 2022 16:09:00 +0800</lastBuildDate><atom:link href="https://thiscute.world/tags/tmux/" rel="self" type="application/rss+xml"/><item><title>Linux/Windows/MacOSX 系统常用命令集锦</title><link>https://thiscute.world/posts/common-commands-for-various-operating-systems/</link><pubDate>Sun, 13 Feb 2022 16:09:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/common-commands-for-various-operating-systems/</guid><description><![CDATA[<blockquote>
<p>个人笔记，只会列出我自己容易忘掉的命令，方便查阅。</p>
</blockquote>
<blockquote>
<p>内容比较多，适合当参考手册用。可能不太适合从头读到尾&hellip;</p>
</blockquote>
<blockquote>
<p>本文主要介绍 Linux 命令，顺带介绍下 Windows/MacOSX.</p>
</blockquote>
<h2 id="一linux">一、Linux</h2>
<h3 id="1-后台运行">1. 后台运行</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 1. 后台运行命令</span>
nohup python xxx.py <span class="p">&amp;</span>
</code></pre></td></tr></table>
</div>
</div><p>也可以使用 tmux，tmux 提供的 session 功能比 nohup 更好用，后面会介绍 tmux</p>
<h3 id="2-查找替换-sedawk">2. 查找替换 sed/awk</h3>
<p>sed 常用命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1">## 只在目录中所有的 .py 和 .dart 文件中递归搜索字符&#34;main()&#34;</span>
grep <span class="s2">&#34;main()&#34;</span> . -r --include *.<span class="o">{</span>py, dart<span class="o">}</span>

<span class="c1">## 1） 全文搜索并替换</span>
<span class="c1">### -i --in-place 原地替换（修改原文件）</span>
<span class="c1">### -i=SUFFIX  替换后的文件添加 SUFFIX 这个后缀</span>
<span class="c1">### -r  使用拓展的正则表达式，注意此正则不支持 \d\w\s 等语法，必须使用 [0-9] [a-zA-Z] 等来替换！！！</span>
sed -ri <span class="s2">&#34;s/pattern_str/replace_str/g&#34;</span> <span class="sb">`</span>grep <span class="s2">&#34;key_pattern&#34;</span> <span class="s1">&#39;path_pattern&#39;</span> -rl<span class="sb">`</span>

<span class="c1">## 2）文件名搜索，替换文件内容</span>
sed -ri <span class="s2">&#34;s/pattern_str/replace_str/g&#34;</span> <span class="sb">`</span>find . -name <span class="s2">&#34;pattern&#34;</span><span class="sb">`</span>

<span class="c1">## 3）批量转换大小写</span>
<span class="c1"># 将当前文件夹内，所有的 gitlab URL 都转换成小写</span>
<span class="c1"># \L 转小写  \U 转大写</span>
sed -ri <span class="s1">&#39;s@http://GITLAB.*.git@\L&amp;@g&#39;</span> <span class="sb">`</span>find . -name pubspec*<span class="sb">`</span>


<span class="c1">## 4) 拷贝文件，并且保持文件夹结构（--parents 表示保持文件夹结构）</span>
cp --parents <span class="sb">`</span>find &lt;src-dir&gt; -name *.py<span class="sb">`</span> &lt;dst-dir&gt;
</code></pre></td></tr></table>
</div>
</div><p>awk 用于按列处理文本，它比 sed 更强大更复杂，常用命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1">## 1. 单独选出第 1 列的文本</span>
cat xxx.txt <span class="p">|</span> awk -F <span class="s1">&#39;{print $1}&#39;</span> <span class="p">|</span> head

<span class="c1">## 2. 可以使用 -F 指定分隔符，打印出多列</span>
awk -F <span class="s1">&#39;,&#39;</span> <span class="s1">&#39;{print $1,$2}&#39;</span><span class="p">|</span> head 

<span class="c1">## 3. 打印出行数</span>
cat log_test <span class="p">|</span> awk <span class="s1">&#39;{print NR,$1}&#39;</span> <span class="p">|</span> more

<span class="c1">## 4. if 判断语句</span>
cat log_test <span class="p">|</span> awk <span class="s1">&#39;{if($11&gt;300) print($1,$11)}&#39;</span>

cat log_test <span class="p">|</span> awk <span class="s1">&#39;{print $11}&#39;</span> <span class="p">|</span> sort -n <span class="p">|</span> uniq -c  

<span class="c1"># 求和</span>
cat data<span class="p">|</span>awk <span class="s1">&#39;{sum+=$1} END {print &#34;Sum = &#34;, sum}&#39;</span>

<span class="c1"># 求平均</span>
cat data<span class="p">|</span>awk <span class="s1">&#39;{sum+=$1} END {print &#34;Average = &#34;, sum/NR}&#39;</span>

<span class="c1"># 求最大值</span>
cat data<span class="p">|</span>awk <span class="s1">&#39;BEGIN {max = 0} {if ($1&gt;max) max=$1 fi} END {print &#34;Max=&#34;, max}&#39;</span>

<span class="c1"># 求最小值（min的初始值设置一个超大数即可）</span>
awk <span class="s1">&#39;BEGIN {min = 1999999} {if ($1&lt;min) min=$1 fi} END {print &#34;Min=&#34;, min}&#39;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="3-压缩相关">3. 压缩相关</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 直接 cat 压缩文件的内容</span>
zcat xxx.gz <span class="p">|</span> more  <span class="c1"># gzip</span>
xzcat xxx.xz <span class="p">|</span> more  <span class="c1"># xz</span>

tar -axvf xxx.tar.*  <span class="c1"># 通过后缀识别压缩格式，智能解压</span>
</code></pre></td></tr></table>
</div>
</div><p>更多命令参见 <a href="https://thiscute.world/posts/compression-related-instructions-under-linux/" target="_blank" rel="noopener noreferrer">常见压缩格式的区别，及 Linux 下的压缩相关指令</a></p>
<h3 id="4-文件拷贝与同步">4. 文件拷贝与同步</h3>
<p>各种 Linux 发行版都自带 scp/ssh，这两个工具功能简单，一般够用。</p>
<p>另外就是更强大也更复杂的 rsync，部分发行版会自带 rsync。</p>
<p>下面分别介绍下。</p>
<h4 id="1-sshscp">1. ssh/scp</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 如果使用 ssh 命令进行文件传输，可安装 pv 命令查看传输速度（pipeviewer）</span>
<span class="c1">## ubuntu</span>
sudo apt-get install pv
<span class="c1">##  centos</span>
sudo yum install epel-release
sudo yum install pv

<span class="c1">## 1)从本地上传到服务器</span>

<span class="c1">### 使用 ssh 的好处是流式传输不会占用目标机器的存储空间，适合传输可能引起空间不足的大文件，并在目标机器上实时处理该文件。</span>
cat &lt;filename&gt; <span class="p">|</span> pv <span class="p">|</span> ssh &lt;user&gt;@&lt;host&gt; -p <span class="m">22</span> <span class="s2">&#34;cat - &gt; &lt;new-filename&gt;&#34;</span>
tar cz &lt;filename or foldername or glob&gt; <span class="p">|</span> pv <span class="p">|</span> ssh &lt;user&gt;@&lt;host&gt; -p <span class="m">22</span> <span class="s2">&#34;tar xz&#34;</span>  <span class="c1"># 压缩传输</span>

<span class="c1">## scp 命令比 ssh 命令更简洁（但是不适合用于传文件夹，它会破坏文件的权限设置，把文件夹弄得一团糟）</span>
scp -P <span class="m">22</span> &lt;filename&gt; &lt;user&gt;@&lt;host&gt;:&lt;folder-name or filename&gt;  <span class="c1"># 通过 scp 传输，传文件夹时记得添加 -r 参数（recursive）</span>

<span class="c1">## 2) 从服务器下载到本地</span>
ssh &lt;user&gt;@&lt;host&gt; -p <span class="m">22</span> <span class="s2">&#34;tar cz &lt;filename or foldername or glob&gt;&#34;</span> <span class="p">|</span> pv <span class="p">|</span> tar xz  <span class="c1"># 压缩传输</span>
scp -P <span class="m">22</span> &lt;user&gt;@&lt;host&gt;:&lt;folder-name or filename&gt; &lt;filename&gt;  <span class="c1"># 通过 scp 传输，传文件夹时记得添加 -r 参数（recursive）</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="2-rsync">2. rsync</h4>
<p>rsync 的功能其实和前面的 scp/(tar+ssh) 是一样的，将文件从一个地方拷贝到另一个地方。
区别在于它只做增量同步，在多次拷贝文件时，只拷贝（同步）修改过的部分，很多场景下可以大大加快拷贝/备份速度。</p>
<p>rsync 的常用命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 将一个文件夹归档、压缩，并通过 ssh 协议（默认）同步到另一个地方</span>
<span class="c1"># -a, --archive   # 归档模式，保留文件的所有元信息，等同于 `-rlptgoD`</span>
<span class="c1"># -r, --recursive # 递归复制文件夹，`-a` 隐含了这个参数，通常都用 -a。</span>
<span class="c1"># -v, --verbose   # 输出详细信息</span>
<span class="c1"># --progress      # 显示传输进度</span>
<span class="c1"># -z, --compress  # 传输文件时进行压缩</span>
rsync -avz --progress src host:dest
rsync -avz --progress -e <span class="s2">&#34;ssh -p225&#34;</span> /path/src user@host:dest  <span class="c1"># 使用非默认的 ssh 端口进行传输</span>
rsync -avz --progress -e <span class="s2">&#34;ssh -i id_xxx&#34;</span> /path/src user@host:dest  <span class="c1"># 使用指定的私钥连接 ssh 服务端，其他各种 ssh 参数都可以在这里指定</span>

<span class="c1"># --exclude 排除掉某些不需要的文件(夹)</span>
rsync -avz --progress --exclude <span class="s2">&#34;foor/bar&#34;</span> src user@host:dest

<span class="c1"># 有时我们希望在同步数据时修改文件的 user/group</span>
<span class="c1"># --chown    # 设置文件的 user:group，必须与 `-og`/`--owner --group` 同时使用！（`-a` 隐含了 `-og`） </span>
rsync -avz --progress --chown<span class="o">=</span>root:root src user@host:dest  <span class="c1"># 传输时修改 user/group 为 root</span>

<span class="c1"># 详细说明 src 和 dest 的位置</span>
rsync -avz --progress path/src user@host:/tmp  <span class="c1"># 将 src 拷贝到远程主机的 /tmp 中（得到 /tmp/src）</span>
<span class="c1">## 注意 src 结尾有 /</span>
rsync -avz --progress path/src/ user@host:/tmp/src  <span class="c1"># 将 src 目录中的文件拷贝到远程主机的 /tmp/src 目录中（同样得到 /tmp/src）</span>

<span class="c1"># 有时候我们在传输文件时不希望保留文件的元信息</span>

<span class="c1"># rsync 默认不会删除 dest 中多余的文件，使用 --delete 可让 rsync 删除这部分无关的文件</span>
<span class="c1"># 对 src 文件夹进行完全镜像，保证两个文件夹的内容一模一样，不多不少</span>
rsync -avz --progress --delete src user@host:dest

<span class="c1"># 也可以使用 --ignore-existing 让 rsync 忽略掉 dest 已经存在的文件。就是只同步新增的文件。</span>
rsync -avz --progress --ignore-existing src user@host:dest

<span class="c1"># 另有使用双冒号 :: 分隔的传输命令，这种命令使用 rsync 协议进行传输，要求目标主机启用 rsync-daemon</span>
<span class="c1"># 暂时不做介绍</span>

详见 https://rsync.samba.org/documentation.html

<span class="c1"># 用户与群组</span>
<span class="c1">## 查看用户属于哪些群组</span>
groups &lt;user-name&gt;  <span class="c1"># 方法一</span>
id &lt;username&gt;       <span class="c1"># 方法二，它会额外列出 gid/uid</span>
cat /etc/group <span class="p">|</span> grep &lt;user-name&gt;  <span class="c1"># 方法三，直接查看配置</span>
<span class="c1">## 查看群组中有哪些用户，第一列是群组，最后一列是用户名</span>
cat /etc/group <span class="p">|</span> grep &lt;group-name&gt;
</code></pre></td></tr></table>
</div>
</div><h3 id="5-tmux">5. Tmux</h3>
<blockquote>
<p>参考文档：https://github.com/tmux/tmux/wiki/Getting-Started
参考文档：https://www.ruanyifeng.com/blog/2019/10/tmux.html</p>
</blockquote>
<ol>
<li>输入 <code>tmux</code> 启动一个 tmux 会话。（或者用 <code>tmux new -s &lt;session-name&gt;</code> 启动一个命名会话）</li>
<li>输入 <code>python xxx.py</code>，python 进程开始运行。</li>
<li>按快捷键 <code>ctrl+b</code>，然后再按一下 <code>d</code> 脱离(detatch)当前会话。此时 python 进程进入后台运行，关闭当前终端对 python 进程没有影响。</li>
<li>输入 <code>tmux ls</code> 可以查看当前正在后台运行的会话。（命名会话会显示名称，否则只显示 id）</li>
<li>通过 <code>tmux attach -t &lt;session-name/id&gt;</code> 重新接入后台会话。
<ol>
<li>缩写 <code>tmux a -t &lt;session&gt;</code></li>
</ol>
</li>
<li>或者通过 <code>tmux kill-session -t &lt;session-name/id&gt;</code> 杀死一个后台会话。</li>
</ol>
<p>常用快捷键：</p>
<pre><code>  # prefix 表示 `ctrl`+`b`

  # pane 的切分与选择
  prefix &quot;  # 在下方新建一个 pane
  prefix %  # 在右侧新建一个 pane
  prefix `方向键`  # 光标移动到指定方向的 pane 中

  # 使用方向键滚动窗口内容
  prefix [  # 进入翻页模式，可使用 page up/down，或者方向键来浏览 pane 的内容
  # 使用鼠标滚轮来滚动窗口内容（也可以把此命令添加到 `~/.tmux.conf` 中使它永久生效）
  prefix `:` 然后输入 `set-window-option -g mode-mouse on`

  # （调整 pane 大小）将当前的 pane 向给定的方向扩容 5 行或者 5 列
  # 按住 ALT 时快速重复敲击「方向键」，能快速调整，否则就得从 prefix 开始重新输入
  prefix `Alt` + `方向键`
  # 将当前窗格全屏显示，第二次使用此命令，会将窗格还原
  prefix z

  # 交换 pane 的位置
  prefix {  # 当前窗格与上一个窗格交换位置
  prefix }  # 当前窗格与下一个窗格交换位置

  # session 相关操作
  prefix s  # 查看 session 列表，并通过方向键选择 session
  prefix `number`  # 通过数字标签选择 session

  # window 相关操作（关系：每个 session 可以包含多个 window，每个 window 里面又可以有多个 pane）
  prefix c # 新建 window
  prefix w # 通过数字标签选择 window
</code></pre>
<h3 id="6-bash-shell-基础">6. Bash Shell 基础</h3>
<p>目标：能使用 shell 编写 10 行以内的脚本。更长的脚本可以使用 Python 编写，就没必要折腾 Shell 了。</p>
<h4 id="1-for-循环">1. For 循环</h4>
<p>单行 for 循环，有时候很有用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 数字枚举</span>
<span class="k">for</span> i in <span class="k">$(</span>seq <span class="m">1</span> 5<span class="k">)</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done</span>  <span class="c1"># sh/bash 都支持</span>
<span class="k">for</span> i in <span class="o">{</span>1..5<span class="o">}</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done</span>  <span class="c1"># sh 不支持此语法</span>


<span class="c1"># 文件枚举，可使用 glob 语法进行文件匹配</span>
<span class="k">for</span> f in *<span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="nv">$f</span><span class="p">;</span> <span class="k">done</span>
<span class="k">for</span> f in /etc/*.py<span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="nv">$f</span><span class="p">;</span> <span class="k">done</span>

<span class="c1"># 使用 find 进行文件枚举</span>
<span class="k">for</span> f in <span class="k">$(</span>find . -name *.py<span class="k">)</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="nv">$f</span><span class="p">;</span> <span class="k">done</span>
</code></pre></td></tr></table>
</div>
</div><p>单行 for 循环加几个换行就得到多行 for 循环，格式如下：写脚本用得到，不过更建议用 python:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="k">for</span> i in <span class="k">$(</span>seq <span class="m">1</span> 5<span class="k">)</span>
<span class="k">do</span> 
  <span class="nb">echo</span> <span class="nv">$i</span>
<span class="k">done</span>  <span class="c1"># sh/bash 都支持</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="2-if-语句">2. if 语句</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 单行 if 语句</span>
<span class="k">if</span> <span class="o">[</span> <span class="nb">true</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span> &lt;command&gt;<span class="p">;</span> <span class="k">fi</span>

<span class="c1">#  if else</span>
<span class="k">if</span> <span class="o">[</span> expression <span class="o">]</span>
<span class="k">then</span>
   Statement<span class="o">(</span>s<span class="o">)</span> to be executed <span class="k">if</span> expression is <span class="nb">true</span>
<span class="k">else</span>
   Statement<span class="o">(</span>s<span class="o">)</span> to be executed <span class="k">if</span> expression is not <span class="nb">true</span>
<span class="k">fi</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="3-shell脚本中的set指令比如set--x-和-set--e">3. Shell脚本中的set指令，比如set -x 和 set -e</h4>
<p>参见：<a href="https://www.cnblogs.com/robinunix/p/11635560.html" target="_blank" rel="noopener noreferrer">Shell脚本中的set指令，比如set -x 和 set -e</a></p>
<h4 id="4-其他资料">4. 其他资料</h4>
<ul>
<li><a href="https://github.com/mritd/shell_scripts" target="_blank" rel="noopener noreferrer">shell_scripts</a>: 实用 shell 小脚本</li>
</ul>
<h3 id="socket-commands">7. socket 连接查询 - ss/netcat/lsof</h3>
<p>查看 socket 信息可以帮我们回答下列问题：</p>
<ol>
<li>我的程序是不是真的在监听我指定的端口？</li>
<li>我的程序是在监听 127.0.0.1（本机），还是在监听 0.0.0.0（整个网络）</li>
<li>进程们分别在使用哪些端口？</li>
<li>我的连接数是否达到了上限？</li>
</ol>
<blockquote>
<p>现在较新版本的 Ubuntu 和 CentOS 都已经使用 <code>iproute2</code> 替换掉了 <code>net-tools</code>，
如果你还需要使用陈旧的 <code>route</code> <code>netstat</code> 等命令，需要手动安装 <code>net-tools</code>。</p>
</blockquote>
<p>我们可以使用 ss(socket statistics) 或者 netstat 命令来查看 socket 信息:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 查看 socket 连接的统计信息</span>
<span class="c1"># 主要统计处于各种状态的 tcp sockets 数量，以及其他 sockets 的统计信息</span>
ss --summary
ss -s  <span class="c1"># 缩写</span>

<span class="c1"># 查看哪个进程在监听 80 端口</span>
<span class="c1"># --listening 列出所有正在被监听的 socket</span>
<span class="c1"># --processes 显示出每个 socket 对应的 process 名称和 pid</span>
<span class="c1"># --numeric 直接打印数字端口号（不解析协议名称）</span>
ss --listening --processes --numeric <span class="p">|</span> grep <span class="m">80</span>
ss -nlp <span class="p">|</span> grep <span class="m">80</span>  <span class="c1"># 缩写</span>
ss -lp <span class="p">|</span> grep http  <span class="c1"># 解析协议名称，然后通过协议名搜索监听</span>

<span class="c1">## 使用过时的 netstat</span>
<span class="c1">### -t tcp</span>
<span class="c1">### -u udp</span>
netstat -tunlp <span class="p">|</span> grep <span class="s2">&#34;:80&#34;</span>

<span class="c1"># 查看 sshd 当前使用的端口号</span>
ss --listening --processes <span class="p">|</span> grep sshd
<span class="c1">## 使用过时的 netstat</span>
netstat -tunlp <span class="p">|</span> grep &lt;pid&gt;  <span class="c1"># pid 通过 ps 命令获得</span>

<span class="c1"># 列出所有的 tcp sockets，包括所有的 socket 状态</span>
ss --tcp --all

<span class="c1"># 只列出正在 listen 的 socket</span>
ss --listening

<span class="c1"># 列出所有 ESTABLISHED 的 socket（默认行为）</span>
ss

<span class="c1"># 统计 TCP 连接数</span>
ss <span class="p">|</span> grep ESTAB <span class="p">|</span> wc -l

<span class="c1"># 列出所有 ESTABLISHED 的 socket，并且给出连接的计时器</span>
ss --options

<span class="c1"># 查看所有来自 192.168.5 的 sockets</span>
ss dst 192.168.1.5

<span class="c1"># 查看本机与服务器 192.168.1.100 建立的 sockets</span>
ss src 192.168.1.5
</code></pre></td></tr></table>
</div>
</div><p>TCP 连接数受 Linux 文件描述符上限控制，可以通过如下方法查看已用文件句柄的数量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 已用文件描述符数量</span>
lsof <span class="p">|</span> wc -l
<span class="c1"># 文件描述符上限</span>
<span class="nb">ulimit</span> -n 
</code></pre></td></tr></table>
</div>
</div><h3 id="8-其他网络相关命令">8. 其他网络相关命令</h3>
<p>主要是 iproute2 dhclient lsof 等</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 查看路由表</span>
routel       <span class="c1"># 旧的 net-tools 包中的命令</span>
ip route ls  <span class="c1"># iproute2 提供的新命令</span>

<span class="c1"># DHCP，先释放旧租约，再建立新租约</span>
sudo dhclient -r eth0 <span class="o">&amp;&amp;</span> sudo dhclient eth0
<span class="c1"># 查看 DHCP 租期</span>
cat /var/lib/dhcp/dhcpd.leases

<span class="c1"># 清理 DNS 缓存</span>
<span class="c1">## 1. 如果你使用的是 systemd-resolve，使用此命令</span>
sudo systemd-resolve --flush-caches
sudo systemd-resolve --statistics  <span class="c1"># 查看缓存状态</span>
<span class="c1">## 2. 如果使用的是 dnsmasq，使用此命令</span>
sudo systemctl restart dnsmasq
sudo killall -HUP dnsmasq  <span class="c1"># 直接发送 HUP 信号也可以</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="9-容器网络诊断---nsenter">9. 容器网络诊断 - nsenter</h3>
<p>Docker 容器有自己的 namespace，直接通过宿主机的 ss 命令是查看不到容器的 socket 信息的。</p>
<p>比较直观的方法是直接通过 <code>docker exec</code> 在容器中通过 ss 命令。但是这要求容器中必须自带 ss 等程序，有的精简镜像可能不会自带它。</p>
<p>通过 <code>nsenter</code> 可以直接进入到容器的指定 namespace 中，这样就能直接查询容器网络相关的信息了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">docker ps <span class="p">|</span> grep xxx

<span class="nb">echo</span> <span class="nv">CONTAINER</span><span class="o">=</span>xxx  <span class="c1"># 容器名称或 ID</span>

<span class="c1"># 1. 查询到容器对应的 pid</span>
<span class="nv">PID</span><span class="o">=</span><span class="k">$(</span>docker inspect --format <span class="o">{{</span>.State.Pid<span class="o">}}</span> <span class="nv">$CONTAINER</span><span class="k">)</span>

<span class="c1"># 2. nsenter 通过 pid 进入容器的 network namespace，执行 ss 查看 socket 信息</span>
nsenter --target <span class="nv">$PID</span> --net ss -s
</code></pre></td></tr></table>
</div>
</div><p><code>nsenter</code> 这个工具貌似是 docker 自带的或者是系统内置命令，只要装了 docker，ubuntu/centos 都可以直接使用这个命令。</p>
<blockquote>
<p>nsenter 是一个进入名字空间的工具，功能不仅仅局限在「网络诊断」，还有更多用法。</p>
</blockquote>
<h2 id="二powershell">二、Powershell</h2>
<p>Powershell 是微软推出的一款新一代 shell，它的特点之一是，命令都有一致的命名规则：<strong>谓词-名词</strong>，
谓词表示动作：Get/Set/Stop/Start 等，名词指示操作对象：Service/Member/ChildItem/Command 等。</p>
<p>这样的命名格式使我们可以很容易地猜测到自己需要的命令的名称。</p>
<p>为了使用方便，powershell 还提供了一些常用命令的缩写，并且添加了大量类似 Linux 命令的别名。</p>
<p>还有就是，Windows 默认不区分字母大小写，日常使用可以全部小写。</p>
<h3 id="1-实用命令">1. 实用命令</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="c"># 删除文件/文件夹</span>
<span class="nb">remove-item</span> <span class="n">xxx</span>  <span class="n">-confirm</span>
<span class="nb">ri </span><span class="n">xxx</span>  <span class="c"># 别名1</span>
<span class="nb">rm </span><span class="n">xxx</span>  <span class="c"># 别名2</span>
<span class="nb">rmdir </span><span class="n">xxx</span>  <span class="c"># etc...</span>

<span class="c"># 复制</span>
<span class="nb">copy-item</span> <span class="n">xxx</span> <span class="n">xx</span> <span class="n">-r</span>
<span class="nb">cp </span><span class="n">-r</span> <span class="n">xxx</span> <span class="n">xx</span>

<span class="c"># 显示工作目录</span>
<span class="nb">get-location</span>
<span class="nb">gl
</span><span class="nb">pwd
</span><span class="nb"></span>
<span class="c"># 切换工作目录</span>
<span class="nb">set-location</span> <span class="n">xxx</span>
<span class="nb">sl </span><span class="n">xxx</span>
<span class="nb">cd </span><span class="n">xxx</span>

<span class="c"># 查看环境变量</span>
<span class="nb">get-childitem</span> <span class="n">env</span><span class="err">:</span>
<span class="nb">gci </span><span class="n">env</span><span class="err">:</span>
<span class="nb">gci </span><span class="n">env</span><span class="err">:</span><span class="n">PATH</span>  <span class="c"># 查看 PATH 变量</span>

<span class="nv">$env:XXX</span><span class="p">=</span><span class="s2">&#34;value&#34;</span>   <span class="c"># 临时设置环境变量</span>
<span class="nv">$env:Path</span> <span class="p">+=</span> <span class="s2">&#34;;SomeRandomPath&#34;</span>  <span class="c"># 临时在 Path 末尾添加新路径</span>
<span class="c">## 以下三行命令只对 windows 有效，linux 下无效</span>
<span class="no">[Environment]</span><span class="p">::</span><span class="n">SetEnvironmentVariable</span><span class="p">(</span><span class="s2">&#34;XXX&#34;</span><span class="p">,</span> <span class="nv">$env:XXX</span> <span class="p">+</span> <span class="s2">&#34;;value&#34;</span><span class="p">,</span> <span class="no">[EnvironmentVariableTarget]</span><span class="p">::</span><span class="n">User</span><span class="p">)</span>  <span class="c"># 修改当前用户的环境变量（永久），只对新进程有效</span>
<span class="no">[Environment]</span><span class="p">::</span><span class="n">SetEnvironmentVariable</span><span class="p">(</span><span class="s2">&#34;XXX&#34;</span><span class="p">,</span> <span class="s2">&#34;value&#34;</span><span class="p">,</span> <span class="no">[EnvironmentVariableTarget]</span><span class="p">::</span><span class="n">Machine</span><span class="p">)</span>  <span class="c"># 给这台电脑设置环境变量（永久），只对新进程有效，需要管理员权限</span>
<span class="no">[Environment]</span><span class="p">::</span><span class="n">SetEnvironmentVariable</span><span class="p">(</span><span class="s2">&#34;XXX&#34;</span><span class="p">,</span> <span class="nv">$env:XXX</span> <span class="p">+</span> <span class="s2">&#34;;value&#34;</span><span class="p">,</span> <span class="s2">&#34;User&#34;</span><span class="p">)</span>  <span class="c"># target 也可用字符串指定</span>

<span class="c"># 删除文件/文件夹</span>
<span class="nb">rm </span><span class="n">xxx</span>  <span class="c"># 删除文件夹时会进入交互界面，按提示输入就行。</span>

<span class="c"># 查看命名位置（类似 Linux Shell 的 which）</span>
<span class="nb">get-command</span> <span class="n">xxx</span>
<span class="nb">gcm </span><span class="n">xxx</span>

<span class="c"># 通过关键字查找 powershell 命令</span>
<span class="nb">gcm </span><span class="p">|</span> <span class="nb">select-string</span> <span class="p">&lt;</span><span class="n">keyword</span><span class="p">&gt;</span>

<span class="c"># 通过关键字查找 powershell 命令和环境变量中的程序，比较慢</span>
<span class="nb">gcm </span><span class="p">*</span> <span class="p">|</span> <span class="nb">select-string</span> <span class="p">&lt;</span><span class="n">keyword</span><span class="p">&gt;</span>

<span class="c"># 查看别名对应的真实命令</span>
<span class="nb">get-alias</span>

<span class="c"># 类似 linux 的 find/ls 命令</span>
<span class="nb">get-childitem</span> <span class="n">-Recurse</span> <span class="n">-Include</span> <span class="p">*.</span><span class="n">py</span>
<span class="nb">gci </span><span class="n">-r</span> <span class="n">-i</span> <span class="p">*.</span><span class="n">py</span>

<span class="c"># 清空终端的输出</span>
<span class="nb">clear-host</span>
<span class="nb">clear
</span><span class="nb"></span>
<span class="c"># 查看文件内容</span>
<span class="nb">get-content</span> <span class="n">xx</span><span class="p">.</span><span class="n">py</span> <span class="p">|</span> <span class="n">more</span>
<span class="nb">get-content</span> <span class="n">xx</span><span class="p">.</span><span class="n">py</span> <span class="p">|</span> <span class="nb">out-host</span> <span class="n">-paging</span>
<span class="nb">cat </span><span class="n">xx</span><span class="p">.</span><span class="n">py</span>
<span class="nb">gc </span><span class="n">xx</span><span class="p">.</span><span class="n">py</span>

<span class="c"># 字符串搜索，不能对对象使用</span>
<span class="c"># 类似 linux 的 grep 命令</span>
<span class="nb">cat </span><span class="n">xxx</span><span class="p">.</span><span class="n">log</span> <span class="p">|</span> <span class="nb">select-string</span> <span class="p">&lt;</span><span class="n">pattern</span><span class="p">&gt;</span>
<span class="nb">gci </span><span class="n">env</span><span class="err">:</span> <span class="p">|</span> <span class="nb">out-string</span>  <span class="n">-stream</span> <span class="p">|</span> <span class="nb">select-string</span> <span class="p">&lt;</span><span class="n">pattern</span><span class="p">&gt;</span>  <span class="c"># 需要先使用 out-string 将对象转换成 string</span>
<span class="nb">gci </span><span class="n">env</span><span class="err">:</span> <span class="p">|</span> <span class="nb">where-object</span> <span class="p">{</span><span class="nv">$_</span><span class="p">.</span><span class="n">Name</span> <span class="o">-like</span> <span class="p">&lt;</span><span class="n">pattern</span><span class="p">&gt;}</span>

<span class="c"># 计算输出的行数/对象个数</span>
<span class="nb">gci </span><span class="n">env</span><span class="err">:</span> <span class="p">|</span> <span class="nb">measure-object</span>
<span class="nb">gci </span><span class="n">env</span><span class="err">:</span> <span class="p">|</span> <span class="nb">measure </span> <span class="c"># 这是缩写</span>

<span class="c"># 关机/重启</span>
<span class="nb">stop-computer</span>
<span class="nb">restart-computer</span>

<span class="c"># windows 计算 hash 值</span>
<span class="c"># 功能等同于 linux 下的 sha256sum/sha1sum/sha512sum/md5sum</span>
<span class="nb">Get-FileHash</span> <span class="n">-Path</span> <span class="p">/</span><span class="n">path</span><span class="p">/</span><span class="n">to</span><span class="p">/</span><span class="n">file</span> <span class="n">-Algorithm</span> <span class="n">SHA256</span>
<span class="nb">Get-FileHash</span> <span class="n">-Path</span> <span class="p">/</span><span class="n">path</span><span class="p">/</span><span class="n">to</span><span class="p">/</span><span class="n">file</span> <span class="n">-Algorithm</span> <span class="n">SHA256</span>  <span class="p">|</span> <span class="nb">Format-List</span>  <span class="c"># 用 format 修改格式化效果</span>

<span class="c"># base64 编解码</span>
<span class="no">[Convert]</span><span class="p">::</span><span class="n">ToBase64String</span><span class="p">(</span><span class="no">[Text.Encoding]</span><span class="p">::</span><span class="n">UTF8</span><span class="p">.</span><span class="n">GetBytes</span><span class="p">(</span><span class="s2">&#34;xxx&#34;</span><span class="p">))</span>  <span class="c"># base64 编码</span>
<span class="no">[Text.Encoding]</span><span class="p">::</span><span class="n">UTF8</span><span class="p">.</span><span class="n">GetString</span><span class="p">(</span><span class="no">[Convert]</span><span class="p">::</span><span class="n">FromBase64String</span><span class="p">(</span><span class="s2">&#34;eHh4&#34;</span><span class="p">))</span>  <span class="c"># 解码</span>

</code></pre></td></tr></table>
</div>
</div><p>另外 windows 同样自带 ssh/scp 命令，参数也和 linux 一致</p>
<h3 id="2-进程相关命令">2. 进程相关命令</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="c"># 查看所有进程</span>
<span class="nb">get-process</span> <span class="p">|</span> <span class="n">more</span>
<span class="nb">ps </span><span class="p">|</span> <span class="n">more</span>  <span class="c"># 别名</span>

<span class="c"># 查找某进程（替代掉 tasklist）</span>
<span class="nb">get-process</span> <span class="n">-name</span> <span class="n">exp</span><span class="p">*,</span><span class="n">power</span><span class="p">*</span>  <span class="c"># 使用正则查找进程</span>
<span class="nb">get-process</span> <span class="p">|</span> <span class="nb">select-string</span> <span class="p">&lt;</span><span class="n">pattern</span><span class="p">&gt;</span>  <span class="c"># 效果同上</span>

<span class="c"># 通过 id 杀掉某进程（替代掉 taskkill）</span>
<span class="c"># 也可以通过 -Name 用正则匹配进程</span>
<span class="nb">stop-process</span> <span class="p">&lt;</span><span class="n">pid</span><span class="p">&gt;</span>
<span class="nb">kill </span><span class="p">&lt;</span><span class="n">pid</span><span class="p">&gt;</span>  <span class="c"># 别名</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="3-网络相关命令">3. 网络相关命令</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="c">## 1. dns 相关(dns-client)</span>
<span class="nb">Clear-DnsClientCache</span>  <span class="c"># 清除 dns 缓存（替换掉 `ipconfig /flushdns`）</span>
<span class="nb">Get-DnsClientCache</span>  <span class="c"># 查看 dns 缓存</span>
<span class="nb">Resolve-DnsName</span> <span class="n">baidu</span><span class="p">.</span><span class="n">com</span>  <span class="c"># 解析域名</span>

<span class="c"># 更新 DHCP 租约</span>
<span class="n">ipconfig</span> <span class="p">/</span><span class="n">renew</span>

<span class="c">## 2. TCP/IP 相关命令</span>
<span class="nb">Get-Command</span> <span class="nb">Get-Net</span><span class="p">*</span>  <span class="c"># 查看所有 TCP/IP 相关的命令</span>

<span class="nb">Get-NetIPAddress</span>  <span class="c"># 查看 IP 地址</span>
<span class="nb">Get-NetIPInterface</span>  <span class="c"># 查看 IP 接口</span>
<span class="nb">Get-NetRoute</span>        <span class="c"># 查看路由表</span>
<span class="nb">Get-NetNeighbor</span>     <span class="c"># 获取链路层 MAC 地址缓存</span>
<span class="nb">Get-NetTCPConnection</span>   <span class="c"># 查看 TCP 连接</span>
<span class="c">### 也可以对 TCP/IP 的 IP 地址、接口、路由表进行增删改</span>
<span class="nb">New-NetRoute</span>
<span class="nb">Remove-NetNeighbor</span>  <span class="c"># 清除 MAC 地址缓存</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="4-socket-信息查询---netstat">4. socket 信息查询 - netstat</h3>
<p>Windows 系统和 macOS 一样，也没有 <code>ss</code>，但是自带 <code>netstat</code>，该命令和 Linux 下的 <code>netstat</code> 有一定差别，具体使用方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="n">netstat</span> <span class="p">-?</span>  <span class="c"># 查看使用帮助，很清晰易懂</span>

<span class="c"># 查看那个进程在监听 80 端口，最后一列是进程的 Pid</span>
<span class="n">netstat</span> <span class="n">-ano</span> <span class="p">|</span> <span class="n">findstr</span> <span class="n">80</span>        <span class="c"># windows 命令</span>
<span class="n">netstat</span> <span class="n">-ano</span> <span class="p">|</span> <span class="nb">select-string</span> <span class="n">80</span>  <span class="c"># powershell 命令，就是把 findstr 替换成 select-string</span>

<span class="c"># 不仅列出 Pid，还给出 Pid 对应的可执行文件名称（需要管理员权限）</span>
<span class="n">netstat</span> <span class="n">-ano</span> <span class="n">-b</span> <span class="p">|</span> <span class="nb">select-string</span> <span class="n">80</span>  <span class="c"># powershell 命令</span>

<span class="c"># 列出所有 ESTABLISHED 的 socket（默认行为）</span>
<span class="n">netstat</span>

<span class="c"># 列出所有正在监听的端口</span>
<span class="n">netstat</span> <span class="n">-ano</span> <span class="p">|</span> <span class="n">findstr</span> <span class="n">LISTENING</span>

<span class="c"># 只列出 TCP 连接</span>
<span class="n">netstat</span> <span class="n">-ano</span> <span class="n">-p</span> <span class="n">TCP</span>


<span class="c"># 查看路由表</span>
<span class="n">route</span> <span class="p">-?</span>  <span class="c"># 查看使用帮助，很清晰易懂</span>
<span class="n">route</span> <span class="n">print</span>    <span class="c"># 查看所有路由信息</span>
<span class="n">route</span> <span class="n">print</span> <span class="p">-</span><span class="n">4</span>  <span class="c"># 仅 ipv4</span>
</code></pre></td></tr></table>
</div>
</div><p>比如我们遇到端口占用问题时，就可以通过上述命令查找到端口对应的 Pid，然后使用 <code>kill &lt;Pid&gt;</code> 命令（powershell <code>stop-process</code> 的别名）杀死对应的进程。</p>
<h2 id="三mac-os-x">三、Mac OS X</h2>
<p>Mac OS X 系统也是 unix-like 系统，也使用 zsh/bash，因此大部分命令基本都跟 Linux 没啥区别，可以直接参考前面 Linux 一节的内容。</p>
<p>但是要注意一些坑：</p>
<ul>
<li>macos 自带的 tar 并不是 gnutar，命令使用方式不一样！
<ul>
<li>解决：<code>brew install gnu-tar</code>，安装好后通过 <code>gtar</code> 调用，参数就跟 linux 一致了。</li>
</ul>
</li>
<li>网络相关的命令区别较大，后面会详细介绍。</li>
<li>MacOSX 使用 launchpad 作为系统服务管理器，跟 systemd 区别很大。</li>
</ul>
<h3 id="1-查看-socket-信息">1. 查看 socket 信息</h3>
<p>Mac OS X 系统目前没有 <code>ss</code>，但是自带 <code>netstat</code>，该命令和 Linux 下的 <code>netstat</code> 有一定差别，而且还很慢，还不能显示 pid.</p>
<p>所以 stackoverflow 上更推荐使用 <code>lsof</code>，几条常用命令记录如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># -n 表示不显示主机名</span>
<span class="c1"># -P 表示不显示端口俗称</span>
<span class="c1"># 不加 sudo 只能查看以当前用户运行的程序</span>
<span class="c1"># 通用格式：</span>
sudo lsof -nP -iTCP:端口号 -sTCP:LISTEN

<span class="c1"># 查看所有 tcp 连接</span>
lsof -nP -iTCP

<span class="c1"># 查看所有监听端口相关的信息（command/pid）</span>
lsof -nP -iTCP -sTCP:LISTEN
</code></pre></td></tr></table>
</div>
</div><h3 id="2-其他网络相关命令">2. 其他网络相关命令</h3>
<p>清理 DNS 缓存：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># macos 10.10+</span>
sudo dscacheutil -flushcache
sudo killall -HUP mDNSResponder

<span class="c1"># 其他版本请自己网上搜...</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 查看所有网络接口及相关参数（ip/mac/type...）</span>
ifconfig

<span class="c1"># 查看路由表</span>
netstat -nr
</code></pre></td></tr></table>
</div>
</div><h2 id="四跨平台程序">四、跨平台程序</h2>
<h3 id="1-vim">1. vim</h3>
<h4 id="常用技巧">常用技巧</h4>
<p>移动：</p>
<ul>
<li><code>0</code>/<code>^</code> 回到行首，<code>$</code> 去到行末</li>
<li>w 跳到下个单词的首部，e 跳到下个单词末尾
<ul>
<li>也能使用 2w 2e 这种命令按单词数量跳转</li>
</ul>
</li>
</ul>
<p>删除 <code>d</code> 或修改 <code>c</code>:</p>
<ul>
<li>dw 删除单词，d2w 删除两个单词</li>
<li>d$ 删除到行末，<code>d0</code>/<code>d^</code> 删除到行首</li>
<li><code>d(</code>/<code>d{</code>/<code>d[[</code> 删除到文件首部，<code>d)</code>/<code>d}</code>/<code>d]]</code> 删除到文件末尾</li>
<li><code>r</code> 替换一个字符，<code>R</code> 持续往后替换</li>
</ul>
<h4 id="多行修改">多行修改</h4>
<p>多行插入，主要用于加注释之类的：</p>
<ul>
<li>光标停留在你需要插入文本的地方</li>
<li><code>ctrl</code>+<code>v</code> 进入 visual block 模式，选中多行</li>
<li>输入 <code>I</code>，进入编辑模式</li>
<li>输入 <code>#</code> 注释或者其他字符，但是注意不能输入换行符！也不能删除？</li>
<li>按两下 <code>Esc</code>，依次退出 Insert 和 visual block 模式，就插入成功了</li>
</ul>
<p>多行删除：</p>
<ul>
<li><code>v</code> 进入 visual 模式，在第一行，选中你想要删除的文本块
<ul>
<li>或者也可以先进入 visual block 模式，再通过左右方向键选择文本。</li>
</ul>
</li>
<li><code>ctrl</code>+<code>v</code> 进入 visual block 模式，选中多行
<ul>
<li>visual block 的特点是它是垂直选择，而 visual 模式是段落选择</li>
</ul>
</li>
<li>按 <code>d</code> 键就能删除被选中的所有内容。</li>
</ul>
<h4 id="多行替换基本和-sed-一致">多行替换（基本和 sed 一致）</h4>
<p>多行行首插入注释符号 <code>#</code></p>
<pre><code>  :1,6 s/^/#/g
  :2,$ s/^/#/g   注：此为2行至尾行
  :% s/^/#/g     注：此为所有行
</code></pre>
<p>这里使用了正则表达式 <code>^</code> 匹配行首，改成 <code>$</code> 就可在行尾进行批量修改。</p>
<p>此外，它的分隔符也不仅限于 <code>\</code>，也可以用 <code>@</code> 等符号，方便阅读。比如：</p>
<pre><code>  :1,6 s@^@#@g
  :2,$ s@^@#@g   注：此为2行至尾行
  :% s@^@#@g     注：此为所有行
</code></pre>
<p>使用 vim 的这个正则匹配功能，不仅能进行插入，也能完成删除、替换的功能。</p>
<h4 id="将选中部分写入到文件">将选中部分写入到文件</h4>
<ul>
<li>首先按 <code>v</code> 进入 visual 模式，选中需要的内容</li>
<li>按 <code>:</code>，应该会显示 <code>:'&lt;,'&gt;</code>，表示对选中部分进行操作</li>
<li>输入内容 <code>w new.txt</code>，此时显示效果应该是 <code>:'&lt;,'&gt;w new.txt</code></li>
<li>回车就能完成文件写入</li>
</ul>
<h4 id="问题在-vim-中粘贴-yaml-时缩进会变得一团糟">问题：在 vim 中粘贴 yaml 时缩进会变得一团糟</h4>
<p>解决方法：在命令模式下输入 <code>:set paste</code> 进入粘贴模式，然后再粘贴 yaml 内容。</p>
<p>注意行首可能会丢失几个字符，需要手动补上。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/45920111" target="_blank" rel="noopener noreferrer">如何在 Linux 中查看进程占用的端口号</a></li>
<li><a href="https://github.com/jpetazzo/nsenter#how-do-i-use-nsenter" target="_blank" rel="noopener noreferrer">github - nsenter</a></li>
<li><a href="https://tonydeng.github.io/2016/07/07/use-lsof-to-replace-netstat/" target="_blank" rel="noopener noreferrer">使用 lsof 代替 Mac OS X 中的 netstat 查看占用端口的程序</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/81123584" target="_blank" rel="noopener noreferrer">aws 常用命令</a></li>
</ul>
]]></description></item></channel></rss>