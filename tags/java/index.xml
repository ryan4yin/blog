<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>Java - 标签 - This Cute World</title><link>https://thiscute.world/tags/java/</link><description>Java - 标签 - This Cute World</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 11 Mar 2018 16:39:00 +0800</lastBuildDate><atom:link href="https://thiscute.world/tags/java/" rel="self" type="application/rss+xml"/><item><title>Java 中文编码分析</title><link>https://thiscute.world/posts/how-java-handles-chinese/</link><pubDate>Sun, 11 Mar 2018 16:39:00 +0800</pubDate><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/how-java-handles-chinese/</guid><description><![CDATA[<h3 id="一charat-与-codeponitat">一、charAt 与 codePonitAt</h3>
<p>我们知道 Java 内部使用的是 utf-16 作为它的 char、String 的字符编码方式，这里我们叫它内部字符集。而 utf-16 是变长编码，一个字符的编码被称为一个 code point，它可能是 16 位 —— 一个 code unit，也可能是 32 位 —— 两个 code unit。
Java 的 char 类型长度为二字节，它对应的是 code unit。换句话说，一个字符的编码，可能需要用两个 char 来存储。</p>
<p>作为一个输入法爱好者，我偶尔会编程处理一些生僻字。其中有些生僻字大概是后来才加入 unicode 字符集里的，直接用 charAt 方法读取它们，会得到一堆问号。原因很清楚 —— 因为这些字符（eg. &ldquo;𫖯&rdquo;）是用两个 code unit，也就是两个 char 表示的。charAt 找不到对应的编码，就会将这些 char 输出成「?」。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">//示例
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;𫖯&#34;</span><span class="o">;</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>   <span class="c1">//输出：2
</span><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">0</span><span class="o">));</span>  <span class="c1">//输出：?
</span><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">1</span><span class="o">));</span>  <span class="c1">//输出：?
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><p>因此，涉及到中文，一定要使用 String 而不是 char，并且使用 codePoint 相关方法来处理它。否则的话，如果用户使用了生僻字，很可能就会得到不想要的结果。</p>
<p>下面是一个使用 codePoint 遍历一个字符串的示例，需要注意的是，codePoint 是 int 类型的（因为 char 不足以保存一个 codepoint），因此需要做些额外的转换：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>

        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;赵孟𫖯孟&#34;</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">codePointCount</span><span class="o">(</span><span class="n">0</span><span class="o">,</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">());</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
                    <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">Character</span><span class="o">.</span><span class="na">toChars</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">codePointAt</span><span class="o">(</span><span class="n">i</span><span class="o">))));</span>
                    <span class="c1">// 这里的轨迹是：类型为 int 的 codepoint -&gt; char数组 -&gt; String 
</span><span class="c1"></span>        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/* 结果：
</span><span class="cm">        赵
</span><span class="cm">        孟
</span><span class="cm">        𫖯
</span><span class="cm">        ?
</span><span class="cm">*/</span>
</code></pre></td></tr></table>
</div>
</div><p>问题来了，「𫖯」这个字是正常地输出了，可最后的「孟」却变成了黑人问号。。
原因就在于 codepointAt(i) 是以 char 偏移量索引的。。所以只是这样输出也是不行的。。</p>
<p>正确的遍历姿势是这样的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">;</span> <span class="o">)</span> <span class="o">{</span>
   <span class="kd">final</span> <span class="kt">int</span> <span class="n">codepoint</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">codePointAt</span><span class="o">(</span><span class="n">offset</span><span class="o">);</span>

   <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">Character</span><span class="o">.</span><span class="na">toChars</span><span class="o">(</span><span class="n">codepoint</span><span class="o">)));</span>

   <span class="n">offset</span> <span class="o">+=</span> <span class="n">Character</span><span class="o">.</span><span class="na">charCount</span><span class="o">(</span><span class="n">codepoint</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个代码保持了一个变量offset, 来指示下一个 codepoint 的偏移量。最后那一句在处理完毕后，更新这个偏移量</p>
<p>而 Java 8 添加了 <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/CharSequence.html#codePoints--" target="_blank" rel="noopener noreferrer"><code>CharSequence#codePoints</code></a>， 该方法返回一个 <code>IntStream</code>，该流包含所有的 codepoint。可以直接通过 forEach 方法来遍历他。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">string</span><span class="o">.</span><span class="na">codePoints</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span>
        <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">Character</span><span class="o">.</span><span class="na">toChars</span><span class="o">(</span><span class="n">c</span><span class="o">)));</span>
<span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><p>或者用循环</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">:</span> <span class="n">string</span><span class="o">.</span><span class="na">codePoints</span><span class="o">().</span><span class="na">toArray</span><span class="o">()){</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">Character</span><span class="o">.</span><span class="na">toChars</span><span class="o">(</span><span class="n">c</span><span class="o">)));</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="二内部字符集与输出字符集内码与外码">二、内部字符集与输出字符集（内码与外码）</h3>
<p>现在我们知道了中文字符在 java 内部可能会保存成两个 char，可还有个问题：如果我把一个字符输出到某个流，它还会是两个 char，也就是 4 字节么？
回想一下，Java io 有字符流，字符流使用 jvm 默认的字符集输出，而若要指定字符集，可使用转换流。
因此，一个中文字符，在内部是使用 utf-16 表示，可输出就不一定了。
来看个示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.io.UnsupportedEncodingException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="n">UnsupportedEncodingException</span> <span class="o">{</span>

        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;中&#34;</span><span class="o">;</span>   <span class="c1">//𫖯
</span><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">&#34;: chars: &#34;</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">&#34;: utf-8 bytes:&#34;</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">&#34;utf-8&#34;</span><span class="o">).</span><span class="na">length</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">&#34;: unicode bytes: &#34;</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">&#34;unicode&#34;</span><span class="o">).</span><span class="na">length</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">&#34;: utf-16 bytes: &#34;</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">&#34;utf-16&#34;</span><span class="o">).</span><span class="na">length</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>输出为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">中: chars: 1      // 2 bytes 
中: utf-8 bytes:3
中: unicode bytes: 4
中: utf-16 bytes: 4


𫖯: chars: 2       // 4 bytes
𫖯: utf-8 bytes:4
𫖯: unicode bytes: 6
𫖯: utf-16 bytes: 6
</code></pre></td></tr></table>
</div>
</div><p>一个「中」字，内部存储只用了一个 char，也就是 2 个字节。可转换成 utf-8 编码后，却用了 3 个字节。怎么会不一样呢，是不是程序出了问题？
当然不是程序的问题，这是内码(utf-16)转换成外码(utf-8)，字符集发生了改变，所使用的字节数自然也可能会改变。（尤其这俩字符集还都是变长编码）</p>
<h3 id="三utf-16utf-16leutf-16bebom">三、utf-16、utf-16le、utf-16be、bom</h3>
<p>不知道在刚刚的示例中，你有没有发现问题：同是 utf-16，为何「中」和「𫖯」的 <code>s.getBytes(&quot;utf-16&quot;).length</code> 比  <code>s.length</code> 要多个 2？开头就说了 String 也是 <code>utf-16</code> 编码的，这两个数应该相等才对不是吗？
原因在于，utf-16 以 16 位为单位表示数据，而计算机是以字节为基本单位来存储/读取数据的。因此一个 utf-16 的 code unit 会被存储为两个字节，需要明确指明这两个字节的先后顺序，计算机才能正确地找出它对应的字符。而 utf-16 本身并没有指定这些，所以它会在字符串开头插入一个两字节的数据，来存储这些信息（大端还是小端）。这两个字节被称为BOM（Byte Order Mark）。刚刚发现的多出的两字节就是这么来的。
如果你指定编码为 utf-16le 或 utf-16be，就不会有这个 BOM 的存在了。这时就需要你自己记住该文件的大小端。。</p>
<h3 id="四更多utf-8-unicode">四、更多：utf-8 unicode</h3>
<ol>
<li>在 windows 中，utf-8 格式的文件也可能会带有 BOM，但 utf-8 的基本单位本来就是一个字节，因此它不需要 BOM 来表示 所谓大小端。这个 BOM 一般是用来表示该文件是一个 utf-8 文件。不过 linux 系统则对这种带 BOM 的文件不太友好。不般不建议加。。（虽如此说，上面的测试中，utf-8 的数据应该是没加 bom 的结果）</li>
<li>unicode字符集UCS（Unicode Character Set） 就是一张包含全世界所有文字的一个编码表，但是 UCS 太占内存了，所以实际使用基本都是使用它的其他变体。一般来说，指定字符集时使用的 unicode 基本等同于 utf-16.（所以你会发现第二节演示的小程序里，utf-16 和 unicode 得出的结果是一样的。）</li>
</ol>
<h3 id="四与-python3-对比">四、与 Python3 对比</h3>
<p>python3 在字符串表示上，做了大刀阔斧的改革，python3 的 len(str) 得到的就是 unicode 字符数，因此程序员完全不需要去考虑字符的底层表示的问题。（实际上其内部表示也可能随着更新而变化）带 BOM 的 utf-8 也可通过指定字符集为 <code>utf-8-sig</code> 解决。若需要做字符集层面处理，需要 encode 为特定字符集的 byte 类型。</p>
<blockquote>
<p>Encoding pertains mostly to files and transfers. Once
loaded into a Python string, text in memory has no notion of an “encoding,” and is
simply a sequence of Unicode characters (a.k.a. code points) stored generically.
&ndash; Learning Python 5th</p>
</blockquote>
<blockquote>
<p>P.S. Python2 存在和 Java 相同的问题</p>
</blockquote>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://www.zhihu.com/question/27562173/answer/37188642" target="_blank" rel="noopener noreferrer">java 语言中的一个字符占几个字节？ - RednaxelaFX - 知乎</a></li>
<li><a href="https://stackoverflow.com/questions/1527856/how-can-i-iterate-through-the-unicode-codepoints-of-a-java-string" target="_blank" rel="noopener noreferrer">How can I iterate through the unicode codepoints of a Java String?</a></li>
<li><a href="http://blog.csdn.net/softman11/article/details/6124345" target="_blank" rel="noopener noreferrer">彻底搞懂字符编码(unicode,mbcs,utf-8,utf-16,utf-32,big endian,little endian&hellip;)</a></li>
<li><a href="http://blog.csdn.net/tianjf0514/article/details/7854624" target="_blank" rel="noopener noreferrer">Java_字符编码</a></li>
</ul>
<p>本文允许转载，但要求附上源链接：<a href="http://www.cnblogs.com/kirito-c/p/8544408.html" target="_blank" rel="noopener noreferrer">Java 中文编码分析</a></p>
]]></description></item></channel></rss>