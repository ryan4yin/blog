<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>Python - 标签 - This Cute World</title><link>https://thiscute.world/tags/python/</link><description>Python - 标签 - This Cute World</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaoyin_c@qq.com (ryan4yin)</managingEditor><webMaster>xiaoyin_c@qq.com (ryan4yin)</webMaster><lastBuildDate>Tue, 21 May 2019 22:19:00 +0800</lastBuildDate><atom:link href="https://thiscute.world/tags/python/" rel="self" type="application/rss+xml"/><item><title>SQLAlchemy 学习笔记（三）：ORM 中的关系构建</title><link>https://thiscute.world/posts/sqlalchemy-notes-3-relationship-and-foreignkey/</link><pubDate>Tue, 21 May 2019 22:19:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/sqlalchemy-notes-3-relationship-and-foreignkey/</guid><description><![CDATA[<blockquote>
<p>个人笔记，不保证正确。</p>
</blockquote>
<h2 id="一关系构建foreignkey-与-relationship">一、关系构建：<code>ForeignKey</code> 与 <code>relationship</code></h2>
<p>关系构建的重点，在于搞清楚这两个函数的用法。<code>ForeignKey</code> 的用法已经在 <a href="https://www.cnblogs.com/kirito-c/p/10269485.html#%E8%A1%A8%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%BA%A6%E6%9D%9F" target="_blank" rel="noopener noreferrer">SQL表达式语言 - 表定义中的约束</a> 讲过了。主要是 <code>ondelete</code> 和 <code>onupdate</code> 两个参数的用法。</p>
<h2 id="二relationship">二、<code>relationship</code></h2>
<p><code>relationship</code> 函数在 ORM 中用于构建表之间的关联关系。与 <code>ForeignKey</code> 不同的是，它定义的关系不属于表定义，而是动态计算的。
用它定义出来的属性，相当于 SQL 中的视图。</p>
<p>这个函数有点难用，一是因为它的有几个参数不太好理解，二是因为它的参数非常丰富，让人望而却步。下面通过<strong>一对多</strong>、<strong>多对一</strong>、<strong>多对多</strong>几个场景下 <code>relationship</code> 的使用，来一步步熟悉它的用法。</p>
<p>首先初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">relationship</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="kn">import</span> <span class="n">declarative_base</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="1-一对多">1. 一对多</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># 因为 Child 中有 Parent 的 ForeignKey，这边的声明不需要再额外指定什么。</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">)</span>  <span class="c1"># children 的集合，相当于一个视图。</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;child&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;parent.id&#39;</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>一个 <code>Parent</code> 可以有多个 <code>Children</code>，通过 <code>relationship</code>，我们就能直接通过 <code>parent.children</code> 得到结果，免去繁琐的 query 语句。</p>
<h4 id="11-反向引用">1.1 反向引用</h4>
<h5 id="111-backref-与-back_populates">1.1.1 <code>backref</code> 与 <code>back_populates</code></h5>
<p>那如果我们需要得知 <code>child</code> 的 <code>parent</code> 对象呢？能不能直接访问 <code>child.parent</code>？</p>
<p>为了实现这个功能，SQLAlchemy 提供了 <code>backref</code> 和 <code>back_populates</code> 两个参数。</p>
<p>两个参数的效果完全一致，区别在于，<code>backref</code> 只需要在 <code>Parent</code> 类中声明 <code>children</code>，<code>Child.parent</code> 会被动态创建。</p>
<p>而 <code>back_populates</code> 必须在两个类中显式地使用 <code>back_populates</code>，更显繁琐。（但是也更清晰？）</p>
<p>先看 <code>backref</code> 版：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">,</span>
                            <span class="n">backref</span><span class="o">=</span><span class="s2">&#34;parent&#34;</span><span class="p">)</span>  <span class="c1"># backref 表示，在 Child 类中动态创建 parent 属性，指向当前类。</span>

<span class="c1"># Child 类不需要修改</span>
</code></pre></td></tr></table>
</div>
</div><p>再看 <code>back_populates</code> 版：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&#34;parent&#34;</span><span class="p">)</span>  <span class="c1"># back_populates </span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;child&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;parent.id&#39;</span><span class="p">))</span>

    <span class="c1"># 这边也必须声明，不能省略！</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Parent&#34;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&#34;children&#34;</span><span class="p">)</span>  <span class="c1"># parent 不是集合，是属性！</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>NOTE：声明的两个 <code>relationship</code> 不需要多余的说明，SQLAlchemy 能自动识别到 <code>parent.children</code> 是 collection，<code>child.parent</code> 是 attribute.</strong></p>
<h4 id="112-反向引用的参数sqlalchemyormbackrefname-kwargs">1.1.2. 反向引用的参数：<code>sqlalchemy.orm.backref(name, **kwargs)</code></h4>
<p>使用 <code>back_populates</code> 时，我们可以很方便地在两个 <code>relationship</code> 函数中指定各种参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&#34;parent&#34;</span><span class="p">,</span> 
                                        <span class="n">lazy</span><span class="o">=</span><span class="s1">&#39;dynamic&#39;</span><span class="p">)</span>  <span class="c1"># 指定 lazy 的值</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;child&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;parent.id&#39;</span><span class="p">))</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Parent&#34;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&#34;children&#34;</span><span class="p">,</span> 
                                      <span class="n">lazy</span><span class="o">=</span><span class="s1">&#39;dynamic&#39;</span><span class="p">)</span>  <span class="c1"># 指定 lazy 的值</span>
</code></pre></td></tr></table>
</div>
</div><p>但是如果使用 <code>backref</code>，因为我们只有一个 <code>relationship</code> 函数，<code>Child.parent</code> 是被隐式创建的，我们该如何指定这个属性的参数呢？</p>
<p>答案就是 <code>backref()</code> 函数，使用它替代 <code>backref</code> 参数的值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">backref</span>

<span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">,</span>
                            <span class="n">backref</span><span class="o">=</span><span class="n">backref</span><span class="p">(</span><span class="s2">&#34;parent&#34;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="s1">&#39;dynamic&#39;</span><span class="p">))</span>  <span class="c1"># 使用 backref() 函数，指定 Child.parent 属性的参数</span>

<span class="c1"># Child 类不需要修改</span>
</code></pre></td></tr></table>
</div>
</div><p><code>backref()</code> 的参数会被传递给 <code>relationship()</code>，因此它俩的参数也完全一致。</p>
<h3 id="2-多对一">2. 多对一</h3>
<p>A many-to-one is similar to a one-to-many relationship. The difference is that this relationship is looked at from the &ldquo;many&rdquo; side.</p>
<h3 id="3-一对一">3. 一对一</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">child</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">,</span> 
                                    <span class="n">uselist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>   <span class="c1"># 不使用 collection！这是关键</span>
                                    <span class="n">back_populates</span><span class="o">=</span><span class="s2">&#34;parent&#34;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;child&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;parent.id&#39;</span><span class="p">))</span>

     <span class="c1"># 包含 ForeignKey 的类，此属性默认为 attribute，因此不需要 uselist=False</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Parent&#34;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&#34;child&#34;</span><span class="p">)</span> 
</code></pre></td></tr></table>
</div>
</div><h3 id="4-多对多">4. 多对多</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 多对多，必须要使用一个关联表！</span>
<span class="n">association_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;association&#39;</span><span class="p">,</span> <span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;left_id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;left.id&#39;</span><span class="p">)),</span>  <span class="c1"># 约定俗成的规矩，左边是 parent</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;right_id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;right.id&#39;</span><span class="p">))</span>  <span class="c1"># 右边是 child</span>
<span class="p">)</span>

<span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">,</span>
                    <span class="n">secondary</span><span class="o">=</span><span class="n">association_table</span><span class="p">)</span>  <span class="c1"># 专用参数 secondary，用于指定使用的关联表</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>要添加反向引用时，同样可以使用 <code>backref</code> 或 <code>back_populates</code>.</p>
<h4 id="41-user2user">4.1 user2user</h4>
<p>如果多对多关系中的两边都是 user，即都是同一个表时，该怎么声明？</p>
<p>例如用户的「关注」与「粉丝」，你是 user，你的粉丝是 user，你关注的账号也是 user。</p>
<p>这个时候，关联表 <code>association_table</code> 的两个键都是 <code>user</code>，<strong>SQLAlchemy 无法区分主次，需要手动指定</strong>，为此需要使用 <code>primaryjoin</code> 和 <code>secondaryjoin</code> 两个参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 关联表，左侧的 user 正在关注右侧的 user</span>
<span class="n">followers</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s1">&#39;followers&#39;</span><span class="p">,</span>
    <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="s1">&#39;follower_id&#39;</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;user.id&#39;</span><span class="p">)),</span>  <span class="c1"># 左侧</span>
    <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="s1">&#39;followed_id&#39;</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;user.id&#39;</span><span class="p">))</span>  <span class="c1"># 右侧，被关注的 user</span>
<span class="p">)</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">UserMixin</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="mi">120</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">password_hash</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># 我关注的 users</span>
    <span class="n">followed</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">relationship</span><span class="p">(</span>
        <span class="s1">&#39;User&#39;</span><span class="p">,</span>
        <span class="n">secondary</span><span class="o">=</span><span class="n">followers</span><span class="p">,</span>  <span class="c1"># 指定多对多关联表</span>
        <span class="n">primaryjoin</span><span class="o">=</span><span class="p">(</span><span class="n">followers</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">follower_id</span> <span class="o">==</span> <span class="nb">id</span><span class="p">),</span>  <span class="c1"># 左侧，用于获取「我关注的 users」的 join 条件</span>
        <span class="n">secondaryjoin</span><span class="o">=</span><span class="p">(</span><span class="n">followers</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">followed_id</span> <span class="o">==</span> <span class="nb">id</span><span class="p">),</span>  <span class="c1"># 右侧，用于获取「我的粉丝」的 join 条件</span>
        <span class="n">lazy</span><span class="o">=</span><span class="s1">&#39;dynamic&#39;</span><span class="p">,</span>  <span class="c1"># 延迟求值，这样才能用 filter_by 等过滤函数</span>
        <span class="n">backref</span><span class="o">=</span><span class="n">db</span><span class="o">.</span><span class="n">backref</span><span class="p">(</span><span class="s1">&#39;followers&#39;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="s1">&#39;dynamic&#39;</span><span class="p">))</span>  <span class="c1"># followers 也要延迟求值</span>
</code></pre></td></tr></table>
</div>
</div><p>这里比较绕的，就是容易搞混 <code>primaryjoin</code> 和 <code>secondaryjoin</code> 两个参数。</p>
<ol>
<li>primaryjoin：（多对多中）用于从子对象查询其父对象的 condition（child.parents），默认只考虑外键。</li>
<li>secondaryjoin：（多对多中）用于从父对象查询其所有子对象的 condition（parent.children），同样的，默认情况下只考虑外键。</li>
</ol>
<h2 id="三orm-层-的-delete-cascade-vs-foreign-key-层的-on-delete-cascade">三、ORM 层 的 “delete” cascade vs. FOREIGN KEY 层的 “ON DELETE” cascade</h2>
<p>之前有讲过 Table 定义中的级联操作：<code>ON DELETE</code> 和 <code>ON UPDATE</code>，可以通过 <code>ForeignKey</code> 的参数指定为 <code>CASCADE</code>.</p>
<p>可 SQLAlchemy 还有一个 <code>relationship</code> 生成 SQL 语句时的配置参数 <code>cascade</code>，另外 <code>passive_deletes</code> 也可以指定为 <code>cascade</code>。</p>
<p>有这么多的 cascade，我真的是很懵。这三个 cascade 到底有何差别呢？</p>
<p>外键约束中的 <code>ON DELETE</code> 和 <code>ON UPDATE</code>，与 ORM 层的 <code>CASCADE</code> 在功能上，确实有很多重叠的地方。
但是也有很多不同：</p>
<ol>
<li>数据库层面的 <code>ON DELETE</code> 级联能高效地处理 <strong>many-to-one</strong> 的关联；我们在 <code>many</code> 方定义外键，也在这里添加 <code>ON DELETE</code> 约束。而在 ORM 层，就<strong>刚好相反</strong>。SQLAlchemy 在 <code>one</code> 方处理 <code>many</code> 方的删除操作，这意味着它更适合处理 <strong>one-to-many</strong> 的关联。</li>
<li>数据库层面上，不带 <code>ON DELETE</code> 的外键常用于防止父数据被删除，而导致子数据成为无法被索引到的垃圾数据。如果要在一个 one-to-many 映射上实现这个行为，SQLAlchemy 将外键设置为 NULL 的默认行为可以通过以下两种方式之一捕获：
<ol>
<li>最简单也最常用的方法，当然是将外键定义为 <strong>NOT NULL</strong>. 尝试将该列设为 NULL 会触发 NOT NULL constraint exception.</li>
<li>另一种更特殊的方法，是将 <code>passive_deletes</code> 标志设置为字 <code>all</code>. 这会完全禁用 SQLAlchemy 将外键列设置为 NULL 的行为，并且 DELETE 父数据而不会对子数据产生任何影响。这样才能触发数据库层面的 <code>ON DELETE</code> 约束，或者其他的触发器。</li>
<li>数据库层面的 <code>ON DELETE</code> 级联 比 ORM 层面的级联更高效。数据库可以同时在多个 relationship 中链接一系列级联操作。</li>
<li>SQLAlchemy 不需要这么复杂，因为我们通过将 passive_deletes 选项与正确配置的外键约束结合使用，提供与数据库的 <code>ON DELETE</code> 功能的平滑集成。</li>
</ol>
</li>
</ol>
<h3 id="方法一orm-层的-cascade-实现">方法一：ORM 层的 cascade 实现</h3>
<p><code>relationship</code> 的 <code>cascade</code> 参数决定了修改父表时，什么时候子表要进行级联操作。它的可选项有（str，选项之间用逗号分隔）：</p>
<ol>
<li><code>save-update</code>：默认选项之一。在 add（对应 SQL 的 insert 或 update）一个对象的时候，会 add 所有它相关联的对象。</li>
<li><code>merge</code>：默认选项之一。在 merge（相当字典的update操作，有就替换掉，没有就合并）一个对象的时候，会 merge 所有和它相关联的对象。</li>
<li><code>expunge</code> ：移除操作的时候，会将相关联的对象也进行移除。这个操作只是从session中移除，并不会真正的从数据库中删除。</li>
<li><code>delete</code>：删除父表数据时，同时删除与它关联的数据。</li>
<li><code>delete-orphan</code>：当子对象与父对象解除关系时，删除掉此子对象（孤儿）。（其实还是没懂。。）</li>
<li><code>refresh-expire</code>：不常用。</li>
<li><code>all</code>：表示选中除 <code>delete-orphan</code> 之外的所有选项。（因此 <code>all, delete-orphan</code> 很常用，它才是真正的 <code>all</code>）</li>
</ol>
<p>默认属性是 &ldquo;save-update, merge&rdquo;.</p>
<p>这只是简略的说明，上述几个参数的详细文档见 <a href="https://docs.sqlalchemy.org/en/13/orm/cascades.html#unitofwork-cascades" target="_blank" rel="noopener noreferrer">SQLAlchemy - Cascades</a></p>
<h3 id="方法二数据库层的-cascade-实现">方法二：数据库层的 cascade 实现</h3>
<ol>
<li>将 <code>ForeignKey</code> 的 <code>ondelete</code> 和 <code>onupdate</code> 参数指定为 <code>CASCADE</code>，实现数据库层面的级联。</li>
<li>为 <code>relationship</code> 添加关键字参数 <code>passive_deletes=&quot;all&quot;</code>，这样就完全禁用 SQLAlchemy 将外键列设置为 NULL 的行为，并且 DELETE 父数据不会对子数据产生任何影响。</li>
</ol>
<p>这样 DELETE 操作时，就会触发数据库的 <code>ON DELETE</code> 约束，从而级联删除子数据。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://docs.sqlalchemy.org/en/13/orm/relationships.html" target="_blank" rel="noopener noreferrer">SQLAlchemy - Relationship Configuration</a></li>
<li><a href="https://docs.sqlalchemy.org/en/13/orm/cascades.html#unitofwork-cascades" target="_blank" rel="noopener noreferrer">SQLAlchemy - Cascades</a></li>
<li><a href="https://ia.jifangcheng.com/p/46" target="_blank" rel="noopener noreferrer">SQLAlchemy 中的 backref 和 back_populates</a></li>
<li><a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-viii-followers" target="_blank" rel="noopener noreferrer">The Flask Mega-Tutorial Part VIII: Followers</a></li>
<li><a href="https://github.com/hackersandslackers/sqlalchemy-tutorial" target="_blank" rel="noopener noreferrer">hackersandslackers/sqlalchemy-tutorial</a></li>
</ul>
]]></description></item><item><title>Python 并发编程：PoolExecutor 篇</title><link>https://thiscute.world/posts/python-concurrency-pool-executor/</link><pubDate>Fri, 15 Mar 2019 22:34:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/python-concurrency-pool-executor/</guid><description><![CDATA[<blockquote>
<p>个人笔记，如有疏漏，还请指正。</p>
</blockquote>
<p>使用多线程（threading）和多进程（multiprocessing）完成常规的并发需求，在启动的时候 start、join 等步骤不能省，复杂的需要还要用 1-2 个队列。
随着需求越来越复杂，如果没有良好的设计和抽象这部分的功能层次，代码量越多调试的难度就越大。</p>
<p>对于需要并发执行、但是对实时性要求不高的任务，我们可以使用 concurrent.futures 包中的 PoolExecutor 类来实现。</p>
<p>这个包提供了两个执行器：线程池执行器 ThreadPoolExecutor 和进程池执行器 ProcessPoolExecutor，两个执行器提供同样的 API。</p>
<blockquote>
<p>池的概念主要目的是为了重用：让线程或进程在生命周期内可以多次使用。它减少了创建创建线程和进程的开销，提高了程序性能。重用不是必须的规则，但它是程序员在应用中使用池的主要原因。</p>
</blockquote>
<p>池，只有固定个数的线程/进程，通过 max_workers 指定。</p>
<ol>
<li>任务通过 executor.submit 提交到 executor 的任务队列，返回一个 future 对象。
<ul>
<li>Future 是常见的一种并发设计模式。一个Future对象代表了一些尚未就绪（完成）的结果，在「将来」的某个时间就绪了之后就可以获取到这个结果。</li>
</ul>
</li>
<li>任务被调度到各个 workers 中执行。但是要注意，<strong>一个任务一旦被执行，在执行完毕前，会一直占用该 worker！</strong>
<ul>
<li>**如果 workers 不够用，其他的任务会一直等待！**因此 PoolExecutor 不适合实时任务。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">concurrent.futures</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">count</span>

<span class="n">number_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">evaluate_item</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">count</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>  <span class="c1"># count 是无限迭代器，会一直递增。</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
        <span class="c1"># 进程池</span>
        <span class="n">start_time_2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># 使用 with 在离开此代码块时，自动调用 executor.shutdown(wait=true) 释放 executor 资源</span>
        <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
                <span class="c1"># 将 10 个任务提交给 executor，并收集 futures</span>
                <span class="n">futures</span> <span class="o">=</span> <span class="p">[</span><span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">evaluate_item</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">number_list</span><span class="p">]</span>

                <span class="c1"># as_completed 方法等待 futures 中的 future 完成</span>
                <span class="c1"># 一旦某个 future 完成，as_completed 就立即返回该 future</span>
                <span class="c1"># 这个方法，使每次返回的 future，总是最先完成的 future</span>
                <span class="c1"># 而不是先等待任务 1，再等待任务 2...</span>
                <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">as_completed</span><span class="p">(</span><span class="n">futures</span><span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&#34;Thread pool execution in &#34;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time_2</span><span class="p">),</span> <span class="s2">&#34;seconds&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的代码中，item 为 1 2 3 4 5 的五个任务会一直占用所有的 workers，而 6 7 8 9 10 这五个任务会永远等待！！！</p>
<h2 id="api-详细说明">API 详细说明</h2>
<p>concurrent.futures 包含三个部分的 API：</p>
<ol>
<li>PoolExecutor：也就是两个执行器的 API
<ul>
<li>构造器：主要的参数是 max_workers，用于指定线程池大小（或者说 workers 个数）</li>
<li><code>submit(fn, *args, **kwargs)</code>：将任务函数 fn 提交到执行器，args 和 kwargs 就是 fn 需要的参数。
<ul>
<li>返回一个 future，用于获取结果</li>
</ul>
</li>
<li><code>map(func, *iterables, timeout=None, chunksize=1)</code>：当任务是同一个，只有参数不同时，可以用这个方法代替 submit。iterables 的每个元素对应 func 的一组参数。
<ul>
<li>返回一个 futures 的迭代器</li>
</ul>
</li>
<li><code>shutdown(wait=True)</code>：关闭执行器，一般都使用 with 管理器自动关闭。</li>
</ul>
</li>
<li>Future：任务被提交给执行器后，会返回一个 future
<ul>
<li><code>future.result(timout=None)</code>：<strong>最常用的方法</strong>，返回任务的结果。如果任务尚未结束，这个方法会一直等待！
<ul>
<li>timeout 指定超时时间，为 None 时没有超时限制。</li>
</ul>
</li>
<li><code>exception(timeout=None)</code>：给出任务抛出的异常。和 result() 一样，也会等待任务结束。</li>
<li><code>cancel()</code>：取消此任务</li>
<li><code>add_done_callback(fn)</code>：future 完成后，会执行 <code>fn(future)</code>。</li>
<li><code>running()</code>：是否正在运行</li>
<li><code>done()</code>：future 是否已经结束了，boolean</li>
<li>&hellip;详见官方文档</li>
</ul>
</li>
<li>模块带有的实用函数
<ul>
<li><code>concurrent.futures.as_completed(fs, timeout=None)</code>：等待 fs （futures iterable）中的 future 完成
<ul>
<li>一旦 fs 中的某 future 完成了，这个函数就立即返回该 future。</li>
<li>这个方法，使每次返回的 future，总是最先完成的 future。而不是先等待任务 1，再等待任务 2&hellip;</li>
<li>常通过 <code>for future in as_completed(fs):</code> 使用此函数。</li>
</ul>
</li>
<li><code>concurrent.futures.wait(fs, timeout=None, return_when=ALL_COMPLETED)</code>：一直等待，直到 return_when 所指定的事发生，或者 timeout
<ul>
<li>return_when 有三个选项：ALL_COMPLETED（fs 中的 futures 全部完成），FIRST__COMPLETED（fs 中任意一个 future 完成）还有 FIRST_EXCEPTION（某任务抛出异常）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="future-设计模式">Future 设计模式</h2>
<p>这里的 PoolExecutor 的特点，在于它使用了 Future 设计模式，使任务的执行，与结果的获取，变成一个异步的流程。
**我们先通过 submit/map 将任务放入任务队列，这时任务就已经开始执行了！**然后我们在需要的时候，通过 future 获取结果，或者直接 <code>add_done_callback(fn)</code>。</p>
<p>这里任务的执行是在新的 workers 中的，主进程/线程不会阻塞，因此主线程可以干其他的事。这种方式被称作异步编程。</p>
<h2 id="画外">画外</h2>
<p>concurrent.futures 基于 multiprocessing.pool 实现，因此实际上它比直接使用 线程/进程 的 Pool 要慢一点。但是它提供了更方便简洁的 API。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="http://www.dongwm.com/post/78/" target="_blank" rel="noopener noreferrer">使用Python进行并发编程-PoolExecutor篇</a></li>
<li><a href="https://github.com/laixintao/python-parallel-programming-cookbook-cn" target="_blank" rel="noopener noreferrer">Python Parallel Programming Cookbook</a></li>
<li><a href="https://docs.python.org/3/library/concurrent.futures.html" target="_blank" rel="noopener noreferrer">concurrent.futures — Launching parallel tasks</a></li>
<li><a href="https://www.cnblogs.com/kirito-c/p/10306133.html" target="_blank" rel="noopener noreferrer">进程线程协程与并发并行</a></li>
<li><a href="https://www.jianshu.com/p/fea4584d2890" target="_blank" rel="noopener noreferrer">并行设计模式（一）&ndash; Future模式</a></li>
</ul>
]]></description></item><item><title>Python 实用技巧与常见错误集锦</title><link>https://thiscute.world/posts/python-tips-and-tricks/</link><pubDate>Sun, 10 Mar 2019 00:59:21 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/python-tips-and-tricks/</guid><description><![CDATA[<blockquote>
<p>个人笔记，不保证正确。</p>
</blockquote>
<blockquote>
<p>适合有一定基础的童鞋阅读</p>
</blockquote>
<h2 id="一标准库">一、标准库</h2>
<h3 id="1-文件路径---pathlib">1. 文件路径 - pathlib</h3>
<p>提供了 OS 无关的文件路径抽象，可以完全替代旧的 <code>os.path</code> 和 <code>glob</code>.</p>
<p>学会了 <code>pathlib.Path</code>，你就会了 Python 处理文件路径的所有功能。</p>
<h4 id="1-路径解析与拼接">1. 路径解析与拼接</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">data_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&#34;./source_data/text_files/&#34;</span><span class="p">)</span>
<span class="n">data_file</span> <span class="o">=</span> <span class="n">data_folder</span> <span class="o">/</span> <span class="s2">&#34;raw_data.txt&#34;</span>  <span class="c1"># Path 重载了 / 操作符，路径拼接超级方便</span>

<span class="c1"># 路径的解析</span>
<span class="n">data_file</span><span class="o">.</span><span class="n">parent</span>  <span class="c1"># 获取父路径，这里的结果就是 data_folder</span>
<span class="n">data_foler</span><span class="o">.</span><span class="n">parent</span> <span class="c1"># 会返回 Path(&#34;source_data&#34;)</span>
<span class="n">data_file</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># 即获取到 data_file 的上上层目录，结果和上面一样是 Path(&#34;source_data&#34;)</span>
<span class="n">data_file</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># 上上上层目录，Path(&#34;.&#34;)</span>

<span class="n">dara_file</span><span class="o">.</span><span class="n">name</span> <span class="c1"># 文件名 &#34;raw_data.txt&#34;</span>
<span class="n">dara_file</span><span class="o">.</span><span class="n">suffix</span>  <span class="c1"># 文件的后缀（最末尾的）&#34;.txt&#34;，还可用 suffixes 获取所有后缀</span>

<span class="n">data_file</span><span class="o">.</span><span class="n">stem</span>  <span class="c1"># 去除掉最末尾的后缀后（只去除一个），剩下的文件名：raw_data</span>

<span class="c1"># 替换文件名或者文件后缀</span>
<span class="n">data_file</span><span class="o">.</span><span class="n">with_name</span><span class="p">(</span><span class="s2">&#34;test.txt&#34;</span><span class="p">)</span>  <span class="c1"># 变成 .../test.txt</span>
<span class="n">data_file</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&#34;.pdf&#34;</span><span class="p">)</span>  <span class="c1"># 变成 .../raw_data.pdf</span>

<span class="c1"># 当前路径与另一路径 的相对路径</span>
<span class="n">data_file</span><span class="o">.</span><span class="n">relative_to</span><span class="p">(</span><span class="n">data_folder</span><span class="p">)</span>  <span class="c1"># PosixPath(&#39;raw_data.txt&#39;)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="2-pathlib-常用函数">2. pathlib 常用函数</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">if</span> <span class="ow">not</span> <span class="n">data_folder</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="n">data_folder</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># 直接创建文件夹，如果父文件夹不存在，也自动创建</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>  <span class="c1"># 文件是否存在</span>
    <span class="n">filename</span><span class="o">.</span><span class="n">touch</span><span class="p">()</span>  <span class="c1"># 直接创建空文件，或者用 filename.open() 直接获取文件句柄</span>

<span class="c1"># 路径类型判断</span>
<span class="k">if</span> <span class="n">data_file</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>  <span class="c1"># 是文件</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">data_file</span><span class="p">,</span> <span class="s2">&#34;is a file&#34;</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">data_file</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>  <span class="c1"># 是文件夹</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">iterdir</span><span class="p">():</span>  <span class="c1"># 通过 Path.iterdir() 迭代文件夹中的内容</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

<span class="c1"># 路径解析</span>
<span class="c1"># 获取文件的绝对路径（符号链接也会被解析到真正的文件）</span>
<span class="n">filename</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>  <span class="c1"># 在不区分大小写的系统上（Windows），这个函数也会将大小写转换成实际的形式。</span>

<span class="c1"># 可以直接获取 Home 路径或者当前路径</span>
<span class="n">Path</span><span class="o">.</span><span class="n">home</span><span class="p">()</span> <span class="o">/</span> <span class="s2">&#34;file.txt&#34;</span> <span class="c1"># 有时需要以 home 为 base path 来构建文件路径</span>
<span class="n">Path</span><span class="o">.</span><span class="n">cwd</span><span class="p">()</span>  <span class="o">/</span> <span class="s2">&#34;file.txt&#34;</span> <span class="c1"># 或者基于当前路径构建</span>
</code></pre></td></tr></table>
</div>
</div><p>还有很多其它的实用函数，可在使用中慢慢探索。</p>
<h4 id="3-glob-通配符">3. glob 通配符</h4>
<p>pathlib 也提供了 glob 支持，也就是广泛用在路径匹配上的一种简化正则表达式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">data_file</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">glob_pattern</span><span class="p">)</span>  <span class="c1"># 返回 True 或 False，表示文件路径与给出的 glob pattern 是否匹配</span>

<span class="k">for</span> <span class="n">py_file</span> <span class="ow">in</span> <span class="n">data_folder</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&#34;*/*.py&#34;</span><span class="p">):</span>  <span class="c1"># 匹配当前路径下的子文件夹中的 py 文件，会返回一个可迭代对象</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">py_file</span><span class="p">)</span>

<span class="c1"># 反向匹配，相当于 glob 模式开头添加 &#34;**/&#34;</span>
<span class="k">for</span> <span class="n">py_file</span> <span class="ow">in</span> <span class="n">data_folder</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&#34;**/*.py&#34;</span><span class="p">):</span>  <span class="c1"># 匹配当前路径下的所有 py 文件（所有子文件夹也会被搜索），返回一个可迭代对象</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">py_file</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>glob 中的 * 表示任意字符，而 ** 则表示任意层目录。（在大型文件树上使用 ** 速度会很慢！）</p>
<h3 id="2-排序常用库---operator">2. 排序常用库 - operator</h3>
<p>operator 模块包含四种类型的方法：</p>
<h4 id="1-operatoritemgetter">1. <strong>operator.itemgetter</strong></h4>
<p>经常被用于 sorted/max/mix/itertools.groupby 等</p>
<p>使用方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="c1"># itemgetter</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">f</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="c1"># return r[2]</span>

<span class="c1"># 还能一次获取多个值，像 numpy 那样索引</span>
<span class="n">f2</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="n">f2</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="c1"># return (r[2], r[4], r[5])</span>

<span class="c1"># 或者使用 slice 切片</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
<span class="n">s</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>  <span class="c1"># return r[2:]</span>

<span class="c1"># dict 索引也能用</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="s1">&#39;rank&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">)</span>
<span class="n">d</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>  <span class="c1"># return d[&#39;rank&#39;], d[&#39;name&#39;]</span>
</code></pre></td></tr></table>
</div>
</div><p>用途：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="c1"># 用于指定用于比较大小的属性</span>
<span class="n">key</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">sorted</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>  <span class="c1"># 使用 iterable[1] 对 iterable 进行排序</span>
<span class="nb">max</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>  <span class="c1"># 找出最大的元素，使用 iterable[1] 做比较</span>

<span class="c1"># 用于高级切片（比如像 numpy 那样的，指定只获取某几列）</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
<span class="nb">map</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>  <span class="c1"># list 后得到 [(1, 3, 4), (2,4,5)]</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="2-operatorattrgetter">2. <code>operator.attrgetter</code></h4>
<p>可用于动态获取对象的属性，与直接用 <code>getattr()</code> 不同的是，它可以嵌套访问属性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Python3" data-lang="Python3"><span class="c1"># 嵌套访问属性</span>
<span class="n">att</span> <span class="o">=</span> <span class="n">attrgetter</span><span class="p">(</span><span class="s2">&#34;a.b.c&#34;</span><span class="p">)</span>
<span class="n">att</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>  <span class="c1"># return obj.a.b.c</span>

<span class="c1"># 和 itemgetter 一样，也可以一次获取多个属性</span>
<span class="n">att</span> <span class="o">=</span> <span class="n">attrgetter</span><span class="p">(</span><span class="s2">&#34;a.b.c&#34;</span><span class="p">,</span> <span class="s2">&#34;x.y&#34;</span><span class="p">)</span>
<span class="n">att</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>  <span class="c1"># return (obj.a.b.c, obj.x.y)</span>

<span class="c1"># 不嵌套的话，用 getattr 就行</span>
<span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&#34;a&#34;</span><span class="p">)</span>  <span class="c1"># return obj.a</span>
</code></pre></td></tr></table>
</div>
</div><p>这里可以回顾一下类的两个魔法函数：</p>
<ol>
<li><code>__getattr__</code>: 当被访问的属性不存在时，这个方法会被调用，它的返回值会成为对象的该属性。
<ul>
<li>用于动态生成实例的属性/函数</li>
</ul>
</li>
<li><code>__getattribute__</code>: 与 <code>__getattr__</code> 唯一的差别在于，访问对象的任何属性，都会直接调用这个方法，<strong>不管属性存不存在</strong>。</li>
</ol>
<h4 id="3-operatormethodcaller">3. operator.methodcaller</h4>
<p>可用于调用函数，它和 attrgetter 很像，差别在于 attrgetter 只是返回指定的属性，而 methodcaller 会直接把指定的属性当成函数调用，然后返回结果。</p>
<p>举例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="n">f</span> <span class="o">=</span> <span class="n">methodcaller</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># returns b.name(&#39;foo&#39;, bar=1)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="4-各种操作符对应的函数">4. 各种操作符对应的函数</h4>
<p>operator.add、operator.sub、operator.mul、operator.div 等等，函数式编程有时需要用到。</p>
<h3 id="3-itertools">3. itertools</h3>
<p><a href="https://docs.python.org/3/library/itertools.html" target="_blank" rel="noopener noreferrer">itertools</a> 提供了许多针对可迭代对象的实用函数</p>
<p>方法很多，基本不可能一次全记住。还是要用到时多查吧。大致记住有提供哪些功能，需要用到时能想起可以查这个模块就行。</p>
<h4 id="1-无限迭代器">1. 无限迭代器</h4>
<ol>
<li>count(start=0, step=1): 从 start 开始，每次迭代时，返回值都加一个 step
<ul>
<li>默认返回序列为 0 1 2 3&hellip;</li>
</ul>
</li>
<li>cycle(iterable): 不断循环迭代 iterable</li>
<li>repeat(element, times=None): 默认永远返回 element。（如果 times 不为 None，就迭代 times 后结束）</li>
</ol>
<h4 id="2-排列组合迭代器">2. 排列组合迭代器</h4>
<ol>
<li>product(p1, p2, &hellip;, repeat=1)：p1, p2&hellip; 的元素的笛卡尔积，相当于多层 for 循环
<ul>
<li>repeat 指参数重复次数，比如</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">&gt;&gt;&gt; from itertools import product
&gt;&gt;&gt; <span class="nv">r</span> <span class="o">=</span> product<span class="o">([</span>1, 2<span class="o">]</span>, <span class="o">[</span>3, 4<span class="o">]</span>, <span class="o">[</span>5, 6<span class="o">])</span>  <span class="c1"># 重复一次，也就是 (p1, p2, p3) 的笛卡尔积</span>
&gt;&gt;&gt; pprint<span class="o">(</span>list<span class="o">(</span>r<span class="o">))</span>       
<span class="o">[(</span>1, 3, 5<span class="o">)</span>,
 <span class="o">(</span>1, 3, 6<span class="o">)</span>,
 <span class="o">(</span>1, 4, 5<span class="o">)</span>,
 <span class="o">(</span>1, 4, 6<span class="o">)</span>,
 <span class="o">(</span>2, 3, 5<span class="o">)</span>,
 <span class="o">(</span>2, 3, 6<span class="o">)</span>,
 <span class="o">(</span>2, 4, 5<span class="o">)</span>,
 <span class="o">(</span>2, 4, 6<span class="o">)]</span>
&gt;&gt;&gt; <span class="nv">r2</span> <span class="o">=</span> product<span class="o">([</span>1, 2<span class="o">]</span>, <span class="o">[</span>3, 4<span class="o">]</span>, <span class="o">[</span>5, 6<span class="o">]</span>, <span class="nv">repeat</span><span class="o">=</span>2<span class="o">)</span>  <span class="c1"># 重复两次，即 (p1, p2, p3, p1, p2, p3) 的笛卡尔积</span>
&gt;&gt;&gt; pprint<span class="o">(</span>list<span class="o">(</span>r2<span class="o">))</span>
<span class="o">[(</span>1, 3, 5, 1, 3, 5<span class="o">)</span>,
 <span class="o">(</span>1, 3, 5, 1, 3, 6<span class="o">)</span>,
 <span class="o">(</span>1, 3, 5, 1, 4, 5<span class="o">)</span>,
 <span class="o">(</span>1, 3, 5, 1, 4, 6<span class="o">)</span>,
 <span class="o">(</span>1, 3, 5, 2, 3, 5<span class="o">)</span>,
...
</code></pre></td></tr></table>
</div>
</div><ol>
<li>permutations(p[, r])：p 中元素，长度为 r 的所有可能的排列。相当于 product 去重后的结果。</li>
<li>combinations(p, r)：既然有排列，当然就有组合了。</li>
</ol>
<h4 id="3-其他">3. 其他</h4>
<ol>
<li><code>zip_longest(*iterables, fillvalue=None)</code>：和 zip 的差别在于，缺失的元素它会用 fillvalue 补全，而不是直接结束。</li>
<li><code>takewhile()</code></li>
<li><code>dropwhile()</code></li>
<li><code>groupby()</code></li>
</ol>
<p>等等等，用得到的时候再查了。。。</p>
<h3 id="4-collections">4. collections</h3>
<p>提供了一些实用的高级数据结构（容器）</p>
<ol>
<li><strong><code>defaultdict</code></strong>：这个感觉是最常用的，可以给定 key 的默认值</li>
<li><strong><code>Counter</code></strong>：方便、快速的计数器。常用于分类统计</li>
<li><code>deque</code>：一个线程安全的双端队列</li>
<li><code>OrderedDict</code>：有时候会需要有序字典</li>
<li><code>namedtuple</code>：命名元组，有时用于参数传递。与 tuple 的差别是它提供了关键字参数和通过名字访问属性的功能</li>
<li><code>ChainMap</code>：将多个 map 连接（chain）在一起，提供一个统一的视图。因为是视图，所以原来的 map 不会被影响。</li>
</ol>
<h3 id="5-常用函数装饰器-functools">5. 常用函数装饰器 functools</h3>
<p>functools 提供了几个有时很有用的函数和装饰器</p>
<h4 id="1-functoolswraps">1. @functools.wraps</h4>
<p>这个装饰器用于使装饰器 copy 被装饰的对象的 <code>__module__</code>, <code>__name__</code>, <code>__qualname__</code>, <code>__annotations__</code> and <code>__doc__</code> 属性，这样装饰器就显得更加透明。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="k">def</span> <span class="nf">my_decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
     <span class="nd">@wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
     <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
         <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calling decorated function&#39;</span><span class="p">)</span>
         <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
     <span class="k">return</span> <span class="n">wrapper</span>  <span class="c1"># 用了 wraps，wrapper 会复制 f 的各种文档属性</span>

<span class="nd">@my_decorator</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">xx</span><span class="p">):</span>
    <span class="s2">&#34;&#34;&#34; this is func&#39;s docstring&#34;&#34;&#34;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;this is func~&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果不用 wraps 的话，因为实际上返回的是 wrapper，被装饰对象的这些文档属性都会丢失。（比如 docstring）
<strong>因此在使用 wrapper 装饰器时，添加 @wraps() 装饰器是个好习惯。</strong></p>
<h4 id="2-functoolspartial">2. functools.partial</h4>
<p>这个感觉和高等数学的偏函数很像：比如函数 z = f(x, y) 有 x 和 y 两个变量，现在把 x 看作常数，就可以对 y 进行求导运算。
而 python 的 partial 也差不多，不过它不是把 x 看作常数，而是先给定 x 的值。用法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="n">basetwo</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># 先给定 int 函数的 base 参数为 2</span>
<span class="n">basetwo</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s1">&#39;Convert base 2 string to an int.&#39;</span>  <span class="c1"># 如果需要文档，可以添加 __doc__ 属性</span>
<span class="n">basetwo</span><span class="p">(</span><span class="s1">&#39;10010&#39;</span><span class="p">)</span>  <span class="c1"># return 18</span>
</code></pre></td></tr></table>
</div>
</div><p>此外，还有个 partialmethod 函数，待了解</p>
<h4 id="3-functoolslru_cachemaxsize128-typedfalse">3. @functools.lru_cache(maxsize=128, typed=False)</h4>
<p>如果某方法可能被频繁调用（使用相同的参数），而且它的结果在一定时间内不会改变。可以用 lru_cache 装饰它，减少运算量或 IO 操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>

<span class="c1"># 缓存最近的（least recently used，lru） 64 次参数不同的调用结果。</span>
<span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_sum</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>  <span class="c1"># 后续的调用中，如果参数能匹配到缓存，就直接返回缓存结果</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>比如用递归计算斐波那契数列，数值较低的参数会被频繁使用，于是可以用 lru_cache 来缓存它们。
或者爬取网页，可能会需要频繁爬取一个变化不快的网页，这时完全可以用 cache 缓存。</p>
<p>但是它不能控制缓存失效时间，因此不能用于 Web 系统的缓存。还是得自己写个简单的装饰器，把缓存存到 redis 里并设置 expires。或者直接用 Flask 或 Django 的 caching 插件。</p>
<h4 id="4-functoolssingledispatch">4. @functools.singledispatch</h4>
<p>单重派发，即根据函数的第一个参数的类型，来决定调用哪一个同名函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="nd">@singledispatch</span>
<span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>  <span class="c1"># 首先定义一个默认函数</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;没有合适的类型被调用&#39;</span><span class="p">)</span>  <span class="c1"># 如果参数类型没有匹配上，就调用这个默认函数</span>

<span class="nd">@parse</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>  <span class="c1"># 第一个参数为 None</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;出现 None 了&#39;</span><span class="p">)</span>

<span class="nd">@parse</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># 第一个参数为整数</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;这次输入的是整数&#39;</span><span class="p">)</span>

<span class="nd">@parse</span><span class="o">.</span><span class="n">register</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>  <span class="c1"># python3.7 开始，可以直接用类型注解来标注第一个参数的类型</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;这次输入的是列表&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>画外：有单重派发，自然就有多重派发，Julia 语言就支持多重派发，即根据函数所有参数的类型，来决定调用哪一个同名函数。
Julia 语言根本没有类这个定义，类型的所有方法都是通过多重派发来定义的。</p>
<h4 id="其他">其他</h4>
<ol>
<li>@functools.total_ordering：用于自动生成比较函数。</li>
<li>functools.cmp_to_key(func)：用于将老式的比较函数，转换成新式的 key 函数。</li>
</ol>
<h3 id="6-上下文管理---contextlib">6. 上下文管理 - contextlib</h3>
<p>即实现使用 <code>with</code> 语句进行自定义的上下文管理。</p>
<h4 id="1-使用-__enter__-和-__exit__">1. 使用 <code>__enter__</code> 和 <code>__exit__</code></h4>
<p>Java 使用 try 来自动管理资源，只要实现了 AutoCloseable 接口，就可以部分摆脱手动 colse 的地狱了。</p>
<p>而 Python，则是定义了两个 Protocol：<code>__enter__</code> 和 <code>__exit__</code>. 下面是一个 open 的模拟实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">OpenContext</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>  <span class="c1"># 调用 open(filename, mode) 返回一个实例</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># 用 with 管理 __init__ 返回的实例时，with 会自动调用这个方法</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fp</span>

    <span class="c1"># 退出 with 代码块时，会自动调用这个方法。</span>
    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1"># 这里先构造了 OpenContext 实例，然后用 with 管理该实例</span>
<span class="k">with</span> <span class="n">OpenContext</span><span class="p">(</span><span class="s1">&#39;/tmp/a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这里唯一有点复杂的，就是 <code>__exit__</code> 方法。和 Java 一样，<code>__exit__</code> 相当于 <code>try - catch - finally</code> 的 <code>finally</code> 代码块，在发生异常时，它也会被调用。</p>
<p>当没有异常发生时，<code>__exit__</code> 的三个参数 <code>exc_type, exc_value, traceback</code> 都为 None，而当发生异常时，它们就对应异常的详细信息。
发生异常时， <code>__exit__</code> <strong>的返回值将被用于决定是否向外层抛出该异常</strong>，返回 True 则抛出，返回 False 则抑制（swallow it）。</p>
<p>Note 1：Python 3.6 提供了 async with 异步上下文管理器，它的 Protocol 和同步的 with 完全类似，是 <code>__aenter__</code> 和 <code>__aexit__</code> 两个方法。
Note 2：与 Java 相同，with 支持同时管理多个资源，因此可以直接写 <code>with open(x) as a, open(y) as b:</code> 这样的形式。</p>
<h4 id="2-推荐contextlib">2. 推荐：contextlib</h4>
<h5 id="21-contextlibcontextmanager">2.1 @contextlib.contextmanager</h5>
<p>对于简单的 with 资源管理，编写一个类可能会显得比较繁琐，为此 contextlib 提供了一个方便的装饰器 <code>@contextlib.contextmanager</code> 用来简化代码。</p>
<p>使用它，上面的 OpenContext 可以改写成这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">make_open_context</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">fp</span>  <span class="c1"># 没错，这是一个生成器函数</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">with</span> <span class="n">make_open_context</span><span class="p">(</span><span class="s1">&#39;/tmp/a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 <code>contextmanager</code> 装饰一个生成器函数，yield 之前的代码对应 <code>__enter__</code>，finally 代码块就对应 <code>__exit__</code>.</p>
<p>Note：同样，也有异步版本的装饰器 <code>@contextlib.asynccontextmanager</code></p>
<h5 id="22-contextlibclosingthing">2.2 contextlib.closing(thing)</h5>
<p>用于将原本不支持 with 管理的资源，包装成一个 Context 对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">closing</span>
<span class="kn">from</span> <span class="nn">urllib.request</span> <span class="kn">import</span> <span class="n">urlopen</span>

<span class="k">with</span> <span class="n">closing</span><span class="p">(</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">page</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">page</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

<span class="c1"># closing 等同于</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">closing</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">thing</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">thing</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># 就是添加了一个自动 close 的功能</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="23-contextlibsuppressexceptions">2.3 contextlib.suppress(*exceptions)</h5>
<p>使 with 管理器抑制代码块内任何被指定的异常：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">suppress</span>

<span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">FileNotFoundError</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;somefile.tmp&#39;</span><span class="p">)</span>

<span class="c1"># 等同于</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;somefile.tmp&#39;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
    <span class="k">pass</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="24-contextlibredirect_stdoutnew_target">2.4 contextlib.redirect_stdout(new_target)</h5>
<p>将 with 代码块内的 stdout 重定向到指定的 target（可用于收集 stdout 的输出）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
<span class="k">with</span> <span class="n">redirect_stdout</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>  <span class="c1"># 将输出直接写入到 StringIO</span>
    <span class="n">help</span><span class="p">(</span><span class="nb">pow</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

<span class="c1"># 或者直接写入到文件</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;help.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">redirect_stdout</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">help</span><span class="p">(</span><span class="nb">pow</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>redirect_stdout 函数返回的 Context 是可重入的（ reentrant），可以重复使用。</p>
<h2 id="二实用代码片段">二、实用代码片段</h2>
<h3 id="group_size">1. 元素分组/group</h3>
<p>数据处理中一个常见的操作，是将列表中的元素，依次每 k 个分作一组。</p>
<p>下面的函数使用非常简洁的代码实现了元素分组的功能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">zip_longest</span>

<span class="k">def</span> <span class="nf">group_each</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">longest</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="s2">&#34;&#34;&#34;
</span><span class="s2">        将一个可迭代对象 a 内的元素, 每 size 个分为一组
</span><span class="s2">        group_each([1,2,3,4], 2) -&gt; [(1,2), (3,4)]
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="n">iterators</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span> <span class="o">*</span> <span class="n">size</span>  <span class="c1"># 将新构造的 iterator 复制 size 次（浅复制）</span>

    <span class="n">func_zip</span> <span class="o">=</span> <span class="n">zip_longest</span> <span class="k">if</span> <span class="n">longest</span> <span class="k">else</span> <span class="nb">zip</span>
    <span class="k">return</span> <span class="n">func_zip</span><span class="p">(</span><span class="o">*</span><span class="n">iterators</span><span class="p">)</span>  <span class="c1"># 然后 zip</span>

<span class="n">a</span> <span class="o">=</span> <span class="s2">&#34;abcdefghijk&#34;</span>

<span class="nb">list</span><span class="p">(</span><span class="n">group_each</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1"># =&gt; [(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), (&#39;d&#39;, &#39;e&#39;, &#39;f&#39;), (&#39;g&#39;, &#39;h&#39;, &#39;i&#39;)]</span>

<span class="nb">list</span><span class="p">(</span><span class="n">group_each</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">longest</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="c1"># =&gt; [(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), (&#39;d&#39;, &#39;e&#39;, &#39;f&#39;), (&#39;g&#39;, &#39;h&#39;, &#39;i&#39;), (&#39;j&#39;, &#39;k&#39;, None)]</span>
</code></pre></td></tr></table>
</div>
</div><p>这个函数还可以进一步简化为 <code>zip(*[iter(a)] * 3)</code>，如果没想到浅复制（Shallow Copy）特性的话，会很难理解它的逻辑。</p>
<p>此外，如果某个 size 比较常用（比如 2），还可以用 <code>partial</code> 封装一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

 <span class="c1"># 每两个分一组</span>
<span class="n">group_each_2</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">group_each</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># 等同于 group_each_2 = lambda a: group_each(a, 2)</span>

<span class="n">a</span> <span class="o">=</span> <span class="s2">&#34;abcde&#34;</span>

<span class="nb">list</span><span class="p">(</span><span class="n">group_each_2</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="c1"># =&gt; [(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;)]</span>

<span class="nb">list</span><span class="p">(</span><span class="n">group_each_2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">longest</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="c1"># =&gt; [(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;e&#39;, None)]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="2-扁平版本的-map">2. 扁平版本的 map</h3>
<p>稍微接触过函数式应该都知道 flat_map，可 Python 标准库却没有提供。下面是我在 stackoverflow 上找到的实现，其实很简单</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>

<span class="k">def</span> <span class="nf">flat_map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">items</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>它和 map 的差别在于是不是扁平(flat) 的（废话。。），举个例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">&gt;&gt;&gt; list(map(list, [&#39;123&#39;, &#39;456&#39;]))
[[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;], [&#39;4&#39;, &#39;5&#39;, &#39;6&#39;]]
&gt;&gt;&gt; list(flat_map(list, [&#39;123&#39;, &#39;456&#39;]))
[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;]
</code></pre></td></tr></table>
</div>
</div><h3 id="3-轮流迭代多个迭代器">3. 轮流迭代多个迭代器</h3>
<p>假设我有多个可迭代对象（迭代器、列表等），现在我需要每次从每个对象中取一个值，直到某个对象为空。如果用循环写会比较繁琐，但是用 itertools 可以这样写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>

<span class="k">def</span> <span class="nf">iter_one_by_one</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">items</span><span class="p">))</span>

<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>

<span class="nb">list</span><span class="p">(</span><span class="n">iter_one_by_one</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]))</span>  <span class="c1"># =&gt;  [1, 4, 7, 2, 5, 8, 3, 6, 9]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="4-多-dict-的去重">4. 多 dict 的去重</h3>
<p>假设我们有一个 dict 的列表，里面可能有内容一模一样的 dict，我们需要对它做去重。
容易想到的方法就是使用 set，可是 set 中的元素必须是 hashable 的，而 dict 是 unhashable 的，因此不能直接放进 set 里。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">&gt;&gt;&gt; a = [{&#39;a&#39;: 1}, {&#39;a&#39;: 1}, {&#39;b&#39;: 2}]
&gt;&gt;&gt; set(a)
Traceback (most recent call last):
  File &#34;/usr/local/lib/python3.7/site-packages/IPython/core/interactiveshell.py&#34;, line 2961, in run_code
    exec(code_obj, self.user_global_ns, self.user_ns)
  File &#34;&lt;ipython-input-5-5b4c643a6feb&gt;&#34;, line 1, in &lt;module&gt;
    set(a)
TypeError: unhashable type: &#39;dict&#39;
</code></pre></td></tr></table>
</div>
</div><p>难道就必须手写递归了么？未必，我在 stackoverflow 看到这样一个小技巧</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">import</span> <span class="nn">json</span>

<span class="k">def</span> <span class="nf">unique_dicts</span><span class="p">(</span><span class="n">data_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
    <span class="s2">&#34;&#34;&#34;unique a list of dict
</span><span class="s2">        dict 是 unhashable 的，不能放入 set 中，所以先转换成 str
</span><span class="s2">        
</span><span class="s2">        unique_dicts([{&#39;a&#39;: 1}, {&#39;a&#39;: 1}, {&#39;b&#39;: 2}])  -&gt;  [{&#39;a&#39;: 1}, {&#39;b&#39;: 2}]
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="n">data_json_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data_json_set</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="5-str-的-startswith-和-endswith-的参数可以是元组">5. str 的 startswith 和 endswith 的参数可以是元组</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">In[7]: a = &#34;bb.gif&#34;
In[8]: b = &#39;a.jpg&#39;
In[9]: a.endswith((&#39;.jpg&#39;, &#39;.gif&#39;))
Out[9]: True
In[10]: b.startswith((&#39;bb&#39;, &#39;a&#39;))
Out[10]: True
</code></pre></td></tr></table>
</div>
</div><h3 id="6-判断两个对象的所有属性都相同">6. 判断两个对象的所有属性都相同</h3>
<p>python 和 java 一样，直接用 == 做判断，默认是比较的引用，相当于 is。对自定义的类，你需要重写 <code>__eq__</code> 函数。
判断值相等的方法很简单，一行代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">==</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span>  <span class="c1"># 转成 __dict__ 再比较</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="7-案例">7. 案例</h3>
<h4 id="71-html-table-元素的处理">7.1 html table 元素的处理</h4>
<p>在做爬虫工作时，有时会遇到这样的 table 元素：</p>
<p></p>
<p>对这种 html 元素，我一般会直接把它转换成 list，结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="n">table</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;label1&#39;</span><span class="p">,</span> <span class="s1">&#39;value1&#39;</span><span class="p">,</span> <span class="s1">&#39;label2&#39;</span><span class="p">,</span> <span class="s1">&#39;value2&#39;</span><span class="p">],</span>
         <span class="p">[</span><span class="s1">&#39;label3&#39;</span><span class="p">,</span> <span class="s1">&#39;value3&#39;</span><span class="p">],</span>
         <span class="p">[</span><span class="s1">&#39;label4&#39;</span><span class="p">,</span> <span class="s1">&#39;value4&#39;</span><span class="p">,</span> <span class="s1">&#39;label5&#39;</span><span class="p">,</span> <span class="s1">&#39;value5&#39;</span><span class="p">],</span>
         <span class="o">...</span>
         <span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>为了方便索引，现在我需要把上面的数据转换成下面这个样子的 dict</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="p">{</span>
    <span class="s1">&#39;label1&#39;</span><span class="p">:</span> <span class="s1">&#39;value1&#39;</span><span class="p">,</span>
    <span class="s1">&#39;label2&#39;</span><span class="p">:</span> <span class="s1">&#39;value2&#39;</span><span class="p">,</span>
    <span class="s1">&#39;label3&#39;</span><span class="p">:</span> <span class="s1">&#39;value3&#39;</span><span class="p">,</span>
    <span class="s1">&#39;label4&#39;</span><span class="p">:</span> <span class="s1">&#39;value4&#39;</span><span class="p">,</span>
    <span class="s1">&#39;label5&#39;</span><span class="p">:</span> <span class="s1">&#39;value5&#39;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果是平常，大概需要写循环了。不过如果用刚刚说到的几个函数的话，会变得异常简单</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"> # 1. 分组
groups = flat_map(group_each_2, table)

# 1.1 flat_map 返回的是迭代器，list 后内容如下：
# [(&#39;label1&#39;, &#39;value1&#39;),
#  (&#39;label2&#39;, &#39;value2&#39;),
#  (&#39;label3&#39;, &#39;value3&#39;),
#  (&#39;label4&#39;, &#39;value4&#39;),
#  (&#39;label5&#39;, &#39;value5&#39;)]

# 2. 转换成 dict
key_values = dict(groups)   # 得到的 key_values 与上面需要的 dict 别无二致。
</code></pre></td></tr></table>
</div>
</div><h2 id="三常见错误">三、常见错误</h2>
<h3 id="1-浅复制导致错误">1. 浅复制导致错误</h3>
<p>利用好浅复制，可以非常简洁的实现前面提到的<a href="##group_size" rel="">元素分组/group</a>功能，但是如果不注意，也会导致非常隐晦的错误！</p>
<p>比如在使用 * 作为重复运算符时，如果目标是一个嵌套的可变对象，就会产生令人费解的问题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>  <span class="c1"># nested</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
</code></pre></td></tr></table>
</div>
</div><p>因为 * 并不是深拷贝，它只是简单地复制了 [a] 这个列表，里面的 [1,2,3] 都是同一个对象，所以改了一个，所有的都会改变。
<strong>解决方法是不要使用 * 号，改用<code>[a.copy() for i in range(3)]</code> 执行深拷贝。如果不需要修改，请直接使用不可变对象。</strong></p>
<h3 id="2-变量作用域">2. 变量作用域</h3>
<ol>
<li>Python 中<strong>只有模块，类以及函数才会引入新的作用域</strong>，其它的代码块是不会引入新的作用域的。（而在 C/Java 中，任何一个 <code>{}</code> 块就构成一个局部作用域。另外 Julia 中 for/while/try-catch 都是局部作用域，但 if-else 又不是局部作用域。总之这些小差别要注意。）</li>
<li>局部变量可以与外部变量同名，并且在其作用域中，局部变量会覆盖掉外部变量。
不知是出于实现简单或是性能，还是其他的原因，好像所有的语言都是这样的。其实我更希望变量的作用域覆盖会报错。</li>
<li>如果有函数与其他函数或变量（甚至某些保留字）同名，后定义的会覆盖掉先定义的。（这是因为 Python 中函数也是对象。而在 C/Java 中这是会报错的）</li>
</ol>
<p>此外，还有一个小问题，先看一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="o">&gt;&gt;&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">f</span><span class="p">():</span>     <span class="c1"># 单纯的从函数作用域访问外部作用域是没问题的</span>
<span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="o">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">()</span>
<span class="mi">4</span>
</code></pre></td></tr></table>
</div>
</div><p>再看一个问题举例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="o">&gt;&gt;&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
<span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="c1"># 这里应该是访问外部作用域</span>
<span class="o">...</span>     <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span>     <span class="c1"># 可这里又定义了一个同名局部变量 i</span>
<span class="o">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">()</span>   <span class="c1"># 于是就出错了</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&#34;&lt;stdin&gt;&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s2">&#34;&lt;stdin&gt;&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="ow">in</span> <span class="n">f</span>
<span class="ne">UnboundLocalError</span><span class="p">:</span> <span class="n">local</span> <span class="n">variable</span> <span class="s1">&#39;i&#39;</span> <span class="n">referenced</span> <span class="n">before</span> <span class="n">assignment</span>
</code></pre></td></tr></table>
</div>
</div><p>如果在内部作用域先访问外部作用域，再定义一个同名的局部变量，解释器就懵逼了。
如果你其实想做的是改变全局变量 i 的值，就应该在开头声明 <code>global i</code>. 而如果 外部变量 i 不是存在于全局作用域，而是在某个闭合作用域内的话，就该用 <code>nonlocal i</code></p>
<h2 id="四自定义装饰器">四、自定义装饰器</h2>
<p>装饰器有两种：用函数定义的装饰器，还有用类定义的装饰器。函数装饰器最常用。</p>
<p>装饰器可用于装饰函数，修改函数/类的某些行为，或者将函数注册到别的地方。</p>
<h3 id="1-函数定义装饰器">1. 函数定义装饰器</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="nd">@decc</span>
<span class="k">def</span> <span class="nf">gg</span><span class="p">(</span><span class="n">xx</span><span class="p">):</span>
    <span class="o">...</span>

<span class="c1"># 等同于</span>
<span class="k">def</span> <span class="nf">gg</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span>
<span class="n">gg</span> <span class="o">=</span> <span class="n">decc</span><span class="p">(</span><span class="n">gg</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="带参的装饰器">带参的装饰器</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="nd">@decorator</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>

<span class="n">F</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>

<span class="c1"># 等同于</span>
<span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>

<span class="n">F</span> <span class="o">=</span> <span class="n">decorator</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)(</span><span class="n">F</span><span class="p">)</span>      <span class="c1"># Rebind F to result of decorator&#39;s return value</span>
<span class="n">F</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>                                <span class="c1"># Essentially calls decorator(A, B)(F)(99)</span>
</code></pre></td></tr></table>
</div>
</div><p>上面演示的是用函数定义的装饰器，也是最常用的装饰器。
装饰器接收的参数可以是各种各样的，下面是一个带参的装饰器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="nd">@on_command</span><span class="p">(</span><span class="s2">&#34;info&#34;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_info</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&#34;这就是你需要的 info&#34;</span>

<span class="k">def</span> <span class="nf">on_command</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># 调用此函数获得装饰器，这样就实现了带参装饰器</span>
    <span class="k">def</span> <span class="nf">deco</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>  <span class="c1"># 这个才是真正的装饰器</span>
        <span class="c1"># 将命令处理器注册到命令列表内</span>
        <span class="k">return</span> <span class="n">func</span>  <span class="c1"># 直接返回原函数，这样的话，多个装饰器就不会相互影响了。</span>
    <span class="k">return</span> <span class="n">deco</span>

<span class="c1"># 上面的等同于：</span>
<span class="n">get_info</span> <span class="o">=</span> <span class="n">on_command</span><span class="p">(</span><span class="s2">&#34;info&#34;</span><span class="p">)(</span><span class="n">get_info</span><span class="p">)</span>  <span class="c1"># on_command(&#34;info&#34;) 返回真正的装饰器</span>
</code></pre></td></tr></table>
</div>
</div><p>如果你的 <code>on_command</code> 有通用的部分，还可以将通用的部分抽离出来复用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">_deco_maker</span><span class="p">(</span><span class="n">event_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>  <span class="c1"># 调用这个，获取 on_xxx 的 deco_deco，</span>
    <span class="k">def</span> <span class="nf">deco_deco</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>   <span class="c1"># 这个对应 on_xxx</span>
        <span class="k">def</span> <span class="nf">deco</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span> <span class="c1"># 这个才是真正的装饰器</span>
            <span class="c1"># do something </span>
            <span class="k">return</span> <span class="n">func</span>  <span class="c1"># 返回原函数</span>

        <span class="k">return</span> <span class="n">deco</span>

    <span class="k">return</span> <span class="n">deco_deco</span>
</code></pre></td></tr></table>
</div>
</div><p>我们知道 Python 的类实际上是可以很方便的修改的，因此函数装饰器也能用于装饰类，修改类的某些行为。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">log_getattribute</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="c1"># Get the original implementation</span>
    <span class="n">orig_getattribute</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__getattribute__</span>

    <span class="c1"># Make a new definition</span>
    <span class="k">def</span> <span class="nf">new_getattribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;getting:&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">orig_getattribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="c1"># Attach to the class and return</span>
    <span class="bp">cls</span><span class="o">.</span><span class="fm">__getattribute__</span> <span class="o">=</span> <span class="n">new_getattribute</span>  <span class="c1"># 修改了被装饰类 cls 的 __getattribute__</span>
    <span class="k">return</span> <span class="bp">cls</span>

<span class="c1"># Example use</span>
<span class="nd">@log_getattribute</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="2-类定义装饰器">2. 类定义装饰器</h3>
<p>类定义装饰器和函数定义装饰器的使用方式完全一致。它也可以用于装饰函数或者类。</p>
<p>那么为啥还需要类定义装饰器呢？它的优势在于类是可以继承的，这样的话，就能用继承的方式定义装饰器，将通用部分定义成超类。</p>
<p>类定义装饰器的定义方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># PythonDecorators/entry_exit_class.py</span>
<span class="k">class</span> <span class="nc">entry_exit</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1">#关键在于这个函数，它使此类的对象变成 Callable</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Entering&#34;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Exited&#34;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

<span class="nd">@entry_exit</span>
<span class="k">def</span> <span class="nf">func1</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;inside func1()&#34;</span><span class="p">)</span>

<span class="c1"># 上面的装饰器相当于</span>
<span class="n">func1</span> <span class="o">=</span> <span class="n">entry_exit</span><span class="p">(</span><span class="n">func1</span><span class="p">)</span>  <span class="c1"># 从这里看的话，装饰器的行为完全一致</span>

<span class="c1"># 接下来调用该函数（实际上是调用了 entry_exit 对象的 call 函数）</span>
<span class="n">func1</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>输出结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Entering func1
inside func1()
Exited func1
</code></pre></td></tr></table>
</div>
</div><h2 id="五oop">五、OOP</h2>
<ol>
<li>
<p>调用超类方法：</p>
<ul>
<li>直接通过<code>超类名.__init__(self,xx)</code>调用</li>
<li>通过<code>super(__class__, self).__init__()</code>调用。
（Python3 可直接用 <code>super().__init__()</code>
但是要搞清楚，<strong><a href="https://docs.python.org/3/library/functions.html#super" target="_blank" rel="noopener noreferrer">super() 方法</a>返回的是一个代理类。另外被代理的类也不一定是其超类。如果不清楚这些差别，最好还是显式用方法一最好。</strong>）</li>
</ul>
</li>
<li>
<p>抽象超类：@abstractmethod</p>
</li>
<li>
<p><code>@staticmethod</code> <code>@classmethod</code> 与 Java 的 static 方法对比
python的类方法、静态方法，与java的静态方法：</p>
<ol>
<li>
<p>java 中 constants、utils 这样的静态类，对应的是python的一个模块（文件），类属性对应模块的全局属性，静态方法对应模块的函数</p>
</li>
<li>
<p>对于 java 中需要访问类属性的静态方法，如果它不属于第一类，应该用 <code>@classmethod</code> 实现它。classmethod最大的特点就是一定有一个 cls 传入。这种方法的主要用途是实现工厂函数。</p>
</li>
<li>
<p>对于不需要访问任何类属性，也不属于第一类的方法，应该用 <code>@staticmathod</code> 实现。这种方法其实完全不需要放到类里面，它就是一个独立的函数。（仍然放里面，是为了把功能类似的函数组织到一起而已。）</p>
</li>
</ol>
</li>
<li>
<p><code>__slots__</code>: 属性导出，不在该列表内的属性，若存在则为只读。不存在的话，就不存在。。
6.<code> __getattr__</code>: 拦截对不存在的属性的访问，可用于实现动态分配属性。</p>
</li>
<li>
<p><code>__getattribute__</code>: 和上面相同，但是它拦截对所有属性的访问，包括对已存在的属性的访问。</p>
</li>
<li>
<p>@property: 提供对属性访问的安全检查</p>
</li>
<li>
<p>descriptor: <strong>get</strong> <strong>set</strong> <strong>delete</strong> 控制对类的访问。（上面的 <strong>getattr</strong> 等是控制对类的属性的访问）</p>
</li>
<li>
<p>类构造器 <code>__new__</code>：在 <code>__init__</code> 之前运行，它接收一个 <code>cls</code> 参数，然后使用它构造并返回类实例 <code>self</code>。</p>
</li>
<li>
<p>类方法的 <code>cls</code> 即是当前类，是 type 的实例，<code>cls.xxx</code> 和 <code>&lt;类名&gt;.xxx</code> 调用结果是一致的。而 self 由 <code>__new__</code> 构造，是 cls 的实例。</p>
</li>
</ol>
<h3 id="元类-metaclasses">元类 metaclasses</h3>
<p>元类，也就是用于创建class 的 class，算是很高级的话题了（If you wonder whether you need metaclasses, you don’t ）
元类的工作流程：</p>
<ol>
<li>拦截类的创建</li>
<li>修改类</li>
<li>返回修改之后的类</li>
</ol>
<p>详细直接看 <a href="http://blog.jobbole.com/21351/" target="_blank" rel="noopener noreferrer">http://blog.jobbole.com/21351/</a> 吧。</p>
<h2 id="六查看-python-源码">六、查看 Python 源码</h2>
<p>对一般的标准库的模块，要查看其具体的 Python 实现是很简单的：直接通过 <code>__file__</code> 属性就能看到 <code>.py</code> 文件的位置。</p>
<p>但是 Python 很多功能是 C 写的，对于这类函数/类，<code>__file__</code> 就没啥用了。</p>
<p>如果是需要查看 <a href="https://stackoverflow.com/questions/8608587/finding-the-source-code-for-built-in-python-functions" target="_blank" rel="noopener noreferrer">builtins 模块</a> 的具体实现，直接查看 <a href="https://github.com/python/cpython/blob/master/Python/bltinmodule.c" target="_blank" rel="noopener noreferrer">Python/bltinmodule.c</a> 就行。</p>
<p>其他 C 模块的源码，待补充具体的查看方法。</p>
<h2 id="七参考文档">七、参考文档</h2>
<ul>
<li><a href="https://www.jb51.net/article/140443.htm" target="_blank" rel="noopener noreferrer">Python中一些不为人知的基础技巧总结</a></li>
</ul>
]]></description></item><item><title>Python 异步编程笔记：asyncio</title><link>https://thiscute.world/posts/python-asyncio/</link><pubDate>Thu, 14 Feb 2019 13:11:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/python-asyncio/</guid><description><![CDATA[<blockquote>
<p>个人笔记，不保证正确。</p>
</blockquote>
<p>虽然说看到很多人不看好 asyncio，但是这个东西还是必须学的。。
基于协程的异步，在很多语言中都有，学会了 Python 的，就一通百通。</p>
<h2 id="一生成器-generator">一、生成器 generator</h2>
<p>Python 的 asyncio 是通过 generator 实现的，要学习 async，先得复习下 generator.</p>
<h3 id="1-yield">1. yield</h3>
<p>众所周知，yield 是用于定义 generator 函数的关键字，调用该函数，会返回一个 generator</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">yield</span> <span class="mi">1</span>
<span class="o">...</span>     <span class="k">yield</span> <span class="mi">2</span>
<span class="o">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">()</span>  <span class="c1"># 返回的是 generator</span>
<span class="o">&lt;</span><span class="n">generator</span> <span class="nb">object</span> <span class="n">f</span> <span class="n">at</span> <span class="mh">0x7f672c460570</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>  <span class="c1"># 通过 next 方法从 generator 获取值</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">g</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span>  <span class="c1"># next 方法实际是调用了 generator 的 __next__ 方法</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>  <span class="c1"># 生成器运行结束，产生一个 StopIteration 的 exception</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&#34;&lt;stdin&gt;&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">StopIteration</span>
</code></pre></td></tr></table>
</div>
</div><p>每次调用 next，generator 都只会运行到下一个 yield 关键字所在行，返回 yield 右侧的对象，然后暂停在该处，等待下一次 next 调用。</p>
<p>从上面的例子看，yield 就是延迟求值而已。**但是 yield 还有一个特性，就是它是一个 expression，有返回值！**看例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
<span class="o">...</span>     <span class="n">r</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">1</span>
<span class="o">...</span>     <span class="k">yield</span> <span class="n">r</span>
<span class="o">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="n">func</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>  <span class="c1"># 通过 next 调用，yield 的返回值为 None</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">func</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">next</span><span class="p">(</span><span class="n">g2</span><span class="p">)</span>  <span class="c1"># 首先需要通过 next 调用，运行到 yield 语句处</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">g2</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">419</span><span class="p">)</span>  <span class="c1"># 现在用 send 方法，这会将当前所在的 yield 语句的值设置为你 send 的值，也就是 419</span>
<span class="mi">419</span>  <span class="c1"># 然后 generator 运行到下一个 yield，返回右边的值并暂停</span>
</code></pre></td></tr></table>
</div>
</div><p>generator 有四个实例函数：<strong>next</strong>、send 是刚刚已经介绍了的，此外还有 throw 用于从 yield 所在处抛出 Exception，和 close 用于关闭 Generator。详见 <a href="https://docs.python.org/3/reference/expressions.html#generator-iterator-methods" target="_blank" rel="noopener noreferrer">Generator-iterator methods</a></p>
<h3 id="2-yield-from-iterable">2. yield from <iterable></h3>
<p>可以理解成是 <code>yield &lt;value&gt; from &lt;iterable&gt;</code>，每次调用时它都会从 &lt;iterable&gt; 中取值，直到遇到 StopIteration。才会从下一个 yield 取值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">yield from</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>  <span class="c1"># iterable</span>
<span class="o">...</span>     <span class="k">yield</span> <span class="mi">5</span>
<span class="o">...</span>     <span class="k">yield from</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># iterable</span>
<span class="o">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">())</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>当然，<code>yield from &lt;iterable&gt;</code> 也是一个 expression，也有值。它的值就是 StopIteration 异常的第一个参数，内置类型的这个值都是 None.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
<span class="o">...</span>     <span class="n">r</span> <span class="o">=</span> <span class="k">yield from</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="o">...</span>     <span class="k">yield</span> <span class="sa">f</span><span class="s2">&#34;value of yield from is </span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s2">&#34;</span>
<span class="o">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">())</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;value of yield from is None&#39;</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>当 &lt;iterable&gt; 是 generator 时，<code>yield from</code> 会直接将函数调用委托给这个子 generator，这里的调用包括了前面说过的 next、send、throw、close 四个函数。
并直接将 sub generator yield 的值 yield 给 caller.</p>
<h3 id="3-yield-和-return-混用会发生什么">3. yield 和 return 混用会发生什么？</h3>
<p>generator 中的 <code>return value</code>，语义上等同于 <code>rasie StopIteration(value)</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">&gt;&gt;&gt; def f<span class="o">()</span>:
...     yield <span class="m">1</span>
...     <span class="k">return</span> <span class="m">2</span>
...     yield <span class="m">3</span>  <span class="c1"># 永远不会被执行</span>
... 
&gt;&gt;&gt; <span class="nv">g</span> <span class="o">=</span> f<span class="o">()</span>
&gt;&gt;&gt; next<span class="o">(</span>g<span class="o">)</span>
<span class="m">1</span>
&gt;&gt;&gt; next<span class="o">(</span>g<span class="o">)</span>  <span class="c1"># return 引发 StopIteration</span>
Traceback <span class="o">(</span>most recent call last<span class="o">)</span>:
  File <span class="s2">&#34;&lt;input&gt;&#34;</span>, line 1, in &lt;module&gt;
StopIteration: <span class="m">2</span>
&gt;&gt;&gt; next<span class="o">(</span>g<span class="o">)</span>  <span class="c1"># 再次调用，StopIteration 变成无参了。</span>
Traceback <span class="o">(</span>most recent call last<span class="o">)</span>:
  File <span class="s2">&#34;&lt;input&gt;&#34;</span>, line 1, in &lt;module&gt;
StopIteration
</code></pre></td></tr></table>
</div>
</div><p>可以看到 return 引发了 StopIteration 异常，而 return 的值则成了该异常的第一个参数。</p>
<p>之前说过 <code>yield from &lt;sub generator&gt;</code> 表达式的值，就是该 &lt;sub generator&gt; 的 StopIteration 异常的第一个参数，因此：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">&gt;&gt;&gt; def f2<span class="o">()</span>:
...     <span class="nv">a</span> <span class="o">=</span> yield from f<span class="o">()</span>
...     yield a  <span class="c1"># a 是 f() 中 return 的值</span>
...     
&gt;&gt;&gt; list<span class="o">(</span>f2<span class="o">())</span>
<span class="o">[</span>1, 2<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><a href="https://www.python.org/dev/peps/pep-0479/#background-information" target="_blank" rel="noopener noreferrer">PEP 479 &ndash; Change StopIteration handling inside generators</a> 修改了StopIteration 的行为，该 PEP 使人为 raise 的 StopIteration 引发一个 RuntimeError。
该 PEP 在 Python 3.5 版本添加到 <strong>future</strong> 中，并在 Python 3.7 成为默认行为。
因此除非你确实想要引发异常，否则应该使用 return 来结束一个 generator 并返回值。</p>
</blockquote>
<h2 id="二异步io协程与非阻塞-io">二、异步IO、协程与非阻塞 IO</h2>
<p>先了解一下 <a href="https://www.cnblogs.com/kirito-c/p/10306133.html" target="_blank" rel="noopener noreferrer">进程线程协程与并发并行</a> 和 <a href="https://www.cnblogs.com/kirito-c/p/10306234.html" target="_blank" rel="noopener noreferrer">各种 IO 模型</a></p>
<h2 id="三asyncio-的简单使用">三、asyncio 的简单使用</h2>
<p>asyncio 引入了两个新关键字：async 和 await，其中 async 能放在三个地方：</p>
<ol>
<li>async def：用于定义异步函数和异步生成器
<ul>
<li>不含有 yield 的是 async def 定义的是协程函数（coroutine function），调用该函数返回协程对象（coroutine object），协程对象需要通过 EventLoop 运行。</li>
<li>内部含有 yield 的 async def 定义的是异步生成器函数（asynchronous generator function），调用该函数返回异步生成器（async_generator）
<ul>
<li>异步生成器只能用在 Coroutine 中</li>
</ul>
</li>
<li>async def 中不允许使用 yield from</li>
</ul>
</li>
<li>async for：表示 for 迭代的是一个异步生成器，该 for 循环的每一次迭代，都是异步的。
<ul>
<li>只能用在 async def 的内部</li>
</ul>
</li>
<li>async with：表示 with 管理的是一个异步上下文管理器（asynchronous context manager）
<ul>
<li>该 context manager 的 enter 和 exit 两个步骤是异步的</li>
<li>只能用在 async def 的内部</li>
</ul>
</li>
</ol>
<p>注意异步 generator、context manager，它的 protocol 都和同步的不同，不能混为一谈。
具体而言，对同步 protocol <strong>xxx</strong> 函数，它的异步版本为 <strong>axxx</strong>，就是加个 a。</p>
<p>而 await，就相当于 yield from，差别在于 await 是异步的。还有我们关心的是 await 表达式的值，而 yield from 中我们更关心它向上层 yield 的值。</p>
<p>在 yield from 中，当前生成器调用另一个生成器，当前生成器会挂起，直到另一个生成器返回。</p>
<p>但是在 await 中，当前 Coroutine 挂起时， eventloop 会寻找其他 task 来跑，这就利用上了 IO 漫长的等待时间。</p>
<p>async for 是每次迭代都会 await 一次，如果迭代对象是 IO 操作，这个 IO 等待时间就会被利用上。</p>
<p>async with 也是同样，如果 context 的 enter 和 exit 是 IO 操作，这个 IO 时间就会被 eventloop 用于运行其他 task.</p>
<p>使用 asyncio 时，我们要用 async def 将所有的 IO 操作都定义成异步操作。然后在调用时，都使用 await/async for/async with 来调用。</p>
<h2 id="四coroutinetask-和-future">四、Coroutine、Task 和 Future</h2>
<p>首先，每个协程对象，都是一个独立的协程单元，协程对象之间可以异步运行。</p>
<p>协程需要放到 EventLoop 内运行，要运行一个协程 a，有三种方法：</p>
<ol>
<li>通过 asyncio.run(coro) 运行一个协程。
<ul>
<li>该方法会新建一个 EventLoop</li>
</ul>
</li>
<li>在另一个协程 b 中通过 await 调用 a。当 b 运行时， a 也会被 task 运行。</li>
<li>通过 asyncio.create_task(coro)，将需要运行的协程包装成 task，然后通过 task 相关的方法来异步运行它们。
<ul>
<li>asyncio.gather(*awaitable_objects): 并发执行所有的 task，阻塞到所有 task 结束。返回一个 result 列表。result 的列表顺序和 future 的顺序一致</li>
<li>asyncio.as_completed(aws, *, loop=None, timeout=None)，和 gather 的区别在于，它返回一个异步迭代器，每次迭代都返回最先完成的一个 future.</li>
</ul>
</li>
</ol>
<blockquote>
<p>concurrent.futures 是进程线程的异步执行，而 asyncio 是基于协程的单线程异步执行</p>
</blockquote>
<h2 id="五参考">五、参考</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/25228075" target="_blank" rel="noopener noreferrer">从0到1，Python异步编程的演进之路</a></li>
<li><a href="https://www.zhihu.com/question/294188439/answer/555273313" target="_blank" rel="noopener noreferrer">怎么掌握 asyncio</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27258289" target="_blank" rel="noopener noreferrer">Python Async/Await入门指南</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/30275154" target="_blank" rel="noopener noreferrer">谈谈Python协程技术的演进</a></li>
<li><a href="https://docs.python.org/3/reference/compound_stmts.html#coroutines" target="_blank" rel="noopener noreferrer">Python Doc - Coroutines</a></li>
<li><a href="https://docs.python.org/3/library/asyncio.html" target="_blank" rel="noopener noreferrer">Python Doc - asyncio</a></li>
</ul>
]]></description></item><item><title>SQLAlchemy 学习笔记（二）：ORM 基础</title><link>https://thiscute.world/posts/sqlalchemy-notes-2-orm-basics/</link><pubDate>Mon, 11 Feb 2019 19:52:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/sqlalchemy-notes-2-orm-basics/</guid><description><![CDATA[<p>照例先看层次图</p>
<p><figure><a class="lightgallery" href="/images/sqlalchemy-notes/sqlalchemy-arch.png" title="/images/sqlalchemy-notes/sqlalchemy-arch.png" data-thumbnail="/images/sqlalchemy-notes/sqlalchemy-arch.png" data-sub-html="<h2>SQLAlchemy 层次结构</h2>">
        
    </a><figcaption class="image-caption">SQLAlchemy 层次结构</figcaption>
    </figure></p>
<h3 id="一声明映射关系">一、声明映射关系</h3>
<p>使用 ORM 时，我们首先需要定义要操作的表（通过 <code>Table</code>），然后再定义该表对应的 Python class，并声明两者之间的映射关系（通过 <code>Mapper</code>）。</p>
<p>方便起见，SQLAlchemy 提供了 Declarative 系统来一次完成上述三个步骤，Declarative 系统提供 base class，这个 base class 会为继承了它的 Python class（可称作 model）创建 Table，并维护两者的映射关系。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="kn">import</span> <span class="n">declarative_base</span>
<span class="kn">from</span> <span class="nn">SQLAlchemy</span> <span class="kn">import</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>  <span class="c1"># 拿到 Base 类</span>


<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># 添加 index 提升搜索效率</span>
    <span class="n">fullname</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
    <span class="n">password</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span>  <span class="c1"># 真实情况下一般只存 hash</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&#34;&lt;User </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2">&gt;&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>这样就声明好了一个对象-关系映射，上一篇文章说过所有的 Table 都在某个 MetaData 中，可以通过 <code>Base.metadata</code> 获取它。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>  <span class="c1"># 通过 metadata 创建表（或者说生成模式 schema）</span>
</code></pre></td></tr></table>
</div>
</div><p>engine 的创建请见上篇文档 <a href="https://www.cnblogs.com/kirito-c/p/10269485.html" target="_blank" rel="noopener noreferrer">SQLAlchemy 学习笔记（一）：Engine 与 SQL 表达式语言</a></p>
<h4 id="约束条件">约束条件</h4>
<blockquote>
<p>可参考 <a href="https://www.cnblogs.com/kirito-c/p/10295693.html" target="_blank" rel="noopener noreferrer">SQL 基础笔记（三）：约束</a> 与 <a href="https://www.cnblogs.com/kirito-c/p/10269485.html#%E8%A1%A8%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%BA%A6%E6%9D%9F" target="_blank" rel="noopener noreferrer">SQLAlchemy 学习笔记（一）：Engine 与 SQL 表达式语言 - 表定义中的约束</a></p>
</blockquote>
<p>使用 ORM 来定义约束条件，与直接使用 SQL 表达式语言定义很类似，也有两种方法：</p>
<ol>
<li>直接将约束条件作为 <code>Column</code>、<code>ForeignKey</code> 的参数传入。这种方式最简洁，也最常用。</li>
<li>使用 <code>UniqueConstraint</code>、<code>CheckConstraint</code> 等类构造约束，然后放入 <code>__table_args__</code> 属性中。举例：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># 添加 index 提升搜索效率</span>
    <span class="n">fullname</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
    <span class="n">password</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span>  <span class="c1"># 真实情况下一般只存 hash</span>

    <span class="c1"># 顾名思义，这是 `Table` 类的参数的序列。里面的约束条件会被用于构建 __table__</span>
    <span class="n">__table_args__</span> <span class="o">=</span> <span class="p">(</span><span class="n">UniqueConstraint</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;c_user&#39;</span><span class="p">),)</span>  <span class="c1"># username 的唯一性约束</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&#34;&lt;User </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2">&gt;&#34;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="二获取-session">二、获取 session</h3>
<p>上一节讲 engine 时，我们是通过 connection 来与数据库交互，而在 ORM 中我们使用 Session 访问数据库。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">sessionmaker</span>

<span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>  <span class="c1"># 获取 session</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="三增删改查">三、增删改查</h3>
<p>直接使用 SQL 表达式语言时，我们使用 insert()、select()、update()、delete() 四个函数构造 SQL，使用 where() 添加条件，使用 model.join(another_model) 进行 join 操作。
而使用 ORM 时，数据库操作不再与 SQL 直接对应。我们现在是通过操作 Python 对象来操作数据库了。</p>
<p>现在，我们通过 db.session.add()、db.session.delete() 进行添加与删除，使用 db.session.query(Model) 进行查询，通过 filter 和 filter_by 添加过滤条件。
而修改，则是先查询出对应的 row 对象，直接修改这个对象，然后 commit 就行。</p>
<ol>
<li>增添：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">ed_user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="s1">&#39;edspassword&#39;</span><span class="p">)</span>  <span class="c1"># 用构造器构造对象</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ed_user</span><span class="p">)</span>  <span class="c1"># 添加，此外还有批量添加 add_all([user1, user2...])</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># 必须手动 commit</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>修改：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">ed_user</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>  <span class="c1"># 先获取到 User 对象</span>
<span class="n">ed_user</span><span class="o">.</span><span class="n">password</span> <span class="o">=</span> <span class="s1">&#39;f8s7ccs&#39;</span>  <span class="c1"># 改了密码</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># 提交</span>

<span class="c1"># 批量修改</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">home</span><span class="o">==</span><span class="s1">&#39;shanghai&#39;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">User</span><span class="o">.</span><span class="n">login_num</span><span class="p">:</span><span class="mi">0</span><span class="p">})</span>  <span class="c1"># 将所有上海的用户的 login_num 设为 0</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>删除：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">ed_user</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>  <span class="c1"># 先获取到 User 对象</span>
<span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ed_user</span><span class="p">)</span>  <span class="c1"># 直接删除（session 知道 ed_user 属于哪个表）</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># 提交</span>

<span class="c1"># 批量删除</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">home</span><span class="o">==</span><span class="s1">&#39;shanghai&#39;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">delete</span><span class="p">()</span>  <span class="c1"># 删除所有上海的用户</span>

<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>同样的，也可以在外面检查异常，然后调用 <code>session.rollback()</code> 实现失败回滚。</p>
<h3 id="四进阶查询">四、进阶查询</h3>
<ol>
<li>filter_by：使用关键字参数进行过滤，前面的演示中已经用过多次了。</li>
<li>filter：它对应 SQL 表达式语言中的 where，支持各种复杂的 SQL 语法。</li>
<li>group_by: 通过指定 column 分组</li>
<li>distinct(): 去重</li>
<li>join(): 关联</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ed&#39;</span><span class="p">)</span>  <span class="c1"># 这个等同于 filter_by，但是更繁琐</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;ed&#39;</span><span class="p">)</span>  <span class="c1"># 不等于，这个就是 filter_by 无法做到的了</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">d%&#39;</span><span class="p">))</span>  <span class="c1"># SQL like 的 like 语法</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="s1">&#39;jack&#39;</span><span class="p">]))</span>  <span class="c1"># 包含</span>

<span class="c1"># 查询还可以嵌套</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">in_</span><span class="p">(</span>
    <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">d%&#39;</span><span class="p">))</span>
<span class="p">))</span>

<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">~</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="s1">&#39;jack&#39;</span><span class="p">]))</span>  <span class="c1"># 不包含</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># NULL 对应 Python 的 None</span>

<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">or_</span><span class="p">,</span> <span class="n">and_</span><span class="p">,</span> <span class="n">in_</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">or_</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;wendy&#39;</span><span class="p">))</span>  <span class="c1"># OR 语法</span>

<span class="n">query</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># 分组</span>
<span class="n">query</span><span class="o">.</span><span class="n">distinct</span><span class="p">()</span>  <span class="c1"># 去重</span>

<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">func</span>  <span class="c1"># SQL 函数包</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">))</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">xxx</span><span class="o">=</span><span class="n">xxx</span><span class="p">)</span>  <span class="c1"># 使用 count 函数</span>

<span class="c1"># join 关联</span>
<span class="c1"># 默认使用内联（inner），即只取两表的交集</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="o">==</span><span class="n">Address</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>  <span class="c1"># 方法一</span>

<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span>\  <span class="c1"># 方法二</span>
    <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">==</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">)</span>

<span class="c1"># 外联 outer join，将另一表的列联结到主表，没有的行为 NULL</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">outerjoin</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">==</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="执行查询获取数据">执行查询，获取数据</h4>
<p>查询返回 query 对象，但 SQL 还没有被执行，直到你调用下列几个方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 构造 query 对象</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">d&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

<span class="c1"># 1. all 返回所有结果的列表</span>
<span class="n">res_list</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="c1"># 2. first 先在 SQL 中加入限制 `limit 1`，然后执行。</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>

<span class="c1"># 3. one 执行 sql 并获取所有结果</span>
<span class="c1"># 如果结果不止一行，抛出 MultipleResultsFound Error！！！</span>
<span class="c1"># 如果结果为空，抛出 NoResultFound Error ！！！</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>

<span class="mf">4.</span> <span class="n">one_or_none</span> <span class="n">差别在于结果为空</span><span class="err">，</span><span class="n">它不抛出异常</span><span class="err">，</span><span class="n">而是返回</span> <span class="kc">None</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">one_or_none</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="参考">参考</h3>
<ul>
<li><a href="https://docs.sqlalchemy.org/en/latest/orm/tutorial.html" target="_blank" rel="noopener noreferrer">SQLAlchemy 对象关系入门</a></li>
<li><a href="https://docs.sqlalchemy.org/en/latest/orm/basic_relationships.html" target="_blank" rel="noopener noreferrer">SQLAlchemy ORM 的关联映射定义：一对多、多对多</a></li>
<li><a href="https://github.com/hackersandslackers/sqlalchemy-tutorial" target="_blank" rel="noopener noreferrer">hackersandslackers/sqlalchemy-tutorial</a></li>
</ul>
]]></description></item><item><title>SQLAlchemy 学习笔记（一）：Engine 与 SQL 表达式语言</title><link>https://thiscute.world/posts/sqlalchemy-notes-1-engine-and-sql-expression-language/</link><pubDate>Mon, 21 Jan 2019 14:02:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/sqlalchemy-notes-1-engine-and-sql-expression-language/</guid><description><![CDATA[<blockquote>
<p>个人笔记，如有错误烦请指正。</p>
</blockquote>
<p>SQLAlchemy 是一个用 Python 实现的 ORM （Object Relational Mapping）框架，它由多个组件构成，这些组件可以单独使用，也能独立使用。它的组件层次结构如下：</p>
<p><figure><a class="lightgallery" href="/images/sqlalchemy-notes/sqlalchemy-arch.png" title="/images/sqlalchemy-notes/sqlalchemy-arch.png" data-thumbnail="/images/sqlalchemy-notes/sqlalchemy-arch.png" data-sub-html="<h2>SQLAlchemy 层次结构</h2>">
        
    </a><figcaption class="image-caption">SQLAlchemy 层次结构</figcaption>
    </figure></p>
<p>其中最常用的组件，应该是 <strong>ORM</strong> 和 <strong>SQL 表达式语言</strong>，这两者既可以独立使用，也能结合使用。</p>
<p><strong>ORM</strong> 的好处在于它</p>
<ol>
<li>自动处理了数据库和 Python 对象之间的映射关系，屏蔽了两套系统之间的差异。程序员不需要再编写复杂的 SQL 语句，直接操作 Python 对象就行。</li>
<li>屏蔽了各数据库之间的差异，更换底层数据库不需要修改 SQL 语句，改下配置就行。</li>
<li>使数据库结构文档化，models 定义很清晰地描述了数据库的结构。</li>
<li>避免了不规范、冗余、风格不统一的 SQL 语句，可以避免很多人为 Bug，也方便维护。</li>
</ol>
<p>但是 ORM 需要消耗额外的性能来处理对象关系映射，此外用 ORM 做多表关联查询或复杂 SQL 查询时，效率低下。因此它适用于场景不太复杂，性能要求不太苛刻的场景。</p>
<p>都说 ORM 学习成本高，我自己也更倾向于直接使用 SQL 语句（毕竟更熟悉），因此这一篇笔记不涉及 ORM 部分，只记录 SQLAlchemy 的 Engine 与 SQL 表达式语言。</p>
<h2 id="一直接使用-enginehttpsdocssqlalchemyorgenlatestcoreengineshtmlsqlalchemycreate_engine-和-connections">一、直接使用 <a href="https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine" target="_blank" rel="noopener noreferrer">Engine</a> 和 Connections</h2>
<p>第一步是创建数据库引擎实例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite:///:memory:&#39;</span><span class="p">,</span> 
                    <span class="n">echo</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># echo=True 表示打印出自动生成的 SQL 语句（通过 logging）</span>
                    <span class="n">pool_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>  <span class="c1"># 连接池容量，默认为 5，生产环境下太小，需要修改。</span>
                    <span class="c1"># 下面是 connection 回收的时间限制，默认 -1 不回收</span>
                    <span class="n">pool_recycle</span><span class="o">=</span><span class="mi">7200</span><span class="p">)</span>   <span class="c1"># 超过 2 小时就重新连接（MySQL 默认的连接最大闲置时间为 8 小时）</span>
</code></pre></td></tr></table>
</div>
</div><p><code>create_engine</code> 接受的第一个参数是数据库 URI，格式为 <code>dialect+driver://username:password@host:port/database</code>，dialect 是具体的数据库名称，driver 是驱动名称。key-value 是可选的参数。举例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># PostgreSQL</span>
postgresql+psycopg2://scott:tiger@localhost/dbtest

<span class="c1"># MySQL + PyMySQL（或者用更快的  mysqlclient）</span>
mysql+pymysql://scott:tiger@localhost/dbtest

<span class="c1"># sqlite 内存数据库</span>
<span class="c1"># 注意 sqlite 要用三个斜杠，表示不存在 hostname，sqlite://&lt;nohostname&gt;/&lt;path&gt;</span>
sqlite:///:memory:

<span class="c1"># sqlite 文件数据库</span>
<span class="c1"># 四个斜杠是因为文件的绝对路径以 / 开头：/home/ryan/Codes/Python/dbtest.db</span>
sqlite:////home/ryan/Codes/Python/dbtest.db

<span class="c1"># SQL Server + pyodbc</span>
<span class="c1"># 首选基于 dsn 的连接，dsn 的配置请搜索hhh</span>
mssql+pyodbc://scott:tiger@some_dsn
</code></pre></td></tr></table>
</div>
</div><p>如果你的密码中含有 &lsquo;@&rsquo; 等特殊字符，就不能直接放入 URI 中，必须使用 <code>urllib.parse.quote_plus</code> 编码，然后再插入 URI.</p>
<p>引擎创建后，我们就可以直接获取 connection，然后执行 SQL 语句了。这种用法相当于把 SQLAlchemy 当成带 log 的数据库连接池使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&#34;select username from users&#34;</span><span class="p">)</span>  <span class="c1"># 无参直接使用</span>

    <span class="c1"># 使用问号作占位符，前提是下层的 DBAPI 支持。更好的方式是使用 text()，这个后面说</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&#34;INSERT INTO table (id, value) VALUES (?, ?)&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&#34;v1&#34;</span><span class="p">)</span>  <span class="c1"># 参数不需要包装成元组</span>

    <span class="c1"># 查询返回的是 ResultProxy 对象，有和 dbapi 相同的 fetchone()、fetchall()、first() 等方法，还有一些拓展方法</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;username:&#34;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><p>但是要注意的是，connection 的 execute 是自动提交的（autocommit），这就像在 shell 里打开一个数据库客户端一样，分号结尾的 SQL 会被自动提交。
只有在 <code>BEGIN TRANSACTION</code> 内部，<code>AUTOCOMMIT</code> 会被临时设置为 <code>FALSE</code>，可以通过如下方法开始一个内部事务：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">transaction_a</span><span class="p">(</span><span class="n">connection</span><span class="p">):</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>  <span class="c1"># 开启一个 transaction</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># do sthings</span>
        <span class="n">trans</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># 这里需要手动提交</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">trans</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>  <span class="c1"># 出现异常则 rollback</span>
        <span class="k">raise</span>
<span class="c1"># do other things</span>

<span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="n">transaction_a</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="1-使用-texthttpsdocssqlalchemyorgenlatestcoresqlelementhtmlsqlalchemysqlexpressiontext-构建-sql">1. 使用 <a href="https://docs.sqlalchemy.org/en/latest/core/sqlelement.html#sqlalchemy.sql.expression.text" target="_blank" rel="noopener noreferrer">text()</a> 构建 SQL</h3>
<p>相比直接使用 string，text() 的优势在于它：</p>
<ol>
<li>提供了统一的参数绑定语法，与具体的 DBAPI 无关。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 1. 参数绑定语法</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">text</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
            <span class="c1"># 使用 :key 做占位符</span>
            <span class="n">text</span><span class="p">(</span><span class="s1">&#39;select * from table where id &lt; :id and typeName=:type&#39;</span><span class="p">),</span>
            <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span><span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="s1">&#39;USER_TABLE&#39;</span><span class="p">})</span>  <span class="c1"># 用 dict 传参数，更易读</span>

<span class="c1"># 2. 参数类型指定</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">DateTime</span>

<span class="n">date_param</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">today</span><span class="p">()</span><span class="o">+</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=-</span><span class="mi">1</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span>
<span class="n">sql</span><span class="o">=</span><span class="s2">&#34;delete from caw_job_alarm_log  where alarm_time &lt; :alarm_time_param&#34;</span>

<span class="c1"># bindparams 是 bindparam 的列表，bindparam 则提供参数的一些额外信息（类型、值、限制等）</span>
<span class="n">t</span><span class="o">=</span><span class="n">text</span><span class="p">(</span><span class="n">sql</span><span class="p">,</span> <span class="n">bindparams</span><span class="o">=</span><span class="p">[</span><span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;alarm_time_param&#39;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">DateTime</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">)])</span>
<span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">{</span><span class="s2">&#34;alarm_time_param&#34;</span><span class="p">:</span> <span class="n">date_param</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>可以很方便地转换 Result 中列的类型</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">stmt = text(&#34;SELECT * FROM table&#34;,
            # 使用 typemap 指定将 id 列映射为 Integer 类型，name 映射为 String 类型
            typemap={&#39;id&#39;: Integer, &#39;name&#39;: String},
          )
result = connection.execute(stmt)
# 对多个查询结果，可以用 for obj in result 遍历
# 也可用 fetchone() 只获取一个
</code></pre></td></tr></table>
</div>
</div><h2 id="二sql-表达式语言">二、SQL 表达式语言</h2>
<blockquote>
<p>复杂的 SQL 查询可以直接用 raw sql 写，而增删改一般都是单表操作，用 SQL 表达式语言最方便。</p>
</blockquote>
<p>SQLAlchemy 表达式语言是一个使用 Python 结构表示关系数据库结构和表达式的系统。</p>
<h3 id="1-定义并创建表">1. 定义并创建表</h3>
<p>SQL 表达式语言使用 Table 来定义表，而表的列则用 Column 定义。Column 总是关联到一个 Table 对象上。</p>
<p>一组 Table 对象以及它们的子对象的集合就被称作「数据库元数据（database metadata）」。metadata 就像你的网页分类收藏夹，相关的 Table 放在一个 metadata 中。</p>
<p>下面是创建元数据（一组相关联的表）的例子，：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">ForeignKey</span>

<span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>  <span class="c1"># 先创建元数据（收藏夹）</span>

<span class="n">users</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>  <span class="c1"># 创建 user 表，并放到 metadata 中</span>
              <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
              <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">),</span>
              <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;fullname&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span>
             <span class="p">)</span>

<span class="n">addresses</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;user_id&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;user.id&#39;</span><span class="p">)),</span>  <span class="c1"># 外键约束，引用 user 表的 id 列</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;email_address&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                 <span class="p">)</span>

<span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>  <span class="c1"># 使用 engine 创建 metadata 内的所有 Tables（会检测表是否已经存在，所以可以重复调用）</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="表定义中的约束">表定义中的约束</h4>
<blockquote>
<p>应该给所有的约束命名，即为 <code>name</code> 参数指定一个不冲突的列名。详见 <a href="https://alembic.sqlalchemy.org/en/latest/naming.html" target="_blank" rel="noopener noreferrer">The Importance of Naming Constraints</a></p>
</blockquote>
<p>表还有一个属性：<a href="https://www.cnblogs.com/kirito-c/p/10295693.html" target="_blank" rel="noopener noreferrer">约束条件</a>。下面一一进行说明。</p>
<ol>
<li><strong>外键约束</strong>：用于在删除或更新某个值或行时，对主键/外键关系中一组数据列强制进行的操作限制。
<ol>
<li>用法一：<code>Column('user_id', None, ForeignKey('user.id'))</code>，直接在 <code>Column</code> 中指定。这也是最常用的方法</li>
<li>用法二：通过 <code>ForeignKeyConstraint(columns, refcolumns)</code> 构建约束，作为参数传给 <code>Table</code>.</li>
</ol>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">item</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;item&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>  <span class="c1"># 商品 table</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;invoice_id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>  <span class="c1"># 发票 id，是外键</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;ref_num&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
    <span class="n">ForeignKeyConstraint</span><span class="p">([</span><span class="s1">&#39;invoice_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ref_num&#39;</span><span class="p">],</span>  <span class="c1"># 当前表中的外键名称</span>
                         <span class="p">[</span><span class="s1">&#39;invoice.id&#39;</span><span class="p">,</span> <span class="s1">&#39;invoice.ref_num&#39;</span><span class="p">])</span>  <span class="c1"># 被引用的外键名称的序列（被引用的表）</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li><code>on delete</code> 与 <code>on update</code>：<strong>外键约束的两个约束条件</strong>，通过 <code>ForeignKey()</code> 或 <code>ForeignKeyConstraint()</code> 的关键字参数 <code>ondelete/onupdate</code> 传入。
可选值有：
<ol>
<li><strong>默认行为 <code>NO ACTION</code></strong>：什么都不做，直接报错。</li>
<li><code>CASCADE</code>：删除/更新 父表数据时，<strong>从表数据会同时被 删除/更新</strong>。（无报错）</li>
<li><code>RESTRICT</code>：<strong>不允许直接 删除/更新 父表数据</strong>，直接报错。（和默认行为基本一致）</li>
<li><code>SET NULL</code> or <code>SET DEFAULT</code>：删除/更新 父表数据时，将对应的从表数据重置为 <code>NULL</code> 或者默认值。</li>
</ol>
</li>
<li><strong>唯一性约束</strong>：<code>UniqueConstraint('col2', 'col3', name='uix_1')</code>，作为参数传给 <code>Table</code>.</li>
<li><strong>CHECK 约束</strong>：<code>CheckConstraint('col2 &gt; col3 + 5', name='check1')</code>， 作为参数传给 <code>Table</code>.</li>
<li>主键约束：不解释
<ol>
<li>方法一：通过 <code>Column('id', Integer, primary_key=True)</code> 指定主键。（参数 <code>primary_key</code> 可在多个 <code>Column</code> 上使用）</li>
<li>方法二：使用 <code>PrimaryKeyConstraint</code></li>
</ol>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">PrimaryKeyConstraint</span>

<span class="n">my_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;mytable&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
            <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">),</span>
            <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;version_id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">),</span>
            <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">)),</span>
            <span class="n">PrimaryKeyConstraint</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;version_id&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;mytable_pk&#39;</span><span class="p">)</span>
        <span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="2-增删改查语句">2. 增删改查语句</h3>
<ol>
<li><strong>增</strong>:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 方法一，使用 values 传参</span>
<span class="n">ins</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&#34;Jack&#34;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s2">&#34;Jack Jones&#34;</span><span class="p">)</span>  <span class="c1"># 可以通过 str(ins) 查看自动生成的 sql</span>
<span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>

<span class="c1"># 方法二，参数传递给 execute()</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Wendy Williams&#39;</span><span class="p">)</span>

<span class="c1"># 方法三，批量 INSERT，相当于 executemany</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="p">[</span>  <span class="c1"># 插入到 addresses 表</span>
    <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span><span class="p">:</span> <span class="s1">&#39;jack@yahoo.com&#39;</span><span class="p">},</span>  <span class="c1"># 传入 dict 列表</span>
    <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span><span class="p">:</span> <span class="s1">&#39;jack@msn.com&#39;</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span><span class="p">:</span> <span class="s1">&#39;www@www.org&#39;</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span><span class="p">:</span> <span class="s1">&#39;wendy@aol.com&#39;</span><span class="p">}</span>
<span class="p">])</span>

<span class="c1"># 此外，通过使用 bindparam，INSERT 还可以执行更复杂的操作</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span> \ 
         <span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&#34; .. name&#34;</span><span class="p">)</span>  <span class="c1"># string 拼接</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="p">[</span>
        <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;_name&#39;</span><span class="p">:</span><span class="s1">&#39;name1&#39;</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;_name&#39;</span><span class="p">:</span><span class="s1">&#39;name2&#39;</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;_name&#39;</span><span class="p">:</span><span class="s1">&#39;name3&#39;</span><span class="p">},</span>
     <span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li><strong>删</strong>：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">_table</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span> \
        <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">f1</span><span class="o">==</span><span class="n">value1</span><span class="p">)</span> \
        <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">f2</span><span class="o">==</span><span class="n">value2</span><span class="p">)</span>  <span class="c1"># where 指定条件</span>
</code></pre></td></tr></table>
</div>
</div><ol start="3">
<li><strong>改</strong>：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 举例</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">()</span> \
             <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;jack&#39;</span><span class="p">)</span> \
             <span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;tom&#39;</span><span class="p">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>

<span class="c1"># 批量更新</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">()</span> \
             <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;oldname&#39;</span><span class="p">))</span> \
             <span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;newname&#39;</span><span class="p">))</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="p">[</span>
     <span class="p">{</span><span class="s1">&#39;oldname&#39;</span><span class="p">:</span><span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="s1">&#39;newname&#39;</span><span class="p">:</span><span class="s1">&#39;ed&#39;</span><span class="p">},</span>
     <span class="p">{</span><span class="s1">&#39;oldname&#39;</span><span class="p">:</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="s1">&#39;newname&#39;</span><span class="p">:</span><span class="s1">&#39;mary&#39;</span><span class="p">},</span>
     <span class="p">{</span><span class="s1">&#39;oldname&#39;</span><span class="p">:</span><span class="s1">&#39;jim&#39;</span><span class="p">,</span> <span class="s1">&#39;newname&#39;</span><span class="p">:</span><span class="s1">&#39;jake&#39;</span><span class="p">},</span>
     <span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，所有的条件都是通过 <code>where</code> 指定的，它和后面 ORM 的 filter 接受的参数是一样的。（详细的会在第二篇文章里讲）</p>
<ol start="4">
<li><strong>查</strong></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">select</span>

<span class="c1"># 1. 字段选择</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">])</span>  <span class="c1"># 相当于 select * from users</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">])</span>  <span class="c1"># 这个就是只 select 一部分</span>

<span class="c1"># 2. 添加过滤条件</span>
<span class="n">s3</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">])</span> \
    <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span> 

<span class="n">res</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
<span class="c1"># 可用 for row in res 遍历结果集，也可用 fetchone() 只获取一行</span>
</code></pre></td></tr></table>
</div>
</div><p>查询返回的是 ResultProxy 对象，这是 SQLAlchemy 对 Python DB-API 的 cursor 的一个封装类，要从中获取结果行，主要有下列几个方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">row1</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>  <span class="c1"># 对应 cursor.fetchone()</span>
<span class="n">row2</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>  <span class="c1"># 对应 cursor.fetchall()</span>
<span class="n">row3</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fetchmany</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># 对应 cursor.fetchmany(size=3)</span>

<span class="n">row4</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>  <span class="c1"># 获取一行，然后立即调用 result 的 close() 方法</span>

<span class="n">col</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">mytable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">mycol</span><span class="p">]</span> <span class="c1"># 获取 mycol 这一列</span>

<span class="n">result</span><span class="o">.</span><span class="n">rowcount</span>  <span class="c1"># 结果集的行数</span>

<span class="n">同时</span><span class="err">，</span><span class="n">result</span> <span class="n">也实现了</span> <span class="nb">next</span> <span class="n">protocol</span><span class="err">，</span><span class="n">因此可以直接用</span> <span class="k">for</span> <span class="n">循环遍历</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="where-进阶">where 进阶</h3>
<p>通过使用 or_、and_、in_ model.join 等方法，where 可以构建更复杂的 SQL 语句。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">and_</span><span class="p">,</span> <span class="n">or_</span><span class="p">,</span> <span class="n">not_</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span> <span class="o">+</span>
               <span class="s2">&#34;, &#34;</span> <span class="o">+</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span>
                <span class="n">label</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">)])</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">))</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span>
               <span class="n">or_</span><span class="p">(</span>
                  <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@aol.com&#39;</span><span class="p">),</span>
                  <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">)</span>
               <span class="p">)</span>
        <span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="链接">链接</h2>
<ul>
<li><a href="https://docs.sqlalchemy.org/en/latest/core/connections.html" target="_blank" rel="noopener noreferrer">使用 Engines 和 Connections</a></li>
<li><a href="https://docs.sqlalchemy.org/en/latest/core/tutorial.html" target="_blank" rel="noopener noreferrer">SQL 表达式语言入门</a></li>
<li><a href="https://docs.sqlalchemy.org/en/13/core/constraints.html" target="_blank" rel="noopener noreferrer">SQLAlchemy - 定义约束</a></li>
<li><a href="https://www.cnblogs.com/harrychinese/archive/2012/09/12/My_Own_Tutorial_For_SqlAlchemy.html" target="_blank" rel="noopener noreferrer">SQLAlchemy个人学习笔记完整汇总</a></li>
<li><a href="https://github.com/hackersandslackers/sqlalchemy-tutorial" target="_blank" rel="noopener noreferrer">hackersandslackers/sqlalchemy-tutorial</a></li>
</ul>
]]></description></item></channel></rss>