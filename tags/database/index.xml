<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>Database - 标签 - This Cute World</title><link>https://thiscute.world/tags/database/</link><description>Database - 标签 - This Cute World</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaoyin_c@qq.com (ryan4yin)</managingEditor><webMaster>xiaoyin_c@qq.com (ryan4yin)</webMaster><lastBuildDate>Tue, 21 May 2019 22:19:00 +0800</lastBuildDate><atom:link href="https://thiscute.world/tags/database/" rel="self" type="application/rss+xml"/><item><title>SQLAlchemy 学习笔记（三）：ORM 中的关系构建</title><link>https://thiscute.world/posts/sqlalchemy-notes-3-relationship-and-foreignkey/</link><pubDate>Tue, 21 May 2019 22:19:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/sqlalchemy-notes-3-relationship-and-foreignkey/</guid><description><![CDATA[<blockquote>
<p>个人笔记，不保证正确。</p>
</blockquote>
<h2 id="一关系构建foreignkey-与-relationship">一、关系构建：<code>ForeignKey</code> 与 <code>relationship</code></h2>
<p>关系构建的重点，在于搞清楚这两个函数的用法。<code>ForeignKey</code> 的用法已经在 <a href="https://www.cnblogs.com/kirito-c/p/10269485.html#%E8%A1%A8%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%BA%A6%E6%9D%9F" target="_blank" rel="noopener noreferrer">SQL表达式语言 - 表定义中的约束</a> 讲过了。主要是 <code>ondelete</code> 和 <code>onupdate</code> 两个参数的用法。</p>
<h2 id="二relationship">二、<code>relationship</code></h2>
<p><code>relationship</code> 函数在 ORM 中用于构建表之间的关联关系。与 <code>ForeignKey</code> 不同的是，它定义的关系不属于表定义，而是动态计算的。
用它定义出来的属性，相当于 SQL 中的视图。</p>
<p>这个函数有点难用，一是因为它的有几个参数不太好理解，二是因为它的参数非常丰富，让人望而却步。下面通过<strong>一对多</strong>、<strong>多对一</strong>、<strong>多对多</strong>几个场景下 <code>relationship</code> 的使用，来一步步熟悉它的用法。</p>
<p>首先初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">relationship</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="kn">import</span> <span class="n">declarative_base</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="1-一对多">1. 一对多</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># 因为 Child 中有 Parent 的 ForeignKey，这边的声明不需要再额外指定什么。</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">)</span>  <span class="c1"># children 的集合，相当于一个视图。</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;child&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;parent.id&#39;</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>一个 <code>Parent</code> 可以有多个 <code>Children</code>，通过 <code>relationship</code>，我们就能直接通过 <code>parent.children</code> 得到结果，免去繁琐的 query 语句。</p>
<h4 id="11-反向引用">1.1 反向引用</h4>
<h5 id="111-backref-与-back_populates">1.1.1 <code>backref</code> 与 <code>back_populates</code></h5>
<p>那如果我们需要得知 <code>child</code> 的 <code>parent</code> 对象呢？能不能直接访问 <code>child.parent</code>？</p>
<p>为了实现这个功能，SQLAlchemy 提供了 <code>backref</code> 和 <code>back_populates</code> 两个参数。</p>
<p>两个参数的效果完全一致，区别在于，<code>backref</code> 只需要在 <code>Parent</code> 类中声明 <code>children</code>，<code>Child.parent</code> 会被动态创建。</p>
<p>而 <code>back_populates</code> 必须在两个类中显式地使用 <code>back_populates</code>，更显繁琐。（但是也更清晰？）</p>
<p>先看 <code>backref</code> 版：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">,</span>
                            <span class="n">backref</span><span class="o">=</span><span class="s2">&#34;parent&#34;</span><span class="p">)</span>  <span class="c1"># backref 表示，在 Child 类中动态创建 parent 属性，指向当前类。</span>

<span class="c1"># Child 类不需要修改</span>
</code></pre></td></tr></table>
</div>
</div><p>再看 <code>back_populates</code> 版：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&#34;parent&#34;</span><span class="p">)</span>  <span class="c1"># back_populates </span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;child&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;parent.id&#39;</span><span class="p">))</span>

    <span class="c1"># 这边也必须声明，不能省略！</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Parent&#34;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&#34;children&#34;</span><span class="p">)</span>  <span class="c1"># parent 不是集合，是属性！</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>NOTE：声明的两个 <code>relationship</code> 不需要多余的说明，SQLAlchemy 能自动识别到 <code>parent.children</code> 是 collection，<code>child.parent</code> 是 attribute.</strong></p>
<h4 id="112-反向引用的参数sqlalchemyormbackrefname-kwargs">1.1.2. 反向引用的参数：<code>sqlalchemy.orm.backref(name, **kwargs)</code></h4>
<p>使用 <code>back_populates</code> 时，我们可以很方便地在两个 <code>relationship</code> 函数中指定各种参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&#34;parent&#34;</span><span class="p">,</span> 
                                        <span class="n">lazy</span><span class="o">=</span><span class="s1">&#39;dynamic&#39;</span><span class="p">)</span>  <span class="c1"># 指定 lazy 的值</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;child&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;parent.id&#39;</span><span class="p">))</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Parent&#34;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&#34;children&#34;</span><span class="p">,</span> 
                                      <span class="n">lazy</span><span class="o">=</span><span class="s1">&#39;dynamic&#39;</span><span class="p">)</span>  <span class="c1"># 指定 lazy 的值</span>
</code></pre></td></tr></table>
</div>
</div><p>但是如果使用 <code>backref</code>，因为我们只有一个 <code>relationship</code> 函数，<code>Child.parent</code> 是被隐式创建的，我们该如何指定这个属性的参数呢？</p>
<p>答案就是 <code>backref()</code> 函数，使用它替代 <code>backref</code> 参数的值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">backref</span>

<span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">,</span>
                            <span class="n">backref</span><span class="o">=</span><span class="n">backref</span><span class="p">(</span><span class="s2">&#34;parent&#34;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="s1">&#39;dynamic&#39;</span><span class="p">))</span>  <span class="c1"># 使用 backref() 函数，指定 Child.parent 属性的参数</span>

<span class="c1"># Child 类不需要修改</span>
</code></pre></td></tr></table>
</div>
</div><p><code>backref()</code> 的参数会被传递给 <code>relationship()</code>，因此它俩的参数也完全一致。</p>
<h3 id="2-多对一">2. 多对一</h3>
<p>A many-to-one is similar to a one-to-many relationship. The difference is that this relationship is looked at from the &ldquo;many&rdquo; side.</p>
<h3 id="3-一对一">3. 一对一</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;parent&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">child</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">,</span> 
                                    <span class="n">uselist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>   <span class="c1"># 不使用 collection！这是关键</span>
                                    <span class="n">back_populates</span><span class="o">=</span><span class="s2">&#34;parent&#34;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;child&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">parent_id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;parent.id&#39;</span><span class="p">))</span>

     <span class="c1"># 包含 ForeignKey 的类，此属性默认为 attribute，因此不需要 uselist=False</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Parent&#34;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&#34;child&#34;</span><span class="p">)</span> 
</code></pre></td></tr></table>
</div>
</div><h3 id="4-多对多">4. 多对多</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 多对多，必须要使用一个关联表！</span>
<span class="n">association_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;association&#39;</span><span class="p">,</span> <span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;left_id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;left.id&#39;</span><span class="p">)),</span>  <span class="c1"># 约定俗成的规矩，左边是 parent</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;right_id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;right.id&#39;</span><span class="p">))</span>  <span class="c1"># 右边是 child</span>
<span class="p">)</span>

<span class="k">class</span> <span class="nc">Parent</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&#34;Child&#34;</span><span class="p">,</span>
                    <span class="n">secondary</span><span class="o">=</span><span class="n">association_table</span><span class="p">)</span>  <span class="c1"># 专用参数 secondary，用于指定使用的关联表</span>

<span class="k">class</span> <span class="nc">Child</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>要添加反向引用时，同样可以使用 <code>backref</code> 或 <code>back_populates</code>.</p>
<h4 id="41-user2user">4.1 user2user</h4>
<p>如果多对多关系中的两边都是 user，即都是同一个表时，该怎么声明？</p>
<p>例如用户的「关注」与「粉丝」，你是 user，你的粉丝是 user，你关注的账号也是 user。</p>
<p>这个时候，关联表 <code>association_table</code> 的两个键都是 <code>user</code>，<strong>SQLAlchemy 无法区分主次，需要手动指定</strong>，为此需要使用 <code>primaryjoin</code> 和 <code>secondaryjoin</code> 两个参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 关联表，左侧的 user 正在关注右侧的 user</span>
<span class="n">followers</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="s1">&#39;followers&#39;</span><span class="p">,</span>
    <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="s1">&#39;follower_id&#39;</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;user.id&#39;</span><span class="p">)),</span>  <span class="c1"># 左侧</span>
    <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="s1">&#39;followed_id&#39;</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;user.id&#39;</span><span class="p">))</span>  <span class="c1"># 右侧，被关注的 user</span>
<span class="p">)</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">UserMixin</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="mi">120</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">password_hash</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># 我关注的 users</span>
    <span class="n">followed</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">relationship</span><span class="p">(</span>
        <span class="s1">&#39;User&#39;</span><span class="p">,</span>
        <span class="n">secondary</span><span class="o">=</span><span class="n">followers</span><span class="p">,</span>  <span class="c1"># 指定多对多关联表</span>
        <span class="n">primaryjoin</span><span class="o">=</span><span class="p">(</span><span class="n">followers</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">follower_id</span> <span class="o">==</span> <span class="nb">id</span><span class="p">),</span>  <span class="c1"># 左侧，用于获取「我关注的 users」的 join 条件</span>
        <span class="n">secondaryjoin</span><span class="o">=</span><span class="p">(</span><span class="n">followers</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">followed_id</span> <span class="o">==</span> <span class="nb">id</span><span class="p">),</span>  <span class="c1"># 右侧，用于获取「我的粉丝」的 join 条件</span>
        <span class="n">lazy</span><span class="o">=</span><span class="s1">&#39;dynamic&#39;</span><span class="p">,</span>  <span class="c1"># 延迟求值，这样才能用 filter_by 等过滤函数</span>
        <span class="n">backref</span><span class="o">=</span><span class="n">db</span><span class="o">.</span><span class="n">backref</span><span class="p">(</span><span class="s1">&#39;followers&#39;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="s1">&#39;dynamic&#39;</span><span class="p">))</span>  <span class="c1"># followers 也要延迟求值</span>
</code></pre></td></tr></table>
</div>
</div><p>这里比较绕的，就是容易搞混 <code>primaryjoin</code> 和 <code>secondaryjoin</code> 两个参数。</p>
<ol>
<li>primaryjoin：（多对多中）用于从子对象查询其父对象的 condition（child.parents），默认只考虑外键。</li>
<li>secondaryjoin：（多对多中）用于从父对象查询其所有子对象的 condition（parent.children），同样的，默认情况下只考虑外键。</li>
</ol>
<h2 id="三orm-层-的-delete-cascade-vs-foreign-key-层的-on-delete-cascade">三、ORM 层 的 “delete” cascade vs. FOREIGN KEY 层的 “ON DELETE” cascade</h2>
<p>之前有讲过 Table 定义中的级联操作：<code>ON DELETE</code> 和 <code>ON UPDATE</code>，可以通过 <code>ForeignKey</code> 的参数指定为 <code>CASCADE</code>.</p>
<p>可 SQLAlchemy 还有一个 <code>relationship</code> 生成 SQL 语句时的配置参数 <code>cascade</code>，另外 <code>passive_deletes</code> 也可以指定为 <code>cascade</code>。</p>
<p>有这么多的 cascade，我真的是很懵。这三个 cascade 到底有何差别呢？</p>
<p>外键约束中的 <code>ON DELETE</code> 和 <code>ON UPDATE</code>，与 ORM 层的 <code>CASCADE</code> 在功能上，确实有很多重叠的地方。
但是也有很多不同：</p>
<ol>
<li>数据库层面的 <code>ON DELETE</code> 级联能高效地处理 <strong>many-to-one</strong> 的关联；我们在 <code>many</code> 方定义外键，也在这里添加 <code>ON DELETE</code> 约束。而在 ORM 层，就<strong>刚好相反</strong>。SQLAlchemy 在 <code>one</code> 方处理 <code>many</code> 方的删除操作，这意味着它更适合处理 <strong>one-to-many</strong> 的关联。</li>
<li>数据库层面上，不带 <code>ON DELETE</code> 的外键常用于防止父数据被删除，而导致子数据成为无法被索引到的垃圾数据。如果要在一个 one-to-many 映射上实现这个行为，SQLAlchemy 将外键设置为 NULL 的默认行为可以通过以下两种方式之一捕获：
<ol>
<li>最简单也最常用的方法，当然是将外键定义为 <strong>NOT NULL</strong>. 尝试将该列设为 NULL 会触发 NOT NULL constraint exception.</li>
<li>另一种更特殊的方法，是将 <code>passive_deletes</code> 标志设置为字 <code>all</code>. 这会完全禁用 SQLAlchemy 将外键列设置为 NULL 的行为，并且 DELETE 父数据而不会对子数据产生任何影响。这样才能触发数据库层面的 <code>ON DELETE</code> 约束，或者其他的触发器。</li>
<li>数据库层面的 <code>ON DELETE</code> 级联 比 ORM 层面的级联更高效。数据库可以同时在多个 relationship 中链接一系列级联操作。</li>
<li>SQLAlchemy 不需要这么复杂，因为我们通过将 passive_deletes 选项与正确配置的外键约束结合使用，提供与数据库的 <code>ON DELETE</code> 功能的平滑集成。</li>
</ol>
</li>
</ol>
<h3 id="方法一orm-层的-cascade-实现">方法一：ORM 层的 cascade 实现</h3>
<p><code>relationship</code> 的 <code>cascade</code> 参数决定了修改父表时，什么时候子表要进行级联操作。它的可选项有（str，选项之间用逗号分隔）：</p>
<ol>
<li><code>save-update</code>：默认选项之一。在 add（对应 SQL 的 insert 或 update）一个对象的时候，会 add 所有它相关联的对象。</li>
<li><code>merge</code>：默认选项之一。在 merge（相当字典的update操作，有就替换掉，没有就合并）一个对象的时候，会 merge 所有和它相关联的对象。</li>
<li><code>expunge</code> ：移除操作的时候，会将相关联的对象也进行移除。这个操作只是从session中移除，并不会真正的从数据库中删除。</li>
<li><code>delete</code>：删除父表数据时，同时删除与它关联的数据。</li>
<li><code>delete-orphan</code>：当子对象与父对象解除关系时，删除掉此子对象（孤儿）。（其实还是没懂。。）</li>
<li><code>refresh-expire</code>：不常用。</li>
<li><code>all</code>：表示选中除 <code>delete-orphan</code> 之外的所有选项。（因此 <code>all, delete-orphan</code> 很常用，它才是真正的 <code>all</code>）</li>
</ol>
<p>默认属性是 &ldquo;save-update, merge&rdquo;.</p>
<p>这只是简略的说明，上述几个参数的详细文档见 <a href="https://docs.sqlalchemy.org/en/13/orm/cascades.html#unitofwork-cascades" target="_blank" rel="noopener noreferrer">SQLAlchemy - Cascades</a></p>
<h3 id="方法二数据库层的-cascade-实现">方法二：数据库层的 cascade 实现</h3>
<ol>
<li>将 <code>ForeignKey</code> 的 <code>ondelete</code> 和 <code>onupdate</code> 参数指定为 <code>CASCADE</code>，实现数据库层面的级联。</li>
<li>为 <code>relationship</code> 添加关键字参数 <code>passive_deletes=&quot;all&quot;</code>，这样就完全禁用 SQLAlchemy 将外键列设置为 NULL 的行为，并且 DELETE 父数据不会对子数据产生任何影响。</li>
</ol>
<p>这样 DELETE 操作时，就会触发数据库的 <code>ON DELETE</code> 约束，从而级联删除子数据。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://docs.sqlalchemy.org/en/13/orm/relationships.html" target="_blank" rel="noopener noreferrer">SQLAlchemy - Relationship Configuration</a></li>
<li><a href="https://docs.sqlalchemy.org/en/13/orm/cascades.html#unitofwork-cascades" target="_blank" rel="noopener noreferrer">SQLAlchemy - Cascades</a></li>
<li><a href="https://ia.jifangcheng.com/p/46" target="_blank" rel="noopener noreferrer">SQLAlchemy 中的 backref 和 back_populates</a></li>
<li><a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-viii-followers" target="_blank" rel="noopener noreferrer">The Flask Mega-Tutorial Part VIII: Followers</a></li>
<li><a href="https://github.com/hackersandslackers/sqlalchemy-tutorial" target="_blank" rel="noopener noreferrer">hackersandslackers/sqlalchemy-tutorial</a></li>
</ul>
]]></description></item><item><title>SQLAlchemy 学习笔记（二）：ORM 基础</title><link>https://thiscute.world/posts/sqlalchemy-notes-2-orm-basics/</link><pubDate>Mon, 11 Feb 2019 19:52:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/sqlalchemy-notes-2-orm-basics/</guid><description><![CDATA[<p>照例先看层次图</p>
<p><figure><a class="lightgallery" href="/images/sqlalchemy-notes/sqlalchemy-arch.png" title="/images/sqlalchemy-notes/sqlalchemy-arch.png" data-thumbnail="/images/sqlalchemy-notes/sqlalchemy-arch.png" data-sub-html="<h2>SQLAlchemy 层次结构</h2>">
        
    </a><figcaption class="image-caption">SQLAlchemy 层次结构</figcaption>
    </figure></p>
<h3 id="一声明映射关系">一、声明映射关系</h3>
<p>使用 ORM 时，我们首先需要定义要操作的表（通过 <code>Table</code>），然后再定义该表对应的 Python class，并声明两者之间的映射关系（通过 <code>Mapper</code>）。</p>
<p>方便起见，SQLAlchemy 提供了 Declarative 系统来一次完成上述三个步骤，Declarative 系统提供 base class，这个 base class 会为继承了它的 Python class（可称作 model）创建 Table，并维护两者的映射关系。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy.ext.declarative</span> <span class="kn">import</span> <span class="n">declarative_base</span>
<span class="kn">from</span> <span class="nn">SQLAlchemy</span> <span class="kn">import</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span>

<span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>  <span class="c1"># 拿到 Base 类</span>


<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># 添加 index 提升搜索效率</span>
    <span class="n">fullname</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
    <span class="n">password</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span>  <span class="c1"># 真实情况下一般只存 hash</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&#34;&lt;User </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2">&gt;&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>这样就声明好了一个对象-关系映射，上一篇文章说过所有的 Table 都在某个 MetaData 中，可以通过 <code>Base.metadata</code> 获取它。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>  <span class="c1"># 通过 metadata 创建表（或者说生成模式 schema）</span>
</code></pre></td></tr></table>
</div>
</div><p>engine 的创建请见上篇文档 <a href="https://www.cnblogs.com/kirito-c/p/10269485.html" target="_blank" rel="noopener noreferrer">SQLAlchemy 学习笔记（一）：Engine 与 SQL 表达式语言</a></p>
<h4 id="约束条件">约束条件</h4>
<blockquote>
<p>可参考 <a href="https://www.cnblogs.com/kirito-c/p/10295693.html" target="_blank" rel="noopener noreferrer">SQL 基础笔记（三）：约束</a> 与 <a href="https://www.cnblogs.com/kirito-c/p/10269485.html#%E8%A1%A8%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%BA%A6%E6%9D%9F" target="_blank" rel="noopener noreferrer">SQLAlchemy 学习笔记（一）：Engine 与 SQL 表达式语言 - 表定义中的约束</a></p>
</blockquote>
<p>使用 ORM 来定义约束条件，与直接使用 SQL 表达式语言定义很类似，也有两种方法：</p>
<ol>
<li>直接将约束条件作为 <code>Column</code>、<code>ForeignKey</code> 的参数传入。这种方式最简洁，也最常用。</li>
<li>使用 <code>UniqueConstraint</code>、<code>CheckConstraint</code> 等类构造约束，然后放入 <code>__table_args__</code> 属性中。举例：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># 添加 index 提升搜索效率</span>
    <span class="n">fullname</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
    <span class="n">password</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span>  <span class="c1"># 真实情况下一般只存 hash</span>

    <span class="c1"># 顾名思义，这是 `Table` 类的参数的序列。里面的约束条件会被用于构建 __table__</span>
    <span class="n">__table_args__</span> <span class="o">=</span> <span class="p">(</span><span class="n">UniqueConstraint</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;c_user&#39;</span><span class="p">),)</span>  <span class="c1"># username 的唯一性约束</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&#34;&lt;User </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2">&gt;&#34;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="二获取-session">二、获取 session</h3>
<p>上一节讲 engine 时，我们是通过 connection 来与数据库交互，而在 ORM 中我们使用 Session 访问数据库。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">sessionmaker</span>

<span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>  <span class="c1"># 获取 session</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="三增删改查">三、增删改查</h3>
<p>直接使用 SQL 表达式语言时，我们使用 insert()、select()、update()、delete() 四个函数构造 SQL，使用 where() 添加条件，使用 model.join(another_model) 进行 join 操作。
而使用 ORM 时，数据库操作不再与 SQL 直接对应。我们现在是通过操作 Python 对象来操作数据库了。</p>
<p>现在，我们通过 db.session.add()、db.session.delete() 进行添加与删除，使用 db.session.query(Model) 进行查询，通过 filter 和 filter_by 添加过滤条件。
而修改，则是先查询出对应的 row 对象，直接修改这个对象，然后 commit 就行。</p>
<ol>
<li>增添：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">ed_user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Ed Jones&#39;</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="s1">&#39;edspassword&#39;</span><span class="p">)</span>  <span class="c1"># 用构造器构造对象</span>
<span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ed_user</span><span class="p">)</span>  <span class="c1"># 添加，此外还有批量添加 add_all([user1, user2...])</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># 必须手动 commit</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>修改：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">ed_user</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>  <span class="c1"># 先获取到 User 对象</span>
<span class="n">ed_user</span><span class="o">.</span><span class="n">password</span> <span class="o">=</span> <span class="s1">&#39;f8s7ccs&#39;</span>  <span class="c1"># 改了密码</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># 提交</span>

<span class="c1"># 批量修改</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">home</span><span class="o">==</span><span class="s1">&#39;shanghai&#39;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">User</span><span class="o">.</span><span class="n">login_num</span><span class="p">:</span><span class="mi">0</span><span class="p">})</span>  <span class="c1"># 将所有上海的用户的 login_num 设为 0</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>删除：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">ed_user</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ed&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>  <span class="c1"># 先获取到 User 对象</span>
<span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ed_user</span><span class="p">)</span>  <span class="c1"># 直接删除（session 知道 ed_user 属于哪个表）</span>
<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># 提交</span>

<span class="c1"># 批量删除</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">home</span><span class="o">==</span><span class="s1">&#39;shanghai&#39;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">delete</span><span class="p">()</span>  <span class="c1"># 删除所有上海的用户</span>

<span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>同样的，也可以在外面检查异常，然后调用 <code>session.rollback()</code> 实现失败回滚。</p>
<h3 id="四进阶查询">四、进阶查询</h3>
<ol>
<li>filter_by：使用关键字参数进行过滤，前面的演示中已经用过多次了。</li>
<li>filter：它对应 SQL 表达式语言中的 where，支持各种复杂的 SQL 语法。</li>
<li>group_by: 通过指定 column 分组</li>
<li>distinct(): 去重</li>
<li>join(): 关联</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ed&#39;</span><span class="p">)</span>  <span class="c1"># 这个等同于 filter_by，但是更繁琐</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;ed&#39;</span><span class="p">)</span>  <span class="c1"># 不等于，这个就是 filter_by 无法做到的了</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">d%&#39;</span><span class="p">))</span>  <span class="c1"># SQL like 的 like 语法</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="s1">&#39;jack&#39;</span><span class="p">]))</span>  <span class="c1"># 包含</span>

<span class="c1"># 查询还可以嵌套</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">in_</span><span class="p">(</span>
    <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">d%&#39;</span><span class="p">))</span>
<span class="p">))</span>

<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">~</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="s1">&#39;jack&#39;</span><span class="p">]))</span>  <span class="c1"># 不包含</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># NULL 对应 Python 的 None</span>

<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">or_</span><span class="p">,</span> <span class="n">and_</span><span class="p">,</span> <span class="n">in_</span>
<span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">or_</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ed&#39;</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;wendy&#39;</span><span class="p">))</span>  <span class="c1"># OR 语法</span>

<span class="n">query</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># 分组</span>
<span class="n">query</span><span class="o">.</span><span class="n">distinct</span><span class="p">()</span>  <span class="c1"># 去重</span>

<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">func</span>  <span class="c1"># SQL 函数包</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">))</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">xxx</span><span class="o">=</span><span class="n">xxx</span><span class="p">)</span>  <span class="c1"># 使用 count 函数</span>

<span class="c1"># join 关联</span>
<span class="c1"># 默认使用内联（inner），即只取两表的交集</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="o">==</span><span class="n">Address</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>  <span class="c1"># 方法一</span>

<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span>\  <span class="c1"># 方法二</span>
    <span class="nb">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">==</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">)</span>

<span class="c1"># 外联 outer join，将另一表的列联结到主表，没有的行为 NULL</span>
<span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">outerjoin</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">==</span><span class="s1">&#39;jack@google.com&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="执行查询获取数据">执行查询，获取数据</h4>
<p>查询返回 query 对象，但 SQL 还没有被执行，直到你调用下列几个方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 构造 query 对象</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%e</span><span class="s1">d&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

<span class="c1"># 1. all 返回所有结果的列表</span>
<span class="n">res_list</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="c1"># 2. first 先在 SQL 中加入限制 `limit 1`，然后执行。</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>

<span class="c1"># 3. one 执行 sql 并获取所有结果</span>
<span class="c1"># 如果结果不止一行，抛出 MultipleResultsFound Error！！！</span>
<span class="c1"># 如果结果为空，抛出 NoResultFound Error ！！！</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>

<span class="mf">4.</span> <span class="n">one_or_none</span> <span class="n">差别在于结果为空</span><span class="err">，</span><span class="n">它不抛出异常</span><span class="err">，</span><span class="n">而是返回</span> <span class="kc">None</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">one_or_none</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="参考">参考</h3>
<ul>
<li><a href="https://docs.sqlalchemy.org/en/latest/orm/tutorial.html" target="_blank" rel="noopener noreferrer">SQLAlchemy 对象关系入门</a></li>
<li><a href="https://docs.sqlalchemy.org/en/latest/orm/basic_relationships.html" target="_blank" rel="noopener noreferrer">SQLAlchemy ORM 的关联映射定义：一对多、多对多</a></li>
<li><a href="https://github.com/hackersandslackers/sqlalchemy-tutorial" target="_blank" rel="noopener noreferrer">hackersandslackers/sqlalchemy-tutorial</a></li>
</ul>
]]></description></item><item><title>SQLAlchemy 学习笔记（一）：Engine 与 SQL 表达式语言</title><link>https://thiscute.world/posts/sqlalchemy-notes-1-engine-and-sql-expression-language/</link><pubDate>Mon, 21 Jan 2019 14:02:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/sqlalchemy-notes-1-engine-and-sql-expression-language/</guid><description><![CDATA[<blockquote>
<p>个人笔记，如有错误烦请指正。</p>
</blockquote>
<p>SQLAlchemy 是一个用 Python 实现的 ORM （Object Relational Mapping）框架，它由多个组件构成，这些组件可以单独使用，也能独立使用。它的组件层次结构如下：</p>
<p><figure><a class="lightgallery" href="/images/sqlalchemy-notes/sqlalchemy-arch.png" title="/images/sqlalchemy-notes/sqlalchemy-arch.png" data-thumbnail="/images/sqlalchemy-notes/sqlalchemy-arch.png" data-sub-html="<h2>SQLAlchemy 层次结构</h2>">
        
    </a><figcaption class="image-caption">SQLAlchemy 层次结构</figcaption>
    </figure></p>
<p>其中最常用的组件，应该是 <strong>ORM</strong> 和 <strong>SQL 表达式语言</strong>，这两者既可以独立使用，也能结合使用。</p>
<p><strong>ORM</strong> 的好处在于它</p>
<ol>
<li>自动处理了数据库和 Python 对象之间的映射关系，屏蔽了两套系统之间的差异。程序员不需要再编写复杂的 SQL 语句，直接操作 Python 对象就行。</li>
<li>屏蔽了各数据库之间的差异，更换底层数据库不需要修改 SQL 语句，改下配置就行。</li>
<li>使数据库结构文档化，models 定义很清晰地描述了数据库的结构。</li>
<li>避免了不规范、冗余、风格不统一的 SQL 语句，可以避免很多人为 Bug，也方便维护。</li>
</ol>
<p>但是 ORM 需要消耗额外的性能来处理对象关系映射，此外用 ORM 做多表关联查询或复杂 SQL 查询时，效率低下。因此它适用于场景不太复杂，性能要求不太苛刻的场景。</p>
<p>都说 ORM 学习成本高，我自己也更倾向于直接使用 SQL 语句（毕竟更熟悉），因此这一篇笔记不涉及 ORM 部分，只记录 SQLAlchemy 的 Engine 与 SQL 表达式语言。</p>
<h2 id="一直接使用-enginehttpsdocssqlalchemyorgenlatestcoreengineshtmlsqlalchemycreate_engine-和-connections">一、直接使用 <a href="https://docs.sqlalchemy.org/en/latest/core/engines.html#sqlalchemy.create_engine" target="_blank" rel="noopener noreferrer">Engine</a> 和 Connections</h2>
<p>第一步是创建数据库引擎实例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s1">&#39;sqlite:///:memory:&#39;</span><span class="p">,</span> 
                    <span class="n">echo</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># echo=True 表示打印出自动生成的 SQL 语句（通过 logging）</span>
                    <span class="n">pool_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>  <span class="c1"># 连接池容量，默认为 5，生产环境下太小，需要修改。</span>
                    <span class="c1"># 下面是 connection 回收的时间限制，默认 -1 不回收</span>
                    <span class="n">pool_recycle</span><span class="o">=</span><span class="mi">7200</span><span class="p">)</span>   <span class="c1"># 超过 2 小时就重新连接（MySQL 默认的连接最大闲置时间为 8 小时）</span>
</code></pre></td></tr></table>
</div>
</div><p><code>create_engine</code> 接受的第一个参数是数据库 URI，格式为 <code>dialect+driver://username:password@host:port/database</code>，dialect 是具体的数据库名称，driver 是驱动名称。key-value 是可选的参数。举例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># PostgreSQL</span>
postgresql+psycopg2://scott:tiger@localhost/dbtest

<span class="c1"># MySQL + PyMySQL（或者用更快的  mysqlclient）</span>
mysql+pymysql://scott:tiger@localhost/dbtest

<span class="c1"># sqlite 内存数据库</span>
<span class="c1"># 注意 sqlite 要用三个斜杠，表示不存在 hostname，sqlite://&lt;nohostname&gt;/&lt;path&gt;</span>
sqlite:///:memory:

<span class="c1"># sqlite 文件数据库</span>
<span class="c1"># 四个斜杠是因为文件的绝对路径以 / 开头：/home/ryan/Codes/Python/dbtest.db</span>
sqlite:////home/ryan/Codes/Python/dbtest.db

<span class="c1"># SQL Server + pyodbc</span>
<span class="c1"># 首选基于 dsn 的连接，dsn 的配置请搜索hhh</span>
mssql+pyodbc://scott:tiger@some_dsn
</code></pre></td></tr></table>
</div>
</div><p>如果你的密码中含有 &lsquo;@&rsquo; 等特殊字符，就不能直接放入 URI 中，必须使用 <code>urllib.parse.quote_plus</code> 编码，然后再插入 URI.</p>
<p>引擎创建后，我们就可以直接获取 connection，然后执行 SQL 语句了。这种用法相当于把 SQLAlchemy 当成带 log 的数据库连接池使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&#34;select username from users&#34;</span><span class="p">)</span>  <span class="c1"># 无参直接使用</span>

    <span class="c1"># 使用问号作占位符，前提是下层的 DBAPI 支持。更好的方式是使用 text()，这个后面说</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&#34;INSERT INTO table (id, value) VALUES (?, ?)&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&#34;v1&#34;</span><span class="p">)</span>  <span class="c1"># 参数不需要包装成元组</span>

    <span class="c1"># 查询返回的是 ResultProxy 对象，有和 dbapi 相同的 fetchone()、fetchall()、first() 等方法，还有一些拓展方法</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;username:&#34;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><p>但是要注意的是，connection 的 execute 是自动提交的（autocommit），这就像在 shell 里打开一个数据库客户端一样，分号结尾的 SQL 会被自动提交。
只有在 <code>BEGIN TRANSACTION</code> 内部，<code>AUTOCOMMIT</code> 会被临时设置为 <code>FALSE</code>，可以通过如下方法开始一个内部事务：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">transaction_a</span><span class="p">(</span><span class="n">connection</span><span class="p">):</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>  <span class="c1"># 开启一个 transaction</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># do sthings</span>
        <span class="n">trans</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>  <span class="c1"># 这里需要手动提交</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">trans</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>  <span class="c1"># 出现异常则 rollback</span>
        <span class="k">raise</span>
<span class="c1"># do other things</span>

<span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="n">transaction_a</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="1-使用-texthttpsdocssqlalchemyorgenlatestcoresqlelementhtmlsqlalchemysqlexpressiontext-构建-sql">1. 使用 <a href="https://docs.sqlalchemy.org/en/latest/core/sqlelement.html#sqlalchemy.sql.expression.text" target="_blank" rel="noopener noreferrer">text()</a> 构建 SQL</h3>
<p>相比直接使用 string，text() 的优势在于它：</p>
<ol>
<li>提供了统一的参数绑定语法，与具体的 DBAPI 无关。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 1. 参数绑定语法</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">text</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
            <span class="c1"># 使用 :key 做占位符</span>
            <span class="n">text</span><span class="p">(</span><span class="s1">&#39;select * from table where id &lt; :id and typeName=:type&#39;</span><span class="p">),</span>
            <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span><span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="s1">&#39;USER_TABLE&#39;</span><span class="p">})</span>  <span class="c1"># 用 dict 传参数，更易读</span>

<span class="c1"># 2. 参数类型指定</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">DateTime</span>

<span class="n">date_param</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">today</span><span class="p">()</span><span class="o">+</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=-</span><span class="mi">1</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span>
<span class="n">sql</span><span class="o">=</span><span class="s2">&#34;delete from caw_job_alarm_log  where alarm_time &lt; :alarm_time_param&#34;</span>

<span class="c1"># bindparams 是 bindparam 的列表，bindparam 则提供参数的一些额外信息（类型、值、限制等）</span>
<span class="n">t</span><span class="o">=</span><span class="n">text</span><span class="p">(</span><span class="n">sql</span><span class="p">,</span> <span class="n">bindparams</span><span class="o">=</span><span class="p">[</span><span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;alarm_time_param&#39;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">DateTime</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">)])</span>
<span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">{</span><span class="s2">&#34;alarm_time_param&#34;</span><span class="p">:</span> <span class="n">date_param</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>可以很方便地转换 Result 中列的类型</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">stmt = text(&#34;SELECT * FROM table&#34;,
            # 使用 typemap 指定将 id 列映射为 Integer 类型，name 映射为 String 类型
            typemap={&#39;id&#39;: Integer, &#39;name&#39;: String},
          )
result = connection.execute(stmt)
# 对多个查询结果，可以用 for obj in result 遍历
# 也可用 fetchone() 只获取一个
</code></pre></td></tr></table>
</div>
</div><h2 id="二sql-表达式语言">二、SQL 表达式语言</h2>
<blockquote>
<p>复杂的 SQL 查询可以直接用 raw sql 写，而增删改一般都是单表操作，用 SQL 表达式语言最方便。</p>
</blockquote>
<p>SQLAlchemy 表达式语言是一个使用 Python 结构表示关系数据库结构和表达式的系统。</p>
<h3 id="1-定义并创建表">1. 定义并创建表</h3>
<p>SQL 表达式语言使用 Table 来定义表，而表的列则用 Column 定义。Column 总是关联到一个 Table 对象上。</p>
<p>一组 Table 对象以及它们的子对象的集合就被称作「数据库元数据（database metadata）」。metadata 就像你的网页分类收藏夹，相关的 Table 放在一个 metadata 中。</p>
<p>下面是创建元数据（一组相关联的表）的例子，：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">MetaData</span><span class="p">,</span> <span class="n">ForeignKey</span>

<span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span>  <span class="c1"># 先创建元数据（收藏夹）</span>

<span class="n">users</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>  <span class="c1"># 创建 user 表，并放到 metadata 中</span>
              <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
              <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">),</span>
              <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;fullname&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span>
             <span class="p">)</span>

<span class="n">addresses</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;user_id&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s1">&#39;user.id&#39;</span><span class="p">)),</span>  <span class="c1"># 外键约束，引用 user 表的 id 列</span>
                  <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;email_address&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                 <span class="p">)</span>

<span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>  <span class="c1"># 使用 engine 创建 metadata 内的所有 Tables（会检测表是否已经存在，所以可以重复调用）</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="表定义中的约束">表定义中的约束</h4>
<blockquote>
<p>应该给所有的约束命名，即为 <code>name</code> 参数指定一个不冲突的列名。详见 <a href="https://alembic.sqlalchemy.org/en/latest/naming.html" target="_blank" rel="noopener noreferrer">The Importance of Naming Constraints</a></p>
</blockquote>
<p>表还有一个属性：<a href="https://www.cnblogs.com/kirito-c/p/10295693.html" target="_blank" rel="noopener noreferrer">约束条件</a>。下面一一进行说明。</p>
<ol>
<li><strong>外键约束</strong>：用于在删除或更新某个值或行时，对主键/外键关系中一组数据列强制进行的操作限制。
<ol>
<li>用法一：<code>Column('user_id', None, ForeignKey('user.id'))</code>，直接在 <code>Column</code> 中指定。这也是最常用的方法</li>
<li>用法二：通过 <code>ForeignKeyConstraint(columns, refcolumns)</code> 构建约束，作为参数传给 <code>Table</code>.</li>
</ol>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">item</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;item&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>  <span class="c1"># 商品 table</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">60</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;invoice_id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>  <span class="c1"># 发票 id，是外键</span>
    <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;ref_num&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
    <span class="n">ForeignKeyConstraint</span><span class="p">([</span><span class="s1">&#39;invoice_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ref_num&#39;</span><span class="p">],</span>  <span class="c1"># 当前表中的外键名称</span>
                         <span class="p">[</span><span class="s1">&#39;invoice.id&#39;</span><span class="p">,</span> <span class="s1">&#39;invoice.ref_num&#39;</span><span class="p">])</span>  <span class="c1"># 被引用的外键名称的序列（被引用的表）</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li><code>on delete</code> 与 <code>on update</code>：<strong>外键约束的两个约束条件</strong>，通过 <code>ForeignKey()</code> 或 <code>ForeignKeyConstraint()</code> 的关键字参数 <code>ondelete/onupdate</code> 传入。
可选值有：
<ol>
<li><strong>默认行为 <code>NO ACTION</code></strong>：什么都不做，直接报错。</li>
<li><code>CASCADE</code>：删除/更新 父表数据时，<strong>从表数据会同时被 删除/更新</strong>。（无报错）</li>
<li><code>RESTRICT</code>：<strong>不允许直接 删除/更新 父表数据</strong>，直接报错。（和默认行为基本一致）</li>
<li><code>SET NULL</code> or <code>SET DEFAULT</code>：删除/更新 父表数据时，将对应的从表数据重置为 <code>NULL</code> 或者默认值。</li>
</ol>
</li>
<li><strong>唯一性约束</strong>：<code>UniqueConstraint('col2', 'col3', name='uix_1')</code>，作为参数传给 <code>Table</code>.</li>
<li><strong>CHECK 约束</strong>：<code>CheckConstraint('col2 &gt; col3 + 5', name='check1')</code>， 作为参数传给 <code>Table</code>.</li>
<li>主键约束：不解释
<ol>
<li>方法一：通过 <code>Column('id', Integer, primary_key=True)</code> 指定主键。（参数 <code>primary_key</code> 可在多个 <code>Column</code> 上使用）</li>
<li>方法二：使用 <code>PrimaryKeyConstraint</code></li>
</ol>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">PrimaryKeyConstraint</span>

<span class="n">my_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s1">&#39;mytable&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
            <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">),</span>
            <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;version_id&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">),</span>
            <span class="n">Column</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">50</span><span class="p">)),</span>
            <span class="n">PrimaryKeyConstraint</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;version_id&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;mytable_pk&#39;</span><span class="p">)</span>
        <span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="2-增删改查语句">2. 增删改查语句</h3>
<ol>
<li><strong>增</strong>:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 方法一，使用 values 传参</span>
<span class="n">ins</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&#34;Jack&#34;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s2">&#34;Jack Jones&#34;</span><span class="p">)</span>  <span class="c1"># 可以通过 str(ins) 查看自动生成的 sql</span>
<span class="n">connection</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>

<span class="c1"># 方法二，参数传递给 execute()</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s1">&#39;Wendy Williams&#39;</span><span class="p">)</span>

<span class="c1"># 方法三，批量 INSERT，相当于 executemany</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">addresses</span><span class="o">.</span><span class="n">insert</span><span class="p">(),</span> <span class="p">[</span>  <span class="c1"># 插入到 addresses 表</span>
    <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span><span class="p">:</span> <span class="s1">&#39;jack@yahoo.com&#39;</span><span class="p">},</span>  <span class="c1"># 传入 dict 列表</span>
    <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span><span class="p">:</span> <span class="s1">&#39;jack@msn.com&#39;</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span><span class="p">:</span> <span class="s1">&#39;www@www.org&#39;</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;user_id&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;email_address&#39;</span><span class="p">:</span> <span class="s1">&#39;wendy@aol.com&#39;</span><span class="p">}</span>
<span class="p">])</span>

<span class="c1"># 此外，通过使用 bindparam，INSERT 还可以执行更复杂的操作</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span> \ 
         <span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&#34; .. name&#34;</span><span class="p">)</span>  <span class="c1"># string 拼接</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="p">[</span>
        <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;_name&#39;</span><span class="p">:</span><span class="s1">&#39;name1&#39;</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;_name&#39;</span><span class="p">:</span><span class="s1">&#39;name2&#39;</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;_name&#39;</span><span class="p">:</span><span class="s1">&#39;name3&#39;</span><span class="p">},</span>
     <span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li><strong>删</strong>：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">_table</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span> \
        <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">f1</span><span class="o">==</span><span class="n">value1</span><span class="p">)</span> \
        <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">f2</span><span class="o">==</span><span class="n">value2</span><span class="p">)</span>  <span class="c1"># where 指定条件</span>
</code></pre></td></tr></table>
</div>
</div><ol start="3">
<li><strong>改</strong>：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># 举例</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">()</span> \
             <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;jack&#39;</span><span class="p">)</span> \
             <span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;tom&#39;</span><span class="p">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>

<span class="c1"># 批量更新</span>
<span class="n">stmt</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="n">update</span><span class="p">()</span> \
             <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;oldname&#39;</span><span class="p">))</span> \
             <span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">bindparam</span><span class="p">(</span><span class="s1">&#39;newname&#39;</span><span class="p">))</span>
<span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="p">[</span>
     <span class="p">{</span><span class="s1">&#39;oldname&#39;</span><span class="p">:</span><span class="s1">&#39;jack&#39;</span><span class="p">,</span> <span class="s1">&#39;newname&#39;</span><span class="p">:</span><span class="s1">&#39;ed&#39;</span><span class="p">},</span>
     <span class="p">{</span><span class="s1">&#39;oldname&#39;</span><span class="p">:</span><span class="s1">&#39;wendy&#39;</span><span class="p">,</span> <span class="s1">&#39;newname&#39;</span><span class="p">:</span><span class="s1">&#39;mary&#39;</span><span class="p">},</span>
     <span class="p">{</span><span class="s1">&#39;oldname&#39;</span><span class="p">:</span><span class="s1">&#39;jim&#39;</span><span class="p">,</span> <span class="s1">&#39;newname&#39;</span><span class="p">:</span><span class="s1">&#39;jake&#39;</span><span class="p">},</span>
     <span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，所有的条件都是通过 <code>where</code> 指定的，它和后面 ORM 的 filter 接受的参数是一样的。（详细的会在第二篇文章里讲）</p>
<ol start="4">
<li><strong>查</strong></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">select</span>

<span class="c1"># 1. 字段选择</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">])</span>  <span class="c1"># 相当于 select * from users</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">])</span>  <span class="c1"># 这个就是只 select 一部分</span>

<span class="c1"># 2. 添加过滤条件</span>
<span class="n">s3</span> <span class="o">=</span> <span class="n">select</span><span class="p">([</span><span class="n">users</span><span class="p">])</span> \
    <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span> 

<span class="n">res</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
<span class="c1"># 可用 for row in res 遍历结果集，也可用 fetchone() 只获取一行</span>
</code></pre></td></tr></table>
</div>
</div><p>查询返回的是 ResultProxy 对象，这是 SQLAlchemy 对 Python DB-API 的 cursor 的一个封装类，要从中获取结果行，主要有下列几个方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">row1</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>  <span class="c1"># 对应 cursor.fetchone()</span>
<span class="n">row2</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>  <span class="c1"># 对应 cursor.fetchall()</span>
<span class="n">row3</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fetchmany</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># 对应 cursor.fetchmany(size=3)</span>

<span class="n">row4</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>  <span class="c1"># 获取一行，然后立即调用 result 的 close() 方法</span>

<span class="n">col</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">mytable</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">mycol</span><span class="p">]</span> <span class="c1"># 获取 mycol 这一列</span>

<span class="n">result</span><span class="o">.</span><span class="n">rowcount</span>  <span class="c1"># 结果集的行数</span>

<span class="n">同时</span><span class="err">，</span><span class="n">result</span> <span class="n">也实现了</span> <span class="nb">next</span> <span class="n">protocol</span><span class="err">，</span><span class="n">因此可以直接用</span> <span class="k">for</span> <span class="n">循环遍历</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="where-进阶">where 进阶</h3>
<p>通过使用 or_、and_、in_ model.join 等方法，where 可以构建更复杂的 SQL 语句。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">and_</span><span class="p">,</span> <span class="n">or_</span><span class="p">,</span> <span class="n">not_</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">([(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span> <span class="o">+</span>
               <span class="s2">&#34;, &#34;</span> <span class="o">+</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span>
                <span class="n">label</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">)])</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span><span class="n">users</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">))</span><span class="o">.</span>\
        <span class="n">where</span><span class="p">(</span>
               <span class="n">or_</span><span class="p">(</span>
                  <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@aol.com&#39;</span><span class="p">),</span>
                  <span class="n">addresses</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%@msn.com&#39;</span><span class="p">)</span>
               <span class="p">)</span>
        <span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="链接">链接</h2>
<ul>
<li><a href="https://docs.sqlalchemy.org/en/latest/core/connections.html" target="_blank" rel="noopener noreferrer">使用 Engines 和 Connections</a></li>
<li><a href="https://docs.sqlalchemy.org/en/latest/core/tutorial.html" target="_blank" rel="noopener noreferrer">SQL 表达式语言入门</a></li>
<li><a href="https://docs.sqlalchemy.org/en/13/core/constraints.html" target="_blank" rel="noopener noreferrer">SQLAlchemy - 定义约束</a></li>
<li><a href="https://www.cnblogs.com/harrychinese/archive/2012/09/12/My_Own_Tutorial_For_SqlAlchemy.html" target="_blank" rel="noopener noreferrer">SQLAlchemy个人学习笔记完整汇总</a></li>
<li><a href="https://github.com/hackersandslackers/sqlalchemy-tutorial" target="_blank" rel="noopener noreferrer">hackersandslackers/sqlalchemy-tutorial</a></li>
</ul>
]]></description></item><item><title>SQL 基础笔记（三）约束</title><link>https://thiscute.world/posts/sql-basics-3-restrict/</link><pubDate>Sun, 20 Jan 2019 21:08:46 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/sql-basics-3-restrict/</guid><description><![CDATA[<blockquote>
<p>个人笔记不保证正确。</p>
</blockquote>
<p>数据类型是限制我们可以在表里存储什么数据的一种方法。不过，对于许多应用来说， 这种限制实在是太粗糙了。比如，一个包含产品价格的字段应该只接受正数。 但是没有哪种标准数据类型只接受正数。 另外一个问题是你可能需要根据其它字段或者其它行的数据来约束字段数据。比如， 在一个包含产品信息的表中，每个产品编号都应该只有一行。</p>
<p>对于这些问题，SQL 允许你在字段和表上定义约束。约束允许你对数据施加任意控制。 如果用户企图在字段里存储违反约束的数据，那么就会抛出一个错误。 这种情况同时也适用于数值来自默认值的情况。</p>
<h3 id="1-外键-foreign-key">1. 外键 <code>FOREIGN KEY</code></h3>
<p>外键约束声明一个字段(或者一组字段)的数值必须匹配另外一个表中出现的数值。
创建外键约束的前提是，该外键所在的表已经存在，并且外键必须是 UNIQUE 的。（主键默认 UNIQUE 且 NOT NULL）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表名</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="o">&lt;</span><span class="err">字段名</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="err">类型</span><span class="o">&gt;</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="o">&lt;</span><span class="err">字段名</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="err">类型</span><span class="o">&gt;</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="o">&lt;</span><span class="err">外键所在的表名</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="err">字段名</span><span class="o">&gt;</span><span class="p">),</span><span class="w">  </span><span class="c1">-- 这创建了一个外键
</span><span class="c1"></span><span class="w">    </span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>还有另一种语法，它支持以多个字段为外键（<strong>字段约束也可以写成表约束，也就是放在一个独立的行中。而反过来很可能不行</strong>）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">CREATE TABLE &lt;表名&gt; (
    &lt;字段名1&gt; &lt;类型&gt; PRIMARY KEY,
    &lt;字段名2&gt; &lt;类型&gt;
    &lt;字段名3&gt; &lt;类型&gt;
    ...
    FOREIGN KEY (&lt;字段名2&gt;,  &lt;字段名3&gt;) REFERENCES &lt;外键所在的表名&gt; (&lt;字段名4&gt;, &lt;字段名5&gt;)
);
</code></pre></td></tr></table>
</div>
</div><p>一个表也可以包含多个外键约束。这个特性用于实现表之间的多对多关系。 比如你有关于产品和订单的表，但现在你想允许一个订单可以包含多种产品 (上面那个结构是不允许这么做的)，你可以使用这样的结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">products</span><span class="w"> </span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">product_no</span><span class="w"> </span><span class="nb">integer</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">text</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">price</span><span class="w"> </span><span class="nb">numeric</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">order_id</span><span class="w"> </span><span class="nb">integer</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">shipping_address</span><span class="w"> </span><span class="nb">text</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">order_items</span><span class="w"> </span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">product_no</span><span class="w"> </span><span class="nb">integer</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">products</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">order_id</span><span class="w"> </span><span class="nb">integer</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">orders</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">quantity</span><span class="w"> </span><span class="nb">integer</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">product_no</span><span class="p">,</span><span class="w"> </span><span class="n">order_id</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>外键能通过 <code>ALTER</code> 语句添加或删除</p>
<h3 id="2-级联操作-on-delete-与-on-update">2. 级联操作 <code>ON DELETE</code> 与 <code>ON UPDATE</code></h3>
<p>上面说过：外键约束声明一个字段(或者一组字段)的数值必须匹配另外一个表中出现的数值。</p>
<p>但是以 1. 中最后一个 sql 为例，如果一个订单（order）在创建之后，该订单包含的某个产品（product）被删除了，会发生什么？</p>
<p>这个例子中，订单包含的产品通过外键被记录在 order_items 表中。现在如果你要删除 product 中某个被 order_items 引用了的行，默认情况为 <code>NO ACTION</code>，就是直接报错。</p>
<p>这个行为也可以手动指定：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">products</span><span class="w"> </span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">product_no</span><span class="w"> </span><span class="nb">integer</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">text</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">price</span><span class="w"> </span><span class="nb">numeric</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">order_id</span><span class="w"> </span><span class="nb">integer</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">shipping_address</span><span class="w"> </span><span class="nb">text</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">order_items</span><span class="w"> </span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">product_no</span><span class="w"> </span><span class="nb">integer</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">products</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">DELETE</span><span class="w"> </span><span class="k">RESTRICT</span><span class="p">,</span><span class="w">  </span><span class="c1">-- 限制，也就是禁止删除被它引用的行
</span><span class="c1"></span><span class="w">    </span><span class="n">order_id</span><span class="w"> </span><span class="nb">integer</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">DELETE</span><span class="w"> </span><span class="k">CASCADE</span><span class="p">,</span><span class="w">    </span><span class="c1">-- 级联，在删除被它引用的行的时候，这一行本身也会被自动删除掉
</span><span class="c1"></span><span class="w">    </span><span class="n">quantity</span><span class="w"> </span><span class="nb">integer</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">product_no</span><span class="p">,</span><span class="w"> </span><span class="n">order_id</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>除了 <code>RESTRICT</code> 和 <code>CASCADE</code> 外，在外键上的动作还有两个选项：<code>SET NULL</code> 和 <code>SET DEFAULT</code>，顾名思义，就是在被引用的行删除后将外键设置为 <code>NULL</code> 或默认值。</p>
<p><code>ON UPDATE</code> 与 <code>ON DELETE</code> 的动作是一样的，只是 <code>CASCADE</code> 表示同步更新。</p>
<h3 id="3-check-约束">3. <code>CHECK</code> 约束</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">products</span><span class="w"> </span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">product_no</span><span class="w"> </span><span class="nb">integer</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">text</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">price</span><span class="w"> </span><span class="nb">numeric</span><span class="w"> </span><span class="k">CHECK</span><span class="w"> </span><span class="p">(</span><span class="n">price</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>你还可以给这个约束取一个独立的名字。这样就可以令错误消息更清晰， 并且在你需要修改它的时候引用这个名字。语法是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">products</span><span class="w"> </span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">product_no</span><span class="w"> </span><span class="nb">integer</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">text</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">price</span><span class="w"> </span><span class="nb">numeric</span><span class="w"> </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">positive_price</span><span class="w"> </span><span class="k">CHECK</span><span class="w"> </span><span class="p">(</span><span class="n">price</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>稍微复杂一点的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">products</span><span class="w"> </span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">product_no</span><span class="w"> </span><span class="nb">integer</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">text</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">price</span><span class="w"> </span><span class="nb">numeric</span><span class="w"> </span><span class="k">CHECK</span><span class="w"> </span><span class="p">(</span><span class="n">price</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">discounted_price</span><span class="w"> </span><span class="nb">numeric</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="k">CHECK</span><span class="w"> </span><span class="p">(</span><span class="n">discounted_price</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">price</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">discounted_price</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>同样的，可以为 CHECK 命名，令错误信息更清晰：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">products</span><span class="w"> </span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">product_no</span><span class="w"> </span><span class="nb">integer</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">text</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">price</span><span class="w"> </span><span class="nb">numeric</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="k">CHECK</span><span class="w"> </span><span class="p">(</span><span class="n">price</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">discounted_price</span><span class="w"> </span><span class="nb">numeric</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="k">CHECK</span><span class="w"> </span><span class="p">(</span><span class="n">discounted_price</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">valid_discount</span><span class="w"> </span><span class="k">CHECK</span><span class="w"> </span><span class="p">(</span><span class="n">price</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">discounted_price</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>要注意的是，<strong>当约束表达式计算结果为真或 NULL 的时候，检查约束会被认为是满足条件的</strong>。 因为大多数表达式在含有 NULL 操作数的时候结果都是 NULL ，所以这些约束不能阻止字段值为 NULL 。要排除掉 NULL，只能使用 <code>NOT NULL</code> 约束。（所以就说 NULL 是万恶之源hhh）</p>
<h3 id="参考">参考</h3>
<ul>
<li><a href="http://www.postgres.cn/docs/9.4/ddl-constraints.html" target="_blank" rel="noopener noreferrer">约束</a></li>
</ul>
]]></description></item><item><title>SQL 基础笔记（二）进阶查询</title><link>https://thiscute.world/posts/sql-basics-2-queries/</link><pubDate>Sun, 17 Jun 2018 14:17:46 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/sql-basics-2-queries/</guid><description><![CDATA[<blockquote>
<p>本笔记整理自<a href="https://book.douban.com/subject/24841239/" target="_blank" rel="noopener noreferrer">《SQL 基础教程》</a>、<a href="https://book.douban.com/subject/3354490/" target="_blank" rel="noopener noreferrer">《MySQL 必知必会》</a>和网上资料。个人笔记不保证正确。</p>
</blockquote>
<h2 id="一复杂查询">一、复杂查询</h2>
<h3 id="视图">视图</h3>
<p>将 SELECT 查询包装成一个虚拟表，该虚拟表就被称为视图。（因为只是一个包装，因此视图的数据也会随着原表的更新而更新）</p>
<ol>
<li>用途：
<ol>
<li>简化复杂的SQL查询，用它替换子查询，能降低查询的嵌套深度。</li>
<li>SELECT 查询的重用，减少重复查询。</li>
<li>&hellip;</li>
</ol>
</li>
<li>创建视图：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span><span class="w"> </span><span class="k">VIEW</span><span class="w"> </span><span class="o">&lt;</span><span class="err">视图名称</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="o">&lt;</span><span class="err">视图列名</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="err">视图列名</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">...</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="k">AS</span><span class="w">
</span><span class="w">    </span><span class="o">&lt;</span><span class="k">SELECT</span><span class="w"> </span><span class="err">语句</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>其中 SELECT 的结果列和视图列名一一对应。
3. 视图的限制
1. 视图的 SELECT 子句，不能包含 ORDER BY 子句。因为视图也是表，而表是集合，它没有顺序。（也有些DB支持该用法，但不通用）
1. 视图的更新：只在很有限的条件下，才能在视图上使用 INSERT/DELETE/UPDATE 这样的变更数据的语句。（<strong>视图应该只用于检索，能不更新就不要更新它</strong>）
4. 删除视图：<code>DROP VIEW &lt;视图名称&gt;;</code></p>
<h3 id="子查询">子查询</h3>
<p>子查询，其实就是一次性的视图:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w">
</span><span class="w">    </span><span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w">  </span><span class="c1">-- 这就是一个子查询：嵌套的 select 语句
</span><span class="c1"></span><span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="o">&lt;</span><span class="err">别名</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">...</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>上面的查询的 FROM 子句中，给另一 SELECT 子句定义了一个别名，并将它作为了查询对象。这就是一个子查询。</p>
<p>子查询不仅能用于 FROM，还能用在 WHERE 子句等很多地方。</p>
<h4 id="关联子查询">关联子查询</h4>
<p>即用到了外部数据的子查询语句：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w">
</span><span class="w">    </span><span class="k">FROM</span><span class="w"> </span><span class="n">product</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">p1</span><span class="w">
</span><span class="w">    </span><span class="k">WHERE</span><span class="w"> </span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w">
</span><span class="w">            </span><span class="k">FROM</span><span class="w"> </span><span class="n">duck</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">p2</span><span class="w">
</span><span class="w">            </span><span class="k">WHERE</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">price</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">price</span><span class="w">   </span><span class="c1">-- 这里，内部子查询访问了外部查询的表p1，因此是一个关联子查询。
</span><span class="c1"></span><span class="w">    </span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="二函数谓词case-表达式">二、函数、谓词、CASE 表达式</h2>
<h3 id="函数httpsdevmysqlcomdocrefman57enfunctionshtml"><a href="https://dev.mysql.com/doc/refman/5.7/en/functions.html" target="_blank" rel="noopener noreferrer"><strong>函数</strong></a></h3>
<blockquote>
<p>给出的链接都是 MySQL 的</p>
</blockquote>
<ol>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/numeric-functions.html" target="_blank" rel="noopener noreferrer">算术函数</a>
<ul>
<li>加减乘除：+ - * /</li>
<li>ABS 绝对值</li>
<li>MOD 求余</li>
<li>ROUND 四舍五入</li>
</ul>
</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/string-functions.html" target="_blank" rel="noopener noreferrer">字符串函数</a>
<ul>
<li>CONCAT(str1,str2,&hellip;)   拼接</li>
<li>LENGTH(str)  字符串的 <strong>bytes</strong> 长度</li>
<li>CHAR_LENGTH(str)</li>
<li>LOWER/UPPER  大小写转换</li>
<li>REPLACE(str,from_str,to_str) 替换</li>
<li>SUBSTRING(str FROM pos FOR len) 截取</li>
</ul>
</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html" target="_blank" rel="noopener noreferrer">时间和日期函数</a>
<ul>
<li>CURRENT_DATE  当前日期</li>
<li>CURRENT_TIME 当前时间</li>
<li>CURRENT_TIMESTAMP  当前的日期和时间</li>
<li>EXTRACT(unit FROM date) 截取日期元素，unit 可为 <code>YEAR</code> <code>MONTH</code> <code>HOUR</code> 等等</li>
</ul>
</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/cast-functions.html" target="_blank" rel="noopener noreferrer">转换函数</a>
<ul>
<li>CAST(expr AS type) 将 expr 的结果转换成 type 类型</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#function_coalesce" target="_blank" rel="noopener noreferrer">COALESCE(value,&hellip;)</a>  从左往右扫描，返回第一个非 NULL 的值。常用于将 NULL 转换为其他值。eg. COALESCE(sth, 1) 如果 sth 为 NULL 就会返回1.</li>
</ul>
</li>
<li>聚合函数：基本就五个，已经学过了。</li>
</ol>
<h3 id="谓词">谓词</h3>
<p>即返回布尔值的表达式</p>
<h4 id="like谓词简单字符串匹配慢">LIKE谓词——简单字符串匹配（慢）</h4>
<blockquote>
<p>匹配整个列</p>
</blockquote>
<ul>
<li><code>%</code>：任意字符出现任意次</li>
<li><code>_</code>：匹配任意一个字符</li>
</ul>
<p>举例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span><span class="w"> </span><span class="n">name</span><span class="w">
</span><span class="w">    </span><span class="k">FROM</span><span class="w"> </span><span class="n">list</span><span class="w">
</span><span class="w">    </span><span class="k">WHERE</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;%Ryan%&#39;</span><span class="p">;</span><span class="w">  </span><span class="c1">-- 匹配任意包含 &#39;Ryan&#39; 的字符串
</span></code></pre></td></tr></table>
</div>
</div><h4 id="regexp谓词正则字符串匹配">REGEXP谓词——正则字符串匹配</h4>
<blockquote>
<p>MySQL 只实现了通用正则的一个子集，而且是search模式。（非match）</p>
</blockquote>
<h4 id="其他">其他</h4>
<ul>
<li>BETWEEN：范围匹配，eg. <code>BETWEEN 1 AND 10</code></li>
<li>IS NULL、IS NOT NULL</li>
<li>IN、NOT IN：是否在某集合内</li>
<li>EXISTS、NOT EXISTS（比较难的一个，入门阶段不要求）：该谓词比较特殊，只需要右侧一个参数，**而且该参数绝大多数情况下，都是一个关联子查询。**而且该子查询的SELECT子句的参数基本可以随意，通常使用<code>SELECT *</code>. 对于子查询有返回值的列，它返回True，否则返回False. 但要注意为 NULL 时返回 UNKNOW.（而 WHERE 只认 True）</li>
</ul>
<h3 id="case-表达式">CASE 表达式</h3>
<ol>
<li>if - else if - else 形式：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CASE</span><span class="w"> </span><span class="k">WHEN</span><span class="w"> </span><span class="o">&lt;</span><span class="err">求值表达式</span><span class="o">&gt;</span><span class="w"> </span><span class="k">THEN</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表达式</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">WHEN</span><span class="w"> </span><span class="o">&lt;</span><span class="err">求值表达式</span><span class="o">&gt;</span><span class="w"> </span><span class="k">THEN</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表达式</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">WHEN</span><span class="w"> </span><span class="o">&lt;</span><span class="err">求值表达式</span><span class="o">&gt;</span><span class="w"> </span><span class="k">THEN</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表达式</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">...</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="k">ELSE</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表达式</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="k">END</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>switch 模式（但不需要break）</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CASE</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表达式</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">WHEN</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表达式</span><span class="o">&gt;</span><span class="w"> </span><span class="k">THEN</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表达式</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">WHEN</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表达式</span><span class="o">&gt;</span><span class="w"> </span><span class="k">THEN</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表达式</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">...</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="k">ELSE</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表达式</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="k">END</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这是对 CASE 后的元素做switch比较。</p>
<h2 id="三集合运算">三、集合运算</h2>
<h3 id="注意事项">注意事项</h3>
<ol>
<li>作为运算对象的结果集，<strong>列字段必须一一对应</strong>，而且对应列的类型必须相同。</li>
</ol>
<h3 id="结果集的交并差">结果集的交并差</h3>
<ol>
<li><code>&lt;查询1&gt; UNION &lt;查询2&gt;</code>：对两个结果集求并</li>
<li><code>UNION ALL</code>：添加 ALL 能使结果集包含重复行。</li>
<li><code>&lt;查询1&gt; INTERSECT &lt;查询2&gt;</code>：两结果集的交集</li>
<li><code>&lt;查询1&gt; EXCEPT &lt;查询2&gt;</code>：两结果集的差集</li>
</ol>
<h3 id="以列为单位对表进行联结join">以列为单位，对表进行联结(JOIN)</h3>
<blockquote>
<p>最强大的功能之一</p>
</blockquote>
<p>交并差是以行为单位的操作，是竖向的运算。而联结是以列为单位的操作，是横向的拼接。</p>
<h4 id="内联inner-join">内联(INNER JOIN)</h4>
<blockquote>
<p><strong>内联结果只包含两表的交集</strong></p>
</blockquote>
<p>语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w">
</span><span class="w">    </span><span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="n">product</span><span class="w"> </span><span class="k">INNER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">shop</span><span class="w">
</span><span class="w">        </span><span class="k">ON</span><span class="w"> </span><span class="n">product</span><span class="p">.</span><span class="n">p_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shop</span><span class="p">.</span><span class="n">p_id</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="k">WHERE</span><span class="w"> </span><span class="n">filter_condition</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>使用 跟在 INNER JOIN 子句后的 ON 子句指定联结条件。（这里我特意用了括号，表示 JOIN 和 ON 两个子句是配套的）</p>
<p>也有另一个很常用的语法（但是现在已经不推荐使用）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w">
</span><span class="w">    </span><span class="k">FROM</span><span class="w"> </span><span class="n">product</span><span class="p">,</span><span class="w"> </span><span class="n">shop</span><span class="w">
</span><span class="w">    </span><span class="k">WHERE</span><span class="w"> </span><span class="n">product</span><span class="p">.</span><span class="n">p_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shop</span><span class="p">.</span><span class="n">p_id</span><span class="w">
</span><span class="w">        </span><span class="k">AND</span><span class="w"> </span><span class="n">filter_condition</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>对于 shop 表中有多行对应同一个 product 的情况（有多人购买了同一款商品），结果中该 product 会被复制给 shop 中的多个购买记录。（也就是说该 product 会变成多行）</p>
<blockquote>
<p>INNER 可以省略，也就是说只写 JOIN，就默认是 INNER JOIN</p>
</blockquote>
<h4 id="外联outer-join">外联(OUTER JOIN)</h4>
<blockquote>
<p>**外联以某表为主表，将另一表的列联结到该表。**另一表没有值的列，就用 NULL 代替。使用<code>LEFT</code> 或 <code>RIGHT</code>指定主表。（两个关键字都能实现同样的效果，不过用 LEFT 的多一些）</p>
</blockquote>
<p>语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w">
</span><span class="w">    </span><span class="k">FROM</span><span class="w"> </span><span class="n">product</span><span class="w"> </span><span class="k">LEFT</span><span class="w"> </span><span class="k">OUTER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">shop</span><span class="w">
</span><span class="w">        </span><span class="k">ON</span><span class="w"> </span><span class="n">product</span><span class="p">.</span><span class="n">p_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shop</span><span class="p">.</span><span class="n">p_id</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这和内联很相似，差别只是联结关键词改成了<code>LEFT OUTER JOIN</code>。这表示以左边的表为主表，把右边的表的内容联结上去。因此左表的所有列都会出现在结果集中。</p>
<p>多表联查举例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- 登录异常的账号及密码
</span><span class="c1"></span><span class="k">select</span><span class="w"> </span><span class="k">distinct</span><span class="w"> </span><span class="n">batches</span><span class="p">.</span><span class="n">identity_number</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="s1">&#39;登录失败账号&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">accounts</span><span class="p">.</span><span class="n">password</span><span class="w">
</span><span class="w">	</span><span class="k">from</span><span class="w"> </span><span class="p">((</span><span class="n">batches</span><span class="w"> </span><span class="k">left</span><span class="w"> </span><span class="k">outer</span><span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="n">tasks</span><span class="w">
</span><span class="w">			</span><span class="k">on</span><span class="w"> </span><span class="n">batches</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tasks</span><span class="p">.</span><span class="n">batch_id</span><span class="p">)</span><span class="w">   </span><span class="c1">-- 批次表联结具体的任务表
</span><span class="c1"></span><span class="w">		</span><span class="k">left</span><span class="w"> </span><span class="k">outer</span><span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="o">`</span><span class="n">status</span><span class="o">`</span><span class="w">
</span><span class="w">			</span><span class="k">on</span><span class="w"> </span><span class="n">tasks</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">status</span><span class="p">.</span><span class="n">task_id</span><span class="p">)</span><span class="w">  </span><span class="c1">-- 再联结上状态表
</span><span class="c1"></span><span class="w">        </span><span class="k">left</span><span class="w"> </span><span class="k">outer</span><span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="n">accounts</span><span class="w">
</span><span class="w">			</span><span class="k">on</span><span class="w"> </span><span class="n">batches</span><span class="p">.</span><span class="n">identity_number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">accounts</span><span class="p">.</span><span class="n">identity_number</span><span class="w">  </span><span class="c1">-- 再联结上账号表
</span><span class="c1"></span><span class="w">	</span><span class="k">where</span><span class="w"> </span><span class="o">`</span><span class="n">status</span><span class="o">`</span><span class="p">.</span><span class="n">step_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;check_login&#39;</span><span class="w">     </span><span class="c1">-- 只提取 &#34;check_login&#34; 步骤的记录
</span><span class="c1"></span><span class="w">		</span><span class="k">and</span><span class="w"> </span><span class="n">status</span><span class="p">.</span><span class="n">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s1">&#39;info&#39;</span><span class="w">  </span><span class="c1">-- 状态不为 info，说明登录异常
</span></code></pre></td></tr></table>
</div>
</div><p>此外还有 FULL OUTER JOIN 表示返回左右两表的所有行！所有没有匹配的行都给出 NULL</p>
<blockquote>
<p>P.S. 其中的关键字 OUTER 通常可省略。但是 LEFT、RIGHT、FULL 不可以省略。</p>
</blockquote>
<h2 id="画外字段引用符号">画外：字段引用符号</h2>
<p>如果数据库的字段名/数据库名/表名可能和数据库关键字重复，就需要用引用符号将他们引用起来，消除歧义。</p>
<p>MySQL 中经常用反引号干这个事。
而 SQL Server 则使用方括号。
标准 SQL 使用双引号。在看到这些符号时要知道这些差别。</p>
<h2 id="查询语句分析">查询语句分析</h2>
<ul>
<li><a href="https://www.cnblogs.com/xuanzhi201111/p/4175635.html" target="_blank" rel="noopener noreferrer">MySQL Explain详解</a></li>
</ul>
<h2 id="常见问题">常见问题</h2>
<h3 id="隐式类型转换">隐式类型转换</h3>
<p>在MySQL中，当操作符与不同类型的操作数一起使用时，会发生类型转换以使操作数兼容。则会发生隐式类型转换。</p>
<p>隐式类型转换会导致查询不会走索引！！！可能会严重拖累性能。另外还可能会导致各种奇怪的问题。</p>
<p>详见 <a href="https://www.cnblogs.com/BOHB-yunying/p/12458589.html" target="_blank" rel="noopener noreferrer">MYSQL隐式类型转换</a></p>
<p>完。（接下来就是用 Python/Java 连接 MySQL 了）</p>
]]></description></item><item><title>SQL 基础笔记（一）</title><link>https://thiscute.world/posts/sql-basics-1/</link><pubDate>Fri, 15 Jun 2018 16:27:46 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/sql-basics-1/</guid><description><![CDATA[<blockquote>
<p>本笔记整理自<a href="https://book.douban.com/subject/24841239/" target="_blank" rel="noopener noreferrer">《SQL 基础教程》</a>、<a href="https://book.douban.com/subject/3354490/" target="_blank" rel="noopener noreferrer">《MySQL 必知必会》</a>和网上资料。个人笔记不保证正确。</p>
</blockquote>
<h2 id="一基础">一、基础</h2>
<p>SQL，即结构化查询语言，是为访问与操作关系数据库中的数据而设计的语言。</p>
<ol>
<li>关系数据库以行(row)为单位读写数据</li>
<li>SQL 根据功能的不同，可分为三类（其中DML用得最多，增删查改嘛）
<ol>
<li>DDL(Data Definition Language, 数据定义语言): CREATE/DROP/ALTER</li>
<li>DML(Data Manipulation Language, 数据操作语言): SELECT/INSERT/UPDATE/DELETE</li>
<li>DCL(Data Control Language, 数据控制语言): COMMIT/ROLLBACK/GRANT/REVOKE</li>
</ol>
</li>
<li>SQL 语句要以分号结尾。换行在 SQL 中不表示结束，而等同于空格。</li>
<li>SQL 不区分**关键字(Keyword)**的大小写，但是描述符就不一定了。
<ul>
<li>这里有个坑：MySQL 中，数据库和表其实就是数据目录下的目录和文件，因而，<strong>操作系统的敏感性决定数据库名和表名 是否大小写敏感</strong>。这就意味着<strong>数据库名</strong>和<strong>表名</strong>在 Windows 中是大小写不敏感的，而在大多数类型的 Unix/Linux 系统中是大小写敏感的。（注意仅指数据库名和表名）可通过修改配置文件的<code>lower_case_table_names</code>属性来统一这一行为。</li>
<li>而<strong>字段名</strong>、<strong>字段内容</strong>都是内部数据，是操作系统无关的。它们的大小写敏感性，由 MySQL 的的校对（COLLATE）规则来控制。该规则体现在 MySQL 的 校对字符集（COLLATION）的后缀上：比如 utf8字符集，<code>utf8_general_ci</code>表示不区分大小写，这个是 utf8 字符集默认的校对规则；<code>utf8_general_cs</code> 表示区分大小写，<code>utf8_bin</code> 表示二进制比较，同样也区分大小写 。</li>
</ul>
</li>
<li>SQL 中的字符串和日期需要用单引号引用起来，日期有特定格式<code>年-月-日</code></li>
</ol>
<p>修改字符集：<code>set names &lt;字符集名&gt;</code>
记住在 MySQL 中，utf-8mb4 才是完全的 utf-8字符集。</p>
<h2 id="二ddl">二、DDL</h2>
<h3 id="1-数据库的创建和删除">1. 数据库的创建和删除</h3>
<ol>
<li>创建数据库</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span><span class="w"> </span><span class="k">DATABASE</span><span class="w"> </span><span class="o">&lt;</span><span class="err">数据库名称</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">DROP</span><span class="w"> </span><span class="k">DATABASE</span><span class="w"> </span><span class="o">&lt;</span><span class="err">数据库名称</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="2-创建表">2. 创建表：</h3>
<h4 id="关系表的设计">关系表的设计</h4>
<p>关系表的设计，要确保把信息分解成多个表，一类信息一个表，各表通过某些常用的，基本不会改变的值（即关系表设计中的关系，也常称为外键）互相关联。尽量不要有冗余数据。</p>
<h4 id="语句">语句：</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表名</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="o">&lt;</span><span class="err">列名</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="err">数据类型</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="err">该列所需约束</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="o">&lt;</span><span class="err">列名</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="err">数据类型</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="err">该列所需约束</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="o">&lt;</span><span class="err">列名</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="err">数据类型</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="err">该列所需约束</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">...</span><span class="w">
</span><span class="w">    </span><span class="o">&lt;</span><span class="err">该表的约束</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="err">该表的约束</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>举例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">`</span><span class="n">persons</span><span class="o">`</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="n">UNSIGNED</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="o">`</span><span class="n">name</span><span class="o">`</span><span class="w"> </span><span class="nb">CHAR</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w"> 
</span><span class="w">    </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>后面的是设置引擎和默认字符集。工作上，表的设计一定要深思熟虑，因为改起来很困难。</p>
<h4 id="字段类型mysql">字段类型（MySQL）</h4>
<p>有四类数据类型：字符串、数字、日期、二进制。它们又根据数据长度的区别，下分为多个类型。</p>
<ol>
<li>字符串：
</li>
<li>数字
</li>
<li>日期
</li>
<li>二进制
</li>
</ol>
<h4 id="约束">约束</h4>
<p>SQL 约束是除了数据类型之外，对列中数据追加的限定条件。</p>
<ol>
<li>类型约束：<code>NOT NULL</code>、<code>AUTO_INCREMENT</code>、<code>UNSIGNED</code>（这个只 MySQL 支持）</li>
<li>默认值：<code>DEFAULT</code>，举例 <code>&lt;列名3&gt; VARCHAR(32) NOT NULL DEFAULT &quot;los angeles&quot;</code></li>
<li>表约束：<code>PRIMARY KEY</code> 主键约束（主键默认 UNIQUE 且 NOT NULL）</li>
</ol>
<p>此外还有 <code>FOREIGN KEY</code> 和 <code>CHECK</code> 两个约束语句，在<a href="https://www.cnblogs.com/kirito-c/p/10295693.html" target="_blank" rel="noopener noreferrer">进阶笔记</a>中介绍。</p>
<blockquote>
<p>P.S. 字段约束也可以写成表约束（比如主键约束），而反过来很可能不行。</p>
</blockquote>
<h3 id="3-删除表和更新表定义">3. 删除表和更新表定义</h3>
<ol>
<li>删除表（危险操作）
<ul>
<li>删除整个表：</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">DROP</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表名</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><pre><code>- 只清空表内数据，但留下表：
</code></pre>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">TRUNCATE</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表名</span><span class="o">&gt;</span><span class="p">;</span><span class="w">  </span><span class="c1">-- 非标准SQL语句，但是大部分DB都支持。（可能不能ROLLBACK）
</span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>更新表定义（麻烦的操作）
所以所创建表前要仔细想好格式了，更新表定义是不得已才能为之。
添加列定义：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表名</span><span class="o">&gt;</span><span class="w"> </span><span class="k">ADD</span><span class="w"> </span><span class="k">COLUMN</span><span class="w"> </span><span class="o">&lt;</span><span class="err">列名</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="err">数据类型</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="err">该列的约束</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>删除列定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表名</span><span class="o">&gt;</span><span class="w"> </span><span class="k">DROP</span><span class="w"> </span><span class="k">COLUMN</span><span class="w"> </span><span class="o">&lt;</span><span class="err">列名</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="三dml">三、DML</h2>
<blockquote>
<p>万恶之源 NULL</p>
</blockquote>
<h3 id="1-查询重点">1. 查询（重点）</h3>
<ol>
<li>基本语句：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">SELECT &lt;字段1&gt; AS &lt;别名1&gt;,
     &lt;字段2&gt; AS &lt;别名2&gt;,
     ...
FROM &lt;表名&gt;
WHERE &lt;过滤条件&gt;;
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>可<strong>用 <code>DISTINCT</code> 修饰列名</strong>，使查询结果无重。例：<code>SELECT DISTINCT &lt;列名&gt; FROM &lt;表名&gt;</code></li>
<li>过滤条件可使用比较运算(&lt;&gt;、=等)和逻辑运算(AND OR NOT).</li>
<li>过滤条件中，<strong>比较运算会永远忽略 NULL 值</strong>，如果需要对 NULL 值做操作，需要使用 <strong>IS NULL</strong> 或 <strong>IS NOT NULL</strong>（说忽略也许不太准确，NULL 既不为真也不为假，反正少用NULL。。）</li>
<li>包含NULL的四则运算，得到的结果总为NULL</li>
</ol>
<h3 id="2-聚合与排序重点">2. 聚合与排序（重点）</h3>
<h4 id="聚合函数">聚合函数</h4>
<p>即对列进行统计分析的函数，主要有五个：</p>
<ol>
<li>COUNT：计算列的行数。（只有<code>COUNT(*)</code>会计算NULL行）</li>
<li>SUM：求该列之和。</li>
<li>AVG：求该列的平均值。</li>
<li>MAX/MIN：求该列的 最大/最小 值</li>
</ol>
<p>NOTE：</p>
<ol>
<li><strong>聚合函数计算时会排除所有NULL行。只有COUNT(*)例外，NULL行也会被它计数。</strong></li>
<li>MAX/MIN 几乎适用于所有数据类型的列（对非数值型，以其二进制值来排序），而SUM/AVG只能用于数值类型的列。</li>
<li>聚合函数操作的列，也能用DISTINCT修饰。例：<code>SELECT COUNT(DISTINCT &lt;列名&gt;) FROM &lt;表名&gt;</code></li>
<li>聚合函数只能用于SELECT子句和还没讲的HAVING子句（以及 ORDER BY 子句）中。</li>
</ol>
<h4 id="分组group-by">分组(GROUP BY)</h4>
<p>分组以聚合键为分类标准，将数据分为多个逻辑组，从而能分别对每个组进行聚合运算。（分组是为了分类聚合）</p>
<ol>
<li>若出现了 GROUP BY 子句，查询结果一定是每一组一行。</li>
<li>GROUP BY 会将 NULL 作为一组特定数据，显示为空。</li>
</ol>
<h4 id="聚合对select子句的限制">聚合对SELECT子句的限制</h4>
<p>首先要理解的是：</p>
<ol>
<li>聚合函数的操作对象为某一列，而产生的结果只有一个值。</li>
<li>GROUP BY 的操作对象为一列或者多列，产生的结果呢，是每一组一个值。</li>
</ol>
<p>因此为了避免歧义，只要使用了聚合函数或 GROUP BY 二者之一，SELECT 子句就只能包含：</p>
<ol>
<li>常数</li>
<li>其他聚合函数（该聚合函数的操作对象可以为其他列）</li>
<li>如果使用了 GROUP BY 子句，还能包括该子句所指定的列名。（也就是聚合键）但是<strong>绝不能包含其他的列名</strong>，因为这会有歧义。</li>
</ol>
<p>此外，还有一个问题是由 SQL 的执行顺序引起的。应该能很容易猜到，<strong>SELECT 语句的执行顺序和书写顺序是不一致的</strong>。
查询应该是从表开始，所以 FROM 语句一定先执行。然后应该要过滤(WHERE)，再是分组(GROUP BY)，最后才是 SELECT 语句。（就已经学到的子句而言，顺序是这样）
因此按理说，<strong>SELECT 语句 定义的别名，是不能在 GROUP BY 里使用的</strong>。（也有些DB支持该用法，但不通用）</p>
<h4 id="对聚合结果进行过滤having">对聚合结果进行过滤(HAVING)</h4>
<p>从刚刚说过的SQL执行顺序可见，WHERE要比GROUP BY先执行，因此如果想过滤分组后的结果，不能用它。而应该使用 HAVING 子句。
HAVING 子句和 WHERE 子句都是用来过滤的，但是执行顺序的不同也就决定了它们的用途不同。</p>
<p>NOTE：</p>
<ol>
<li>有时候，会发现某个过滤条件，不论是先执行（就是写在WHERE子句中）还是后执行（写在HAVING中）都没问题，这时候应该将它写在WHERE子句中，这样GROUP BY操作的数据会更少，处理更快。</li>
<li>HAVING 子句的元素，也存在和 SELECT 子句同样的限制。不能使用聚合键以外的列名。</li>
</ol>
<h4 id="排序order-by">排序(ORDER BY)</h4>
<p><strong>ORDER BY 子句在 SELECT 子句之后执行</strong>，因此它能使用 SELECT 子句中定义的别名。（而 GROUP BY 之前已经说过不能用别名了）
格式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span><span class="w"> </span><span class="o">&lt;</span><span class="err">字段</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="o">&lt;</span><span class="err">别名</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">     </span><span class="o">&lt;</span><span class="err">字段</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="o">&lt;</span><span class="err">别名</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">     </span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表名</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="o">&lt;</span><span class="err">过滤条件</span><span class="mi">1</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="o">&lt;</span><span class="err">列名</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="err">列名</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="k">HAVING</span><span class="w"> </span><span class="o">&lt;</span><span class="err">过滤条件</span><span class="mi">2</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="o">&lt;</span><span class="err">列名</span><span class="o">/</span><span class="err">别名</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="err">列名</span><span class="o">/</span><span class="err">别名</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">...</span><span class="w">  </span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ol>
<li>多排序键/列：指定多排序键时的排序规则为：<strong>优先使用左侧的列，如果该列存在相同值，再接着参考右侧的键，依此类推。</strong>（如果左侧键值不同，右侧的键就不会被使用了）</li>
<li>NULL 值的顺序：<strong>排序键中出现了 NULL 值时，这类值会在结果的开头或结尾汇总</strong>，究竟是排在开头还是结尾，并没有特殊规定。</li>
<li>ORDER BY 子句只影响结果的先后顺序，因此排序键可以是结果集以外的东西，比如其他的列，或者使用了 GROUP BY 时，还能用聚合函数。</li>
</ol>
<h3 id="3-数据的增删改">3. 数据的增、删、改</h3>
<h4 id="插入insert-into-也算用的多了">插入(INSERT INTO) 也算用的多了</h4>
<p>语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表名</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="err">列名</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="err">列名</span><span class="mi">2</span><span class="p">...)</span><span class="w">
</span><span class="w">    </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="err">值</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="err">值</span><span class="mi">2</span><span class="p">...);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>或者也可以使用 SELECT 语句来替代 VALUES 子句，达到将 SELECT 到的结果集插入某表的效果。（但是不要用ORDER BY，因为结果是<strong>集</strong>，没有顺序，排序是徒劳无功的）
插入时主键不能重复，否则会报错。（因此如果需要包含重复数据，一般都会定义一个自增的id字段）</p>
<h4 id="删除delete">删除(DELETE)</h4>
<p>清空表（危险操作，而且效率不如 TRUNCATE）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">DELETE</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表名</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>条件删除：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">DELETE</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表名</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">WHERE</span><span class="w"> </span><span class="o">&lt;</span><span class="err">条件</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> 
</span></code></pre></td></tr></table>
</div>
</div><p>因此使用DELETE时，一定要记得带WHERE，不然就好玩了。。</p>
<h4 id="更新update">更新(UPDATE)</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">UPDATE</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表名</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">SET</span><span class="w"> </span><span class="o">&lt;</span><span class="err">列名</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="err">算术表达式</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="o">&lt;</span><span class="err">列名</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="err">表达式</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">...</span><span class="w">
</span><span class="w">    </span><span class="k">WHERE</span><span class="w"> </span><span class="o">&lt;</span><span class="err">条件</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>同 DELETE 一样，不带 WHERE 子句的 UPDATE 是很危险的。</p>
<h2 id="四dcl---事务处理mysql">四、DCL - 事务处理(MySQL)</h2>
<p><strong>事务是一系列不可分割的数据库操作</strong>，也就是说，这一系列操作要么全部执行，要么全部不执行。如果执行过程中发生了问题（检查执行状态），可以通过执行 ROLLBACK 回滚到该事务执行前的状态。（<strong>注意并不会自动回滚</strong>）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">START</span><span class="w"> </span><span class="n">TRANSACTION</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="c1">-- do somthing
</span><span class="c1"></span><span class="n">COMMIT</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>START TRANSACTION</code>: 标识事务的开始</li>
<li><code>COMMIT</code>：提交事务。一旦提交，所执行过的操作就已成定论，恢复不了了。</li>
<li><code>ROLLBACK</code>：事务回滚，**只能回滚未 COMMIT 的 DML 操作！**也就是说只能用在 <code>START TRANSACTION</code> 和 <code>COMMIT</code> 之间，并且只能回滚 <code>INSERT/UPDATE/DELETE</code>。（回滚 SELECT 没啥意义）</li>
<li><code>SAVEPOINT &lt;保留点&gt;</code> 和 <code>ROLLBACK TO &lt;保留点&gt;</code>：同样只能用在 <code>START TRANSACTION</code> 和 <code>COMMIT</code> 之间，其优势在于，<code>ROLLBACK TO</code> 可以指定回滚到某特定保留点，更灵活，而 <code>ROLLBACK</code> 只能回滚到事务开始前。</li>
</ul>
<p>需要注意的有：</p>
<ol>
<li><code>COMMIT</code> 和 <code>ROLLBACK</code> 语句也是事务的结束，因此如果执行了 <code>ROLLBACK</code>，那它与 <code>COMMIT</code> 之间的内容会被跳过。（在这一点上，它相当于大多数 PL 的 return）</li>
<li><strong>如果事务执行出现问题，问题行后面的所有语句都不会被执行！包括 <code>COMMIT</code> 和 <code>ROLLBACK</code>！</strong> 如果想用纯 SQL 实现事务原子性，必须使用存储过程检查执行状态！举例如下：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">CREATE PROCEDURE my_test()
    BEGIN
        DECLARE EXIT HANDLER FOR SQLEXCEPTION ROLLBACK  -- 检测到 SQLEXCEPTION 则 rollback，然后 exit
        START TRANSACTION
            INSERT INTO table_test VALUES(1, &#39;A&#39;)
            INSERT INTO table_test VALUES(1, &#39;B&#39;)  -- 这里主键冲突，会触发 SQLEXCEPTION

            COMMIT
    END

CALL my_test()
</code></pre></td></tr></table>
</div>
</div><p>或者<strong>在 PL 中通过异常处理执行 <code>ROLLBACK</code></strong>。（事务虽然中止了，但并未结束！所以仍然可以 <code>ROLLBACK</code> 或者 <code>COMMIT</code>）</p>
<h3 id="数据何时被提交到数据库">数据何时被提交到数据库</h3>
<ol>
<li>显式提交：在事务中使用 <code>COMMIT</code> 提交数据操作被称为显式提交</li>
<li>隐式提交：非 DML 操作会被立即提交，也就是说这些语句本身就隐含了提交语义</li>
<li>自动提交： 如果 <code>AUTOCOMMIT</code> 被设置为 <code>ON</code>，当前 session 中的 DML 语句会在执行后被自动提交（<code>START TRANSACTION</code> 内部的 DML 除外，在它内部必须显式 <code>COMMIT</code>）</li>
</ol>
<p>所有的 DML 语句都是要显式提交的，MySQL session 的 <code>AUTOCOMMIT</code> 默认为 <code>ON</code>，所以 DML 会被自动提交。</p>
<blockquote>
<p>P.S. 许多语言的数据库 API 会定义自己的事务操作，不一定与这里一致。</p>
</blockquote>
]]></description></item></channel></rss>