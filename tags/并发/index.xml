<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>并发 - 标签 - This Cute World</title><link>https://thiscute.world/tags/%E5%B9%B6%E5%8F%91/</link><description>并发 - 标签 - This Cute World</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaoyin_c@qq.com (ryan4yin)</managingEditor><webMaster>xiaoyin_c@qq.com (ryan4yin)</webMaster><lastBuildDate>Fri, 15 Mar 2019 22:34:00 +0800</lastBuildDate><atom:link href="https://thiscute.world/tags/%E5%B9%B6%E5%8F%91/" rel="self" type="application/rss+xml"/><item><title>Python 并发编程：PoolExecutor 篇</title><link>https://thiscute.world/posts/python-concurrency-pool-executor/</link><pubDate>Fri, 15 Mar 2019 22:34:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/python-concurrency-pool-executor/</guid><description><![CDATA[<blockquote>
<p>个人笔记，如有疏漏，还请指正。</p>
</blockquote>
<p>使用多线程（threading）和多进程（multiprocessing）完成常规的并发需求，在启动的时候 start、join 等步骤不能省，复杂的需要还要用 1-2 个队列。
随着需求越来越复杂，如果没有良好的设计和抽象这部分的功能层次，代码量越多调试的难度就越大。</p>
<p>对于需要并发执行、但是对实时性要求不高的任务，我们可以使用 concurrent.futures 包中的 PoolExecutor 类来实现。</p>
<p>这个包提供了两个执行器：线程池执行器 ThreadPoolExecutor 和进程池执行器 ProcessPoolExecutor，两个执行器提供同样的 API。</p>
<blockquote>
<p>池的概念主要目的是为了重用：让线程或进程在生命周期内可以多次使用。它减少了创建创建线程和进程的开销，提高了程序性能。重用不是必须的规则，但它是程序员在应用中使用池的主要原因。</p>
</blockquote>
<p>池，只有固定个数的线程/进程，通过 max_workers 指定。</p>
<ol>
<li>任务通过 executor.submit 提交到 executor 的任务队列，返回一个 future 对象。
<ul>
<li>Future 是常见的一种并发设计模式。一个Future对象代表了一些尚未就绪（完成）的结果，在「将来」的某个时间就绪了之后就可以获取到这个结果。</li>
</ul>
</li>
<li>任务被调度到各个 workers 中执行。但是要注意，<strong>一个任务一旦被执行，在执行完毕前，会一直占用该 worker！</strong>
<ul>
<li>**如果 workers 不够用，其他的任务会一直等待！**因此 PoolExecutor 不适合实时任务。</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">concurrent.futures</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">count</span>

<span class="n">number_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">evaluate_item</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">count</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>  <span class="c1"># count 是无限迭代器，会一直递增。</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
        <span class="c1"># 进程池</span>
        <span class="n">start_time_2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># 使用 with 在离开此代码块时，自动调用 executor.shutdown(wait=true) 释放 executor 资源</span>
        <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
                <span class="c1"># 将 10 个任务提交给 executor，并收集 futures</span>
                <span class="n">futures</span> <span class="o">=</span> <span class="p">[</span><span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">evaluate_item</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">number_list</span><span class="p">]</span>

                <span class="c1"># as_completed 方法等待 futures 中的 future 完成</span>
                <span class="c1"># 一旦某个 future 完成，as_completed 就立即返回该 future</span>
                <span class="c1"># 这个方法，使每次返回的 future，总是最先完成的 future</span>
                <span class="c1"># 而不是先等待任务 1，再等待任务 2...</span>
                <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">as_completed</span><span class="p">(</span><span class="n">futures</span><span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&#34;Thread pool execution in &#34;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time_2</span><span class="p">),</span> <span class="s2">&#34;seconds&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的代码中，item 为 1 2 3 4 5 的五个任务会一直占用所有的 workers，而 6 7 8 9 10 这五个任务会永远等待！！！</p>
<h2 id="api-详细说明">API 详细说明</h2>
<p>concurrent.futures 包含三个部分的 API：</p>
<ol>
<li>PoolExecutor：也就是两个执行器的 API
<ul>
<li>构造器：主要的参数是 max_workers，用于指定线程池大小（或者说 workers 个数）</li>
<li><code>submit(fn, *args, **kwargs)</code>：将任务函数 fn 提交到执行器，args 和 kwargs 就是 fn 需要的参数。
<ul>
<li>返回一个 future，用于获取结果</li>
</ul>
</li>
<li><code>map(func, *iterables, timeout=None, chunksize=1)</code>：当任务是同一个，只有参数不同时，可以用这个方法代替 submit。iterables 的每个元素对应 func 的一组参数。
<ul>
<li>返回一个 futures 的迭代器</li>
</ul>
</li>
<li><code>shutdown(wait=True)</code>：关闭执行器，一般都使用 with 管理器自动关闭。</li>
</ul>
</li>
<li>Future：任务被提交给执行器后，会返回一个 future
<ul>
<li><code>future.result(timout=None)</code>：<strong>最常用的方法</strong>，返回任务的结果。如果任务尚未结束，这个方法会一直等待！
<ul>
<li>timeout 指定超时时间，为 None 时没有超时限制。</li>
</ul>
</li>
<li><code>exception(timeout=None)</code>：给出任务抛出的异常。和 result() 一样，也会等待任务结束。</li>
<li><code>cancel()</code>：取消此任务</li>
<li><code>add_done_callback(fn)</code>：future 完成后，会执行 <code>fn(future)</code>。</li>
<li><code>running()</code>：是否正在运行</li>
<li><code>done()</code>：future 是否已经结束了，boolean</li>
<li>&hellip;详见官方文档</li>
</ul>
</li>
<li>模块带有的实用函数
<ul>
<li><code>concurrent.futures.as_completed(fs, timeout=None)</code>：等待 fs （futures iterable）中的 future 完成
<ul>
<li>一旦 fs 中的某 future 完成了，这个函数就立即返回该 future。</li>
<li>这个方法，使每次返回的 future，总是最先完成的 future。而不是先等待任务 1，再等待任务 2&hellip;</li>
<li>常通过 <code>for future in as_completed(fs):</code> 使用此函数。</li>
</ul>
</li>
<li><code>concurrent.futures.wait(fs, timeout=None, return_when=ALL_COMPLETED)</code>：一直等待，直到 return_when 所指定的事发生，或者 timeout
<ul>
<li>return_when 有三个选项：ALL_COMPLETED（fs 中的 futures 全部完成），FIRST__COMPLETED（fs 中任意一个 future 完成）还有 FIRST_EXCEPTION（某任务抛出异常）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="future-设计模式">Future 设计模式</h2>
<p>这里的 PoolExecutor 的特点，在于它使用了 Future 设计模式，使任务的执行，与结果的获取，变成一个异步的流程。
**我们先通过 submit/map 将任务放入任务队列，这时任务就已经开始执行了！**然后我们在需要的时候，通过 future 获取结果，或者直接 <code>add_done_callback(fn)</code>。</p>
<p>这里任务的执行是在新的 workers 中的，主进程/线程不会阻塞，因此主线程可以干其他的事。这种方式被称作异步编程。</p>
<h2 id="画外">画外</h2>
<p>concurrent.futures 基于 multiprocessing.pool 实现，因此实际上它比直接使用 线程/进程 的 Pool 要慢一点。但是它提供了更方便简洁的 API。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="http://www.dongwm.com/post/78/" target="_blank" rel="noopener noreferrer">使用Python进行并发编程-PoolExecutor篇</a></li>
<li><a href="https://github.com/laixintao/python-parallel-programming-cookbook-cn" target="_blank" rel="noopener noreferrer">Python Parallel Programming Cookbook</a></li>
<li><a href="https://docs.python.org/3/library/concurrent.futures.html" target="_blank" rel="noopener noreferrer">concurrent.futures — Launching parallel tasks</a></li>
<li><a href="https://www.cnblogs.com/kirito-c/p/10306133.html" target="_blank" rel="noopener noreferrer">进程线程协程与并发并行</a></li>
<li><a href="https://www.jianshu.com/p/fea4584d2890" target="_blank" rel="noopener noreferrer">并行设计模式（一）&ndash; Future模式</a></li>
</ul>
]]></description></item><item><title>进程线程协程与并发并行</title><link>https://thiscute.world/posts/process-thread-coroutines-concurrency-parallelism/</link><pubDate>Tue, 23 Jan 2018 16:39:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/process-thread-coroutines-concurrency-parallelism/</guid><description><![CDATA[<blockquote>
<p>个人笔记，不保证正确。</p>
</blockquote>
<h3 id="一进程-process并行运算分布式">一、进程 Process：（并行运算，分布式）</h3>
<p>每一个进程，都可以看作是一个完整的 Program，它有自己完全独立的内容。不与其他进程直接共享数据。（一个工作(job)可以由多个 process 完成，例如电脑上的qq/360就会有好几个进程，这种程序可能会有一个守护进程，当主进程挂掉，它会自动重启主进程。）</p>
<p>每个进程可以由多个线程组成。进程抽象由操作系统提供，Linux 是使用 fork 函数，Windows 是用 CreateProccess。</p>
<h3 id="二线程-thread并发执行">二、线程 Thread：（并发执行）</h3>
<p>属于同一个进程的线程之间，是共享一套工作内容的。这使得线程的创建和移除开销很小，但同时也使编程变得复杂。
</p>
<p>关于线程，分用户级线程和内核级线程。不同的语言中，这两种线程的对应关系也不尽相同。</p>
<ul>
<li>
<p>多对一模型
将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成，这种模型下操作系统并不知道多线程的存在。Python 就是这种模型。</p>
<ul>
<li><strong>优点</strong>：线程管理是在用户空间进行的，切换上下文开销比较小，性能较高。</li>
<li><strong>缺点</strong>：当一个线程在使用内核服务时被阻塞，那么整个进程都会被阻塞；多个线程不能并行地运行在多处理机上。</li>
</ul>
</li>
<li>
<p>一对一模型
将每个用户级线程映射到一个内核级线程。Java的线程就属于这种模型。</p>
<ul>
<li><strong>优点</strong>：当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强；能很好的利用到CPU的多核心。</li>
<li><strong>缺点</strong>：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。并且切换线程要进出内核，代价比较大。</li>
</ul>
</li>
<li>
<p>多对多模型
将n个用户级线程映射到m个内核级线程上，要求 m &lt;= n。GO（1.5之后）的协程就属于这种线程模型。</p>
<ul>
<li><strong>特点</strong>：既克服了多对一模型的并发度不高的缺点，又克服了一对一模型的一个用户进程占用太多内核级线程，开销太大的缺点。又拥有多对一模型和一对一模型各自的优点。</li>
</ul>
</li>
</ul>
<h3 id="三协程-coroutine并发执行">三、协程 Coroutine（并发执行）</h3>
<p>如果说线程是轻量级的进程，那么协程就是轻量级的线程。线程跑在进程里，协程就跑在线程里。</p>
<p>优点：</p>
<ol>
<li>协程是跑在同一个线程里，并且是由程序本身来调度的。协程间的切换就是函数的调用，完全没有线程切换那么大的开销。
<ul>
<li>线程的数量越多，协程的优势越大</li>
</ul>
</li>
<li>因为协程是程序调度的，它实际上是串行运行的，因此不需要复杂的锁机制来保证线程安全。
<ul>
<li>在协程中控制共享资源不加锁，只需要判断状态就好了。这免去了锁机制带来的开销。</li>
</ul>
</li>
</ol>
<p>因为协程跑在单个线程内，所占用的 CPU 资源有限，所以多协程<strong>并不能提升计算性能</strong>。不仅如此，因为多了程序本身的调度开销，计算密集型程序的性能反而会下降。</p>
<p>此外，协程代码中<strong>决不能出现阻塞</strong>，否则整个线程都会停下来等待该操作完成，这就麻烦了。</p>
<p>协程适合用于 IO 密集型任务，可用于简化异步 IO 的 callback hell。例如 Python 的 asyncio 就是用协程实现的。</p>
<h3 id="并发并行">并发并行</h3>
<p>由此，又引出两个名词：</p>
<ol>
<li>并发（Concurrent）：多个任务交替进行。</li>
<li>并行（Parallel）：多个任务同时进行。</li>
</ol>
<p>一张图说明两者的差别
</p>
<p><strong>Note</strong>：进程 和 线程 都可能是 并发 或 并行 的。关键看你程序的运行状态。多核是并行的前提。并发则只要求交替执行，因此单核也没问题。</p>
<h3 id="同步异步">同步异步</h3>
<ol>
<li>同步：不同程序单元为了完成某个任务，在执行过程中需靠某种通信方式以协调一致，称这些程序单元是同步执行的。
<ul>
<li>多线程编程中，所有修改共享变量的行为，都必须加锁，保证顺序执行，保证同步。或者加原子锁，保证该修改操作是原子的。</li>
<li>同步意味着有序</li>
</ul>
</li>
<li>异步：为完成某个任务，不同程序单元之间过程中无需通信协调，也能完成任务的方式。
<ul>
<li>不相关的程序单元之间可以是异步的。比如爬虫下载网页</li>
<li>异步意味着无序</li>
</ul>
</li>
</ol>
<ul>
<li><a href="https://www.cnblogs.com/euphie/p/7008077.html" target="_blank" rel="noopener noreferrer">进程、线程和协程</a></li>
</ul>
]]></description></item></channel></rss>