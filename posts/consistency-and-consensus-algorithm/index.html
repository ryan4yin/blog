<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>分布式数据库的一致性问题与共识算法 - This Cute World</title><meta name=Description content="This Cute World"><meta property="og:title" content="分布式数据库的一致性问题与共识算法"><meta property="og:description" content="个人笔记，不保证正确！ 谈到分布式数据库，不论是 Etcd/Zookeeper 这样的中心化数据库，还是 Ethereum 区块链这样的去中 心化数据库，都避免不了两个关键词：「一致性」跟「共"><meta property="og:type" content="article"><meta property="og:url" content="https://thiscute.world/posts/consistency-and-consensus-algorithm/"><meta property="og:image" content="https://thiscute.world/posts/consistency-and-consensus-algorithm/featured-image.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-07T04:11:23+08:00"><meta property="article:modified_time" content="2022-08-07T04:11:23+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://thiscute.world/posts/consistency-and-consensus-algorithm/featured-image.webp"><meta name=twitter:title content="分布式数据库的一致性问题与共识算法"><meta name=twitter:description content="个人笔记，不保证正确！ 谈到分布式数据库，不论是 Etcd/Zookeeper 这样的中心化数据库，还是 Ethereum 区块链这样的去中 心化数据库，都避免不了两个关键词：「一致性」跟「共"><meta name=application-name content="This Cute World"><meta name=apple-mobile-web-app-title content="This Cute World"><meta name=theme-color content="#f8f8f8"><meta name=twitter:creator content="@ryan4yin"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=https://thiscute.world/posts/consistency-and-consensus-algorithm/><link rel=prev href=https://thiscute.world/posts/kubernetes-cert-management/><link rel=next href=https://thiscute.world/posts/learn-english-again/><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/color.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><meta name=google-site-verification content="E8bpp1lVVlb9YnSJcUzPL1dLAG17Nl_sp5Ru9a8tUDQ"><meta name=baidu-site-verification content="code-ZZtDruAnX1"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"分布式数据库的一致性问题与共识算法","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https://thiscute.world/posts/consistency-and-consensus-algorithm/"},"image":[{"@type":"ImageObject","url":"https://thiscute.world/posts/consistency-and-consensus-algorithm/featured-image.webp","width":974,"height":312}],"genre":"posts","keywords":"共识, 一致性, 分布式, 数据库, 区块链","wordcount":12267,"url":"https://thiscute.world/posts/consistency-and-consensus-algorithm/","datePublished":"2022-08-07T04:11:23+08:00","dateModified":"2022-08-07T04:11:23+08:00","publisher":{"@type":"Organization","name":"ryan4yin","logo":"https://thiscute.world/avatar/myself.png"},"author":{"@type":"Person","name":"ryan4yin"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e),document.documentElement.style.setProperty("color-scheme",e==="light"?"light":"dark"),window.theme=e,window.isDark=window.theme!=="light"}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(e){const t=document.getElementsByTagName("meta");for(let n=0;n<t.length;n++)if(t[n].getAttribute("name")===e)return t[n];return""}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"||e==="black"?setTheme(e):setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")}else"auto"==="light"||"auto"==="dark"||"auto"==="black"?(setTheme("auto"),saveTheme("auto")):(saveTheme("auto"),setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"));let metaColors={light:"#f8f8f8",dark:"#252627",black:"#000000"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")],window.switchThemeEventSet=new Set</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="This Cute World"><span id=desktop-header-typeit class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/statistics/>阅读排行 </a><a class=menu-item href=/series/>系列 </a><a class=menu-item href=/categories/tech/>技术 </a><a class=menu-item href=/categories/life/>生活 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/friends/>朋友们 </a><a class=menu-item href=/now/>此刻 </a><a class=menu-item href=/about/>关于 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item language" title=选择语言>Simplified Chinese<i class="fas fa-chevron-right fa-fw"></i>
<select class=language-select title=选择语言 id=language-select-desktop onchange="location=this.value"><option value=/posts/consistency-and-consensus-algorithm/ selected>Simplified Chinese</option></select>
</a><span class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="This Cute World"><span id=mobile-header-typeit class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/statistics/ title>阅读排行</a><a class=menu-item href=/series/ title>系列</a><a class=menu-item href=/categories/tech/ title>技术</a><a class=menu-item href=/categories/life/ title>生活</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/friends/ title>朋友们</a><a class=menu-item href=/now/ title>此刻</a><a class=menu-item href=/about/ title>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
</a><a href=javascript:void(0); class=menu-item title=选择语言>Simplified Chinese<i class="fas fa-chevron-right fa-fw"></i>
<select class=language-select title=选择语言 onchange="location=this.value"><option value=/posts/consistency-and-consensus-algorithm/ selected>Simplified Chinese</option></select></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto><nav id=TableOfContents><ul><li><a href=#一一致性---consistency>一、一致性 - Consistency</a><ul><li><a href=#1-事务一致性---transactions-consistency>1. 事务一致性 - Transactions Consistency</a><ul><li><a href=#事务与-acid-理论>事务与 ACID 理论</a></li><li><a href=#acid-中最复杂的特性---隔离性>ACID 中最复杂的特性 - 隔离性</a></li></ul></li><li><a href=#2-数据一致性-data-consistency>2. 数据一致性 Data Consistency</a><ul><li><a href=#数据一致性模型>数据一致性模型</a><ul><li><a href=#1-状态视角---强一致与弱一致>1. 状态视角 - 强一致与弱一致</a></li><li><a href=#2-操作视角---多种一致性模型>2. 操作视角 - 多种一致性模型</a></li></ul></li></ul></li></ul></li><li><a href=#二分布式系统的-base-与最终一致性>二、分布式系统的 BASE 与最终一致性</a></li><li><a href=#三共识算法>三、共识算法</a><ul><li><a href=#拜占庭将军问题与拜占庭容错>拜占庭将军问题与拜占庭容错</a></li><li><a href=#常用共识算法>常用共识算法</a></li><li><a href=#不同共识算法的应用场景>不同共识算法的应用场景</a></li><li><a href=#非拜占庭错误共识算法-paxos-与-raft>非拜占庭错误共识算法 Paxos 与 Raft</a></li><li><a href=#能容忍拜占庭错误的-pow-概率共识算法>能容忍拜占庭错误的 PoW 概率共识算法</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">分布式数据库的一致性问题与共识算法</h1><div class=post-meta><div class=post-meta-line><span class=post-author><span class="author fas fa-user-circle fa-fw"></span><a href=https://thiscute.world/ title=Author target=_blank rel="noopener noreferrer author" class=author>ryan4yin</a>
</span>&nbsp;<span class=post-category>收录于 </span>&nbsp;<span class=post-category>类别 <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>tech</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-08-07>2022-08-07</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2022-08-07>2022-08-07</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 12267 字&nbsp;<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 25 分钟&nbsp;</div></div><div class=featured-image><img loading=eager src=/posts/consistency-and-consensus-algorithm/featured-image.webp srcset="/posts/consistency-and-consensus-algorithm/featured-image.webp, /posts/consistency-and-consensus-algorithm/featured-image.webp 1.5x, /posts/consistency-and-consensus-algorithm/featured-image.webp 2x" sizes=auto alt=/posts/consistency-and-consensus-algorithm/featured-image.webp title=/posts/consistency-and-consensus-algorithm/featured-image.webp height=312 width=974></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#一一致性---consistency>一、一致性 - Consistency</a><ul><li><a href=#1-事务一致性---transactions-consistency>1. 事务一致性 - Transactions Consistency</a><ul><li><a href=#事务与-acid-理论>事务与 ACID 理论</a></li><li><a href=#acid-中最复杂的特性---隔离性>ACID 中最复杂的特性 - 隔离性</a></li></ul></li><li><a href=#2-数据一致性-data-consistency>2. 数据一致性 Data Consistency</a><ul><li><a href=#数据一致性模型>数据一致性模型</a><ul><li><a href=#1-状态视角---强一致与弱一致>1. 状态视角 - 强一致与弱一致</a></li><li><a href=#2-操作视角---多种一致性模型>2. 操作视角 - 多种一致性模型</a></li></ul></li></ul></li></ul></li><li><a href=#二分布式系统的-base-与最终一致性>二、分布式系统的 BASE 与最终一致性</a></li><li><a href=#三共识算法>三、共识算法</a><ul><li><a href=#拜占庭将军问题与拜占庭容错>拜占庭将军问题与拜占庭容错</a></li><li><a href=#常用共识算法>常用共识算法</a></li><li><a href=#不同共识算法的应用场景>不同共识算法的应用场景</a></li><li><a href=#非拜占庭错误共识算法-paxos-与-raft>非拜占庭错误共识算法 Paxos 与 Raft</a></li><li><a href=#能容忍拜占庭错误的-pow-概率共识算法>能容忍拜占庭错误的 PoW 概率共识算法</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div><div class=content id=content><blockquote><p>个人笔记，不保证正确！</p></blockquote><p>谈到分布式数据库，不论是 Etcd/Zookeeper 这样的中心化数据库，还是 Ethereum 区块链这样的去中
心化数据库，都避免不了两个关键词：「<strong>一致性</strong>」跟「<strong>共识</strong>」。</p><p>本文是笔者学习「<strong>一致性</strong>」和「<strong>共识</strong>」以及相关的理论知识时记录的笔记，这些知识能帮助我
们了解 Etcd/Zookeeper/Consul/MySQL/PostgreSQL/DynamoDB/Cassandra/MongoDB/CockroachDB/TiDB
等一众数据库的区别，理解各数据库的优势与局限性，搞懂数据库隔离级别的含义以及应该如何设置，
并使我们能在各种应用场景中选择出适用的数据库。</p><p>如果你对区块链感兴趣，那这篇文章也能帮助你了解区块链这样的去中心化数据库，跟业界流行的分布
式数据库在技术上有何区别，又有哪些共同点，具体是如何实现。</p><h2 id=一一致性---consistency class=headerLink><a href=#%e4%b8%80%e4%b8%80%e8%87%b4%e6%80%a7---consistency class=header-mark></a>一、一致性 - Consistency</h2><p>「一致性」本身是一个比较模糊的定义，视使用场景的不同，存在许多不同的含义。由于数据库仍然是
一个新兴领域，目前存在许多不同的一致性模型，其中的一些术语描述的一致性之间可能还有重叠关
系，这些关系甚至会困扰专业的数据库开发人员。</p><p>但是究其根本，实际上在谈论一致性时，我们是在谈论<strong>事务一致性</strong>跟<strong>数据一致性</strong>，下面我们分
别介绍下这两个一致性。</p><h3 id=1-事务一致性---transactions-consistency class=headerLink><a href=#1-%e4%ba%8b%e5%8a%a1%e4%b8%80%e8%87%b4%e6%80%a7---transactions-consistency class=header-mark></a>1. 事务一致性 - Transactions Consistency</h3><p>「事务一致性」指的是数据库中事务的一致性，它是 ACID 理论中最不起眼的特性，也并不是本文的重
点。但是这里就写这么一句话也说不过去，所以下面就仔细介绍下事务与 ACID 理论。</p><h4 id=事务与-acid-理论 class=headerLink><a href=#%e4%ba%8b%e5%8a%a1%e4%b8%8e-acid-%e7%90%86%e8%ae%ba class=header-mark></a>事务与 ACID 理论</h4><p>事务是一种「要么全部完成，要么完全不做（All or Nothing）」的指令运行机制。</p><p><strong>ACID 理论</strong>定义，拥有如下四个特性的「数据库指令序列」，就被称为事务：</p><ul><li><strong>原子性 Atomicity</strong>：事务是一个不可分割的工作单元，事务中的所有操作，要么全部完成，要么
全部不完成，不可能停滞在某个中间状态。<ul><li>比如 A 转账 100 元给 B，要么转账失败，要么转账成功，不可能卡在 A 被扣除了 100 元，而 B
还没收到 100 元的中间状态。</li><li>原子性在单机数据库上已得到妥善解决，但是在分布式数据库上它成为一项新的挑战。要在分布式
架构下支持原子性并不容易，所以不少 NoSQL 产品都选择绕过这个问题，聚焦到那些对原子性不
敏感的细分场景。</li></ul></li><li><strong>一致性 Consistency</strong>：也叫数据的「<strong>正确性 Correctness</strong>」或者完整性，指事务对数据库状
态的变更必须满足所有预定义的规则，包括「约束 constraints」、「级联 cascades」、「触发器
triggers」以及这些规则的任何组合。<ul><li>比如如果用户为某个字段设置了约束条件 <code>unique</code>，那么事务对该表的所有修改都必须保证此约
束成立，否则它将会失败。</li><li>是存在感最低的特性</li></ul></li><li><strong>隔离性 Isolation</strong>：<strong>并发执行的多个事务之间是完全隔离的</strong>，它们的执行效果跟按事务的开
始顺序串行执行完全一致。<ul><li>事务中最复杂的特性</li></ul></li><li><strong>持久性 Durability</strong>：事务执行完毕后，结果就保存不变了。这个最好理解。</li></ul><p>ACID 是传统的单机数据库的核心特性，比如 MySQL/PostgreSQL.</p><h4 id=acid-中最复杂的特性---隔离性 class=headerLink><a href=#acid-%e4%b8%ad%e6%9c%80%e5%a4%8d%e6%9d%82%e7%9a%84%e7%89%b9%e6%80%a7---%e9%9a%94%e7%a6%bb%e6%80%a7 class=header-mark></a>ACID 中最复杂的特性 - 隔离性</h4><p>完全地实现 ACID 得到的数据库，性能是非常差的。因此在关系数据库中，设计者通常会选择牺牲相对
不重要的「隔离性」来获取更好的性能。</p><p>而一旦隔离不够彻底，就可能会遇到一些事务之间互相影响的异常情况，这些异常被分为如下几种：</p><ul><li><strong>脏写 Dirty writes</strong>：即事务 T1 跟事务 T2 同时在原数据的基础上更新同一个数据，导致结果
不符合预期。<ul><li>案例：两个事务同时尝试从账户中扣款 1000 元，但是它们读到的初始状态都是 5000 元，于是都
尝试将账户修改为 4000 元，结果就是少扣了 1000 元。</li><li>最简单的解决方法：针对 <code>UPDATE table SET field = field - 1000 WHERE id = 1</code> 这类数据增
删改的逻辑，需要对被更新的行加一把「行写锁」，使其他需要写此数据的事务等待。</li></ul></li><li><strong>脏读 Dirty reads</strong>：事务 T1 读取了事务 T2 未提交的数据。这个数据不一定准确，被称为脏数
据，因为假如事务 T2 回滚了，T1 拿到的就是一个错误的数据<ul><li>案例：假设小明小红在一个银行账户存了 5000 元，小明小红在用这同一个账户消费 1000 元，这
中间小明付款的事务读取到账户已经被小红的事务修改为了 4000 元，于是它把余额修改为 3000
元，然后付款成功。但是在小明的付款事务成功后，小红的付款失败回滚了，余额又从 3000 被修
改回 5000 元。小明就完成了 0 元购的壮举。</li><li>最简单的解决方法：事务 T2 写数据时对被修改的行加「行写锁」，T2 结束后再释放锁，这样事
务 T1 的读取就会被阻塞，直到锁释放。</li></ul></li><li><strong>不可重复读 Non-repeatable reads</strong>：事务 T1 读取数据后，紧接着事务 T2 就更新了数据并提
交，事务 T1 再次读取的时候发现数据不一致了<ul><li>案例：<ul><li>小明在京东上抢购商品，抢购事务启动时事务读到还剩 36 件商品，于是继续执行抢购逻辑，之
后事务因为某种原因需要再读一次商品数量，结果发现商品数量已经变成 0 了，抢购失败。</li><li>更麻烦的是，不可重复读导致 SELECT 跟 UPDATE 之间也可能出现数据变更，如果你在事务中先
通过 <code>SELECT field INTO myvar FROM mytable WHERE uid = 1</code> 读到余额，再在此基础上通过
<code>UPDATE</code> 去更新余额，很可能导致数据变得一团糟！<ul><li>正确的做法是使用 <code>UPDATE mytable SET field = field - 1000 WHERE id = 1</code>，因为每一
条 SQL 命令本身都是原子的，这个 SQL 不会有问题。</li></ul></li></ul></li><li>最简单的解决办法：事务 T1 读数据时，也加一把「行」锁，直到不再需要读该数据了，再释放
锁。</li></ul></li><li><strong>幻读 Phantom reads</strong>：事务 T1 在多次批量读数据时，事务 T2 往其中执行了插入/删除操作，
导致 T1 读到的是旧数据的一个残影，而非当前真实的数据状态。<ul><li>最简单的解决办法：事务 T1 在批量读数据时，先加一把范围锁，在事务 T1 结束读取之后，再释
放这把锁。这能同时解决「幻读」跟「不可重复读」的问题。</li></ul></li></ul><p>根据隔离程度，ANSI SQL-92 标准中将「隔离性」细分为四个等级（避免「脏写」是数据库的必备要
求，因此未记录在下面的四个等级中）：</p><ul><li><strong>串行化 Serializable</strong>：也就是完全的隔离，只要事务之间存在互相影响的可能，就（通过锁机
制）强制它们串行执行。</li><li><strong>可重复读 Repeatable read</strong>：可避免脏读、不可重复读的发生，但是解决不了幻读的问题。</li><li><strong>读已提交 Read committed</strong>：只能避免脏读</li><li><strong>读未提交 Read uncommitted</strong>：最低级别，完全放弃隔离性</li></ul><p>MySQL 默认的隔离级别为「可重复读 Repeatable Read」，PostgreSQL 和 Oracle 默认隔离级别为
「读已提交 Read committed」。</p><p>为什么 MySQL/PostgreSQL/Oracle 的默认隔离级别是这样设置的呢？该如何选择正确的隔离级别呢？
我们针对普通的高并发业务场景做个简单分析：</p><ul><li>首先，「脏读」是必须避免的，它会使事务读到错误的数据！最低的「读未提交」级别直接排除</li><li>「串行化」的性能太差，也直接排除</li><li>只要 SQL 用得对，「不可重复读」问题对业务逻辑的正确性通常并无影响，所以是可以容忍的。</li><li><strong>因此一般「读已提交」是最佳的隔离级别</strong>，这也是 PostgreSQL/Oracle 将其设为默认隔离级别
的原因。</li><li>那么为什么 MySQL 这么特立独行，将默认隔离级别提高到了「可重复读」呢？为啥阿里这种大的互
联网公司又会把 MySQL 默认的隔离级别改成「读已提交」？<ul><li>根据网上查到的资料，这是 MySQL 的历史问题导致的。MySQL 5.0 之前只支持 statement 这种
binlog 格式，此格式在「读已提交」的隔离级别下会出现诸多问题，最明显的就是可能会导致主
从数据库的数据不一致。</li><li>除了设置默认的隔离级别外，MySQL 还禁止在使用 statement 格式的 binlog 时，使用 READ
COMMITTED 作为事务隔离级别，尝试修改隔离级别会报错
<code>Transaction level 'READ-COMMITTED' in InnoDB is not safe for binlog mode 'STATEMENT'</code></li><li>而互联网公司将隔离级别改为「读已提交」的原因也很好理解，正如前文所述「读已提交」是最佳
的隔离级别，这样修改能够提升数据库的性能。</li></ul></li></ul><p>「隔离性」的本质其实就是<strong>事务的并发控制</strong>，不同的隔离级别代表了对并发事务的隔离程度，主要
的实现手段是「<strong>多版本并发控制 MVCC</strong>」与「锁」。锁机制前面已经简单介绍过了，而 MVCC 其实
就是为每个事务创建一个特定隔离级别的快照，这样读写不会互相阻塞，性能就提升了。（MVCC 暂时
也是超纲知识，后面再研究吧 emmmm）</p><p>ANSI SQL-92 对异常现象的分析仍然太过简单了，1995 年新发布的论文
<a href=https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf target=_blank rel="noopener noreferrer">A Critique of ANSI SQL Isolation Levels</a>
丰富和细化了 SQL-92 的内容，定义了六种隔离级别和八种异常现象（有大佬强烈建议通读此论文，重
点是文中的快照隔离（Snapshot Isolation, SI）级别）。</p><h3 id=2-数据一致性-data-consistency class=headerLink><a href=#2-%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7-data-consistency class=header-mark></a>2. 数据一致性 Data Consistency</h3><p>「数据一致性」是指对数据库的每一次读操作都应该读到最新写入的数据，或者直接报错。</p><p>对单机数据库而言「数据一致性」往往不是问题，因为它通常只有一份保存在磁盘或内存中的数据。但
是在分布式系统中，为了数据安全性或者为了性能，往往每一份数据都在多个节点上存有其副本，这就
引出了数据副本们的一致性问题。因此，我们通常谈论的「数据一致性」就是指分布式系统的「数据一
致性」。</p><p><strong>CAP 原则</strong>是分布式系统领域一个著名的理论，它告诉我们在分布式系统中如下三种属性不可能全部
达成，因此也被称作「<strong>CAP 不可能三角</strong>」：</p><ul><li><strong>数据一致性 Data Consistency</strong>：客户端的每次读操作，不管访问系统的哪个节点，要么读到的
都是同一份最新写入的数据，要么读取失败<ul><li>强调数据完全正确</li></ul></li><li><strong>可用性 Availability</strong>：任何来自客户端的请求，不管访问哪个非故障节点，都能得到响应数
据，但不保证是同一份最新数据<ul><li>强调的是服务可用，但不保证数据正确</li></ul></li><li><strong>分区容错性 Partition Tolerance</strong>：即使节点之间出现了任意数量的消息丢失或者高延迟，系统
仍能正常运行<ul><li>就是说网络丢包或延迟会导致系统被分成多个 Partition，系统能够容忍这种情况</li></ul></li></ul><p>为了保证分区容错性 P，考虑当分布式系统因为网络问题被割裂成多个分区时，每个分区只有如下两种
选择，A 跟 C 必须牺牲掉其中之一：</p><ul><li>取消操作并拒绝提供服务，这降低了可用性，但是能确保数据一致性</li><li>继续处理请求，这确保了可用性，但是数据一致性就无法保证了</li></ul><p>如果系统的多个分区都在同时提供服务，导致数据不一致并且存在冲突无法合并，这就被称为分布式系
统的「<strong>脑裂</strong>」，显然任何分布式系统都不会希望发生「脑裂」。</p><p>因为分布式系统与单机系统不同，它涉及到多节点间的网络通讯和交互，但是只要有网络交互就一定会
有延迟和数据丢失，节点间的分区故障是很有可能发生的。因此为了正常运行，P 是分布式系统必须保
证的特性，<strong>在出现分区故障时，为了 P 只能牺牲掉 A 或者 C</strong>。</p><p>工程上是要 AP 还是 CP，得视情况而定：</p><ul><li>Etcd/Zookeeper/Consul: 它们通常被用于存储系统运行的关键元信息，每次读，都要能读取到最新
数据。因此它们实现了 CP，牺牲了 A</li><li>DynamoDB/Cassandra/MongoDB：不要求数据一致性，一段时间内用旧的缓存问题也不大，但是要求可
用性，因此应该实现 AP，牺牲掉 C</li></ul><h4 id=数据一致性模型 class=headerLink><a href=#%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7%e6%a8%a1%e5%9e%8b class=header-mark></a>数据一致性模型</h4><p>分布式系统中，多副本数据上的一组读写策略，被称为「（数据）一致性模型 Consistency Model」。
一致性模型数量很多，让人难以分辨。为了便于理解，我们先从状态视角出发区分一下强一致与弱一致
的概念，在这个的基础上再从操作视角去理解这众多的一致性模型。</p><h5 id=1-状态视角---强一致与弱一致 class=headerLink><a href=#1-%e7%8a%b6%e6%80%81%e8%a7%86%e8%a7%92---%e5%bc%ba%e4%b8%80%e8%87%b4%e4%b8%8e%e5%bc%b1%e4%b8%80%e8%87%b4 class=header-mark></a>1. 状态视角 - 强一致与弱一致</h5><p>我们首先把整个分布式系统看作一个<strong>白盒</strong>，从状态视角看，任何变更操作后，分布式系统的多个数
据副本只有如下三种状态：</p><ul><li>在某些条件下，各副本状态不一致的现象只是暂时的，后续还会转换到一致的状态，这被称为「<strong>弱
一致</strong>」；<ul><li>这通常是使用<strong>异步复制</strong>来同步各副本的状态。</li></ul></li><li>相对的说，如果系统各副本不存在「不一致」这种状态，只要变更操作成功数据就一定完全一致，那
它就被称为「<strong>强一致</strong>」。<ul><li>这要求所有副本之间的数据更新必须完全同步，就必须使用<strong>全同步复制</strong>。</li></ul></li><li><strong>永远不会一致</strong>：这在分布式系统中就是 bug 了，也被称为「脑裂」。</li></ul><p>上面描述的是整个系统的客观、实际状态，但对于绝大部分用户而言分布式系统更多的是一个<strong>黑
盒</strong>，因此更流行的是基于「黑盒」的分类方式，它根据系统的对外状态将系统分成两种类型：</p><ul><li><strong>强一致</strong>：指对系统的任何节点/进程，写操作完成后，任何用户对任何节点的后续访问都能读到
新的值。就好像系统只存在一个副本一样。<ul><li>最常用算法是 Raft/Paxos，它们的写操作只要求超过半数节点写入成功，因此写入完成时，内部
状态实际是不一致的，但是对它进行读写，效果跟「全同步复制」没有区别。</li></ul></li><li><strong>弱一致</strong>：指对系统的任何节点/进程，写操作完成后，后续的任何访问可能会拿到的值是不确定
的，但经过一段时间后，后续的任何访问都能读到新的值。<ul><li>弱一致是非常模糊的定义。如果我们把最终所有用户都能访问到新的值被称为「<strong>系统收敛</strong>」，
系统收敛的用时可以有明确边界，也可以没有。系统收敛前的访问行为可以有明确规范，也可以不
存在规范。一切都看具体系统的实现。</li><li>如果系统能够在有限时间内收敛，那它就是「<strong>最终一致</strong>」，否则可以认为它是「<strong>不一
致</strong>」。</li></ul></li></ul><p>为了实际需要，数据库专家对系统收敛之前的读写效果进行各种限制，对系统的收敛时间进行各种限
制，得到了许多一致性模型。</p><h5 id=2-操作视角---多种一致性模型 class=headerLink><a href=#2-%e6%93%8d%e4%bd%9c%e8%a7%86%e8%a7%92---%e5%a4%9a%e7%a7%8d%e4%b8%80%e8%87%b4%e6%80%a7%e6%a8%a1%e5%9e%8b class=header-mark></a>2. 操作视角 - 多种一致性模型</h5><p>从每个客户端的操作角度看，有四种一致性模型：</p><ul><li><strong>写后读一致性 Read after Write Consistency</strong>：也被称作「读自己所写一致性」，即自己写完
数据版本 N 后，后续读到的版本一定不小于版本 N。<ul><li>它解决的问题：A 发了个抖音视频，刷新页面后却莫名其妙消失了（旧版本），几分钟后才重新刷
出来。</li><li>实现方式之一：为写入者单独添加一个读取规则，他的读都由已更新其写入数据的副本来处理。</li></ul></li><li><strong>单调读一致性 Monotonic Read Consistency</strong>：保证多个读操作的顺序，即客户端一旦读到某个
数据版本 N，后续不会读到比 N 更低的版本。<ul><li>它解决的问题是：A 删除了一个抖音视频，可多次刷新，偶尔刷不到视频，偶尔又能刷到被删除视
频（旧版本），几分钟后才彻底被删除。</li><li>实现方式之一：为每个用户的读都创建一个副本映射，后续的读都由一个固定的副本处理，避免随
机切换副本而读到更老的值。</li></ul></li><li><strong>单调写一致性 Monotonic Write Consistency</strong>：保证多个写操作的顺序，即客户端对同一数据的
两次写入操作，一定按其被提交的顺序被执行。</li><li><strong>读后写一致性 Write after Read Consistency</strong>：读后写一致性，保证一个客户端读到数据版本
N 后（可能是其他客户端写入的），随后对同一数据的写操作必须要在版本号大于等于 N 的副本上
执行。</li></ul><p>上述四个一致性模型都只从每个客户端自身的角度定义规则，比较片面，因此它们都是「弱一致模
型」。</p><p>而不考虑客户端，直接从所有数据库用户的操作视角看，有如下几种一致性模型：</p><ul><li><strong>线性一致性 Linearizability</strong>：线性一致性利用了事件的提交顺序，它保证任何读操作得到的数
据，其顺序跟读/写事件的提交顺序一致。<ul><li>简单的说它要求<strong>整个系统表现得像只存在一个副本</strong>，所有操作的执行结果就跟这些事件按提交
顺序完全串行执行一样。这实际也是在说所有并发事件都是原子的，一旦互相之间存在冲突，就一
定得按顺序执行，因此也有人称它为「原子一致性」。</li><li>线性一致性，完全等价于系统对外状态的「强一致性」</li><li>线性一致性的系统是完全确定性的</li><li>实现方式：需要一个所有节点都一致的「<strong>全局时钟</strong>」，这样才可以对所有事件进行全局排序。<ul><li>大多数分布式数据库如 TiDB/Etcd 都是通过 NTP 等协议进行单点授时与同步实现的全局时钟。</li><li>有全球化部署需要的 Google Spanner 是使用 GPS + 原子钟实现的全局时钟 TrueTime，全局误
差可以控制在 7ms 以内。</li></ul></li><li>局限性：根据爱因斯坦相对论，「时间是相对的」，实际上并不存在绝对的时间，因此线性一致性
只在经典物理学范围内适用。</li></ul></li><li><strong><a href=https://en.wikipedia.org/wiki/Consistency_model target=_blank rel="noopener noreferrer">顺序一致性 Sequentially Consistent</a></strong>：
顺序一致性最早是 Leslie Lamport 用来描述多核 CPU 的行为的，在分布式系统领域用得较少。<ul><li>顺序一致性的要求有两点：<ul><li>从单个进程（副本）的角度看，所有指令的执行顺序跟代码逻辑的顺序完全一致。</li><li>从所有的处理器（整个分布式系统）角度看，写操作不必立即对所有用户可见，但是所有副本必
须以相同的顺序接收这些写操作。</li></ul></li><li>顺序一致性和线性一致性都是要找到一个满足「写后读」的一组操作历史，差异在于<strong>线性一致性
要求严格的时间序，而顺序一致性只要求满足代码的逻辑顺序</strong>，而其他代码逻辑未定义的事件顺
序（比如多副本上各事件之间的顺序），具体是什么样的顺序无所谓，只要所有副本看到的事件顺
序都相同就行。</li><li>顺序一致性并不能提供「确定性」，相同的两次操作仍然可能得到不同的事件顺序。</li><li>实现方式：因为不要求严格的全局时间序，它就不需要一个全局时钟了，但实际上为了满足全局的
确定性，仍然需要一些复杂的操作。</li></ul></li><li><strong>因果一致性 Causal Consistency</strong>：线性一致性的全局时钟有其局限性，而因果一致性基于写事
件的「偏序关系」提出了「<strong>逻辑时钟</strong>」的概念，并保证读顺序与逻辑时钟上的写事件顺序一致。<ul><li>写事件的「偏序关系」关系是指，至少部分事件（比如一个节点内部的事件）是可以使用本地时钟
直接排序的，而节点之间发生通讯时，接收方的事件一定晚于调用方的事件。基于这一点可以实现
一个「<strong>逻辑时钟</strong>」，但逻辑时钟的缺点在于，如果某两个事件不存在相关性，那逻辑时钟给出
的顺序就没有任何意义。</li><li>多数观点认为，因果一致性弱于线性一致性，但<strong>在并发性能上具有优势，也足以处理多数的异常
现象</strong>，所以因果一致性也在工业界得到了应用。</li><li>CockroachDB 和 YugabyteDB 都在设计中采用了逻辑混合时钟（Hybrid Logical Clocks），这个
方案源自 Lamport 的逻辑时钟，也取得了不错的效果</li></ul></li><li><strong>前缀一致性 Consistent Prefix</strong>：副本之间的同步过程中，会存在一些副本接收数据的顺序并不
一致。「前缀一致性」是说所有用户读到的数据顺序的前缀永远是一致的。<ul><li>「前缀」是指程序在执行写操作时，需要显式声明其「前缀」事件，这样每个事件就都存在一个由
其他写事件排列而成的前缀。比如当前有写事件排列「A B C D」，那所有用户读到的数据都拥有
同样的写事件前缀，比如「A」、「A B」、「A B C」、「A B C D」，但不可能出现「A C」或者
「C A」等结果。</li><li>它解决的是<strong>分片分布式数据库</strong>的一致性问题：A B C 因为地域区别读写的是不同的副本，B 在
抖音评论区问了个问题，然后 A 作出了回答。但是问题跟回答两个数据如果处于不同的分片，副
本同步时这两个数据的顺序是无法保证的，C 可能会先读到回答信息，之后才刷新出 B 的提问，
历史事件的顺序就乱了。</li><li>实现方式：需要程序主动为消息之间添加显式的依赖关系，再据此控制其读取顺序，实现比较复
杂。</li><li>存在的问题：只有被显式定义了因果关系的事件，它们之间的顺序才能被保证。</li></ul></li></ul><p>其中<strong>线性一致性</strong>就是<strong>强一致性</strong>，其他所有的模型都是<strong>弱一致性模型</strong>或者说<strong>最终一致性模
型</strong>。所有这些模型按强度降序排列如下：</p><ul><li>线性一致性/强一致性：系统对外表现得好像整个系统完全一致，不存在不一致的情况。</li><li>顺序一致性：只保证每个节点上的事件顺序一致，对节点之间的事件顺序只有非常宽松的要求。</li><li>因果一致性：同样只保证每个节点上的事件顺序一致，但是对节点之间的事件顺序的要求比顺序一致
性更宽松。</li><li>有界旧一致性（Bounded Staleness）：保证读到的数据与最新版本的差距不超过 K 个版本</li><li>会话一致性（Session Consistency）：在一个会话内保证单调读，单调写，和读自己所写，会话之
间不保证</li><li>前缀一致性：在每个会话内保证了单调读，会话之间不保证</li><li>客户端角度的四个一致性模型：写后读、单调读、单调写、读后写。这四个模型的视角都非常片面，
通常被包含在前述的一致性模型中。</li></ul><p>更完整的关系树状图：<a href=https://jepsen.io/consistency target=_blank rel="noopener noreferrer">Consistency Models</a></p><h2 id=二分布式系统的-base-与最终一致性 class=headerLink><a href=#%e4%ba%8c%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e7%9a%84-base-%e4%b8%8e%e6%9c%80%e7%bb%88%e4%b8%80%e8%87%b4%e6%80%a7 class=header-mark></a>二、分布式系统的 BASE 与最终一致性</h2><p>BASE 理论：</p><ul><li><strong>基本可用 Basically Available</strong>：当分布式系统在出现不可预知的故障时，允许损失部分功能的
可用性，保障核心功能的可用性<ul><li>四种实现基本可用的手段：流量削峰、延迟响应、体验降级、过载保护</li></ul></li><li><strong>软状态 Soft state</strong>：在柔性事务中，允许系统存在中间状态，且这个中间状态不会影响系统整
体可用性。比如，数据库读写分离，写库同步到读库（主库同步到从库）会有一个延时，其实就是一
种柔性状态。</li><li><strong>最终一致性 Eventually consistent</strong>：前面已经说得很详细了，它指对系统的任何节点/进程，
写操作完成后，后续的任何访问可能会拿到的值是不确定的，但经过有限的一段时间后，后续的任何
访问都能读到新的值。</li></ul><p>ACID 与 BASE 实质上是分布式系统实现中的的两个极端：</p><ul><li>ACID 理论就如它的含义「<strong>酸</strong>」一样，是 CAP 原则中一致性的边界——<strong>最强的一致性</strong>，是牺牲
掉 A 后达到 CP 的极致。</li><li>BASE 翻译过来就是「<strong>碱</strong>」，它是 CAP 原则中可用性的边界——<strong>最高的可用性，最弱的一致
性</strong>，通过牺牲掉 C 来达到 AP 的极致。</li></ul><p>根据 CAP 理论，如果在分布式系统中实现了一致性，可用性必然受到影响。比如，如果出现一个节点
故障，则整个分布式事务的执行都是失败的。实际上，绝大部分场景对一致性要求没那么高，短暂的不
一致是能接受的，另外，也基于可用性和并发性能的考虑，建议在开发实现分布式系统时，<strong>如果不是
必须，尽量不要实现事务，可以考虑采用最终一致性</strong>。</p><p>最终一致性的实现手段：</p><ul><li><strong>读时修复</strong>：在读取数据时，检测数据的不一致，进行修复</li><li><strong>写时修复</strong>：在写入数据时，检测数据的不一致，进行修复</li><li><strong>异步修复</strong>：这个是最常用的方式，通过定时对账，检测副本数据的一致性并修复</li></ul><p>在实现最终一致性的时候，还推荐同时实现自定义写一致性级别（比如 All、Quorum、One、Any），许
多分布式数据库的最终一致性级别都是可调的。</p><p>但是随着 TiDB 等分布式关系数据库的兴起，分布式领域的 BASE 理论实际上正在被 ACID 赶超，ACID
焕发又一春了。</p><h2 id=三共识算法 class=headerLink><a href=#%e4%b8%89%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95 class=header-mark></a>三、共识算法</h2><p>共识算法，也被称为一致性协议，是指在分布式系统中多个节点之间对某个提案 Proposal（例如多个
事务请求，先执行谁？）达成一致看法的一套流程。</p><p>提案的含义在分布式系统中十分宽泛，如多个事件发生的顺序、某个键对应的值、谁是主节点……等等。
可以认为任何可以达成一致的信息都是一个提案。</p><p>对于分布式系统来讲，各个节点通常都是相同的确定性状态机模型（又称为状态机复制问
题，State-Machine Replication），从相同初始状态开始接收相同顺序的指令，则可以保证相同的结
果状态。因此，系统中多个节点最关键的是对多个事件的顺序进行共识，即排序。</p><p><strong>共识算法是达成数据一致性的一种手段，而且是数据强一致性的必要非充分条件</strong>。比如直接使用
Raft 算法，但是允许读取集群的任何节点，只能得到数据的最终一致性，还需要其他手段才能确保强
一致性。</p><h3 id=拜占庭将军问题与拜占庭容错 class=headerLink><a href=#%e6%8b%9c%e5%8d%a0%e5%ba%ad%e5%b0%86%e5%86%9b%e9%97%ae%e9%a2%98%e4%b8%8e%e6%8b%9c%e5%8d%a0%e5%ba%ad%e5%ae%b9%e9%94%99 class=header-mark></a>拜占庭将军问题与拜占庭容错</h3><p>拜占庭错误是 1982 年兰伯特在《拜占庭将军问题》中提出的一个错误模型，描述了在少数节点不仅存
在故障，还存在恶意行为的场景下，能否达成共识这样一个问题，论文描述如下：</p><blockquote><p>9 位拜占庭将军分别率领一支军队要共同围困一座城市，因为这座城市很强大，如果不协调统一将军
们的行动策略，部分军队进攻、部分军队撤退会造成围困失败，因此各位将军必须通过投票来达成一
致策略，要么一起进攻，要么一起撤退。</p><p>因为各位将军分别占据城市的一角，他们只能通过信使互相联系。在协调过程中每位将军都将自己投
票“进攻”还是“撤退”的消息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其
他将军送过来的投票，就可以知道投票结果，从而决定是进攻还是撤退。</p><p>而问题的复杂性就在于：将军中可能出现叛徒，他们不仅可以投票给错误的决策，还可能会选择性地
发送投票。假设 9 位将军中有 1 名叛徒，8 位忠诚的将军中出现了 4 人投“进攻”，4 人投“撤退
”，这时候叛徒可能故意给 4 名投“进攻”的将军投“进攻”，而给另外 4 名投“撤退”的将军投“撤退
”。这样在 4 名投“进攻”的将军看来，投票是 5 人投“进攻”，从而发动进攻；而另外 4 名将军看来
是 5 人投“撤退”，从而撤退。这样，一致性就遭到了破坏。</p><p>还有一种情况，因为将军之间需要通过信使交流，即便所有的将军都是忠诚的，派出去的信使也可能
被敌军截杀，甚至被间谍替换，也就是说将军之间进行交流的信息通道是不能保证可靠性的。所以在
没有收到对应将军消息的时候，将军们会默认投一个票，例如“进攻”。</p></blockquote><p>更一般地，在已知有 N 个将军谋反的情况下，其余 M 个忠诚的将军在不受叛徒的影响下能否达成共
识？有什么样的前提条件，该如何达成共识？这就是拜占庭将军问题。</p><p>如果一个共识算法在一定条件下能够解决拜占庭将军问题，那我们就称这个算法是「<strong>拜占庭容错
Byzantine Fault Tolerance（BFT）</strong>」算法。反之如果一个共识算法无法接受任何一个节点作恶，那
它就被称为「<strong>非拜占庭容错 Crash Fault Tolerance (CFT)</strong>」算法。</p><p>可以通过简单穷举发现，二忠一叛是无法达成共识的，这个结论结合反证法可证明，<strong>拜占庭容错算法
要求叛徒的比例必须低于 1/3</strong>。</p><h3 id=常用共识算法 class=headerLink><a href=#%e5%b8%b8%e7%94%a8%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95 class=header-mark></a>常用共识算法</h3><p>对于「<strong>非拜占庭容错 Crash Fault Tolerance (CFT)</strong>」的情况，已经存在不少经典的算法，包括
Paxos（1990 年）、Raft（2014 年）及其变种等。这类容错算法往往性能比较好，处理较快，容忍不
超过一半的故障节点。</p><p>对于「<strong>拜占庭容错 Byzantine Fault Tolerance（BFT）</strong>」的情况，目前有 PBFT（Practical
Byzantine Fault Tolerance，1999 年）为代表的确定性系列算法、PoW（1999 年）为代表的概率算法
等算法可选。确定性算法一旦达成共识就不可逆转，即共识是最终结果；而概率类算法的共识结果则是
临时的，随着时间推移或某种强化，共识结果被推翻的概率越来越小，最终成为事实上结果。拜占庭类
容错算法往往性能较差，容忍不超过 1/3 的故障节点。</p><p>此外，XFT（Cross Fault Tolerance，2015 年）等最近提出的改进算法可以提供类似 CFT 的处理响应
速度，并能在大多数节点正常工作时提供 BFT 保障。Algorand 算法（2017 年）基于 PBFT 进行改
进，通过引入可验证随机函数解决了提案选择的问题，理论上可以在容忍拜占庭错误的前提下实现更好
的性能（1000+ TPS）。</p><blockquote><p>注：实践中，对客户端来说要拿到共识结果需要自行验证，典型地，可访问足够多个服务节点来比对
结果，确保获取结果的准确性。</p></blockquote><p>常见共识算法列举如下：</p><table><thead><tr><th></th><th>拜占庭容错</th><th>一致性</th><th>性能</th><th>可用性（能容忍多大比例的节点出现故障）</th></tr></thead><tbody><tr><td>两阶段提交 2PC</td><td>否</td><td>强一致性</td><td>低</td><td>低</td></tr><tr><td>TCC(try-confirm-cancel)</td><td>否</td><td>最终一致性</td><td>低</td><td>低</td></tr><tr><td>Paxos</td><td>否</td><td>强一致性</td><td>中</td><td>中</td></tr><tr><td>ZAB</td><td>否</td><td>最终一致性</td><td>中</td><td>中</td></tr><tr><td>Raft</td><td>否</td><td>强一致性</td><td>中</td><td>中</td></tr><tr><td>Gossip</td><td>否</td><td>最终一致性</td><td>高</td><td>高</td></tr><tr><td>Quorum NWR</td><td>否</td><td>强一致性</td><td>中</td><td>中</td></tr><tr><td>PBFT</td><td>是</td><td>N/A</td><td>低</td><td>中</td></tr><tr><td>PoW</td><td>是</td><td>N/A</td><td>低</td><td>中</td></tr><tr><td>PoS</td><td>是</td><td>N/A</td><td>低</td><td>中</td></tr><tr><td><a href=https://medium.com/solana-labs/proof-of-history-explained-by-a-water-clock-e682183417b8 target=_blank rel="noopener noreferrer">PoH</a></td><td>是</td><td>N/A</td><td>中</td><td>中</td></tr></tbody></table><blockquote><p>注：这里虽然列出了 PoW/PoS/PoH 等应用在区块链中的一致性算法，但是它们跟 PBFT 等其他拜占
庭容错算法存在很大的区别，后面会给出介绍。</p></blockquote><h3 id=不同共识算法的应用场景 class=headerLink><a href=#%e4%b8%8d%e5%90%8c%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af class=header-mark></a>不同共识算法的应用场景</h3><p>在不可信环境中，因为可能存在恶意行为，就需要使用支持拜占庭容错的共识算法如 PoW/PoS，使系统
在存在部分节点作恶的情况下仍然能达成共识。这就是区块链使用 PoW/PoS 算法而不是 Paxos/Raft
算法的原因。</p><p>而在企业内网等场景下，可以认为是可信环境，基本不会出现恶意节点或者可以通过 mTLS 等手段进行
节点身份认证，这种场景下系统具有故障容错能力就够了，就没必要做到拜占庭容错，因此常用
Raft/Paxos 等算法。</p><h3 id=非拜占庭错误共识算法-paxos-与-raft class=headerLink><a href=#%e9%9d%9e%e6%8b%9c%e5%8d%a0%e5%ba%ad%e9%94%99%e8%af%af%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95-paxos-%e4%b8%8e-raft class=header-mark></a>非拜占庭错误共识算法 Paxos 与 Raft</h3><p>受限于篇幅与笔者精力，这部分暂时跳过&mldr;后面可能会写篇新的文章专门介绍 Paxos/Raft 算法。</p><h3 id=能容忍拜占庭错误的-pow-概率共识算法 class=headerLink><a href=#%e8%83%bd%e5%ae%b9%e5%bf%8d%e6%8b%9c%e5%8d%a0%e5%ba%ad%e9%94%99%e8%af%af%e7%9a%84-pow-%e6%a6%82%e7%8e%87%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95 class=header-mark></a>能容忍拜占庭错误的 PoW 概率共识算法</h3><p>PoW 即 Proof of Work 工作量证明，指系统为达到某一目标而设置的度量方法。简单理解就是一份证
明，用来确认你做过一定量的工作。监测工作的整个过程通常是极为低效的，而通过对工作的结果进行
认证来证明完成了相应的工作量，这个认证流程是非常简单高效的，这就是 PoW 的优势所在。</p><p>在 1993 年，<a href=http://www.wisdom.weizmann.ac.il/~naor/PAPERS/pvp.ps target=_blank rel="noopener noreferrer">Cynthia Dwork 和 Moni Naor 设计了一个系统用于反垃圾邮件、避免资源被滥
用</a>，
这是 PoW 算法的雏形。其核心思想如下：</p><blockquote><p>The main idea is to require a user to compute a moderately hard but not intractable
function in order to gain access to the resource, thus preventing frivolous use.</p></blockquote><p>翻译成中文：</p><blockquote><p>其主要思想是要求用户计算一个中等难度但不难处理的函数，以获得对资源的访问，从而防止（系统
资源被）滥用。</p></blockquote><p>在 1999 年，<a href=https://link.springer.com/chapter/10.1007/978-0-387-35568-9_18 target=_blank rel="noopener noreferrer">Markus Jakobsson 与 Ari Juels 第一次从各种协议中提炼出 Proofs of Work 这个概
念</a>。</p><p>POW 系统中一定有两个角色，工作者和验证者，他们需要具有以下特点：</p><ul><li>工作者需要完成的工作必须有一定的量，这个量由工作验证者给出。</li><li>验证者可以迅速的检验工作量是否达标。</li><li>工作者无法自己"创造工作"，必须由验证者发布工作。</li><li>工作者无法找到很快完成工作的办法。</li></ul><p>说到这里，我们对 PoW 应该有足够的理解了，它就是让工作者消耗一定的资源作为使用系统的成本。
对于正常的用户而言这部分被消耗的资源是完全可以接受的，但是对于恶意攻击者而言，它如果想滥用
系统的资源或者发送海量的垃圾邮件，就需要消耗海量的计算资源作为成本，这样就极大地提升了攻击
成本。</p><p>再总结下，PoW 算法的核心是<strong>它为信息发送加入了成本，降低了信息传递的速率</strong>。</p><p>把比特币区块链转换成拜占庭将军问题来看，它的思路是这样的：</p><ul><li>限制一段时间内提案的个数，只有拥有对应权限的节点（将军）可以发起提案。<ul><li>这是通过 PoW 工作量证明实现的，比特币区块链要求节点进行海量的哈希计算作为<strong>获得提案权
限的代价</strong>，算法难度每隔两周调整一次以保证整个系统找到正确 Hash 值的平均用时大约为 10
分钟。</li></ul></li><li>由强一致性放宽至最终一致性。<ul><li>对应一次提案的结果不需要全部的节点马上跟进，只需要在节点能搜寻到的全网络中的所有链条
中，选取最长的链条进行后续拓展就可以。</li></ul></li><li>使用非对称加密算法对节点间的消息传递提供签名技术支持，每个节点（将军）都有属于自己的秘钥
（公钥私钥），唯一标识节点身份。<ul><li>使用非对称加密算法传递消息，能够保证消息传递的私密性。而且消息签名不可篡改，这避免了消
息被恶意节点伪造。</li></ul></li></ul><p>我们前面有给出一个结论：<strong>拜占庭容错算法要求叛徒的比例必须低于 1/3</strong>。</p><p>但是区块链与拜占庭将军问题的区别很大，举例如下：</p><ul><li>区块链允许任何节点随时加入或离开区块链，而拜占庭将军问题是预设了节点数，而且不考虑节点的
添加或删除。</li><li>比特币区块链的 PoW 算法只能保证整个系统找到正确 Hash 值的<strong>平均用时</strong>大约为 10 分钟，那
肯定就存在性能更好的节点用时更短，性能更差的节点用时更长，甚至某些节点运气好几秒钟就算出
了结果，这都是完全可能的。而越早算出这个 Hash 值的节点，它的提案（区块）成为最长链条的概
率就越大。</li><li>PoW 由强一致性放宽至最终一致性，系统总会选取最长的链进行后续拓展，那如果某个链条一开始不
长，但是它的拓展速度足够快，它就能成为最长的链条。而拜占庭将军问题不允许任何分支，只存在
一个结果！<ul><li>只是受限于算力，随着时间的推移，短的链条追上最长链条的概率会越来越小。</li></ul></li></ul><p>总之因为区块链这样的特点，它会产生一些跟拜占庭容错算法不同的结果：</p><ul><li>攻击者拥有的节点数量占比是毫无意义的，核心是算力，也就对应着区块链中的提案权。<ul><li>即使攻击者拥有了 99% 的节点，但是它的总体算力很弱的话，它的提案（区块）成为最长链条的
概率也会很低。</li></ul></li><li><strong>区块链的 51% 攻击</strong>：因为「系统总是选取最长链条进行后续拓展」这个原则，只有某个攻击者
拥有了超过 50% 算力的情况下，它才拥有绝对性的优势，使它的区块在一定时间后一定能成为最长
的链条，并且始终维持这样一个优势，从而达成攻击目的。</li></ul><p>至于 PoW 算法的具体实现，以及它的替代算法 PoS/PoH 等新兴算法的原理与实现，将在后续的区块链
系列文章中详细介绍，尽请期待&mldr;</p><h2 id=参考 class=headerLink><a href=#%e5%8f%82%e8%80%83 class=header-mark></a>参考</h2><ul><li>《Designing Data-Intensive Applications - The Big Ideas Behind Reliable, Scalable, and
Maintainable Systems (Martin Kleppmann)》</li><li>极客时间《分布式数据库 30 讲》</li><li>极客时间《分布式协议与算法实战》</li><li><a href=https://zhuanlan.zhihu.com/p/34656939 target=_blank rel="noopener noreferrer">分布式存储系统的一致性是什么？- OceanBase</a></li><li><a href=https://pingcap.com/zh/blog/linearizability-and-raft target=_blank rel="noopener noreferrer">线性一致性和 Raft - PingCAP</a></li><li><a href=https://int64.me/2020/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0.html target=_blank rel="noopener noreferrer">一致性模型笔记</a></li><li><a href=http://zhangtielei.com/posts/blog-distributed-strong-weak-consistency.html target=_blank rel="noopener noreferrer">条分缕析分布式：浅析强弱一致性 - 张铁蕾</a></li><li><a href=https://cloud.google.com/blog/products/databases/why-you-should-pick-strong-consistency-whenever-possible target=_blank rel="noopener noreferrer">Why you should pick strong consistency, whenever possible - Google Spanner</a></li><li><a href=https://www.infoq.cn/article/the-byzantine-generals-problem-and-blockchain target=_blank rel="noopener noreferrer">拜占庭将军问题与区块链</a></li><li><a href=https://paper.seebug.org/1643/ target=_blank rel="noopener noreferrer">区块链协议安全系列— —当拜占庭将军犯错时，区块链共识还安全么？（上集）</a></li><li><a href=https://www.allthingsdistributed.com/2008/12/eventually_consistent.html target=_blank rel="noopener noreferrer">Eventually Consistent - Revisited</a></li></ul></div><h2>相关内容</h2><div class=related-container><div class=related-item-container><div class=related-image><a href=/posts/sqlalchemy-notes-3-relationship-and-foreignkey/><img loading=lazy src=/posts/sqlalchemy-notes-3-relationship-and-foreignkey/sqlalchemy-relationships.webp srcset="/posts/sqlalchemy-notes-3-relationship-and-foreignkey/sqlalchemy-relationships.webp, /posts/sqlalchemy-notes-3-relationship-and-foreignkey/sqlalchemy-relationships.webp 1.5x, /posts/sqlalchemy-notes-3-relationship-and-foreignkey/sqlalchemy-relationships.webp 2x" sizes=auto alt=/posts/sqlalchemy-notes-3-relationship-and-foreignkey/sqlalchemy-relationships.webp title=/posts/sqlalchemy-notes-3-relationship-and-foreignkey/sqlalchemy-relationships.webp height=200 width=400></a></div><h2 class=related-title><a href=/posts/sqlalchemy-notes-3-relationship-and-foreignkey/>SQLAlchemy 学习笔记（三）：ORM 中的关系构建</a></h2></div><div class=related-item-container><div class=related-image><a href=/posts/sqlalchemy-notes-2-orm-basics/><img loading=lazy src=/posts/sqlalchemy-notes-2-orm-basics/sqlalchemy-models.webp srcset="/posts/sqlalchemy-notes-2-orm-basics/sqlalchemy-models.webp, /posts/sqlalchemy-notes-2-orm-basics/sqlalchemy-models.webp 1.5x, /posts/sqlalchemy-notes-2-orm-basics/sqlalchemy-models.webp 2x" sizes=auto alt=/posts/sqlalchemy-notes-2-orm-basics/sqlalchemy-models.webp title=/posts/sqlalchemy-notes-2-orm-basics/sqlalchemy-models.webp height=200 width=400></a></div><h2 class=related-title><a href=/posts/sqlalchemy-notes-2-orm-basics/>SQLAlchemy 学习笔记（二）：ORM 基础</a></h2></div><div class=related-item-container><div class=related-image><a href=/posts/sqlalchemy-notes-1-engine-and-sql-expression-language/><img loading=lazy src=/posts/sqlalchemy-notes-1-engine-and-sql-expression-language/sqlalchemy-intro.webp srcset="/posts/sqlalchemy-notes-1-engine-and-sql-expression-language/sqlalchemy-intro.webp, /posts/sqlalchemy-notes-1-engine-and-sql-expression-language/sqlalchemy-intro.webp 1.5x, /posts/sqlalchemy-notes-1-engine-and-sql-expression-language/sqlalchemy-intro.webp 2x" sizes=auto alt=/posts/sqlalchemy-notes-1-engine-and-sql-expression-language/sqlalchemy-intro.webp title=/posts/sqlalchemy-notes-1-engine-and-sql-expression-language/sqlalchemy-intro.webp height=200 width=400></a></div><h2 class=related-title><a href=/posts/sqlalchemy-notes-1-engine-and-sql-expression-language/>SQLAlchemy 学习笔记（一）：Engine 与 SQL 表达式语言</a></h2></div></div><div class=sponsor><div class=sponsor-avatar><img loading=lazy src=https://thiscute.world/avatar/myself.webp srcset="https://thiscute.world/avatar/myself.webp, https://thiscute.world/avatar/myself.webp 1.5x, https://thiscute.world/avatar/myself.webp 2x" sizes=auto alt=https://thiscute.world/avatar/myself.webp title=https://thiscute.world/avatar/myself.webp></div><p class=sponsor-bio><em>如果你觉得这篇文章对你有所帮助，欢迎评论、分享、打赏~</em></p><a href=https://afdian.net/a/ryan4yin title=Sponsor target=_blank class=sponsor-button rel="noopener noreferrer"><i class="far fa-heart fa-fw icon" style=color:#ec6cb9></i>
<span>赞赏</span></a></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-08-07</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><button title="分享到 Twitter" data-sharer=twitter data-url=https://thiscute.world/posts/consistency-and-consensus-algorithm/ data-title=分布式数据库的一致性问题与共识算法 data-via=ryan4yin data-hashtags=共识,一致性,分布式,数据库,区块链><span class="fab fa-twitter fa-fw"></span></button><button title="分享到 Hacker News" data-sharer=hackernews data-url=https://thiscute.world/posts/consistency-and-consensus-algorithm/ data-title=分布式数据库的一致性问题与共识算法><span class="fab fa-hacker-news fa-fw"></span></button><button title="分享到 Reddit" data-sharer=reddit data-url=https://thiscute.world/posts/consistency-and-consensus-algorithm/><span class="fab fa-reddit fa-fw"></span></button><script>function shareOnMastodon(e,t){const o="share_mastodon_domain",i=localStorage.getItem(o)??"mastodon.social",n=prompt("Enter your Mastodon domain",i);if(n===null)return;localStorage.setItem(o,n);const a=e+`

`+t,s=new URL("https://"+n);s.pathname="share",s.searchParams.append("text",a),window.open(s,"_blank","width=500,height=500,left=500,toolbar=0,status=0")}</script>
<button title="分享到 Mastodon" onclick='shareOnMastodon("分布式数据库的一致性问题与共识算法","https://thiscute.world/posts/consistency-and-consensus-algorithm/")'><span class="fab fa-mastodon fa-fw"></span></button></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/%E5%85%B1%E8%AF%86/>共识</a>,&nbsp;<a href=/tags/%E4%B8%80%E8%87%B4%E6%80%A7/>一致性</a>,&nbsp;<a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F/>分布式</a>,&nbsp;<a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>,&nbsp;<a href=/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/>区块链</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/kubernetes-cert-management/ class=prev rel=prev title="Kubernetes 中的证书管理工具 - cert-manager"><i class="fas fa-angle-left fa-fw"></i>Kubernetes 中的证书管理工具 - cert-manager</a>
<a href=/posts/learn-english-again/ class=next rel=next title="Learn English Again">Learn English Again<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><a href=https://www.foreverblog.cn/ target=_blank><img src=https://img.foreverblog.cn/logo_en_default.png alt style=display:inline-block;width:auto;height:20px></a>
<a href=https://www.foreverblog.cn/go.html target=_blank><img src=https://img.foreverblog.cn/wormhole_3.gif alt style=display:inline-block;width:auto;height:20px title=穿梭虫洞-随机访问十年之约友链博客></a></div><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer" title="Hugo 0.110.0">Hugo</a> 强力驱动&nbsp;|&nbsp;托管在 <a title=Vercel href=https://vercel.com/ target=_blank rel="noopener noreffer">Vercel</a> 上&nbsp;|&nbsp;主题 - <a href=https://github.com/HEIGE-PCloud/DoIt target=_blank rel="noopener noreferrer" title="DoIt 0.4.0"><i class="far fa-edit fa-fw"></i> DoIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021 - 2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://thiscute.world/ target=_blank rel="noopener noreferrer">ryan4yin</a></span>&nbsp;|&nbsp;<span class=license> <a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class=footer-line></div><div class=footer-line></div></div></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><div class=assets><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/katex/copy-tex.min.css><noscript><link rel=stylesheet href=/lib/katex/copy-tex.min.css></noscript><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:30},comment:{utterances:{darkTheme:"github-dark",issueTerm:"pathname",label:"",lightTheme:"github-light",repo:"ryan4yin/thiscute.world"}},data:{"desktop-header-typeit":"This Cute World","mobile-header-typeit":"This Cute World"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"747LJ10EI7",algoliaIndex:"ryan-space",algoliaSearchKey:"658db5f2bf056f83458cacf5dd58ec80",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},sharerjs:!0,typeit:{cursorChar:null,cursorSpeed:null,data:{"desktop-header-typeit":["desktop-header-typeit"],"mobile-header-typeit":["mobile-header-typeit"]},duration:null,speed:null}}</script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/typeit/typeit.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js defer></script><script type=text/javascript src=/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/js/katex.min.js defer></script><script type=text/javascript src=/js/theme.min.js defer></script><script type=text/javascript src=/js/utterances.min.js defer></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4V93QVSNFW",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-4V93QVSNFW" async></script></div></body></html>