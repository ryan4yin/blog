<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Linux 上的 WireGuard 网络分析（一） - This Cute World</title><meta name=Description content="This Cute World"><meta property="og:title" content="Linux 上的 WireGuard 网络分析（一）"><meta property="og:description" content="阅读此文章需要前置知识：Linux 网络基础知识、iptables、conntrack 本文内容部分采用了 Copilot 提示内容，也有部分内容用了 ChatGPT 免费版进"><meta property="og:type" content="article"><meta property="og:url" content="https://thiscute.world/posts/wireguard-on-linux/"><meta property="og:image" content="https://thiscute.world/posts/wireguard-on-linux/wireguard.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-28T22:19:25+08:00"><meta property="article:modified_time" content="2023-03-28T22:19:25+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://thiscute.world/posts/wireguard-on-linux/wireguard.png"><meta name=twitter:title content="Linux 上的 WireGuard 网络分析（一）"><meta name=twitter:description content="阅读此文章需要前置知识：Linux 网络基础知识、iptables、conntrack 本文内容部分采用了 Copilot 提示内容，也有部分内容用了 ChatGPT 免费版进"><meta name=application-name content="This Cute World"><meta name=apple-mobile-web-app-title content="This Cute World"><meta name=theme-color content="#f8f8f8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=https://thiscute.world/posts/wireguard-on-linux/><link rel=prev href=https://thiscute.world/posts/ee-basics-2-esp32-display/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><meta name=google-site-verification content="E8bpp1lVVlb9YnSJcUzPL1dLAG17Nl_sp5Ru9a8tUDQ"><meta name=baidu-site-verification content="code-ZZtDruAnX1"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Linux 上的 WireGuard 网络分析（一）","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/thiscute.world\/posts\/wireguard-on-linux\/"},"image":[{"@type":"ImageObject","url":"https:\/\/thiscute.world\/posts\/wireguard-on-linux\/wireguard.png","width":1280,"height":500}],"genre":"posts","keywords":"WireGuard, VPN, Linux, 网络, iptables, conntrack","wordcount":5541,"url":"https:\/\/thiscute.world\/posts\/wireguard-on-linux\/","datePublished":"2023-03-28T22:19:25+08:00","dateModified":"2023-03-28T22:19:25+08:00","publisher":{"@type":"Organization","name":"ryan4yin","logo":"https:\/\/thiscute.world\/avatar\/myself.png"},"author":{"@type":"Person","name":"ryan4yin"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e),document.documentElement.style.setProperty("color-scheme",e==="light"?"light":"dark")}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(e){const t=document.getElementsByTagName("meta");for(let n=0;n<t.length;n++)if(t[n].getAttribute("name")===e)return t[n];return""}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"||e==="black"?setTheme(e):setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")}else"auto"==="light"||"auto"==="dark"||"auto"==="black"?(setTheme("auto"),saveTheme("auto")):(saveTheme("auto"),setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"));let metaColors={light:"#f8f8f8",dark:"#252627",black:"#000000"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")]</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="This Cute World"><span id=desktop-header-typeit class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/statistics/>阅读排行 </a><a class=menu-item href=/categories/tech/>技术 </a><a class=menu-item href=/categories/life/>生活 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/friends/>朋友们 </a><a class=menu-item href=/now/>此刻 </a><a class=menu-item href=/about/>关于 </a><span class="menu-item delimiter"></span><a href=# onclick=return!1 class="menu-item language" title=选择语言>Simplified Chinese<i class="fas fa-chevron-right fa-fw"></i>
<select class=language-select title="Select Language" id=language-select-desktop onchange="location=this.value"><option value=/posts/wireguard-on-linux/ selected>Simplified Chinese</option></select>
</a><span class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=# onclick=return!1 class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=# onclick=return!1 class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=# onclick=return!1 class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="This Cute World"><span id=mobile-header-typeit class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=# onclick=return!1 class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=# onclick=return!1 class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=# onclick=return!1 class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/statistics/ title>阅读排行</a><a class=menu-item href=/categories/tech/ title>技术</a><a class=menu-item href=/categories/life/ title>生活</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/friends/ title>朋友们</a><a class=menu-item href=/now/ title>此刻</a><a class=menu-item href=/about/ title>关于</a><a href=# onclick=return!1 class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
</a><a href=# onclick=return!1 class=menu-item title=选择语言>Simplified Chinese<i class="fas fa-chevron-right fa-fw"></i>
<select class=language-select title="Select Language" onchange="location=this.value"><option value=/posts/wireguard-on-linux/ selected>Simplified Chinese</option></select></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto><nav id=TableOfContents><ul><li><a href=#wireguard-是什么>WireGuard 是什么</a></li><li><a href=#wireguard-服务端网络分析>WireGuard 服务端网络分析</a></li><li><a href=#wireguard-客户端网络分析>WireGuard 客户端网络分析</a></li><li><a href=#结语>结语</a></li><li><a href=#参考>参考</a></li></ul></nav></div></div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle","normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Linux 上的 WireGuard 网络分析（一）</h1><div class=post-meta><div class=post-meta-line><span class=post-author><i class="author fas fa-user-circle fa-fw"></i><a href=https://thiscute.world/ title=Author target=_blank rel="noopener noreferrer author" class=author>ryan4yin</a>
</span>&nbsp;<span class=post-category>收录于 </span>&nbsp;<span class=post-category>类别 <a href=/categories/tech/><i class="far fa-folder fa-fw"></i>tech</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2023-03-28>2023-03-28</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2023-03-28>2023-03-28</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 5541 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 12 分钟&nbsp;</div></div><div class=featured-image><img loading=eager src=/posts/wireguard-on-linux/wireguard.png srcset="/posts/wireguard-on-linux/wireguard.png, /posts/wireguard-on-linux/wireguard.png 1.5x, /posts/wireguard-on-linux/wireguard.png 2x" sizes=auto alt=/posts/wireguard-on-linux/wireguard.png title=/posts/wireguard-on-linux/wireguard.png height=500 width=1280></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#wireguard-是什么>WireGuard 是什么</a></li><li><a href=#wireguard-服务端网络分析>WireGuard 服务端网络分析</a></li><li><a href=#wireguard-客户端网络分析>WireGuard 客户端网络分析</a></li><li><a href=#结语>结语</a></li><li><a href=#参考>参考</a></li></ul></nav></div></div><div class=content id=content><blockquote><p>阅读此文章需要前置知识：Linux 网络基础知识、iptables、conntrack</p></blockquote><blockquote><p>本文内容部分采用了 Copilot 提示内容，也有部分内容用了 ChatGPT 免费版进行分析，确实都比较有帮助。</p></blockquote><p>最近因为工作需要研究了一波 WireGuard 协议，在这篇文章中简单记录下心得。</p><h2 id=wireguard-是什么 class=headerLink><a href=#wireguard-%e6%98%af%e4%bb%80%e4%b9%88 class=header-mark></a>WireGuard 是什么</h2><p>WireGuard 是极简主义思想下的 VPN 实现，解决了很多现存 VPN 协议存在的问题。
它于 2015 年由 Jason A. Donenfeld 设计实现，因其代码实现简洁易懂、配置简单、性能高、安全强度高而受到广泛关注。</p><p>WireGuard 在 2020 年初进入 Linux 主线分支，随后成为 Linux 5.6 的一个内核模块，这之后很快就涌现出许多基于 WireGuard 的开源项目与相关企业，各大老牌 VPN 服务商也逐渐开始支持 WireGuard 协议，很多企业也使用它来组建企业 VPN 网络。</p><p>基于 WireGuard 的明星开源项目举例：</p><ul><li><a href=https://github.com/tailscale/tailscale target=_blank rel="noopener noreferrer">tailscale</a>: 一套简单易用的 WireGuard VPN 私有网络解决方案，强烈推荐！</li><li><a href=https://github.com/juanfont/headscale target=_blank rel="noopener noreferrer">headscale</a>: tailscale 控制服务器的开源实现，使你可以自建 tailscale 服务。</li><li><a href=https://github.com/squat/kilo target=_blank rel="noopener noreferrer">kilo</a>: 基于 WireGuard 的 Kubernetes 多云网络解决方案。</li><li>&mldr;</li><li>除了上面这些，还有很多其他 WireGuard 项目，有兴趣可以去 <a href=https://github.com/cedrickchee/awesome-wireguard target=_blank rel="noopener noreferrer">awesome-wireguard</a> 仓库看看。</li></ul><p>WireGuard 本身只是一个点对点隧道协议，只提供点对点通信的能力（这也是其极简主义思想的体现）。而其他网络路由、NAT 穿越、DNS 解析、防火墙策略等功能都是基于 Linux 系统的现有工具来实现的。</p><p>在这篇文章里，我将搭建一个简单的单服务器 + 单客户端 WireGuard 网络，然后分析它如何使用 Linux 系统现有的工具，在 WireGuard 隧道上搭建出一个安全可靠的虚拟网络。</p><p>文章测试用到的服务器与客户端均为虚拟机，使用 Ubuntu 20.04 系统，内核版本为 5.15，也就是说都包含了 wireguard 内核模块。</p><h2 id=wireguard-服务端网络分析 class=headerLink><a href=#wireguard-%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%bd%91%e7%bb%9c%e5%88%86%e6%9e%90 class=header-mark></a>WireGuard 服务端网络分析</h2><p>简单起见，这里使用 docker-compose 启动一个 WireGuard 服务端，使用的镜像是 <a href=https://github.com/linuxserver/docker-wireguard target=_blank rel="noopener noreferrer">linuxserver/docker-wireguard</a>。</p><p>配置文件如下，内容完全参考自此镜像的官方 README：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nn>---</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;2.1&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>wireguard</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>lscr.io/linuxserver/wireguard:latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>container_name</span><span class=p>:</span><span class=w> </span><span class=l>wireguard</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>cap_add</span><span class=p>:</span><span class=w>           
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>NET_ADMIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>SYS_MODULE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>environment</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>PUID=1000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>PGID=1000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>TZ=Etc/UTC</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>SERVERURL=auto  </span><span class=w> </span><span class=c># 自动确定服务器的外部 IP 地址，在生成客户端配置时会用到</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>SERVERPORT=51820</span><span class=w> </span><span class=c># 服务端监听的端口号</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>PEERS=1         </span><span class=w> </span><span class=c># 自动生成 1 个客户端配置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>PEERDNS=auto    </span><span class=w> </span><span class=c># 自动确定客户端的 DNS 服务器地址，同样是在生成客户端配置时会用到</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>INTERNAL_SUBNET=10.13.13.0   </span><span class=w> </span><span class=c># WireGuard 虚拟网络的网段</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>ALLOWEDIPS=0.0.0.0/0         </span><span class=w> </span><span class=c># 这条规则表示允许虚拟网络内的所有客户端将流量发送到此节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c># 众所周知，NAT 网络需要定期发送心跳包来保持 NAT 表内容不过期，俗称连接保活。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c># 这里设置为 all 表示所有客户端都开启连接保活。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>PERSISTENTKEEPALIVE_PEERS=all </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>LOG_CONFS=true</span><span class=w> </span><span class=c># 开启日志</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>./config:/config</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>/lib/modules:/lib/modules</span><span class=w> </span><span class=c># 将宿主机的内核模块挂载到容器内，用于加载 WireGuard 内核模块</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=m>51820</span><span class=p>:</span><span class=m>51820</span><span class=l>/udp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>sysctls</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>net.ipv4.conf.all.src_valid_mark=1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>restart</span><span class=p>:</span><span class=w> </span><span class=l>unless-stopped</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>将上面的配置文件保存为 <code>docker-compose.yml</code>，然后通过如下命令后台启动 WireGuard 服务端：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>docker-compose up -d
</span></span></code></pre></td></tr></table></div></div><p>WireGuard 服务端启动好了，现在查看下服务端容器的日志（我加了详细注释说明）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker logs wireguard
</span></span><span class=line><span class=cl><span class=c1># ...省略若干内容</span>
</span></span><span class=line><span class=cl>.:53                          <span class=c1># 这几行日志是启动 CoreDNS，为虚拟网络提供默认的 DNS 服务</span>
</span></span><span class=line><span class=cl>CoreDNS-1.10.1                <span class=c1># 实际上 CoreDNS 不是必须的，客户端可以改用其他 DNS 服务器</span>
</span></span><span class=line><span class=cl>linux/amd64, go1.20, 055b2c3
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] ip link add wg0 type wireguard   # 创建一个 wireguard 设备</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] wg setconf wg0 /dev/fd/63        # 设置 wireguard 设备的配置</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] ip -4 address add 10.13.13.1 dev wg0   # 为 wireguard 设备添加一个 ip 地址</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] ip link set mtu 1420 up dev wg0        # 设置 wireguard 设备的 mtu</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] ip -4 route add 10.13.13.2/32 dev wg0  # 为 wireguard peer1 添加路由，其地址来自 wireguard 配置的 `allowedIPs` 参数</span>
</span></span><span class=line><span class=cl><span class=c1># 下面这几条 iptables 命令为 wireguard 设备添加 NAT 规则，使其成为 WireGuard 虚拟网络的默认网关</span>
</span></span><span class=line><span class=cl><span class=c1># 并使虚拟网络内的其他 peers 能通过此默认网关访问外部网络。</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] iptables -A FORWARD -i wg0 -j ACCEPT; iptables -A FORWARD -o wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth+ -j MASQUERADE</span>
</span></span><span class=line><span class=cl><span class=o>[</span>ls.io-init<span class=o>]</span> <span class=k>done</span>.
</span></span></code></pre></td></tr></table></div></div><p>通过日志能看到，程序首先创建了 WireGuard 设备 wg0 并绑定了地址 <code>10.13.13.1</code>。作为 WireGuard 网络中的服务端，它所创建的这个 wg0 的任务是成为整个 WireGuard 虚拟网络的默认网关，处理来自虚拟网络内的其他 peers 的流量，构成一个星型网络。</p><p>然后服务端为它所生成的 peer1 添加了一个路由，使得 peer1 的流量能够被正确路由到 wg0 设备上。</p><p>最后为了让 WireGuard 虚拟网络内的其他 peers 的流量能够通过 wg0 设备访问外部网络或者互相访问，服务端为 wg0 设备添加了如下的 iptables 规则：</p><ul><li><code>iptables -A FORWARD -i wg0 -j ACCEPT; iptables -A FORWARD -o wg0 -j ACCEPT;</code>：允许进出 wg0 设备的数据包通过 netfilter 的 FORWARD 链（默认规则是 DROP，即默认是不允许通过的）</li><li><code>iptables -t nat -A POSTROUTING -o eth+ -j MASQUERADE</code>：在 eth+ 网卡上添加 MASQUERADE 规则，即将数据包的源地址伪装成 eth+ 网卡的地址，目的是为了允许 wireguard 的数据包通过 NAT 访问外部网络。<ul><li>而回来的流量会被 NAT 的 conntrack 链接追踪规则自动允许通过，不过 conntrack 表有自动清理机制，长时间没流量的话会被从 conntrack 表中移除。这就是前面 <code>docker-compose.yml</code> 中的 <code>PERSISTENTKEEPALIVE_PEERS=all</code> 参数解决的问题通过定期发送心跳包来保持 conntrack 表中的连接信息。</li><li>这里还涉及到了 NAT 穿越相关内容，就不多展开了，感兴趣的可以自行了解。</li></ul></li></ul><p>WireGuard 的实现中还有一个比较重要的概念叫做 <code>AllowedIPs</code>，它是一个 IP 地址列表，表示允许哪些 IP 地址的流量通过 WireGuard 虚拟网络。
为了详细说明这一点，我们先看下服务端配置文件夹中 wg0 的配置：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ cat wg0.conf
</span></span><span class=line><span class=cl><span class=o>[</span>Interface<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>Address</span> <span class=o>=</span> 10.13.13.1
</span></span><span class=line><span class=cl><span class=nv>ListenPort</span> <span class=o>=</span> <span class=m>51820</span>
</span></span><span class=line><span class=cl><span class=nv>PrivateKey</span> <span class=o>=</span> kGZzt/CU2MVgq19ffXB2YMDSr6WIhlkdlL1MOeGH700<span class=o>=</span>
</span></span><span class=line><span class=cl><span class=c1># wg0 隧道启动后添加 iptables 规则</span>
</span></span><span class=line><span class=cl><span class=nv>PostUp</span> <span class=o>=</span> iptables -A FORWARD -i %i -j ACCEPT<span class=p>;</span> iptables -A FORWARD -o %i -j ACCEPT<span class=p>;</span> iptables -t nat -A POSTROUTING -o eth+ -j MASQUERADE
</span></span><span class=line><span class=cl><span class=c1># wg0 隧道停止后删除前面添加的 iptables 规则</span>
</span></span><span class=line><span class=cl><span class=nv>PostDown</span> <span class=o>=</span> iptables -D FORWARD -i %i -j ACCEPT<span class=p>;</span> iptables -D FORWARD -o %i -j ACCEPT<span class=p>;</span> iptables -t nat -D POSTROUTING -o eth+ -j MASQUERADE
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>Peer<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=c1># peer1</span>
</span></span><span class=line><span class=cl><span class=nv>PublicKey</span> <span class=o>=</span> HR8Kp3xWIt2rNdS3aaCk+Ss7yQqC9cn6h3WS6UK3WE0<span class=o>=</span>
</span></span><span class=line><span class=cl><span class=nv>PresharedKey</span> <span class=o>=</span> 7mCNCZdMKeRz1Zrpl9bFS08jJAdv6/USazRVq7tjznY<span class=o>=</span>
</span></span><span class=line><span class=cl><span class=c1># AllowedIPs 设置为 peer1 的虚拟 IP 地址，表示允许 peer1 的流量通过 WireGuard 虚拟网络</span>
</span></span><span class=line><span class=cl><span class=nv>AllowedIPs</span> <span class=o>=</span> 10.13.13.2/32
</span></span></code></pre></td></tr></table></div></div><p><code>AllowedIPs</code> 实际就是每个 peer 在服务端路由表中的 ip 地址，它既可以是 ip 也可以是网段，而且能设置多个，这使所有 peer 都可以负责一个甚至多个 ip 段的转发，也就是充当局域网的路由器——VPN 子路由。</p><p>WireGuard 本身只是一个点对点隧道协议，它非常通用。通过 <code>AllowedIPs</code> 参数，我们就能在每个 peer 上添加各 peers 的配置与不同的路由规则，构建出各种复杂的网络拓扑，比如星型、环型、树型等等。</p><h2 id=wireguard-客户端网络分析 class=headerLink><a href=#wireguard-%e5%ae%a2%e6%88%b7%e7%ab%af%e7%bd%91%e7%bb%9c%e5%88%86%e6%9e%90 class=header-mark></a>WireGuard 客户端网络分析</h2><p>现在换台虚拟机跑 WireGuard 客户端，首先需要安装 wireguard 命令行工具：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>sudo apt install wireguard resolvconf
</span></span></code></pre></td></tr></table></div></div><p>第二步是从服务端的配置文件夹中找到 <code>peer1/peer1.conf</code>，它是服务端容器根据参数 <code>PEERS=1</code> 自动生成的客户端配置文件，先确认下它的内容：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ <span class=nb>cd</span> ./config/peer1
</span></span><span class=line><span class=cl>$ cat peer1.conf
</span></span><span class=line><span class=cl><span class=o>[</span>Interface<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>Address</span> <span class=o>=</span> 10.13.13.2
</span></span><span class=line><span class=cl><span class=nv>PrivateKey</span> <span class=o>=</span> +GLDb5QQOHQ2QKWvuFS/4FiWpnivaxzwlm0QmFJIHV8<span class=o>=</span>
</span></span><span class=line><span class=cl><span class=nv>ListenPort</span> <span class=o>=</span> <span class=m>51820</span>
</span></span><span class=line><span class=cl><span class=nv>DNS</span> <span class=o>=</span> 10.13.13.1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>Peer<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>PublicKey</span> <span class=o>=</span> <span class=nv>t95vF4b11RLCId3ArVVIJoC5Ih9CNbI0VTNuDuEzZyw</span><span class=o>=</span>
</span></span><span class=line><span class=cl><span class=nv>PresharedKey</span> <span class=o>=</span> 7mCNCZdMKeRz1Zrpl9bFS08jJAdv6/USazRVq7tjznY<span class=o>=</span>
</span></span><span class=line><span class=cl><span class=c1># 需要注意的是这个 Peer Endpoint 的 IP 是否正确</span>
</span></span><span class=line><span class=cl><span class=nv>Endpoint</span> <span class=o>=</span> 192.168.5.198:51820
</span></span><span class=line><span class=cl><span class=nv>AllowedIPs</span> <span class=o>=</span> 0.0.0.0/0
</span></span></code></pre></td></tr></table></div></div><blockquote><p>插入下，这个 Endpoint 的地址也很值得一说，能看到服务端 wg0.conf 的配置中，peer1 并未被设置任何 Endpoint，这实质是表示这个 peer1 的 Endpoint 是动态的，也就是说每次 peer1 发送数据到服务端 wg0 时，服务端通过认证加密技术认证了数据后，就会以数据包的来源 IP 地址作为 peer1 的 Endpoint，这样 peer1 就可以随意更换自己的 IP 地址（Roaming），而 WireGuard 隧道仍然能正常工作（IP 频繁更换的一个典型场景就是手机的网络漫游与 WiFi 切换）。这使 WireGuard 具备了比较明显的无连接特性，也就是说 WireGuard 隧道不需要保持一个什么连接，切换网络也不需要重连，只要数据包能够到达服务端，就能够正常工作。</p></blockquote><p>因为我这里是内网环境测试，配置文件中的 <code>Peer</code> - <code>Endpoint</code> 的 IP 地址直接用服务端的内网 IP 地址就行，也就是 <code>192.168.5.198</code>。</p><blockquote><p>如果你的服务端有公网 IP 地址（比如是云服务器，或者通过端口映射用家庭宽带的动态公网 IP），这个 Endpoint 地址也可以使用该公网 IP 地址，效果是一样的。</p></blockquote><p>配置文件确认无误后，将该配置文件保存到客户端的 <code>/etc/wireguard/peer1.conf</code> 这个路径下，然后使用如下命令启动 WireGuard 客户端：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>sudo wg-quick up peer1
</span></span></code></pre></td></tr></table></div></div><p>上述命令会自动在 <code>/etc/wireguard/</code> 目录下找到名为 <code>peer1.conf</code> 的配置文件，然后根据其内容启动一个名为 <code>peer1</code> 的 WireGuard 设备并完成对应配置。</p><p>我启动时的日志如下，wg-quick 打印出了它执行的所有网络相关指令（我添加了详细的注释）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo wg-quick up peer1
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] ip link add peer1 type wireguard        # 创建一个名为 peer1 的 WireGuard 设备</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] wg setconf peer1 /dev/fd/63             # 设置 peer1 设备的配置</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] ip -4 address add 10.13.13.2 dev peer1  # 设置 peer1 设备的 IP 地址</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] ip link set mtu 1420 up dev peer1       # 设置 peer1 设备的 MTU</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] resolvconf -a tun.peer1 -m 0 -x  # 设置 peer1 设备的 DNS，确保 DNS 能够正常工作</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] wg set peer1 fwmark 51820        # 将 peer1 设备的防火墙标记设为 51820，用于标记 WireGuard 出站流量</span>
</span></span><span class=line><span class=cl>                                     <span class=c1># 在后面的路由策略中会使用该标记使 WireGuard 出站流量走默认路由表</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] ip -4 route add 0.0.0.0/0 dev peer1 table 51820     # 创建单独的路由表 51820，默认将所有流量转发到 peer1 接口</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] ip -4 rule add not fwmark 51820 table 51820         # 所有不带 51820 标记的流量（普通流量），都转发到前面新建的路由表 51820</span>
</span></span><span class=line><span class=cl>                                                        <span class=c1># 也就是所有普通流量都转发到 peer1 接口</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] ip -4 rule add table main suppress_prefixlength 0   # 流量全都走 main 路由表（即默认路由表），但是排除掉前缀长度（掩码） &lt;= 0 的流量</span>
</span></span><span class=line><span class=cl>                                                        <span class=c1># 掩码 &lt;= 0 的只有 0.0.0.0/0，即默认路由。所以意思是所有非默认路由策略的流量都走 main 路由表</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] sysctl -q net.ipv4.conf.all.src_valid_mark=1        # 启用源地址有效性检查，用于防止伪造源地址</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] nft -f /dev/fd/63                                   # 配置 nftables 规则，用于确保 WireGuard 流量能正确路由，并防止恶意数据包进入网络</span>
</span></span></code></pre></td></tr></table></div></div><p>跑完后我们现在确认下状态，应该是能正常走 WireGuard 访问相关网络了，可以 WireShark 抓个包确认下。</p><blockquote><p>如果网络不通，那肯定是中间哪一步配置有问题，可以根据上面的日志一步步排查网络接口、路由表、路由策略、iptables/nftables 的配置，必要时可以通过 WireShark 抓包定位。</p></blockquote><p>现在再检查下系统的网络状态，首先检查下路由表，会发现路由表没任何变化：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ ip route ls
</span></span><span class=line><span class=cl>default via 192.168.5.201 dev eth0 proto static 
</span></span><span class=line><span class=cl>192.168.5.0/24 dev eth0 proto kernel scope link src 192.168.5.197 
</span></span></code></pre></td></tr></table></div></div><p>但是我们的 WireGuard 隧道已经生效了，这就说明现在我们的流量已经不是直接走上面这个默认路由表了，还有其他配置在起作用。
往回看看前面的客户端启动日志，其中显示 wg-quick 创建了一个名为 51820 的路由表，我们来检查下这个表：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ryan@ubuntu-2004-builder:~$ ip route ls table <span class=m>51820</span>
</span></span><span class=line><span class=cl>default dev peer1 scope link
</span></span></code></pre></td></tr></table></div></div><p>能看到这个表确实是将所有流量都转发到了 WireGuard 的 peer1 接口，基本能确认现在流量都走了这个路由表。
那么问题来了，系统的流量是如何被转发到这个路由表的呢？为什么默认的路由表现在不生效了？</p><p>要理清这个问题，需要补充点知识——Linux 从 2.2 开始支持了多路由表，并通过路由策略数据库来为每个数据包选择正确的路由表，这个路由策略数据库可以通过 <code>ip rule</code> 命令来查看、修改。</p><p>前置知识补充完毕，现在来看下系统当前的路由策略，同样我已经补充好了注释：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ ip rule show
</span></span><span class=line><span class=cl>0:      from all lookup <span class=nb>local</span>   <span class=c1># 0 是最高优先级，`all` 表示所有流量，`lookup local` 表示查找 local 路由表。</span>
</span></span><span class=line><span class=cl>                                <span class=c1># local 是一个特殊路由表，包含对本地和广播地址的优先级控制路由。</span>
</span></span><span class=line><span class=cl>32764:  from all lookup main suppress_prefixlength <span class=m>0</span>  <span class=c1># 32764 目前是第二优先级，将所有流量路由到　main 路由表，但是排除掉默认路由（前缀/掩码 &lt;= 0）</span>
</span></span><span class=line><span class=cl>                                                      <span class=c1># 功能是让所有非默认路由的流量都走 main 路由表</span>
</span></span><span class=line><span class=cl>                                                      <span class=c1># 这条规则前面实际解释过了，它是 wg-quick 在启动隧道时添加的规则。</span>
</span></span><span class=line><span class=cl>32765:  not from all fwmark 0xca6c lookup <span class=m>51820</span> <span class=c1># 所有不带 0xca6c 标记（51820 的 16 进制格式）的流量（普通流量），都走 51820 路由表</span>
</span></span><span class=line><span class=cl>                                                <span class=c1># 也就是都转发到 WireGuard peer1 接口。</span>
</span></span><span class=line><span class=cl>                                                <span class=c1># 这条规则是前面的 `ip -4 rule add not fwmark 51820 table 51820` 命令添加的。</span>
</span></span><span class=line><span class=cl>                                                <span class=c1># 而它所匹配的防火墙标记则是由前面的 `wg set peer1 fwmark 51820` 命令设置的。</span>
</span></span><span class=line><span class=cl>32766:  from all lookup main    <span class=c1># 所有流量都走 main 路由表，当前是不生效状态，因为前面的规则优先级更高。</span>
</span></span><span class=line><span class=cl>                                <span class=c1># main 是系统的默认路由表，通常我们使用 ip route 命令都是在这个表上操作。</span>
</span></span><span class=line><span class=cl>32767:  from all lookup default <span class=c1># 所有流量都走 default 路由表，当前同样是不生效状态。</span>
</span></span><span class=line><span class=cl>                                <span class=c1># default 是一个系统生成的兜底路由表，默认不包含任何路由规则，可用于自定义路由策略，也可删除。</span>
</span></span></code></pre></td></tr></table></div></div><p>结合注释看完上面的路由策略，现在你应该理清楚 WireGuard 的路由规则了，它加了条比默认路由策略 <code>32766</code> 优先级更高的路由策略 <code>32765</code>，将所有普通流量都通过它的自定义路由表路由到 peer1 接口。
另一方面 peer1 接口在前面已经被打了 fwmark 标记 <code>51820</code> 也就是 16 进制的 0xca6c，所以 peer1 出站到服务端的流量不会被 <code>32765</code> 匹配到，所以会走优先级更低的 <code>32766</code> 策略，也就是走了 main 路由表。</p><p>另外 <code>32764</code> 这条路由策略有点特殊，这里也简单解释下，此策略在前面注释中已经做了解释——是让所有非默认路由的流量都走 main 路由表，而 main 路由表中的非默认路由一般都是其他程序自动管理添加的，或者是我们手动添加的，所以这条规则其实就是确保这些路由策略仍然有效，避免 WireGuard 策略把它们覆盖掉而导致问题。</p><p>前面都分析完了，现在还剩下 wg-quick 日志的最后一行 <code>nft -f /dev/fd/63</code>，它到底做了什么呢？
nft 是 nftables 的命令行工具名称，所以它实际是设置了一些 nftables 规则，我们查看下它的规则内容：</p><blockquote><p>注意：nftables 的这些 chain 名称是完全自定义的，没啥特殊意义</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo nft list ruleset
</span></span><span class=line><span class=cl>table ip wg-quick-peer1 <span class=o>{</span>
</span></span><span class=line><span class=cl>        chain preraw <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=nb>type</span> filter hook prerouting priority raw<span class=p>;</span> policy accept<span class=p>;</span>
</span></span><span class=line><span class=cl>                iifname !<span class=o>=</span> <span class=s2>&#34;peer1&#34;</span> ip daddr 10.13.13.2 fib saddr <span class=nb>type</span> !<span class=o>=</span> <span class=nb>local</span> drop
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        chain premangle <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=nb>type</span> filter hook prerouting priority mangle<span class=p>;</span> policy accept<span class=p>;</span>
</span></span><span class=line><span class=cl>                meta l4proto udp meta mark <span class=nb>set</span> ct mark
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        chain postmangle <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=nb>type</span> filter hook postrouting priority mangle<span class=p>;</span> policy accept<span class=p>;</span>
</span></span><span class=line><span class=cl>                meta l4proto udp meta mark 0x0000ca6c ct mark <span class=nb>set</span> meta mark
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看到这里是创建了一个 <code>wg-quick-peer1</code> 表，通过该表在 netfilter 上设置了如下规则：</p><ol><li><code>preraw</code> 链：此链用于防止恶意数据包进入网络。<ol><li>type 开头的一行是规则的类型，这里是 <code>filter</code>，仅匹配了 <code>raw</code> 链的 <code>prerouting</code> 表。</li><li>它丢弃掉所有来源接口不是 peer1、目的地址是 10.13.13.2、且源地址不是本地地址的数据包。</li><li>总结下就是只允许本地地址或者 peer1 直接访问 10.13.13.2 这个地址。</li></ol></li><li><code>premangle</code> 链：此链用于确保所有 UDP 数据包都能被正确从 WireGuard 接口入站。<ol><li>它将所有 UDP 数据包的标记设置为连接跟踪标记（没搞懂这个标记是如何生效的&mldr;.）。</li></ol></li><li><code>postmangle</code> 链：此链用于确保所有 UDP 数据包都能被正确从 WireGuard 接口出站。<ol><li>它将所有 UDP 数据包的标记设置为 0xca6c（51820 的 16 进制格式）（同样没理解这个标记是如何生效的&mldr;）。</li></ol></li></ol><p>最后看下 WireGuard 的状态，它是前面 <code>wg setconf peer1 /dev/fd/63</code> 设置的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ryan@ubuntu-2004-builder:~$ sudo wg show 
</span></span><span class=line><span class=cl>interface: peer1
</span></span><span class=line><span class=cl>  public key: HR8Kp3xWIt2rNdS3aaCk+Ss7yQqC9cn6h3WS6UK3WE0<span class=o>=</span>
</span></span><span class=line><span class=cl>  private key: <span class=o>(</span>hidden<span class=o>)</span>
</span></span><span class=line><span class=cl>  listening port: <span class=m>51820</span>
</span></span><span class=line><span class=cl>  fwmark: 0xca6c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>peer: <span class=nv>t95vF4b11RLCId3ArVVIJoC5Ih9CNbI0VTNuDuEzZyw</span><span class=o>=</span>
</span></span><span class=line><span class=cl>  preshared key: <span class=o>(</span>hidden<span class=o>)</span>
</span></span><span class=line><span class=cl>  endpoint: 192.168.5.198:51820
</span></span><span class=line><span class=cl>  allowed ips: 0.0.0.0/0
</span></span><span class=line><span class=cl>  latest handshake: <span class=m>18</span> minutes, <span class=m>59</span> seconds ago
</span></span><span class=line><span class=cl>  transfer: <span class=m>124</span> B received, <span class=m>324</span> B sent
</span></span></code></pre></td></tr></table></div></div><p>分析完毕，现在关闭掉 WireGuard 客户端，将客户端主机的网络恢复到正常状态。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo wg-quick down peer1
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] ip -4 rule delete table 51820</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] ip -4 rule delete table main suppress_prefixlength 0</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] ip link delete dev peer1</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] resolvconf -d tun.peer1 -f</span>
</span></span><span class=line><span class=cl><span class=o>[</span><span class=c1>#] nft -f /dev/fd/63</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=结语 class=headerLink><a href=#%e7%bb%93%e8%af%ad class=header-mark></a>结语</h2><p>一通分析，你是否感觉到了 wg-quick 的实现十分巧妙，通过简单几行 iptables/nftables 与 iproute2 命令就在 WireGuard 隧道上实现了一个 VPN 网络，更妙的是只要把新增的这些 iptables/nftables 与 iproute2 规则删除，就能恢复到 WireGuard 未启动的状态，相当于整个工作是完全可逆的（显然前面的 <code>sudo wg-quick down peer1</code> 就是这么干的）。</p><p>总之这篇文章简单分析了 wireguard 虚拟网络在 Linux 上的实现，希望对你有所帮助。</p><p>下一篇文章（如果有的话&mldr;），我会带来更多的 WireGuard 实现细节，敬请期待。</p><h2 id=参考 class=headerLink><a href=#%e5%8f%82%e8%80%83 class=header-mark></a>参考</h2><ul><li><a href=https://www.wireguard.com/protocol/ target=_blank rel="noopener noreferrer">wireguard protocol</a>： 官方文档还有官方的白皮书，都写得很清晰易懂。</li><li><a href=https://zhuanlan.zhihu.com/p/404402933 target=_blank rel="noopener noreferrer">WireGuard到底好在哪？</a>: 比较深入浅出的随想，值得一读。</li><li><a href=https://ro-che.info/articles/2021-02-27-linux-routing target=_blank rel="noopener noreferrer">Understanding modern Linux routing (and wg-quick)</a>: 对 WireGuard 客户端用到的多路由表与路由策略技术做了详细的介绍。<ul><li>它的中文翻译：<a href=https://icloudnative.io/posts/linux-routing-of-wireguard/ target=_blank rel="noopener noreferrer">WireGuard 基础教程：wg-quick 路由策略解读 - 米开朗基扬</a></li></ul></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2023-03-28</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=# onclick=return!1 title="分享到 Twitter" data-sharer=twitter data-url=https://thiscute.world/posts/wireguard-on-linux/ data-title="Linux 上的 WireGuard 网络分析（一）" data-via=ryan4yin data-hashtags=WireGuard,VPN,Linux,网络,iptables,conntrack><i class="fab fa-twitter fa-fw"></i></a><a href=# onclick=return!1 title="分享到 Facebook" data-sharer=facebook data-url=https://thiscute.world/posts/wireguard-on-linux/ data-hashtag=WireGuard><i class="fab fa-facebook-square fa-fw"></i></a><a href=# onclick=return!1 title="分享到 Reddit" data-sharer=reddit data-url=https://thiscute.world/posts/wireguard-on-linux/><i class="fab fa-reddit fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/wireguard/>WireGuard</a>,&nbsp;<a href=/tags/vpn/>VPN</a>,&nbsp;<a href=/tags/linux/>Linux</a>,&nbsp;<a href=/tags/%E7%BD%91%E7%BB%9C/>网络</a>,&nbsp;<a href=/tags/iptables/>iptables</a>,&nbsp;<a href=/tags/conntrack/>conntrack</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/ee-basics-2-esp32-display/ class=prev rel=prev title="EE 入门（二） - 使用 ESP32 与 SPI 显示屏绘图、显示图片、跑贪吃蛇"><i class="fas fa-angle-left fa-fw"></i>EE 入门（二） - 使用 ESP32 与 SPI 显示屏绘图、显示图片、跑贪吃蛇</a></div></div><div id=comments><div id=utterances></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><a href=https://www.foreverblog.cn/ target=_blank><img src=https://img.foreverblog.cn/logo_en_default.png alt style=width:auto;height:15px;margin-bottom:5px></a> <a href=https://www.foreverblog.cn/go.html target=_blank><img src=https://img.foreverblog.cn/wormhole_3.gif alt style=width:auto;height:24px title=穿梭虫洞-随机访问十年之约友链博客></a></div><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer" title="Hugo 0.110.0">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href=https://github.com/HEIGE-PCloud/DoIt target=_blank rel="noopener noreferrer" title="DoIt 0.2.13"><i class="far fa-edit fa-fw"></i> DoIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://thiscute.world/ target=_blank rel="noopener noreferrer">ryan4yin</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class=footer-line></div><div class=footer-line></div></div></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><div class=assets><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/katex/copy-tex.min.css><noscript><link rel=stylesheet href=/lib/katex/copy-tex.min.css></noscript><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:30},comment:{utterances:{darkTheme:"github-dark",issueTerm:"pathname",label:"",lightTheme:"github-light",repo:"ryan4yin/thiscute.world"}},data:{"desktop-header-typeit":"This Cute World","mobile-header-typeit":"This Cute World"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"747LJ10EI7",algoliaIndex:"ryan-space",algoliaSearchKey:"658db5f2bf056f83458cacf5dd58ec80",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},sharerjs:!0,typeit:{cursorChar:null,cursorSpeed:null,data:{"desktop-header-typeit":["desktop-header-typeit"],"mobile-header-typeit":["mobile-header-typeit"]},duration:null,speed:null}}</script><script type=text/javascript src=/js/utterances.min.js defer></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/algoliasearch/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/typeit/typeit.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js defer></script><script type=text/javascript src=/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/js/katex.min.js defer></script><script type=text/javascript src=/js/theme.min.js defer></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4V93QVSNFW",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-4V93QVSNFW" async></script></div></body></html>