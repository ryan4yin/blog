<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<meta http-equiv=x-ua-compatible content="IE=edge, chrome=1">
<title>TLS 协议、TLS 证书、TLS 证书的配置方法、TLS 加密的破解手段 - This Cute World</title><meta name=description content="This Cute World"><meta property="og:title" content="TLS 协议、TLS 证书、TLS 证书的配置方法、TLS 加密的破解手段">
<meta property="og:description" content="个人笔记，并非教程！只适合当成参考手册，按目录选读。 如果希望深入学习，建议阅读 Practical Cryptography for Developers 更新记录 补充 TLS 协议的详细流程 完成 TLS 证书的详细介绍 一、T">
<meta property="og:type" content="article">
<meta property="og:url" content="https://thiscute.world/posts/about-tls-cert/"><meta property="og:image" content="https://thiscute.world/posts/about-tls-cert/https-secure.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-01-17T21:53:26+08:00">
<meta property="article:modified_time" content="2021-01-17T21:53:26+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://thiscute.world/posts/about-tls-cert/https-secure.png">
<meta name=twitter:title content="TLS 协议、TLS 证书、TLS 证书的配置方法、TLS 加密的破解手段">
<meta name=twitter:description content="个人笔记，并非教程！只适合当成参考手册，按目录选读。 如果希望深入学习，建议阅读 Practical Cryptography for Developers 更新记录 补充 TLS 协议的详细流程 完成 TLS 证书的详细介绍 一、T">
<meta name=application-name content="This Cute World">
<meta name=apple-mobile-web-app-title content="This Cute World"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://thiscute.world/posts/about-tls-cert/><link rel=prev href=https://thiscute.world/posts/qemu-kvm-usage/><link rel=next href=https://thiscute.world/posts/expirence-of-vault/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><meta name=google-site-verification content="E8bpp1lVVlb9YnSJcUzPL1dLAG17Nl_sp5Ru9a8tUDQ"><meta name=baidu-site-verification content="code-ZZtDruAnX1"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"TLS 协议、TLS 证书、TLS 证书的配置方法、TLS 加密的破解手段","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/thiscute.world\/posts\/about-tls-cert\/"},"image":[{"@type":"ImageObject","url":"https:\/\/thiscute.world\/posts\/about-tls-cert\/https-secure.png","width":1500,"height":450}],"genre":"posts","keywords":"HTTPS, TLS, OpenSSL, 加密, 破解","wordcount":8705,"url":"https:\/\/thiscute.world\/posts\/about-tls-cert\/","datePublished":"2021-01-17T21:53:26+08:00","dateModified":"2021-01-17T21:53:26+08:00","publisher":{"@type":"Organization","name":"ryan4yin","logo":"https:\/\/thiscute.world\/avatar\/myself.png"},"author":{"@type":"Person","name":"ryan4yin"},"description":""}</script></head>
<body header-desktop=fixed header-mobile=auto><script type=text/javascript>(''==='true'&&window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script>
<div id=mask></div><div class=wrapper><header class=desktop id=header-desktop>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="This Cute World"><span id=id-1 class=typeit></span></a>
</div>
<div class=menu>
<div class=menu-inner><a class=menu-item href=/statistics/> 阅读排行 </a><a class=menu-item href=/categories/%E6%8A%80%E6%9C%AF/> 技术 </a><a class=menu-item href=/categories/%E9%9A%8F%E7%AC%94/> 随笔 </a><a class=menu-item href=/tags/> 标签 </a><a class=menu-item href=/friends/> 朋友们 </a><a class=menu-item href=/now/> 此刻 </a><a class=menu-item href=/about/> 关于 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item language" title=选择语言>Simplified Chinese<i class="fas fa-chevron-right fa-fw"></i>
<select class=language-select id=language-select-desktop onchange="location=this.value"><option value=/posts/about-tls-cert/ selected>Simplified Chinese</option></select>
</a><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索>
<i class="fas fa-search fa-fw"></i>
</a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空>
<i class="fas fa-times-circle fa-fw"></i>
</a>
<span class="search-button search-loading" id=search-loading-desktop>
<i class="fas fa-spinner fa-fw fa-spin"></i>
</span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
</a>
</div>
</div>
</div>
</header><header class=mobile id=header-mobile>
<div class=header-container>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="This Cute World"><span id=id-2 class=typeit></span></a>
</div>
<div class=menu-toggle id=menu-toggle-mobile>
<span></span><span></span><span></span>
</div>
</div>
<div class=menu id=menu-mobile><div class=search-wrapper>
<div class="search mobile" id=search-mobile>
<input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索>
<i class="fas fa-search fa-fw"></i>
</a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空>
<i class="fas fa-times-circle fa-fw"></i>
</a>
<span class="search-button search-loading" id=search-loading-mobile>
<i class="fas fa-spinner fa-fw fa-spin"></i>
</span>
</div>
<a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>
取消
</a>
</div><a class=menu-item href=/statistics/ title>阅读排行</a><a class=menu-item href=/categories/%E6%8A%80%E6%9C%AF/ title>技术</a><a class=menu-item href=/categories/%E9%9A%8F%E7%AC%94/ title>随笔</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/friends/ title>朋友们</a><a class=menu-item href=/now/ title>此刻</a><a class=menu-item href=/about/ title>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
</a><a href=javascript:void(0); class=menu-item title=选择语言>Simplified Chinese<i class="fas fa-chevron-right fa-fw"></i>
<select class=language-select onchange="location=this.value"><option value=/posts/about-tls-cert/ selected>Simplified Chinese</option></select>
</a></div>
</div>
</header>
<div class="search-dropdown desktop">
<div id=search-dropdown-desktop></div>
</div>
<div class="search-dropdown mobile">
<div id=search-dropdown-mobile></div>
</div>
<main class=main>
<div class=container><div class=toc id=toc-auto>
<h2 class=toc-title>目录</h2>
<div class=toc-content id=toc-content-auto></div>
</div><article class="page single"><h1 class="single-title animated flipInX">TLS 协议、TLS 证书、TLS 证书的配置方法、TLS 加密的破解手段</h1><div class=post-meta>
<div class=post-meta-line><span class=post-author><a href=https://thiscute.world/ title=Author target=_blank rel="noopener noreferrer author" class=author><i class="fas fa-user-circle fa-fw"></i>ryan4yin</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/%E6%8A%80%E6%9C%AF/><i class="far fa-folder fa-fw"></i>技术</a></span></div>
<div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-01-17>2021-01-17</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 8705 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 18 分钟&nbsp;<span id=/posts/about-tls-cert/ class=leancloud_visitors data-flag-title="TLS 协议、TLS 证书、TLS 证书的配置方法、TLS 加密的破解手段">
<i class="far fa-eye fa-fw"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
</span>&nbsp;
<a href=#comments id=post-meta-vcount title=查看评论>
<i class="fas fa-comment fa-fw"></i>&nbsp;<span id=/posts/about-tls-cert/ class=waline-comment-count></span>&nbsp;条评论
</a></div>
</div><div class=featured-image><img class=lazyload src=/svg/loading.min.svg data-src=/posts/about-tls-cert/https-secure.png data-srcset="/posts/about-tls-cert/https-secure.png, /posts/about-tls-cert/https-secure.png 1.5x, /posts/about-tls-cert/https-secure.png 2x" data-sizes=auto alt=/posts/about-tls-cert/https-secure.png title=/posts/about-tls-cert/https-secure.png></div><div class="details toc" id=toc-static kept>
<div class="details-summary toc-title">
<span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span>
</div>
<div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents>
<ul>
<li><a href=#更新记录>更新记录</a></li>
<li><a href=#一tls-协议>一、TLS 协议</a></li>
<li><a href=#二tls-证书介绍>二、TLS 证书介绍</a>
<ul>
<li><a href=#1-证书是什么>1. 证书是什么？</a></li>
<li><a href=#2-tls-证书支持保护的域名类型>2. TLS 证书支持保护的域名类型</a></li>
</ul>
</li>
<li><a href=#三tls-证书的生成>三、TLS 证书的生成</a>
<ul>
<li><a href=#1-tls-证书的类型>1. TLS 证书的类型</a></li>
<li><a href=#2-向权威ca机构申请受信-tls-证书>2. 向权威CA机构申请「受信 TLS 证书」</a></li>
<li><a href=#3-生成本地签名证书或者自签名证书>3. 生成「本地签名证书」或者「自签名证书」</a></li>
<li><a href=#4-关于证书寿命>4. 关于证书寿命</a></li>
<li><a href=#5-拓展1基于-ecc-算法的-tls-证书>5. 拓展1：基于 ECC 算法的 TLS 证书</a></li>
<li><a href=#6-拓展2使用-openssl-生成-sshjwt-密钥对>6. 拓展2：使用 OpenSSL 生成 SSH/JWT 密钥对</a>
<ul>
<li><a href=#61-加密与签名>6.1 加密与签名</a></li>
</ul>
</li>
</ul>
</li>
<li><a href=#四服务端与客户端的证书配置>四、服务端与客户端的证书配置</a>
<ul>
<li><a href=#1-服务端的-tls-证书配置>1. 服务端的 TLS 证书配置</a>
<ul>
<li><a href=#11-完美前向保密>1.1 完美前向保密</a></li>
</ul>
</li>
<li><a href=#2-客户端的-tls-证书配置针对本地签名的证书>2. 客户端的 TLS 证书配置（针对本地签名的证书）</a>
<ul>
<li><a href=#21-证书锁定certifacte-pining技术>2.1 证书锁定(Certifacte Pining)技术</a></li>
<li><a href=#22-公钥锁定public-key-pining>2.2 公钥锁定(Public Key Pining)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href=#五tls-双向认证mutual-tls-authentication-mtls>五、TLS 双向认证(Mutual TLS authentication, mTLS)</a>
<ul>
<li><a href=#mtls-的安全性>mTLS 的安全性</a></li>
</ul>
</li>
<li><a href=#六-tls-协议的破解手段>六 TLS 协议的破解手段</a>
<ul>
<li><a href=#1-客户端逆向破解手段总结>1. 客户端逆向/破解手段总结</a></li>
</ul>
</li>
<li><a href=#七通过-openssl-对-tls-证书进行-curd增删查改>七、通过 OpenSSL 对 TLS 证书进行 CURD（增删查改）</a>
<ul>
<li><a href=#1-查询与验证>1. 查询与验证</a></li>
<li><a href=#2-证书格式转换>2. 证书格式转换</a></li>
</ul>
</li>
<li><a href=#参考>参考</a>
<ul>
<li><a href=#tls-协议>TLS 协议</a></li>
<li><a href=#tls-证书>TLS 证书</a></li>
</ul>
</li>
</ul>
</nav></div>
</div><div class=content id=content><blockquote>
<p>个人笔记，并非教程！只适合当成参考手册，按目录选读。</p>
</blockquote>
<blockquote>
<p>如果希望深入学习，建议阅读 <a href=https://github.com/nakov/practical-cryptography-for-developers-book target=_blank rel="noopener noreferrer">Practical Cryptography for Developers</a></p>
</blockquote>
<h2 id=更新记录>更新记录</h2>
<ul>
<li><i class="far fa-square fa-fw"></i> 补充 TLS 协议的详细流程</li>
<li><i class="far fa-check-square fa-fw"></i> 完成 TLS 证书的详细介绍</li>
</ul>
<hr>
<h2 id=一tls-协议>一、TLS 协议</h2>
<p>我们需要加密网络数据以实现安全通信，但是有一个现实的问题：</p>
<ol>
<li>非对称加密算法（RSA/ECC 等）可以方便地对数据进行签名/验证，但是计算速度慢。</li>
<li>对称加密算法（ChaCha20/AES 等）计算速度快，强度高，但是无法安全地生成与保管密钥。</li>
</ol>
<p>TLS 协议巧妙地解决了这个问题：它在握手阶段使用「<strong>非对称算法</strong>」验证服务端，并使用 ECDHE 密钥交换算法（Elliptic Curve Diffie-Hellman key exchange）安全地生成一个临时的对称密钥，然后使用「<strong>对称算法</strong>」进行加密通信。</p>
<p>在后续的每次数据交换过程中，TLS 协议都会使用 ECDHE 算法生成新的对称密钥，再使用新密钥加密解密数据。</p>
<p><figure><a class=lightgallery href=/images/about-tls-cert/perfect-forward-secrecy-diagram.webp title=/images/about-tls-cert/perfect-forward-secrecy-diagram.webp data-thumbnail=/images/about-tls-cert/perfect-forward-secrecy-diagram.webp data-sub-html="<h2>perfect-forward-secrecy-diagram</h2>">
<img class=lazyload src=/svg/loading.min.svg data-src=/images/about-tls-cert/perfect-forward-secrecy-diagram.webp data-srcset="/images/about-tls-cert/perfect-forward-secrecy-diagram.webp, /images/about-tls-cert/perfect-forward-secrecy-diagram.webp 1.5x, /images/about-tls-cert/perfect-forward-secrecy-diagram.webp 2x" data-sizes=auto alt=/images/about-tls-cert/perfect-forward-secrecy-diagram.webp>
</a><figcaption class=image-caption>perfect-forward-secrecy-diagram</figcaption>
</figure></p>
<p>TLS 协议通过上述的流程，提供了「完美前向保密（Perfect Forward Secrecy）」特性，也就是说它能够保护过去进行的通讯不受密钥在未来暴露的威胁。
即使攻击者破解出了一个「对称密钥」，也只能获取到一次事务中的数据，黑客必须破解出整个 TLS 连接中所有事务的对称密钥，才能得到完整的数据。</p>
<blockquote>
<p>早期的 tls1.1/tls1.2 使用的不少算法，都不是前向安全的，从安全角度上讲建议使用 tls1.3，或者 tls1.2 + 前向安全的算法。</p>
</blockquote>
<blockquote>
<p>本文主要介绍 TLS 协议的使用、TLS 证书的生成，不涉及具体算法实现及协议细节。</p>
</blockquote>
<p>接下来讲下证书，TLS 协议通过<strong>两个证书</strong>来实现服务端身份验证，以及对称密钥的安全生成：</p>
<ol>
<li><strong>CA 证书</strong>：浏览器/操作系统自带，用于验证服务端 TLS 证书的签名。保证服务端证书可信。</li>
<li><strong>TLS 证书（服务端证书）</strong>：浏览器验证了服务端 TLS 证书可信后，将使用这个 TLS 证书与服务端进行协议/算法协商，以安全地生成一个对称密钥。</li>
</ol>
<p>CA 证书和 TLS 证书，都只在 TLS 握手阶段有用到，之后的通信就与它们无关了。</p>
<h2 id=二tls-证书介绍>二、TLS 证书介绍</h2>
<h3 id=1-证书是什么>1. 证书是什么？</h3>
<p>证书是一个文件，目前主流的证书规范为 X.509，由 <a href=https://tools.ietf.org/html/rfc5280 target=_blank rel="noopener noreferrer">RFC5280</a> 定义。</p>
<p>简单的说，证书其实就是非对称加密中的公钥，加上一些别的信息组成的一个文件。</p>
<p>比如 CA 证书，就是「CA 公钥 + CA 机构相关信息」构成的一个文件。</p>
<p>而 TLS 证书，则主要包含「公钥 + 申请者信息(你) + 颁发者(CA)的信息 + 签名(使用 CA 私钥加密的证书 Hash)」，以及一些其他相关信息。</p>
<p>因为 TLS 证书的签名是使用 CA 证书生成的，因此使用 CA 证书的公钥就能验证 TLS 证书签名的正确性，也就能判断该证书是否可信。</p>
<blockquote>
<p>现实中的 CA 证书实际上还要复杂些，通常证书颁发机构的权威证书的私钥是受到严格保护的，根证书会签发许多中间证书，形成一个 CA 证书链。TLS 证书 由 CA 证书链最末端的证书对 TLS 证书进行签名。
另外还有复杂的证书吊销机制，这里就不详细介绍了。</p>
</blockquote>
<p>你可以尝试使用浏览器查看 Google 的证书详情，我使用 Firefox 查看到的内容如下：</p>
<p><figure><a class=lightgallery href=/images/about-tls-cert/cert-content.png title=/images/about-tls-cert/cert-content.png data-thumbnail=/images/about-tls-cert/cert-content.png data-sub-html="<h2>cert-content</h2>">
<img class=lazyload src=/svg/loading.min.svg data-src=/images/about-tls-cert/cert-content.png data-srcset="/images/about-tls-cert/cert-content.png, /images/about-tls-cert/cert-content.png 1.5x, /images/about-tls-cert/cert-content.png 2x" data-sizes=auto alt=/images/about-tls-cert/cert-content.png>
</a><figcaption class=image-caption>cert-content</figcaption>
</figure></p>
<h3 id=2-tls-证书支持保护的域名类型>2. TLS 证书支持保护的域名类型</h3>
<p>TLS 证书支持配置多个域名，并且支持所谓的通配符（泛）域名。
但是通配符域名证书的匹配规则，<strong>和 DNS 解析中的匹配规则并不一致</strong>！</p>
<p>根据<a href=https://help.aliyun.com/document_detail/28542.html target=_blank rel="noopener noreferrer">证书选型和购买 - 阿里云文档</a> 的解释，<strong>通配符证书只支持同级匹配</strong>，详细说明如下：</p>
<ol>
<li>一级通配符域名：可保护该通配符域名（主域名）自身和该域名所有的一级子域名。
<ul>
<li>例如：一级通配符域名 <code>*.aliyun.com</code> 可以用于保护 <code>aliyun.com</code>、<code>www.aliyun.com</code> 以及其他所有一级子域名。
但是不能用于保护任何二级子域名，如 <code>xx.aa.aliyun.com</code></li>
</ul>
</li>
<li>二级或二级以上通配符域名：只能保护该域名同级的所有通配域名，不支持保护该通配符域名本身。
<ul>
<li>例如：<code>*.a.aliyun.com</code> 只支持保护它的所有同级域名，不能用于保护三级子域名。</li>
</ul>
</li>
</ol>
<p>要想保护多个二三级子域，只能在生成 TLS 证书时，添加多个通配符域名。
因此设计域名规则时，要考虑到这点，尽量不要使用层级太深的域名！有些信息可以通过 <code>-</code> 来拼接以减少域名层级，比如阿里云的 oss 域名：</p>
<ol>
<li>公网：<code>oss-cn-shenzhen.aliyuncs.com</code></li>
<li>内网：<code>oss-cn-shenzhen-internal.aliyuncs.com</code></li>
</ol>
<h2 id=三tls-证书的生成>三、TLS 证书的生成</h2>
<blockquote>
<p><a href=https://github.com/openssl/openssl target=_blank rel="noopener noreferrer">OpenSSL</a> 是目前使用最广泛的网络加密算法库，这里以它为例介绍证书的生成。
另外也可以考虑使用 <a href=https://github.com/cloudflare/cfssl target=_blank rel="noopener noreferrer">cfssl</a>.</p>
</blockquote>
<p>先回顾下，前面讲了 TLS 协议握手需要使用到两个证书：</p>
<ol>
<li>TLS 证书（服务端证书）：这个是服务端需要配置的数据加密证书。
<ul>
<li>服务端需要持有这个 TLS 证书本身，以及证书的私钥。</li>
<li>握手时服务端需要将 TLS 证书发送给客户端。</li>
</ul>
</li>
<li>CA 证书：这是受信的根证书，客户端可用于验证所有使用它进行签名的 TLS 证书。
<ul>
<li>CA 证书的私钥由权威机构持有，客户端（比如浏览器）则保有 CA 证书自身。</li>
</ul>
</li>
</ol>
<p>在 TLS 连接的建立阶段，客户端（如浏览器）会使用 CA 证书的公钥对服务端的证书签名进行验证，验证成功则说明该证书是受信任的。</p>
<h3 id=1-tls-证书的类型>1. TLS 证书的类型</h3>
<p>按照证书的生成方式进行分类，证书有三种类型：</p>
<ol>
<li>由权威 CA 机构签名的 TLS 证书：这类证书会被浏览器、小程序等第三方应用/服务商信任。申请证书时需要验证你的所有权，也就使证书无法伪造。
<ul>
<li>如果你的 API 需要提供给第三方应用/服务商/浏览器访问，那就必须向权威 CA 机构申请此类证书。</li>
</ul>
</li>
<li>本地签名证书 - <code>tls_locally_signed_cert</code>：即由本地 CA 证书签名的 TLS 证书
<ul>
<li>本地 CA 证书，就是自己使用 <code>openssl</code> 等工具生成的 CA 证书。</li>
<li>这类证书不会被浏览器/小程序等第三方应用/服务商信任，证书就可以被伪造。</li>
<li>这类证书的缺点是无法与第三方应用/服务商建立安全的连接。</li>
<li>如果客户端是完全可控的（比如是自家的 APP），那可以自行验证证书的可靠性（公钥锁定、双向 TLS 验证）。这种场景下使用此类证书是安全可靠的。可以不使用权威CA机构颁发的证书。</li>
</ul>
</li>
<li>自签名证书 - <code>tls_self_signed_cert</code>: 和 <code>tls_locally_signed_cert</code> 类似，但使用 TLS 证书自己充当 CA 证书（我签我自己），生成出的证书就叫自签名证书。
<ul>
<li>注意:<strong>更广义地讲，自签名证书，就是「并非由权威 CA 机构签名的 TLS 证书」</strong>，也就是同时指代了 <code>tls_self_signed_cert</code> 和 <code>tls_locally_signed_cert</code>。这也是「自签名证书」应用最广泛的一种含义。</li>
</ul>
</li>
</ol>
<p>总的来说，权威CA机构颁发的证书，可以被第三方的应用信任，但是自己生成的不行。
而越贵的权威证书，安全性与可信度就越高，或者可以保护更多的域名。</p>
<p>在客户端可控的情况下，可以考虑使用「本地签名证书」（方便、省钱），将这个证书预先埋入客户端中用于验证。</p>
<p>而「自签名证书」主要是方便，能不用还是尽量不要使用。</p>
<h3 id=2-向权威ca机构申请受信-tls-证书>2. 向权威CA机构申请「受信 TLS 证书」</h3>
<p>免费的 TLS 证书有两种方式获取：</p>
<ol>
<li>部分 TLS 提供商有提供免费证书的申请，有效期为一年，但是不支持泛域名。</li>
<li>申请 <a href=https://letsencrypt.org target=_blank rel="noopener noreferrer">Let&rsquo;s Encrypt 免费证书</a>
<ul>
<li>很多代理工具都有提供 Let&rsquo;s Encrypt 证书的 Auto Renewal，比如:
<ul>
<li><a href=/network-proxy+web-server/traefik/README.md rel>Traefik</a></li>
<li><a href=https://github.com/caddyserver/caddy target=_blank rel="noopener noreferrer">Caddy</a></li>
<li><a href=https://github.com/nginx-proxy/docker-letsencrypt-nginx-proxy-companion target=_blank rel="noopener noreferrer">docker-letsencrypt-nginx-proxy-companion</a></li>
</ul>
</li>
<li>网上也有一些 <a href=https://github.com/certbot/certbot target=_blank rel="noopener noreferrer">certbot</a> 插件，可以通过 DNS 提供商的 API 进行 Let&rsquo;s Encrypt 证书的 Auto Renewal，比如：
<ul>
<li><a href=https://github.com/tengattack/certbot-dns-aliyun target=_blank rel="noopener noreferrer">certbot-dns-aliyun</a></li>
</ul>
</li>
<li>terraform 也有相关 provider: <a href=https://github.com/vancluever/terraform-provider-acme target=_blank rel="noopener noreferrer">terraform-provider-acme</a></li>
</ul>
</li>
</ol>
<p>收费证书可以在各 TLS 提供商处购买，比如国内的阿里云腾讯云等。</p>
<p>完整的证书申请流程如下：</p>
<p><figure><a class=lightgallery href=/images/about-tls-cert/ca-sign-sechdule.png title=/images/about-tls-cert/ca-sign-sechdule.png data-thumbnail=/images/about-tls-cert/ca-sign-sechdule.png data-sub-html="<h2>证书申请流程</h2>">
<img class=lazyload src=/svg/loading.min.svg data-src=/images/about-tls-cert/ca-sign-sechdule.png data-srcset="/images/about-tls-cert/ca-sign-sechdule.png, /images/about-tls-cert/ca-sign-sechdule.png 1.5x, /images/about-tls-cert/ca-sign-sechdule.png 2x" data-sizes=auto alt=/images/about-tls-cert/ca-sign-sechdule.png>
</a><figcaption class=image-caption>证书申请流程</figcaption>
</figure></p>
<p>为了方便用户，图中的申请人(Applicant)自行处理的部分，目前很多证书申请网站也可以自动处理，用户只需要提供相关信息即可。</p>
<h3 id=3-生成本地签名证书或者自签名证书>3. 生成「本地签名证书」或者「自签名证书」</h3>
<p>除了被第三方信任的「受信 TLS 证书」，在内网环境，我们需要也使用 TLS 证书保障通信安全，这时我们可能会选择自己生成证书，而不是向权威机构申请证书。</p>
<p>可能的原因如下：</p>
<ol>
<li>要向权威机构申请证书，那是要给钱的。而在内网环境下，并无必要使用权威证书。</li>
<li>内网环境使用的可能是非公网域名（<code>xxx.local</code>/<code>xxx.lan</code>/<code>xxx.srv</code> 等），权威机构不签发这种域名的证书。（因为没有人唯一地拥有这个域名）</li>
</ol>
<p>前面介绍过，自己生成的证书有两种方类型：</p>
<ol>
<li>本地签名证书：生成两个独立的密钥对，一个用于 CA 证书，另一个用于 TLS 证书。使用 CA 证书对 TLS 证书进行签名。</li>
<li>自签名证书（我签我自己）：TLS 证书和 CA 证书都使用同一个密钥对，使用 TLS 证书对它自己进行签名。
<ul>
<li>测试发现这种方式得到的证书貌似不包含 SAN 属性！因此不支持多域名。</li>
</ul>
</li>
</ol>
<p>一般来说，直接生成一个泛域名的「自签名证书」就够了，但是它不方便拓展——客户端对每个「自签名证书」，都需要单独添加一次信任。
而「本地签名证书」就没这个问题，one <code>ca.crt</code> rules them all.</p>
<p>总的来说，使用「自签名证书」不方便进行拓展，未来可能会遇到麻烦。因此建议使用「本地签名证书」。</p>
<p>另外介绍下这里涉及到的几种文件类型：</p>
<ol>
<li><code>xxx.key</code>: 就是一个私钥，一般是一个 RSA 私钥，长度通常指定为 2048 位。
<ul>
<li>CA 证书和 TLS 证书的私钥都是通过这种方式生成的。</li>
</ul>
</li>
<li><code>xxx.csr</code>: 即 Certificate Sign Request，证书签名请求。使用 openssl 等工具，通过 TLS 密钥+TLS 证书的相关信息，可生成出一个 CSR 文件。
<ul>
<li>域名（Common Name, CN）就是在这里指定的，可以使用泛域名。</li>
<li>用户将 csr 文件发送给 CA 机构，进行进一步处理。</li>
</ul>
</li>
<li><code>xxx.crt</code>: 这就是我们所说的 TLS 证书，CA 证书和服务端 TLS 证书都是这个格式。
<ul>
<li>使用 CA 证书、CA 密钥对 <code>csr</code> 文件进行签名，就能得到最终的服务端 TLS 证书——一个 <code>crt</code> 文件。</li>
</ul>
</li>
</ol>
<p>生成一个「自签名证书」或者「本地签名证书」（RSA256 算法），有两个步骤：</p>
<ol>
<li>编写证书签名请求的配置文件 <code>csr.conf</code>:
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>[ req ]
default_bits = 2048
prompt = no
default_md = sha256
req_extensions = req_ext
distinguished_name = dn

[ dn ]
C = CN  # Contountry
ST = &lt;state&gt;
L = &lt;city&gt;
O = &lt;organization&gt;
OU = &lt;organization unit&gt;
CN = *.svc.local  # 泛域名，这个字段已经被 chrome/apple 弃用了。

[ alt_names ]  # 备用名称，chrome/apple 目前只信任这里面的域名。
DNS.1 = *.svc.local  # 一级泛域名
DNS.2 = *.aaa.svc.local  # 二级泛域名
DNS.3 = *.bbb.svc.local  # 二级泛域名

[ req_ext ]
subjectAltName = @alt_names

[ v3_ext ]
subjectAltName=@alt_names  # Chrome 要求必须要有 subjectAltName(SAN)
authorityKeyIdentifier=keyid,issuer:always
basicConstraints=CA:FALSE
keyUsage=keyEncipherment,dataEncipherment,digitalSignature
extendedKeyUsage=serverAuth,clientAuth
</code></pre></td></tr></table>
</div>
</div><ul>
<li>此文件的详细文档：<a href=https://www.openssl.org/docs/man1.1.1/man5/ target=_blank rel="noopener noreferrer">OpenSSL file formats and conventions</a></li>
</ul>
</li>
<li>生成证书：
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># 1. 生成 2048 位 的 RSA 密钥</span>
openssl genrsa -out server.key <span class=m>2048</span>
<span class=c1># 2. 通过第一步编写的配置文件，生成证书签名请求（公钥+申请者信息）</span>
openssl req -new -key server.key -out server.csr -config csr.conf
<span class=c1># 3. 生成最终的证书，这里指定证书有效期 3650 天</span>
<span class=c1>## 3.1 方法一（自签名）：使用 server.key 进行自签名。这种方式得到的证书不包含 SAN！不支持多域名！</span>
openssl req -x509 -sha256 -days <span class=m>3650</span> -key server.key -in server.csr -out server.crt
<span class=c1>## 3.2 方法二（本地签名）：生成 ca 证书，并且使用 CA 证书、CA 密钥对 `csr` 文件进行签名</span>
<span class=c1>### 3.2.1 ca 私钥</span>
openssl genrsa -out ca.key <span class=m>2048</span>
<span class=c1>### 3.2.2 ca 证书，ca 证书的有效期尽量设长一点，因为不方便更新换代。</span>
openssl req -x509 -new -nodes -key ca.key -subj <span class=s2>&#34;/CN=MyLocalRootCA&#34;</span> -days <span class=m>10000</span> -out ca.crt
<span class=c1>### 3.2.3 签名，得到最终的 TLS 证书，它包含四部分内容：公钥+申请者信息 + 颁发者(CA)的信息+签名(使用 CA 私钥加密)</span>
openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key <span class=se>\
</span><span class=se></span>  -CAcreateserial -out server.crt -days <span class=m>3650</span> <span class=se>\
</span><span class=se></span>  -extensions v3_ext -extfile csr.conf
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>上述流程生成一个 x509 证书链，详细的参数说明，参见 <a href=https://tools.ietf.org/html/rfc5280 target=_blank rel="noopener noreferrer">RFC5280 - Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a></p>
<h3 id=4-关于证书寿命>4. 关于证书寿命</h3>
<p>对于公开服务，服务端证书的有效期不要超过 825 天（27 个月）！而 2020 年 11 月起，新申请的服务端证书有效期缩短到了 398 天（13 个月）。目前 Apple/Mozilla/Chrome 都发表了相应声明，证书有效期超过上述限制的，将被浏览器/Apple设备禁止使用。</p>
<p>对于其他用途的证书，如果更换起来很麻烦，可以考虑放宽条件。
比如 kubernetes 集群的加密证书，可以考虑有效期设长一些，比如 10 年。</p>
<p>据<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTQ2MjI5OA==&mid=2664079008&idx=1&sn=dede1114d5705880ea757f8d9ae4c92d" target=_blank rel="noopener noreferrer">云原生安全破局｜如何管理周期越来越短的数字证书？</a>所述，大量知名企业如 特斯拉/微软/领英/爱立信 都曾因未及时更换 TLS 证书导致服务暂时不可用。</p>
<p>因此 TLS 证书最好是设置自动轮转！人工维护不可靠！
目前很多 Web 服务器/代理，都支持自动轮转 Let&rsquo;s Encrypt 证书。
另外 Vault 等安全工具，也支持自动轮转私有证书。</p>
<h3 id=5-拓展1基于-ecc-算法的-tls-证书>5. 拓展1：基于 ECC 算法的 TLS 证书</h3>
<blockquote>
<p>Let&rsquo;s Encrypt 目前也已经支持了 ECC 证书。</p>
</blockquote>
<p>ECC(Elliptic Curve Cryptography) 算法被认为是比 RSA 更优秀的算法。与 RSA 算法相比，ECC 算法使用更小的密钥大小，但可提供同样的安全性，这使计算更快，降低了能耗，并节省了内存和带宽。</p>
<p>对于 RSA 密钥，可以提供不同的密钥大小（密钥大小越大，加密效果越好）。
而对于 ECC 密钥，您应选择要用哪种曲线生成密钥对。各个组织（ANSI X9.62、NIST、SECG）命名了多种曲线，可通过如下命名查看 openssl 支持的所有椭圆曲线名称：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell>openssl ecparam -list_curves
</code></pre></td></tr></table>
</div>
</div><p>生成一个自签名的 ECC 证书的命令示例如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># 生成 ec 算法的私钥，使用 prime256v1 算法，密钥长度 256 位。（强度大于 2048 位的 RSA 密钥）</span>
openssl ecparam -genkey -name prime256v1 -out key.pem
<span class=c1># 生成证书签名请求，需要输入域名(Common Name, CN)等相关信息</span>
openssl req -new -sha256 -key key.pem -out csr.csr -config csr.conf
<span class=c1># 生成最终的证书，这里指定证书有效期 10 年</span>
<span class=c1>## 方法一：自签名证书</span>
openssl req -x509 -sha256 -days <span class=m>3650</span> -key key.pem -in csr.csr -out certificate.pem
<span class=c1>## 方法二：使用 ca 进行签名，方法参考前面</span>
</code></pre></td></tr></table>
</div>
</div><h3 id=6-拓展2使用-openssl-生成-sshjwt-密钥对>6. 拓展2：使用 OpenSSL 生成 SSH/JWT 密钥对</h3>
<p>RSA/ECC 这两类非对称加密算法被广泛的应用在各类加密通讯中。
SSH/JWT 都支持 RSA-SHA256 及 ECDSA-SHA256 等基于 RSA/ECDSA 的签名/加密算法，因此使用 OpenSSL 生成的密钥对，也应该能用于 SSH 协议加密、JWT 签名等场景。</p>
<blockquote>
<p>目前有两种基于 ECC 和 DSA 的椭圆曲线签名算法：ECDSA 和 EdDSA(ed25519)，其中 ECDSA 的文档在曲线选择方面语焉不详，被认为可能存在安全隐患（政治和技术两方面带来的）。</p>
</blockquote>
<p>既然 SSH/TLS/JWT 使用的是相同的密钥对，那理所当然地，SSH/JWT 密钥对应该也可以通过 OpenSSL 生成出来。</p>
<p>生成 RSA 密钥对的命令如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># 1. 生成 2048 位（不是 256 位）的 RSA 密钥</span>
openssl genrsa -out rsa-private-key.pem <span class=m>2048</span>

<span class=c1># 2. 通过密钥生成公钥，JWT 使用此公钥验证签名</span>
openssl rsa -in rsa-private-key.pem -pubout -out rsa-public-key.pem

<span class=c1># 3. SSH 使用专用的公钥格式，需要使用 ssh-keygen 转换下格式</span>
ssh-keygen -i -mPKCS8 -f rsa-public-key.pem -y &gt; rsa-public.pub
</code></pre></td></tr></table>
</div>
</div><p>生成 ECC 密钥对的命令如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># 1. 生成 ec 算法的私钥，使用 prime256v1 算法，密钥长度 256 位。（强度大于 2048 位的 RSA 密钥）</span>
openssl ecparam -genkey -name prime256v1 -out ecc-private-key.pem
<span class=c1># 2. 通过密钥生成公钥</span>
openssl ec -in ecc-private-key.pem -pubout -out ecc-public-key.pem

<span class=c1># 3. SSH 使用专用的公钥格式，需要使用 ssh-keygen 转换下格式</span>
ssh-keygen -i -mPKCS8 -f ecc-public-key.pem -y &gt; ecc-public.pub
</code></pre></td></tr></table>
</div>
</div><p>JWT 签名及验证只需要使用标准的私钥-公钥对，即 <code>ecc-private-key.pem</code>/<code>ecc-public-key.pem</code>.</p>
<p>而 SSH 需要使用专用的公钥格式，因此它的使用的密钥对应该是 <code>ecc-private-key.pem</code>/<code>ecc-public.pub</code></p>
<p>注：SSH 目前推荐使用 ed25519 算法，而 JWT 目前推荐使用 ECDSA 算法。</p>
<h4 id=61-加密与签名>6.1 加密与签名</h4>
<ul>
<li>
<p>加密与解密：公钥用于对数据进行加密，私钥用于对数据进行解密</p>
</li>
<li>
<p>签名与验证：私钥用于对数据进行签名，公钥用于对签名进行验证</p>
</li>
<li>
<p><a href=https://www.zhihu.com/question/25912483/answer/31653639 target=_blank rel="noopener noreferrer">加密与签名的公私钥，用途刚好相反！</a></p>
</li>
</ul>
<h2 id=四服务端与客户端的证书配置>四、服务端与客户端的证书配置</h2>
<h3 id=1-服务端的-tls-证书配置>1. 服务端的 TLS 证书配置</h3>
<p>要支持 HTTPS 协议，服务端需要两个文件：</p>
<ol>
<li>TLS 证书私钥(RSA 私钥或 EC 私钥)：<code>server.key</code></li>
<li>TLS 证书（包含公钥）：<code>server.crt</code></li>
</ol>
<p>一般如 Nginx 等服务端应用，都可以通过配置文件指定这两个文件的位置。修改配置后重新启动，就有 TLS 了，可以通过 https 协议访问测试。</p>
<h4 id=11-完美前向保密>1.1 完美前向保密</h4>
<p>旧版本的 TLS 协议并不一定能保证前向保密，为了保证前向安全，需要在服务端配置中进行一定设置。
具体的设置方法参见 <a href="https://ssl-config.mozilla.org/#server=nginx" target=_blank rel="noopener noreferrer">ssl-config - mozilla</a>，该网站提供三个安全等级的配置：</p>
<ol>
<li>「Intermediate」：查看生成出的 <code>ssl-cipher</code> 属性，发现它只支持 <code>ECDHE</code>/<code>DHE</code> 开头的算法。因此它保证前向保密。
<ul>
<li>对于需要通过浏览器访问的 API，推荐选择这个等级。</li>
</ul>
</li>
<li>「Mordern」：只支持 <code>TLSv1.3</code>，该协议废弃掉了过往所有不安全的算法，保证前向保密，安全性极高，性能也更好。
<ul>
<li>对于不需要通过浏览器等旧终端访问的 API，请直接选择这个等级。</li>
</ul>
</li>
<li>「Old」：除非你的用户使用非常老的终端进行访问，否则请不要考虑这个选项！</li>
</ol>
<p>另外阿里云负载均衡器配置前向保密的方法参见：<a href=https://help.aliyun.com/document_detail/90740.html target=_blank rel="noopener noreferrer">管理TLS安全策略 - 负载均衡 - 阿里云文档</a></p>
<h3 id=2-客户端的-tls-证书配置针对本地签名的证书>2. 客户端的 TLS 证书配置（针对本地签名的证书）</h3>
<p>如果你在证书不是权威 CA 机构颁发的（比如是一个自签名证书），那就需要在客户端将这个 TLS 证书添加到受信证书列表中。
这个步骤可以在 OS 层面进行——添加到 OS 的默认证书列表中，也可以在代码层面完成——指定使用某个证书进行 TLS 验证。</p>
<ol>
<li>Linux: 使用如下命令安装证书
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell>sudo cp ca.crt /usr/local/share/ca-certificates/server.crt
sudo update-ca-certificates
</code></pre></td></tr></table>
</div>
</div></li>
<li>Windows: 通过证书管理器 <code>certmgr.msc</code> 将证书安装到 <code>受信任的根证书颁发机构</code>，Chrome 的小锁就能变绿了。</li>
<li>编程：使用 HTTPS 客户端的 api 指定使用的 TLS 证书</li>
<li>Docker-Client: 参见 <a href=https://docs.docker.com/registry/insecure/#use-self-signed-certificates target=_blank rel="noopener noreferrer">Use self-signed certificates - Docker Docs</a></li>
</ol>
<h4 id=21-证书锁定certifacte-pining技术>2.1 证书锁定(Certifacte Pining)技术</h4>
<p>即使使用了 TLS 协议对流量进行加密，并且保证了前向保密，也无法保证流量不被代理！</p>
<p>这是因为客户端大多是直接依靠了操作系统内置的证书链进行 TLS 证书验证，而 Fiddler 等代理工具可以将自己的 TLS 证书添加到该证书链中。</p>
<p>为了防止流量被 Fiddler 等工具使用上述方式监听流量，出现了「证书锁定」技术。
方法是在客户端中硬编码证书的指纹（Hash值，或者直接保存整个证书的内容也行），在建立 TLS 连接前，先计算使用的证书的指纹是否匹配，否则就中断连接。</p>
<p>这种锁定方式需要以下几个前提才能确保流量不被监听：</p>
<ol>
<li>客户端中硬编码的证书指纹不会被篡改。</li>
<li>指纹验证不能被绕过。
<ol>
<li>目前有公开技术（XPosed+JustTrustMe）能破解 Android 上常见的 HTTPS 请求库，直接绕过证书检查。</li>
<li>针对上述问题，可以考虑加大绕过的难度。或者 App 检测自己是否运行在 Xposed 等虚拟环境下。</li>
</ol>
</li>
<li>用于 TLS 协议的证书不会频繁更换。（如果更换了，指纹就对不上了。）</li>
</ol>
<p>而对于第三方的 API，因为我们不知道它们会不会更换 TLS 证书，就不能直接将证书指纹硬编码在客户端中。
这时可以考虑从服务端获取这些 API 的证书指纹（附带私钥签名用于防伪造）。</p>
<p>为了实现证书的轮转(rotation)，可以在新版本的客户端中包含多个证书指纹，这样能保证同时有多个可信证书，达成证书的轮转。（类比 JWT 的公钥轮转机制）</p>
<blockquote>
<p>证书锁定技术几乎等同于 SSH 协议的 <code>StrictHostKeyChecking</code> 选项，客户端会验证服务端的公钥指纹（key fingerprint），验证不通过则断开连接。</p>
</blockquote>
<h4 id=22-公钥锁定public-key-pining>2.2 公钥锁定(Public Key Pining)</h4>
<p>前面提到过，TLS 证书其实就是公钥+申请者(你)和颁发者(CA)的信息+签名(使用 CA 私钥加密)，因此我们也可以考虑只锁定其中的公钥。</p>
<p>「公钥锁定」比「证书锁定」更灵活，这样证书本身其实就可以直接轮转了（证书有过期时间），而不需要一个旧证书和新证书共存的中间时期。</p>
<p><strong>如果不考虑实现难度的话，「公钥锁定」是更推荐的技术。</strong></p>
<h2 id=五tls-双向认证mutual-tls-authentication-mtls>五、TLS 双向认证(Mutual TLS authentication, mTLS)</h2>
<p>TLS 协议（tls1.0+，RFC: <a href=https://tools.ietf.org/html/rfc5246#section-7.4.4 target=_blank rel="noopener noreferrer">TLS1.2 - RFC5246</a>）中，定义了服务端请求验证客户端证书的方法。这
个方法是可选的。如果使用上这个方法，那客户端和服务端就会在 TLS 协议的握手阶段进行互相认证。这种验证方式被称为双向 TLS 认证(mTLS, mutual TLS)。</p>
<p>传统的「TLS 单向认证」技术，只在客户端去验证服务端是否可信。
而「TLS 双向认证（mTLS）」，则添加了服务端验证客户端是否可信的步骤（第三步）：</p>
<ol>
<li>客户端发起请求</li>
<li>「验证服务端是否可信」：服务端将自己的 TLS 证书发送给客户端，客户端通过自己的 CA 证书链验证这个服务端证书。</li>
<li>「验证客户端是否可信」：客户端将自己的 TLS 证书发送给服务端，服务端使用它的 CA 证书链验证该客户端证书。</li>
<li>协商对称加密算法及密钥</li>
<li>使用对称加密进行后续通信。</li>
</ol>
<p>因为相比传统的 TLS，mTLS 只是添加了「验证客户端」这样一个步骤，所以这项技术也被称为「Client Authetication」.</p>
<p>mTLS 需要用到两套 TLS 证书：</p>
<ol>
<li>服务端证书：这个证书签名已经介绍过了。</li>
<li>客户端证书：客户端证书貌似对证书信息（如 CN/SAN 域名）没有任何要求，只要证书能通过 CA 签名验证就行。</li>
</ol>
<p>使用 openssl 生成 TLS 客户端证书（ca 和 csr.conf 可以直接使用前面生成服务端证书用到的，也可以另外生成）：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># 1. 生成 2048 位 的 RSA 密钥</span>
openssl genrsa -out client.key <span class=m>2048</span>
<span class=c1># 2. 通过第一步编写的配置文件，生成证书签名请求</span>
openssl req -new -key client.key -out client.csr -config csr.conf
<span class=c1># 3. 生成最终的证书，这里指定证书有效期 3650 天</span>
<span class=c1>### 使用前面生成的 ca 证书对客户端证书进行签名（客户端和服务端共用 ca 证书）</span>
openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key <span class=se>\
</span><span class=se></span>   -CAcreateserial -out client.crt -days <span class=m>3650</span> <span class=se>\
</span><span class=se></span>   -extensions v3_ext -extfile csr.conf
</code></pre></td></tr></table>
</div>
</div><p>mTLS 的应用场景主要在「零信任网络架构」，或者叫「无边界网络」中。
比如微服务之间的互相访问，就可以使用 mTLS。
这样就能保证每个 RPC 调用的客户端，都是其他微服务（或者别的可信方），防止黑客入侵后为所欲为。</p>
<p>目前查到如下几个Web服务器/代理支持 mTLS:</p>
<ol>
<li>Traefik: <a href=https://docs.traefik.io/v2.0/https/tls/#client-authentication-mtls target=_blank rel="noopener noreferrer">Docs - Client Authentication (mTLS)</a></li>
<li>Nginx: <a href=https://community.openhab.org/t/using-nginx-reverse-proxy-for-client-certificate-authentication-start-discussion/43064 target=_blank rel="noopener noreferrer">Using NGINX Reverse Proxy for client certificate authentication</a>
<ol>
<li>主要参数是两个：<code>ssl_client_certificate /etc/nginx/client-ca.pem</code> 和 <code>ssl_verify_client on</code></li>
</ol>
</li>
</ol>
<h3 id=mtls-的安全性>mTLS 的安全性</h3>
<p>如果将 mTLS 用在 App 安全上，存在的风险是：</p>
<ol>
<li>客户端中隐藏的证书是否可以被提取出来，或者黑客能否 Hook 进 App 中，直接使用证书发送信息。</li>
<li>如果客户端私钥设置了「密码（passphrase）」，那这个密码是否能很容易被逆向出来？</li>
</ol>
<p>mTLS 和「公钥锁定/证书锁定」对比：</p>
<ol>
<li>公钥锁定/证书锁定：只在客户端进行验证。
<ol>
<li>但是在服务端没有进行验证。这样就无法鉴别并拒绝第三方应用（爬虫）的请求。</li>
<li>加强安全的方法，是通过某种算法生成动态的签名。爬虫生成不出来这个签名，请求就被拒绝。</li>
</ol>
</li>
<li>mTLS: 服务端和客户端都要验证对方。
<ol>
<li>保证双边可信，在客户端证书不被破解的情况下，就能 Ban 掉所有的爬虫或代理技术。</li>
</ol>
</li>
</ol>
<h2 id=六-tls-协议的破解手段>六 TLS 协议的破解手段</h2>
<h3 id=1-客户端逆向破解手段总结>1. 客户端逆向/破解手段总结</h3>
<p>要获取一个应用的数据，有两个方向：</p>
<ol>
<li>服务端入侵：现代应用的服务端突破难度通常都比较客户端高，注入等漏洞底层框架就有处理。</li>
<li>客户端逆向+爬虫：客户端是离用户最近的地方，也是最容易被突破的地方。
<ol>
<li>mTLS 常见的破解手段，是找到老版本的安装包，发现很容易就能提取出客户端证书。。</li>
</ol>
</li>
</ol>
<p>待续</p>
<h2 id=七通过-openssl-对-tls-证书进行-curd增删查改>七、通过 OpenSSL 对 TLS 证书进行 CURD（增删查改）</h2>
<h3 id=1-查询与验证>1. 查询与验证</h3>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># 查看证书(crt)信息</span>
openssl x509 -noout -text -in server.crt

<span class=c1># 查看证书请求(csr)信息</span>
openssl req -noout -text -in server.csr

<span class=c1># 查看 RSA 私钥(key)信息</span>
openssl rsa -noout -text -in server.key

<span class=c1># 验证证书是否可信</span>
<span class=c1>## 1. 使用系统的证书链进行验证。因为是自签名证书，会验证失败</span>
openssl verify server.crt
<span class=c1>## 2. 使用 ca.crt 进行验证。验证成功。</span>
openssl verify -CAfile ca.crt server.crt
</code></pre></td></tr></table>
</div>
</div><h3 id=2-证书格式转换>2. 证书格式转换</h3>
<p>openssl 模式使用 PEM 格式的证书，这个证书格式将证书编码为 base64 格式进行保存。
另外一类使用广泛的证书，是 PKCS#12、PKCS#8，以及 Windows 上常用的 DER 格式。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># pem 格式转 pkcs12，公钥和私钥都放里面</span>
openssl pkcs12 -export -in client.crt -inkey client.key -out client.p12
<span class=c1># 按提示输入保护密码</span>
</code></pre></td></tr></table>
</div>
</div><p>或者 p12 转 pem:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell>openssl pkcs12 -in xxx.p12 -out xxx.crt -clcerts -nokeys
openssl pkcs12 -in xxx.p12 -out xxx.key -nocerts -nodes
</code></pre></td></tr></table>
</div>
</div><p>微信/支付宝等支付相关的数字证书，通常就使用 pkcs12 格式，使用商户号做加密密码，然后编码为 base64 再提供给用户。</p>
<h2 id=参考>参考</h2>
<h3 id=tls-协议>TLS 协议</h3>
<ul>
<li><a href=https://halfrost.com/https_tls1-2_handshake/ target=_blank rel="noopener noreferrer">HTTPS 温故知新（三） —— 直观感受 TLS 握手流程(上)</a></li>
<li><a href=https://halfrost.com/https-key-cipher/ target=_blank rel="noopener noreferrer">HTTPS 温故知新（五） —— TLS 中的密钥计算</a></li>
</ul>
<h3 id=tls-证书>TLS 证书</h3>
<ul>
<li>
<p><a href=https://kubernetes.io/docs/concepts/cluster-administration/certificates/ target=_blank rel="noopener noreferrer">Certificates - Kubernetes Docs</a></p>
</li>
<li>
<p><a href=https://www.cnblogs.com/kyrios/p/tls-and-certificates.html target=_blank rel="noopener noreferrer">TLS/HTTPS 证书生成与验证</a></p>
</li>
<li>
<p><a href=https://zhuanlan.zhihu.com/p/57710573 target=_blank rel="noopener noreferrer">ECC作为SSL/TLS证书加密算法的优势</a></p>
</li>
<li>
<p><a href=https://cloud.tencent.com/developer/article/1407305 target=_blank rel="noopener noreferrer">ECC证书的生成和验签</a></p>
</li>
<li>
<p><a href=https://zh.wikipedia.org/wiki/%E5%89%8D%E5%90%91%E4%BF%9D%E5%AF%86 target=_blank rel="noopener noreferrer">前向保密(Forward Secrecy) - WikiPedia</a></p>
</li>
<li>
<p><a href=https://help.aliyun.com/document_detail/28542.html target=_blank rel="noopener noreferrer">证书选型和购买 - 阿里云文档</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4MTQ2MjI5OA==&mid=2664079008&idx=1&sn=dede1114d5705880ea757f8d9ae4c92d" target=_blank rel="noopener noreferrer">云原生安全破局｜如何管理周期越来越短的数字证书？</a></p>
</li>
</ul>
<p>另外两个关于 CN(Common Name) 和 SAN(Subject Altnative Name) 的问答：</p>
<ul>
<li><a href=https://serverfault.com/questions/880804/can-not-get-rid-of-neterr-cert-common-name-invalid-error-in-chrome-with-self target=_blank rel="noopener noreferrer">Can not get rid of <code>net::ERR_CERT_COMMON_NAME_INVALID</code> error in chrome with self-signed certificates</a></li>
<li><a href=https://stackoverflow.com/questions/5935369/ssl-how-do-common-names-cn-and-subject-alternative-names-san-work-together target=_blank rel="noopener noreferrer">SSL - How do Common Names (CN) and Subject Alternative Names (SAN) work together?</a></li>
</ul>
<p>关于证书锁定/公钥锁定技术：</p>
<ul>
<li><a href=https://owasp.org/www-community/controls/Certificate_and_Public_Key_Pinning target=_blank rel="noopener noreferrer">Certificate and Public Key Pinning - OWASP</a></li>
<li><a href=https://security.stackexchange.com/questions/85209/difference-between-certificate-pinning-and-public-key-pinning target=_blank rel="noopener noreferrer">Difference between certificate pinning and public key pinning</a></li>
</ul>
<p>加密/签名算法相关：</p>
<ul>
<li><a href=http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html target=_blank rel="noopener noreferrer">RSA算法原理（二）</a></li>
</ul>
<p>其他：</p>
<ul>
<li><a href=https://www.openssl.org/docs/man1.1.1/ target=_blank rel="noopener noreferrer">OpenSSL ManPage</a></li>
<li><a href=https://www.jianshu.com/p/f5f93c89155e target=_blank rel="noopener noreferrer">openssl 查看证书</a></li>
</ul>
</div><div class=post-footer id=post-footer>
<div class=post-info>
<div class=post-info-line>
<div class=post-info-mod>
<span>更新于 2021-01-17</span>
</div>
<div class=post-info-license></div>
</div>
<div class=post-info-line>
<div class=post-info-md></div>
<div class=post-info-share>
<span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://thiscute.world/posts/about-tls-cert/ data-title="TLS 协议、TLS 证书、TLS 证书的配置方法、TLS 加密的破解手段" data-via=ryan4yin data-hashtags=HTTPS,TLS,OpenSSL,加密,破解><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://thiscute.world/posts/about-tls-cert/ data-hashtag=HTTPS><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="分享到 Reddit" data-sharer=reddit data-url=https://thiscute.world/posts/about-tls-cert/><i class="fab fa-reddit fa-fw"></i></a></span>
</div>
</div>
</div>
<div class=post-info-more>
<section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/https/>HTTPS</a>,&nbsp;<a href=/tags/tls/>TLS</a>,&nbsp;<a href=/tags/openssl/>OpenSSL</a>,&nbsp;<a href=/tags/%E5%8A%A0%E5%AF%86/>加密</a>,&nbsp;<a href=/tags/%E7%A0%B4%E8%A7%A3/>破解</a></section>
<section>
<span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span>
</section>
</div>
<div class=post-nav><a href=/posts/qemu-kvm-usage/ class=prev rel=prev title="QEMU-KVM 虚拟化环境的搭建与使用"><i class="fas fa-angle-left fa-fw"></i>QEMU-KVM 虚拟化环境的搭建与使用</a>
<a href=/posts/expirence-of-vault/ class=next rel=next title="secrets 管理工具 Vault 的介绍、安装及使用">secrets 管理工具 Vault 的介绍、安装及使用<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id=comments><div id=utterances></div><noscript>
Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>Utterances</a>.
</noscript><div id=waline></div><script src=/lib/waline/Waline.min.js></script>
<script>const config={el:'#waline',serverURL:'waline-comment.thiscute.world',visitor:'true',dark:'auto',avatar:'hide',requiredMeta:["nick","mail"],wordLimit:1500};setTimeout(function(){Waline(config)},160)</script>
<noscript>
Please enable JavaScript to view the comments powered by <a href=https://waline.js.org/>Waline</a>.
</noscript></div></article></div>
</main><footer class=footer>
<div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer" title="Hugo 0.92.2">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/sunt-programator/CodeIT target=_blank rel="noopener noreferrer" title="CodeIT 0.2.10"><i class="fas fa-laptop-code fa-fw"></i> CodeIT</a>
</div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021 - 2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://thiscute.world/ target=_blank rel="noopener noreferrer">ryan4yin</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div>
</div>
</footer></div>
<div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部>
<i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论>
<i class="fas fa-comment fa-fw"></i>
</a>
</div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/katex/copy-tex.min.css><script type=text/javascript src=/lib/waline/Waline.min.js></script><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/algoliasearch/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/typeit/typeit.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript src=/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:30},comment:{utterances:{darkTheme:"github-dark",issueTerm:"pathname",label:"",lightTheme:"github-light",repo:"ryan4yin/ryan4yin.space"}},data:{"id-1":"This Cute World","id-2":"This Cute World"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"747LJ10EI7",algoliaIndex:"ryan-space",algoliaSearchKey:"658db5f2bf056f83458cacf5dd58ec80",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},typeit:{cursorChar:null,cursorSpeed:null,data:{"id-1":["id-1"],"id-2":["id-2"]},duration:null,speed:null}}</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-4V93QVSNFW',{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-4V93QVSNFW" async></script></body>
</html>