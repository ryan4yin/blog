<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>数学 - 分类 - Ryan4Yin's Space</title><link>https://ryan4yin.space/categories/%E6%95%B0%E5%AD%A6/</link><description>数学 - 分类 - Ryan4Yin's Space</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaoyin_c@qq.com (ryan4yin)</managingEditor><webMaster>xiaoyin_c@qq.com (ryan4yin)</webMaster><lastBuildDate>Fri, 26 May 2017 23:58:53 +0800</lastBuildDate><atom:link href="https://ryan4yin.space/categories/%E6%95%B0%E5%AD%A6/" rel="self" type="application/rss+xml"/><item><title>欧几里得算法求最大公约数(GCD)的数学原理</title><link>https://ryan4yin.space/posts/mathematics-in-euclidean-gcd/</link><pubDate>Fri, 26 May 2017 23:58:53 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://ryan4yin.space/posts/mathematics-in-euclidean-gcd/</guid><description><![CDATA[<p>很早就学过欧几里得算法，但是一直不知道它的原理。几乎每本算法书都会提到它，但是貌似只有数学书上才会见到它的原理。。。</p>
<p>前段时间粗粗看了点数论（《什么是数学》），惊讶于这个原理的奇妙。现在把它通俗地写下来，以免自己忘记。</p>
<p>欧几里得算法是求两个数的最大公约数(Greatest Common Divisor (GCD))的算法，我们首先假设<strong>有两个数 $a$ 和 $b$，其中 $a$ 是不小于 $b$ 的数</strong>，</p>
<p>记 $a$ 被 $b$ 除的余数为 $r$，那么 $a$ 可以写成这样的形式：</p>
<p>$$a = bq + r$$</p>
<p>其中 $q$ 是整数（我们不需要去管 $q$ 到底是多少，这和我们的目标无关）。</p>
<p>现在假设 $a$ 和 $b$ 的一个约数为 $u$，那么 $a$ 和 $b$ 都能被 $u$ 整除，即</p>
<p>$$a = su$$
$$b = tu$$</p>
<p>$s$ 和 $t$ 都是整数（同样的，我们只需要知道存在这样的整数 $s$ 和 $t$ 就行）。</p>
<p>这样可以得出</p>
<p>$$r = a - bq = su - (tu)q = (s - tq)u$$</p>
<p>所以 $r$ 也能被 $u$ 整除，一般规律如下</p>
<blockquote>
<p>$a$ 和 $b$ 的约数也整除它们的余数 $r$，所以 $a$ 和 $b$ 的任一约数同时也是 $b$ 和 $r$ 的约数。  —— 条件一</p>
</blockquote>
<p>反过来可以得出</p>
<blockquote>
<p>$b$ 和 $r$ 的任一约数同时也是 $a$ 和 $b$ 的约数。  ——条件二</p>
</blockquote>
<p>这是因为对 $b$ 和 $r$ 每一个约数 $v$，有</p>
<p>$$b = kv$$</p>
<p>$$r = cv$$</p>
<p>于是有</p>
<p>$$a = bq + r = (kv)q + cv = (kq + c)v$$</p>
<p>由条件一和条件二可知</p>
<blockquote>
<p>$a$ 和 $b$ 的约数的集合，全等于 $b$ 和 $r$ 的约数的集合。</p>
</blockquote>
<p>于是</p>
<blockquote>
<p>$a$ 和 $b$ 的最大公约数，就是 $b$ 和 $r$ 的最大公约数。</p>
</blockquote>
<p>接下来用递推法，</p>
<p>$a \div b$ 余 $r$，现在设</p>
<p>$b \div r$ 余 $r_1$</p>
<p>$r \div r_1$ 余 $r_2$</p>
<p>……</p>
<p>$r_{n-3} \div r_{n-2}$ 余 $r_{n-1}$</p>
<p>$r_{n-2} \div r_{n-1}$ 余 $r_n=0$</p>
</br>
<p>因为 $a \ge b$，可以看出余数 $r_n$ 会越来越小，最终变成 $0$.</p>
<p>当 $r_{n-1} \neq 0$ 且 $r_n = 0$ 时，可知 $r_{n-2}$ 可被 $r_{n-1}$ 整除（余数为 $0$ 嘛）</p>
<p>此时 $r_{n-2}$ 和 $r_{n-1}$ 的约数就只有：$r_{n-1}$ 和 $r_{n-1}$ 的因数，所以他们的最大公约数就是 $r_{n-1}$！</p>
<p>所以 $r_{n-1}$ 就是 $a$ 和 $b$ 的最大公约数。（若 $r = 0$，则 $b$ 为最大公约数）</p>
<p>这个递推法写成c语言函数是这样的（比推导更简洁&hellip;）:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">Gcd</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">M</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">N</span><span class="p">){</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Rem</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">N</span><span class="p">){</span>
        <span class="n">Rem</span> <span class="o">=</span> <span class="n">M</span> <span class="o">%</span> <span class="n">N</span><span class="p">;</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">Rem</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Rem</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以发现这里没有要求 <code>M&gt;=N</code>，这是因为如果那样，循环会自动交换它们的值。</p>
<blockquote>
<p>P.S. 此外，还有最小公倍数(Least Common Multiple (LCM))算法，详见 <a href="https://www.mathportal.org/calculators/numbers-calculators/gcd-lcm-calculator.php" target="_blank" rel="noopener noreferrer">GCD and LCM calculator</a></p>
</blockquote>
]]></description></item></channel></rss>