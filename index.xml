<feed xmlns="http://www.w3.org/2005/Atom"><title>This Cute World</title><link href="https://thiscute.world/index.xml" rel="self"/><link href="https://thiscute.world/"/><updated>2023-01-31T22:33:51+08:00</updated><id>https://thiscute.world/</id><author><name>ryan4yin</name></author><generator>Hugo -- gohugo.io</generator><entry><title type="html">EE 入门 - 电子电路基础知识</title><link href="https://thiscute.world/posts/electrical-engineering-circuits-basics-1/"/><id>https://thiscute.world/posts/electrical-engineering-circuits-basics-1/</id><author><name>ryan4yin</name></author><published>2023-01-31T22:33:51+08:00</published><updated>2023-01-31T22:33:51+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/electrical-engineering-circuits-basics-1/8051-display-2023.webp" height="2108" width="1044"><figcaption></figcaption>
        </figure><h2 id="前言" class="headerLink">
    <a href="#%e5%89%8d%e8%a8%80" class="header-mark"></a>前言</h2><p>我是从去年 12 月开始玩电子的，起因是 11 月搞了个 Homelab，然后就一路玩到 ESPHome，买了一堆传感器。
玩了一阵后 ESPHome 这种小白式玩法就满足不了我了，于是开始学习电路知识，用树莓派跟其他单片机开始折腾遥控小车、简易机械臂、跑马灯等等，可以说是玩得很尽兴。</p>
<p>今年我也打算继续玩一玩这一块，尤其想玩一玩用 ESP32/STM32 自制无人机，如果能搞搞无人机编队飞行就更好了~</p>
<p>言归正传，这篇文章是我入门电子电路的第一篇笔记，涵盖最基础的电路理论与一些焊接知识，末尾还包含了后续的学习规划。</p>
<p>笔记内容参考了许多网上的资料，主要有如下几个：</p>
<ul>
<li><a href="https://rmxd.gitee.io/guide/elec_start/" target="_blank" rel="noopener noreferrer">纵横向导 - 电路入门</a>
<ul>
<li>采用类比的方法来讲解电路基础，很适合业余玩家零基础快速入门。</li>
</ul>
</li>
<li><a href="https://www.sparkfun.com/engineering_essentials" target="_blank" rel="noopener noreferrer">Electrical Engineering Essentails - sparkfun</a>
<ul>
<li>同样是零基础入门，尤其是还介绍了电烙铁等玩电路板的实用知识。</li>
</ul>
</li>
<li><a href="https://elamazing.com/" target="_blank" rel="noopener noreferrer">The Amazing World of Electronics - Only the Cool Stuff :-)</a>
<ul>
<li>这个是一篇篇零散的文章，每篇文章一个知识点，但是讲得比较深入透彻。</li>
</ul>
</li>
</ul>
<p>我看完上面的文章后，随着玩得越来越深入，又陆续了解了这些内容：</p>
<ul>
<li>电路基础
<ul>
<li>什么是面包板、面包线、杜邦线</li>
<li>如何使用万用表测电压、电流、电阻、电容，判断二极管、三极管引脚。
<ul>
<li>（N 年前学这玩意儿时用的是最简单易懂的物理指针表，但是实际显然是电子的用着更方便）</li>
<li>回忆下用法：首先调到合适档位，然后测电流要串联到电路中、测电压要与被测器件并联、测电阻直接接在被测器件两端即可。</li>
<li>对于手动量程万用表（如 DT-9205A），它的显示单位为量程名字末尾非数字部分。
<ul>
<li>比如电阻 200 量程的显示单位就为 Ω；2K/20K/200K 这三个量程的显示单位都为 KΩ；2M/20M/200M 的显示单位都为 MΩ</li>
<li>对于电流/电压/电容也是一样。</li>
</ul>
</li>
</ul>
</li>
<li>什么元件需要防静电，以及有线防静电手环/台垫</li>
<li>如何读色环电阻的阻值？（不会读不如直接万用表走起&hellip;）</li>
<li>如何选购、使用电烙铁/吸锡器等焊接工具</li>
<li>&hellip;</li>
</ul>
</li>
<li>单片机（MCU）与单板计算机（SBC）
<ul>
<li>什么是开发版</li>
<li>什么是 TTL 串口、串口驱动、波特率</li>
<li>什么是 SPI/UART/I$^{2}$C 数据传输协议</li>
<li>什么是 GPIO 引脚，以及开发版的引脚各有什么功能</li>
<li>如何使用 USB 转 TTL 串口板给 ESP32/ESP8266/51/STM32 等单片机刷固件</li>
<li>ST-Link 调试编程器（仿真器）与 TTL 串口有何区别，JTAG 和 SWD 模式分别有啥用</li>
<li>&hellip;</li>
</ul>
</li>
</ul>
<p>总之兴趣驱动，不会的东西就 Google 一下或者问问 ChatGPT，玩起来~</p>
<h2 id="一常见基础公式" class="headerLink">
    <a href="#%e4%b8%80%e5%b8%b8%e8%a7%81%e5%9f%ba%e7%a1%80%e5%85%ac%e5%bc%8f" class="header-mark"></a>一、常见基础公式</h2><ol>
<li>欧姆定律： $U = IR$
<ol>
<li>电压 U 单位伏特 Volt，符号 $V$</li>
<li>电流 I 单位安培 Ampere，符号 $A$</li>
<li>电阻 R 单位欧姆 Ohm，符号 $\Omega$</li>
</ol>
</li>
<li>电功率公式： $p= UI$
<ol>
<li>功率 p 单位瓦特 Watt，符号 $W$，等同于 $V \cdot A$ 的缩写</li>
</ol>
</li>
<li>电能公式： $w = pT$
<ol>
<li>其中 p 为电功率，单位前面说了就是 Watt</li>
<li>T 为时间，单位秒 Second</li>
<li>$w$ 电能的单位为焦耳 joule，等同于 $V \cdot A \cdot s$</li>
<li>常见的电池通常会使用 $mA \cdot h$ 或者 $w \cdot h$ 来标记其电能容量。
<ol>
<li>$mA \cdot h$ 乘上电压再转换下电流跟时间的单位为 A 跟 s，就得到焦耳数</li>
<li>$w \cdot h$ 直接乘 3600（1 小时的秒数）就得到焦耳数</li>
</ol>
</li>
</ol>
</li>
<li>电容量公式： $C = Q/U$
<ol>
<li>电容量 C 单位为法拉 Farad，符号为 $F$</li>
<li>带电量 Q 的单位为库仑 Coulomb，符号为 $C$</li>
</ol>
</li>
<li>库仑的定义： $1C = 1A \cdot s$
<ol>
<li>1 库仑即 $6.24146 \times 10^{18}$ 个电子所带的电荷量</li>
</ol>
</li>
<li>电感 TODO（貌似用得比较少&hellip;待补充）</li>
</ol>
<h2 id="二常用电子元件介绍" class="headerLink">
    <a href="#%e4%ba%8c%e5%b8%b8%e7%94%a8%e7%94%b5%e5%ad%90%e5%85%83%e4%bb%b6%e4%bb%8b%e7%bb%8d" class="header-mark"></a>二、常用电子元件介绍</h2><p>常见电子元器件：</p>
<ul>
<li>电阻</li>
<li>二极管 Diode
<ul>
<li>发光二极管</li>
<li>整流二极管</li>
<li>稳压二极管</li>
</ul>
</li>
<li>三极管</li>
<li>MOSFET 场效应管
<ul>
<li>电压转换器（power converter）：整流器（rectifier）、逆变器（inverter）、斩波器（chopper）及变频驱动器（VFD）</li>
</ul>
</li>
<li>电容
<ul>
<li>电解电容</li>
<li>瓷片电容</li>
<li>独石电容</li>
</ul>
</li>
<li>晶振</li>
</ul>
<h3 id="1-二极管-diode" class="headerLink">
    <a href="#1-%e4%ba%8c%e6%9e%81%e7%ae%a1-diode" class="header-mark"></a>1. 二极管 Diode</h3><blockquote>
<p><a href="https://learn.sparkfun.com/tutorials/diodes" target="_blank" rel="noopener noreferrer">https://learn.sparkfun.com/tutorials/diodes</a></p>
</blockquote>
<p>二极管是一种<strong>只允许电流由单一方向流过</strong>，具有两个电极的元件，是现代电子产业的基石。
可类比水流中的单向阀门，水只能从一端流向另一端，而不能逆流。</p>
<p>最初的二极管是真空电子二极管，很大、需要预热、功耗大，易破碎。
后来美国人使用半导体材料发明了晶体二极管（或者叫半导体二极管）。
目前常用的二极管都是晶体二极管，主要使用硅或者锗这类半导体材料。</p>
<p>晶体二极管的核心是 PN 结（p–n junction），要了解  PN 结，需要先介绍半导体的几个概念：</p>
<ul>
<li>空穴：又称 Electron hole，物理学中指原子的共价键上流失一个电子，最后在共价键上留下的空位。</li>
<li>载流子：半导体中有两种载流子，即价带中带正电的空穴，和导带中带负电的电子。</li>
<li>P 型半导体：P 表示 Positive，指以带正电的空穴导电为主的半导体，也叫空穴半导体。
<ul>
<li>在纯净的硅晶体中掺入三价元素（如硼），使之取代晶格中硅原子的位置，就形成P型半导体。</li>
</ul>
</li>
<li>N 型半导体：N 表示 Negative，指自由电子浓度远大于空穴浓度的杂质半导体。
<ul>
<li>例如，含有适量五价元素砷、磷、锑等的锗或硅等半导体。</li>
</ul>
</li>
</ul>
<p>懂了上面这些后，让我们考虑在一个 N 型半导体跟 P 型半导体形成的 PN 结中，电子显然只能从 N 极流向 P 极，因为只有 N 极才有足够的电子。相反电流只能从 P 级流向 N 极，因为只有 P 极才有足够的空穴。</p>
<p>如果电流要反向流动，那 PN 结的 P 极的电子会更多，而 N 级的空穴也会更多，电势差会更大，显然就会非常费劲。</p>
<p>二极管在导通状态下二示意图如下，其中也展示了二极管对应的符号与真实二极管的结构（带环的一侧为其 N 极）：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/diode-1.webp" width="50%"/>
</figure>

<p>电阻拥有线性的伏安特性曲线，遵从欧姆定律。而二极管则完全不同，它伏安特性曲线（Current-Voltage Graph）如下：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/diode-current-voltage-graph.png" width="50%"/>
</figure>

<p>几个主要特征与相关名词介绍：</p>
<blockquote>
<p>更详细的文章：<a href="https://elamazing.com/2021/04/13/pn-junction-diode/" target="_blank" rel="noopener noreferrer">PN Junction Diode</a></p>
</blockquote>
<ul>
<li>正向压降 Forward Voltage: 指使电流能够导通的最小电压 $V_F$
<ul>
<li>「正向压降」被用于克服二极管的内部电场了，所以在电流通过二极管后，电压需要减去这个电压，这也是中文名「正向压降」的由来。
<ul>
<li>硅二极管的正向压降通常为 0.6v - 1v，锗二极管的正向压降通常为 0.3v</li>
</ul>
</li>
<li>根据伏安特性曲线，实际上随着电流的变化，「正向压降」也是有小幅波动的，不过计算时一般都认为它是固定值。</li>
</ul>
</li>
<li>击穿电压 Breakdown Voltage: 指使电流能否反向导通的最小电压，从图中标识看 $V_{BR}$ 为 -50v，显然它远大于不到 1v 的「正向压降」。
<ul>
<li>当电流能经过二极管反向导通时，我们称二极管被击穿（Breakdown）</li>
</ul>
</li>
</ul>
<p>二极管依据其设计目标，分类了许多不同类别：</p>
<ul>
<li>普通二极管</li>
<li>整流器(rectifier) / 功率二极管（power diode）
<ul>
<li>依靠二极管只能单向导通的原理，可以使用它将交流电变成直流电。</li>
<li>能承受较大的正向电流和较高的反向电压</li>
</ul>
</li>
<li>发光二极管（Light-Emitting Diodes, LEDs）
<ul>
<li>LED 的正向压降取决于它的颜色，而且比较固定，通常红色约为 1.6v，绿色有 2v 和 3v 两种，黄色和橙色约为 2.2v，蓝色约为 3.2v</li>
</ul>
</li>
<li>稳压二极管
<ul>
<li>利用二极管在反向击穿状态，其电流可在很大范围内变化而电压基本不变的现象，制成的起稳压作用的二极管。</li>
</ul>
</li>
<li>开关二极管
<ul>
<li>能够快速由导通变为截止或由截止变为导通的一种二极管。</li>
</ul>
</li>
<li>检波二极管
<ul>
<li>TODO</li>
</ul>
</li>
<li>阻尼二极管
<ul>
<li>具有较低有电压降和较高的工作频率，且能承受较高的反向击穿电压和较大的峰值电流。</li>
</ul>
</li>
</ul>
<p>还有二极管堆组：</p>
<ul>
<li>整流桥堆(半桥、全桥)
<ul>
<li>菱形联接</li>
</ul>
</li>
</ul>
<p>等等</p>
<h3 id="2-三极管-triode--bipolar-transistor" class="headerLink">
    <a href="#2-%e4%b8%89%e6%9e%81%e7%ae%a1-triode--bipolar-transistor" class="header-mark"></a>2. 三极管 triode / bipolar transistor</h3><p>三极管即双极型晶体管，缩写 BJT，前面介绍了二极管结构为单个 PN 结，而三极管的结构则为 PNP 或者 NPN 结构，<strong>具有电流放大作用</strong>，是电子电路的核心元件之一。</p>
<p>它的工作方式就像是一个一个液压阀门，通过小电流来顶开中间的通路，使大电流得以通过，一个 NPN 型放大器电路的示意图如下：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/bipolar-transistor-1.jpg" width="70%"/>
</figure>

<p>b 与 e 之间的电压形成一个小电流，这个小电流越大，c 与 e 之间的电阻就越小。</p>
<p>就像是如下液压阀门，b 处的水压越大，液压阀门被推得越开，c 与 e 之间的水流就越大：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/bipolar-transistor-vs-hydraulic-valve.png" width="40%"/>
</figure>

<p>三极管不是凭空把电放大了，而是说： 小的电信号（小水流）把另一个通路的大电流的阀门打开了，后面的器件能够感受到这个大电流， 所以是放大了。对电来说 实际有两个电源供电的 一个是小电源（小信号、信号源） 一个是大电源。</p>
<p>咱们的收音机，实际就是天线，接收到空气中的小电流，你可以理解为毛毛雨。</p>
<p>这个毛毛雨到了三极管的一个脚上打开阀门， 电池供电通过另外两个脚流动，再打开一个后面的三极管， 一级级的这样不断打开，一般收音机最早的时候是三管收音机、六管收音机，就是这么个意思一直到这个水流大到能够推动喇叭就发声了。</p>
<p>一个极简三级放大收音机电路：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/minimalist-triode-radio.png" width="60%"/>
</figure>

<p>两种三极管的符号与识别：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/pnp-npn-transistor.png" width="60%"/>
</figure>

<p>三个电极介绍：</p>
<ul>
<li>C: 即 Collector 集电极</li>
<li>B: 即 Base 基极</li>
<li>E: 即 Emitter 发射极</li>
</ul>
<p>可以看到 NPN 跟 PNP 三极管最大的区别，是在于电流流向：</p>
<ul>
<li>NPN 的 Base 基极是 P 对应正极，电流从 B 与 C 极 流向 E 极</li>
<li>PNP 的 Base 基极是 N 对应负极，电流从 E 极流向 B 与 C 两个电极</li>
</ul>
<p>根据 B 极电流 $I_B$ 的变化，$V_{CE}$ 的变化曲线如图：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/output-characteristics-curves-of-bipolar-transistor.webp" width="60%"/>
</figure>

<p>可以看到<strong>在 $I_{B}$ 一定的情况下，不论 $V_{CE}$ 在 2v 以上如何变化，$I_{C}$ 的电流都几乎是恒定的</strong>。换个角度看电压在 2v - 12v 之间时，$I_{B}$ 与 $I_{C}$ 几乎是完全的线性关系，不受电压波动的影响。</p>
<blockquote>
<p>注意 12v 以上只是没有画出来，假使这个三极管最多只能承受 12v 电压，那更高的电压会击穿它，你就能看到三极管冒火花了&hellip;</p>
</blockquote>
<p>$\frac{I_{C}}{I_{B}}$ 之间的比率（常数）被称做三极管的电流增益（Current Gain），一般使用 $\beta$ 表示。</p>
<p>因为实际场景中 $I_{B}$ 不太好判断，通常都是直接调整 $V_{BE}$，因此我们再换个角度，对比下 $I_{C}$ 与 $V_{BE}$：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/npn-transistor-Ic-vs-Vbe.png" width="40%"/>
</figure>

<p>通过上图可以发现三极管的另外两个特征：</p>
<ol>
<li><strong>$V_{BE}$ 需要一个启动电压，大约在 0.7v 左右，低于 0.7v 时$I_C$ 的电流一直非常小</strong>。</li>
<li><strong>在 $V_{BE}$ 超过 0.7v 后，任何此电压的小变化，都会导致 $I_{C}$ 的剧烈变化</strong>。</li>
</ol>
<p>一个常见的单状态 NPN 放大器电路如下：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/npn-transistor-aimplifier-circuit.webp" width="60%"/>
</figure>

<p>可以注意到，输入 $V_{in}$是一个很小的交流信号，过来之前加了一个电容隔绝掉其中参杂的直流信号。</p>
<p>其次因为 $V_{BE}$ 需要一个启动电压才能进入电流放大的工作区间，这里通过 $R1$ 与 $R2$ 为 $V_{BE}$ 提供了一个启动电压 DC Biasing Point.</p>
<h3 id="3-mosfet-金属氧化物场效应晶体管" class="headerLink">
    <a href="#3-mosfet-%e9%87%91%e5%b1%9e%e6%b0%a7%e5%8c%96%e7%89%a9%e5%9c%ba%e6%95%88%e5%ba%94%e6%99%b6%e4%bd%93%e7%ae%a1" class="header-mark"></a>3. MOSFET 金属氧化物场效应晶体管</h3><blockquote>
<p><a href="https://elamazing.com/2021/03/31/mosfet/" target="_blank" rel="noopener noreferrer">https://elamazing.com/2021/03/31/mosfet/</a></p>
</blockquote>
<blockquote>
<p>MOSFET 与三极管的区别与选用：https://www.eet-china.com/mp/a17394.html</p>
</blockquote>
<blockquote>
<p>CMOS 集成电路工艺 - 百科: <a href="https://www.zgbk.com/ecph/words?SiteID=1&amp;ID=124559&amp;Type=bkzyb" target="_blank" rel="noopener noreferrer">https://www.zgbk.com/ecph/words?SiteID=1&ID=124559&Type=bkzyb</a></p>
</blockquote>
<p><strong>MOSFET 晶体管是电压控制元件（通过栅极电压控制源漏间导通电阻），而双极型晶体管（三极管）是电流控制元件（通过基极较小的电流控制较大的集电极电流）</strong>。</p>
<p>MOS管在导通压降下，导通电阻小，栅极驱动不需要电流，损耗小，驱动电路简单，自带保护二极管，热阻特性好，适合大功率并联，缺点开关速度不高，比较昂贵。</p>
<p>三极管开关速度高，大型三极管的 IC 可以做的很大，缺点损耗大，基极驱动电流大，驱动复杂。</p>
<p>一般来说低成本场合，普通应用的先考虑用三极管，不行的话考虑MOS管。</p>
<p>场效应管能在很小电流和很低电压的条件下工作，功耗低，而且可以很方便地把很多场效应管集成在一块硅片上，因此场效应管在大规模集成电路中得到了广泛的应用。</p>
<p>目前主流的数字集成电路，包括 CPU/GPU/RAM，基本都是通过光刻制造的 CMOS 集成电路（Complementary Metal-Oxide-Semiconductor Integrated Circuit），CMOS 就是基于 MOSFET 技术实现的。</p>
<p>MOSFET 管的结构、极性，用法等内容，待补充&hellip; TODO</p>
<h3 id="4-电容-capacitor" class="headerLink">
    <a href="#4-%e7%94%b5%e5%ae%b9-capacitor" class="header-mark"></a>4. 电容 Capacitor</h3><p>电容是电能的容器，里面存储的是电荷，电容在电路中是储能、缓冲、减压、过滤器件。。</p>
<p>水要通过池塘、湖泊，首先需要灌满它才能过得去。所以这部分水（电能）可以被这些容器保存下来，这是<strong>电容的储能作用</strong>，另外很明显，无论前面的水流多么湍急，到了湖泊就要先灌满它，湖泊开口再向下游流水，自然流水就缓慢一些，所以它<strong>也有缓冲的作用</strong>。大波浪到了湖泊变平稳，实际变成了小波浪，波的形状都变了，这就是<strong>过滤的作用，只允许特定的波通过</strong>。</p>
<p>再回顾下电容相关的公式：</p>
<ol>
<li>电容量公式： $C = Q/U$
<ol>
<li>电容量 C 单位为法拉 Farad，符号为 $F$</li>
<li>带电量 Q 的单位为库仑 Coulomb，符号为 $C$</li>
</ol>
</li>
<li>库仑的定义： $1C = 1A \cdot s$
<ol>
<li>1 库仑即 $6.24146 \times 10^{18}$ 个电子所带的电荷量</li>
</ol>
</li>
</ol>
<p>电容的类型：</p>
<ul>
<li>瓷片电容
<ul>
<li>用陶瓷材料作介质，在陶瓷表面涂覆一层金属（银）薄膜，再经高温烧结后作为电极而成。</li>
<li>用途：通常用于高稳定振荡回路中，作为回路、旁路电容器及垫整电容器。但仅限于在工作频率较低的回路中作旁路或隔直流用，或对稳定性和损耗要求不高的场合〈包括高频在内〉。瓷片电容不宜使用在脉冲电路中，因为它们易于被脉冲电压击穿。</li>
</ul>
</li>
<li>铝电解电容（有极性）
<ul>
<li>有极性铝电解电容器是将附有氧化膜的铝箔（正极）和浸有电解液的衬垫纸，与阴极（负极）箔叠片一起卷绕而成。</li>
<li><strong>优点</strong>: 容量范围大，一般为1~10 000 μF，额定工作电压范围为6.3 V~450 V。</li>
<li><strong>缺点</strong>: 介质损耗、容量误差大（最大允许偏差+100%、–20%）耐高温性较差，存放时间长容易失效。</li>
<li><strong>用途</strong>: 通常在直流电源电路或中、低频电路中起滤波、退耦、信号耦合及时间常数设定、隔直流等作用。</li>
<li>注意：因其具有极性，不能用于交流电路。</li>
</ul>
</li>
<li>独石电容
<ul>
<li>独石电容是用钛酸钡为主的陶瓷材料烧结制成的多层叠片状超小型电容器。</li>
<li><strong>优点</strong>: 性能可靠、耐高温、耐潮湿、容量大（容量范围1 pF ~ 1 μF）、漏电流小等</li>
<li><strong>缺点</strong>: 工作电压低（耐压低于100 V）</li>
<li><strong>用途</strong>: 广泛应用于谐振、旁路、耦合、滤波等。 常用的有CT4 （低频） 、CT42（低频）；CC4（高频）、CC42（高频）等系列。</li>
</ul>
</li>
<li>钽电解电容
<ul>
<li>有两种制作工艺：
<ul>
<li>箔式钽电解电容器：内部采用卷绕芯子,负极为液体电解质，介质为氧化钽</li>
<li>粉烧结式： 阳极（正极）用颗粒很细的钽粉压块后烧结而成</li>
</ul>
</li>
<li><strong>优点</strong>: 介质损耗小、频率特性好、耐高温、漏电流小。</li>
<li><strong>缺点</strong>: 生产成本高、耐压低</li>
<li><strong>用途</strong>: 广泛应用于通信、航天、军工及家用电器上各种中 、低频电路和时间常数设置电路中。</li>
</ul>
</li>
<li>等等</li>
</ul>
<h3 id="5-电感-inductance" class="headerLink">
    <a href="#5-%e7%94%b5%e6%84%9f-inductance" class="header-mark"></a>5. 电感 Inductance</h3><p>「电磁感应（Electromagnetic induction）」我们都学过，它是指放在变化磁通量中的导体，会产生电动势。 此电动势称为感应电动势或感生电动势，若将此导体闭合成一回路，则该电动势会驱使电子流动，形成感应电流（感生电流）。
<strong>简单的说就是磁场变化能产生电能，电流变化也会形成磁场</strong>。</p>
<p>电磁感应最为人所知的应用应该就是「发电机」、「电动马达」跟「变压器」了。「发电机」通过电磁感应将机械能转换为电能，而「电动马达」刚好相反，它通过电磁感应将电能转换为机械能。
这个转换实际上都是依靠磁场与「电磁感应」实现的。</p>
<p>而我们这里提的电感这种元器件，其核心原理是楞次定律（Lenz&rsquo;s law）：</p>
<blockquote>
<p>由于磁通量的改变而产生的感应电流，此电流的流向为抗拒磁通量改变的方向。</p>
</blockquote>
<p>将楞次定律应用在闭合回路的自感效应中，得到的结论是：</p>
<blockquote>
<p>电路上所诱导出的电动势的方向，总是使得它所驱动的电流，会阻碍原先产生它（即电动势）的磁通量之变化。</p>
</blockquote>
<p>具体而言，<strong>对于「电感」，当电流增加时它会将能量以磁场的形式暂时存储起来，等到电流减小时它又会将磁场的能量释放出来，这会产生抵抗电流变化的效果</strong>。</p>
<p>电感并不损耗能量，它只是临时将电流存储起来，待会儿再释放出来而已（这叫什么？削峰填谷，平滑算法）。</p>
<p>电感的结构通常是漆包铜线缠绕在一个永磁体上，因为需要有电流的变化才能工作，通常仅应用在交流电领域。</p>
<h3 id="6-电阻" class="headerLink">
    <a href="#6-%e7%94%b5%e9%98%bb" class="header-mark"></a>6. 电阻</h3><blockquote>
<p>足够深入的分析：<a href="https://www.zhihu.com/question/68567332" target="_blank" rel="noopener noreferrer">电阻的定义到底是什么？</a></p>
</blockquote>
<p>我们对电阻最直观的理解，是中学时学过的：</p>
<p>$$R =  \frac{V}{I}$$</p>
<p>但是在简单的含有电阻 R + 一个电感或电容的直流电路中，电流是随时间变化的，并在最终达到一个稳态。</p>
<p>这时根据上面的公式计算，因为电压是固定的，我们发现电路中电阻 R 的阻值实际是随时间变化的。</p>
<p>这个问题在直流电路中并不明显，因为电路最终仍然会达到稳态，这时电阻就跟它的标称电阻差距不大了。</p>
<p>但是在交流电路中，因为电流始终是在震荡的，这个问题就会变得相当明显，以至于无法简单地使用「电阻」来表达一个电阻器的特性，为此引入了一个新概念叫「阻抗」。</p>
<blockquote>
<p>在具有电阻、电感和电容的电路里，对电路中的电流所起的阻碍作用叫做阻抗。阻抗常用Z表示，是一个复数，实部称为电阻，虚部称为电抗，其中电容在电路中对交流电所起的阻碍作用称为容抗 ,电感在电路中对交流电所起的阻碍作用称为感抗，电容和电感在电路中对交流电引起的阻碍作用总称为阻抗。 阻抗的单位是欧姆。阻抗的概念不仅存在于电路中，在力学的振动系统中也有涉及。</p>
</blockquote>
<p>如果仔细看看你买过的耳机的相关参数，会发现它就包含一个「阻抗」参数，知乎上就有相关讨论 <a href="https://www.zhihu.com/question/22519059" target="_blank" rel="noopener noreferrer">耳机是不是阻抗越高越好？</a>.</p>
<p>对电阻更精确的理解是：电阻是电压对电流的变化率，它不一定是一个静态值（也就是说可能是非线性的，比如二极管的伏安特性曲线就不是直线）。</p>
<h4 id="单片机的下拉电阻与上拉电阻" class="headerLink">
    <a href="#%e5%8d%95%e7%89%87%e6%9c%ba%e7%9a%84%e4%b8%8b%e6%8b%89%e7%94%b5%e9%98%bb%e4%b8%8e%e4%b8%8a%e6%8b%89%e7%94%b5%e9%98%bb" class="header-mark"></a>单片机的下拉电阻与上拉电阻</h4><p>用单片机设计电路时，一个重要的点就是下拉电阻与上拉电阻。</p>
<p>不太好直接解释，直接看视频吧，下面这两个视频解释得很清晰：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1W34y1579U/" target="_blank" rel="noopener noreferrer">上拉电阻的通俗解释</a></li>
<li><a href="https://www.bilibili.com/video/BV1ZU4y1Q7eo/" target="_blank" rel="noopener noreferrer">下拉电阻的通俗解释</a></li>
</ul>
<h3 id="7-晶振-xtal-与振荡电路" class="headerLink">
    <a href="#7-%e6%99%b6%e6%8c%af-xtal-%e4%b8%8e%e6%8c%af%e8%8d%a1%e7%94%b5%e8%b7%af" class="header-mark"></a>7. 晶振 (Xtal) 与振荡电路</h3><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/72583737" target="_blank" rel="noopener noreferrer">秒懂单片机晶振电路原理</a></p>
</blockquote>
<p>石英晶体或晶振，是利用石英晶体（又称水晶）的压电效应，用来产生高精度振荡频率的一种电子器件，属于被动器件（无源源件）。</p>
<p>晶体是指其中的原子、分子、或离子以规则、重复的模式朝各方向延伸的一种固体。
晶体与几乎所有的弹性物质都具有自然共振频率，透过适当的传感器可加以利用。</p>
<p>石英晶体的优点是在温度变化时，影响震荡频率的弹性系数与尺寸变化轻微，因而在频率特性上表现稳定。</p>
<p>石英晶体谐振器的原理：</p>
<ul>
<li>石英晶体上的电极对一颗被适当切割并安置的石英晶体施以电场时，晶体会产生形变。这与晶体受压力产生电势的现象刚好相反，因此被称做<strong>逆压电效应</strong>。</li>
<li>当外加电场移除时，石英晶体又会恢复原状并发出电场，因而在电极上产生电压，这是我们熟知的<strong>压电效应</strong>。</li>
<li><strong>逆压电效应</strong> + <strong>压电效应</strong> 这两个特性造成石英晶体在电路中的行为，类似于某种电感器、电容器、与电阻器所组合成的 RLC 电路。组合中的电感电容谐振频率则反映了石英晶体的实体共振频率。</li>
<li>当外加交变电压的频率与晶片的固有频率（决定于晶片的尺寸与切割方法）相等时，机械振动的幅度将急剧增加，这种现象称为<strong>压电谐振</strong>。</li>
</ul>
<p>可能有些初学者会对晶振的频率感到奇怪，12M、24M 之类的晶振较好理解，选用如 11.0592MHZ 的晶振给人一种奇怪的感觉，这个问题解释起来比较麻烦，如果初学者在练习串口编程的时候就会对此有所理解，这种晶振主要是可以方便和精确的设计串口或其它异步通讯时的波特率。</p>
<h3 id="8-地" class="headerLink">
    <a href="#8-%e5%9c%b0" class="header-mark"></a>8. 地</h3><p>电路中每个器件上有电能量集聚，形成电势差，就相当于物体的高度差。
假设没有一个参考基准点，就没法测量这个电势差了，因此规定电路的某个点就是作为基准面，也就是地（GND/Ground）了。</p>
<p>地/GND 并不需要是真正的地面，对于我主要关注的弱电电路板而言，电路的负极就是地。</p>
<p>同理可推出，如果需要将同一个电路板同时接入多个源电路，则必须将这多个电路板的负极连接在一起，这样它们的「GND」参考基准点才是一致的！</p>
<h4 id="静电破坏与防静电" class="headerLink">
    <a href="#%e9%9d%99%e7%94%b5%e7%a0%b4%e5%9d%8f%e4%b8%8e%e9%98%b2%e9%9d%99%e7%94%b5" class="header-mark"></a>静电破坏与防静电</h4><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/570713171" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/570713171</a></p>
</blockquote>
<p>弱电领域另外一个常见的接地应该就是静电接地了，这是为了确保人体/工作台与地面的电势差为零，避免工作时静电放电导致元器件损坏。</p>
<p>人体感应的静电电压一般在 2KV-4KV 左右，通常是人体轻微运动或与绝缘摩擦引起的。
这么高的电压，足够击穿很多电子元件了，所以电子厂都会强制员工穿戴防静电装置（有线防静电手环）。</p>
<p>静电接地通常要求接真正的地面，比如与建筑物接触紧密的金属门窗、水龙头等都算是「地」。
个人用的话，据朋友介绍效果最好的方法是：穿拖鞋，并且一只脚踩地上哈哈~</p>
<h2 id="三常见电路计算方式" class="headerLink">
    <a href="#%e4%b8%89%e5%b8%b8%e8%a7%81%e7%94%b5%e8%b7%af%e8%ae%a1%e7%ae%97%e6%96%b9%e5%bc%8f" class="header-mark"></a>三、常见电路计算方式</h2><h3 id="1-如何选用正确的电阻" class="headerLink">
    <a href="#1-%e5%a6%82%e4%bd%95%e9%80%89%e7%94%a8%e6%ad%a3%e7%a1%ae%e7%9a%84%e7%94%b5%e9%98%bb" class="header-mark"></a>1. 如何选用正确的电阻？</h3><p>这需要使用到我们中学学过的物理学欧姆定律公式：</p>
<p>$$V =  I \cdot R$$</p>
<p>首先针对电子电路领域的 hello world，即发光二极管 + 电阻：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/helloworld-led%2Bresistor.png" width="40%"/>
</figure>

<p>我们可以根据 LED 灯的最大电流来估算电阻值，根据欧姆定律有</p>
<p>$$R = \frac{V}{I}$$</p>
<p>普通发光二极管的正常工作电流通常为 $2 \text{mA}$ ~ $20 \text{mA}$，电流越大它就越亮，正向压降有好几种，假设我们的为 $3.3v$。</p>
<p>因此电路允许的最大电流为 $0.02 \text{A}$，如果电源电压为 3.7v，那电阻得到的电压大概为 $0.4 \text{V}$，这样可计算得到 $R$ 为 $20 \Omega$.</p>
<p>发光二极管在正常工作状态几乎没有电阻，因此可以直接将上面计算出的结果当作串联电阻的阻值。</p>
<p>因此为了使发光二极管正常工作，串联电阻应该略大于 $25 \Omega$.</p>
<h3 id="2-电路分析中的两个重要定律" class="headerLink">
    <a href="#2-%e7%94%b5%e8%b7%af%e5%88%86%e6%9e%90%e4%b8%ad%e7%9a%84%e4%b8%a4%e4%b8%aa%e9%87%8d%e8%a6%81%e5%ae%9a%e5%be%8b" class="header-mark"></a>2. 电路分析中的两个重要定律</h3><ul>
<li>KAL 基尔霍夫电流定律：所有进入某节点的电流的总和等于所有离开这节点的电流的总和</li>
<li>KVL 基尔霍夫电压定律：沿着闭合回路所有元件两端的电势差（电压）的代数和等于零</li>
</ul>
<p>这两个定律感觉通过「能量守恒」去理解，会显得很直观，不论是电流还是电压，都不会无中生有，在整个电路上它始终是守恒的。</p>
<p>KVL + 节点电压法是分析电路的一种有效手段。</p>
<h3 id="3-隔直通交与隔交通直" class="headerLink">
    <a href="#3-%e9%9a%94%e7%9b%b4%e9%80%9a%e4%ba%a4%e4%b8%8e%e9%9a%94%e4%ba%a4%e9%80%9a%e7%9b%b4" class="header-mark"></a>3. 隔直通交与隔交通直</h3><p>上面这个是常见的简单特性描述，但是不够准确，准确的说：</p>
<ul>
<li>电容是隔断不变的电信号，通过变化的电信号。</li>
<li>电感是阻碍变化的电信号，通过不变的电信号。</li>
</ul>
<p>显然直流电的电流也是可以变化的，比如刚过了整流桥的直流电就是一个脉动信号。</p>
<h3 id="4-交直流叠加信号" class="headerLink">
    <a href="#4-%e4%ba%a4%e7%9b%b4%e6%b5%81%e5%8f%a0%e5%8a%a0%e4%bf%a1%e5%8f%b7" class="header-mark"></a>4. 交直流叠加信号</h3><p>交流信号就很好，很真实，为什么还要有交流直流叠加信号，到最后还要把直流信号去掉，只保留交流信号，多麻烦。这是因为，任何器件如果想打开或者处于一定状态，多少都需要一定的能量驱动的，如果这个能量不足，让器件处于不稳定的状态，我们还原不了真实的信号，所以三极管放大加上静态偏置，实际上就是为了让他先工作在临近放大区，再来交流信号才能正确还原。</p>
<p>所谓的静态偏置，实际上就是挂上个电阻先给这个三极管的某个引脚加上直流电。再来的交流信号与直流叠加变成交直流混叠信号，来驱动三极管的b极。</p>
<p>犹如大坝的开口在5米处，但是交流信号（变化的信号）只有1米的波动，所以先把水位抬高到5米，这个波动才能送过去。</p>
<p>现在信号放大电路大部分被运算放大器替代，两个运放之间有一个隔直电容，这是因为运放不需要这种类似三极管的偏置，它不需要抬高水位，本身它建立的条件就是你来波动我就能正常反馈到后级，你这个时候如果叠加了直流信号，反而出问题了，因为你把水位抬高了，比较低的信号不能正常反馈到后级被这个直流信号掩盖了。</p>
<h2 id="四电子电路工具套装介绍" class="headerLink">
    <a href="#%e5%9b%9b%e7%94%b5%e5%ad%90%e7%94%b5%e8%b7%af%e5%b7%a5%e5%85%b7%e5%a5%97%e8%a3%85%e4%bb%8b%e7%bb%8d" class="header-mark"></a>四、电子电路工具套装介绍</h2><p>玩硬件的话，工具套装是必不可少的，最先遇到的场景就是——很多的传感器都需要自己焊接排针。</p>
<p>常用工具的主要有这些：</p>
<ul>
<li>万用电表（Multimeter）</li>
<li>面包板（Breadboard）</li>
<li>电烙铁（Soldering Iron）</li>
<li>玻纤洞洞板（Stripboard / Perfboard）</li>
</ul>
<p>其他进阶玩耍时可能会用到的工具：</p>
<ul>
<li>示波器（Oscilloscope）</li>
<li>可调直流稳压电源（Adjustable DC Power Supply）</li>
<li>频谱分析仪</li>
</ul>
<p>电子元器件又主要分类两类：</p>
<ul>
<li>插式元器件
<ul>
<li>传统电子元器件，都带有较长引脚，PCB 版需要为引脚预留通孔。</li>
<li>相关技术：through-hole technology</li>
</ul>
</li>
<li>片式元器件 SMD (surface-mount device)
<ul>
<li>一种新型元器件，比插式元器件要小很多，而且 PCB 板不需要预留插孔，更节省材料跟空间，广泛应用在各种小型化电子设备中。</li>
<li>相关技术：(SMT) Surface-mount technology</li>
<li>相关设备：激光打印钢网、贴片机（巨贵）</li>
</ul>
</li>
</ul>
<h3 id="1-电烙铁篇" class="headerLink">
    <a href="#1-%e7%94%b5%e7%83%99%e9%93%81%e7%af%87" class="header-mark"></a>1. 电烙铁篇</h3><p>电烙铁主要考虑的是升温速度跟温度保持能力，便宜的电烙铁基本都有升温慢、焊接中途易失温等毛病。
目前总结的电烙铁信息如下：</p>
<ul>
<li>便携电烙铁：入门级别推荐
<ul>
<li><strong>优缺点</strong>: 便携、价格低。但是升温相对焊台要慢一些，温控相对不够精确，而且无自动休眠，空烧烙铁头容易氧化，再有就是它没有接地不防经典，焊接精密元件比较危险。</li>
<li>貌似主要推荐广东黄花 907 电烙铁，淘宝官方店买个刀头的 54 大洋</li>
</ul>
</li>
<li>热风枪：主要用来拆焊，以及焊接贴片元件 + 芯片。
<ul>
<li>我买了一把德力西 2000W 的数显热风枪，不过貌似更多人推荐那种二合一焊台，直接控制热风枪跟电烙铁两个玩意儿。</li>
</ul>
</li>
<li>焊台：进阶推荐，也可考虑一步到位&hellip;
<ul>
<li><strong>优缺点</strong>: 发热很快、热容相对较大，自动休眠不会空烧、还有过流保护、单片机稳定温控。缺点是要贵一些，另外相对没那么便携。</li>
<li>相关流行产品
<ul>
<li><a href="https://hackmd.io/@openlabtaipei/SyfdnAPtU" target="_blank" rel="noopener noreferrer">白菜白光 T12 恒温焊台</a>，最早是网友基于日本白光公司 T12 烙铁头（日本工厂到期强制报废的洋垃圾）配上自制恒温控制电路完成的 DIY 焊台，因为相对高端焊台相当便宜所以冠以「白菜」之名。
<ul>
<li>淘宝上有一些卖这个的，质量见仁见智吧，我没买过。</li>
</ul>
</li>
<li>日本白光 HAKKO 焊台：这个很多人推荐，说是质量好。不过贵，新手用可能有点奢侈了。</li>
</ul>
</li>
</ul>
</li>
<li>二合一焊台：焊台自带热风枪 + 高频电烙铁两件套，高手必备（一般拆机才会用到热风枪）
<ul>
<li>高频电烙铁使用的是跟电磁炉一样的高频涡流发热原理，电烙铁头自身发热，不需要任何发热芯，发热很快、热容大、烙铁头更换便宜。高端烙铁头都是高频的。</li>
<li>反正就很高级也很贵啦。我现阶段买了它也是浪费钱，所以没了解具体型号啥的了</li>
</ul>
</li>
<li>恒温加热台：功能跟热风枪差不多，但是体积大很多，而且更贵，新手不推荐买。</li>
</ul>
<p>关于电烙铁头，貌似刀头是最推荐的，因为它用途最广泛，热容大，基本适用所有场景。</p>
<p>电烙铁，我最后买的第一把电烙铁是网友 DIY 的「<strong>L245 焊笔 玫瑰金</strong>」，铝合金 CNC 切割工艺，Type-C 供电，最高支持到 PD 120W，颜值很高，口碑也很好，价格是 148 大洋。
使用起来还是比较 OK 的，热得很快，热容也 OK。不过毕竟是 DIY 的便宜焊笔，质量不稳，我有遇到过多次误休眠、未识别到焊芯、芯片系统崩溃等问题，都是靠断电重启解决的。</p>
<h4 id="电烙铁的使用与保养" class="headerLink">
    <a href="#%e7%94%b5%e7%83%99%e9%93%81%e7%9a%84%e4%bd%bf%e7%94%a8%e4%b8%8e%e4%bf%9d%e5%85%bb" class="header-mark"></a>电烙铁的使用与保养</h4><blockquote>
<p>参考：http://www.cxg.cn/newshow1346.html</p>
</blockquote>
<p>前面讲了，我毕竟买的是 150 一把的焊笔，C245 这个烙铁头也不便宜，直接当耗材随便折腾就太浪费了。有必要搞清楚怎么使用与保养电烙铁：</p>
<ul>
<li>焊接作业前，先为高温海绵加水湿润，再挤掉部分水分。
<ul>
<li>如果使用非湿润的清洁海绵，会使烙铁头受损氧化，导致不沾锡。</li>
</ul>
</li>
<li>焊接作业中，每次都先在高温海绵上擦干净焊咀上的旧锡，再进行焊接。
<ul>
<li>中途不使用时，如果无自动休眠功能，可以手动将温度调低至 200 度以下，避免空烧。空烧会降低焊咀寿命。</li>
</ul>
</li>
<li>焊接完毕后，将温度调至约 250 摄氏度，使用湿润的高温海绵清洁烙铁头，最后将烙铁头加上一层新锡作保护，这样可以保护焊咀和空气隔离，焊咀不会氧化变黑。</li>
<li>焊咀已经氧化、不沾锡时应如何处理
<ul>
<li>先把温度调到 300 摄氏度，用清洁海绵清理焊咀，并检查焊咀状况。</li>
<li>如果焊咀的镀锡层部分含有黑色氧化物时，可镀上新锡层，再用清洁海绵抹净焊咀。如此重复清理，直到彻底去除氧化物，然后在镀上新锡层。
<ul>
<li>将温度调至 200 摄氏度左右貌似比较容易上锡，不易聚成球。</li>
<li>实测上锡再用海绵抹除，每次都能摸走一些黑色氧化物，非常有效。不过要清理干净还是需要一些耐心。</li>
</ul>
</li>
<li>如果焊咀变形或穿孔，必须替换新咀。</li>
</ul>
</li>
<li>其他注意事项
<ul>
<li>勿大力焊接：只要让烙铁头充分接触焊点，热量就可传递，无需大力焊接。</li>
<li>尽量低温焊接：高温焊接会加速烙铁头氧化，降低烙铁头使用寿命。如烙铁头温度超过470℃，它的氧化速度是380℃的两倍。</li>
<li>经常保持烙铁头上锡：这可以减低烙铁头的氧化机会，使烙铁头更耐用。</li>
<li>保持烙铁头清洁与及时清理氧化物</li>
<li>小心放入烙铁架：如果焊咀接触到烙铁架无法自动休眠，长时间空烧将会毁掉焊咀。</li>
<li>选用活性低的助焊剂：最便宜的就是松香，更好一点的是无铅无酸无卤素助焊剂。</li>
</ul>
</li>
</ul>
<p>另外我发现「<strong>镀铜钢丝球</strong>」确实比高温海绵好用多了，墙裂推荐！笔不干净了往钢丝球里查一查，立即光亮如新。</p>
<h4 id="焊锡丝在焊接过程中为什么会爆锡" class="headerLink">
    <a href="#%e7%84%8a%e9%94%a1%e4%b8%9d%e5%9c%a8%e7%84%8a%e6%8e%a5%e8%bf%87%e7%a8%8b%e4%b8%ad%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e7%88%86%e9%94%a1" class="header-mark"></a>焊锡丝在焊接过程中为什么会爆锡？</h4><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/584316437" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/584316437</a></p>
</blockquote>
<p>建议直接看上面的文章，可能的原因大概是：</p>
<ol>
<li>受潮</li>
<li>焊锡丝混有杂质，或者助焊剂含量过高</li>
<li>焊接操作时手上有汗或是洗过手后手没有完全干就开始焊接</li>
<li>烙铁温度过高</li>
</ol>
<p><del>我最近买的两卷焊锡丝就有爆锡的问题，烙铁温度是设的很常规的 320 度甚至更低的 290 度，现在怀疑是不是这个无铅焊锡丝有问题</del>。
罪魁祸首找到了，是因为我的锡线架，它下方就是湿润的高温海绵&hellip;这显然很容易受潮&hellip;</p>
<h4 id="如何使用电烙铁进行拆焊" class="headerLink">
    <a href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8%e7%94%b5%e7%83%99%e9%93%81%e8%bf%9b%e8%a1%8c%e6%8b%86%e7%84%8a" class="header-mark"></a>如何使用电烙铁进行拆焊</h4><p>当你焊错焊反了元件，或者你需要修修改改电路板时，就需要先进行拆焊。</p>
<p>用电烙铁进行拆焊需要注意这些事项：</p>
<ul>
<li>温度必须要高，起码 350 以上</li>
<li>烙铁尖必须留点锡在上面。如果烙铁尖不挂锡，焊接的时候会发现即使温度高，电路板的焊锡也很难融化</li>
<li>另一个方式是先加点有铅锡丝降低焊锡熔点，然后再用吸锡器或吸锡带来吸</li>
<li>如果用吸锡器，发现不撤烙铁头直接把吸锡器怼上去，效果是最好的</li>
<li>如果使用的是吸锡带，温度就必须更高，估计至少得 380 甚至更高
<ul>
<li>因为吸锡带一般是纯铜，导热性能很好。一般 320 度就很容易熔的锡，上了吸锡带后热量全被吸锡带传导走了，温度不高根本融化不了</li>
</ul>
</li>
</ul>
<p>或者直接上热风枪+镊子也行（我还没试过&hellip;）。</p>
<h3 id="2-其他工具与材料" class="headerLink">
    <a href="#2-%e5%85%b6%e4%bb%96%e5%b7%a5%e5%85%b7%e4%b8%8e%e6%9d%90%e6%96%99" class="header-mark"></a>2. 其他工具与材料</h3><p>焊材（建议日常用贵一点的无铅锡丝，虽然熔点高些，但对身体好）：</p>
<ul>
<li><strong>焊锡丝</strong>：最常见的焊材，不过稍微要求一点焊接技术，可能需要大约半个小时熟悉下
<ul>
<li>常用 0.8mm 跟 1.0mm 的锡丝</li>
<li>个人玩建议买无铅的，虽然贵点熔点高一点，但更环保，对身体也好。</li>
</ul>
</li>
<li><strong>锡膏</strong>：新型焊接材料，由焊锡粉、助焊剂以及其它的表面活性剂等混合成的膏状物。
<ul>
<li>对于常用焊接场景，可以直接抹上锡膏，然后用热风枪一吹，或者用烙铁刀头拖焊，或者直接上发热板 / 恒温加热台，据说非常简单好用。</li>
<li>最常用的场景是复杂 PCB 板子，直接用定制的钢丝网覆盖 PCB 板子刷上锡膏、直接就把触点都刷上了，然后再用镊子手工贴上贴片元器件。不过这个有难度&hellip;已经是高手玩法了。最省心是花钱直接找 PCB 厂子给打印 + 焊接（钞能力）。</li>
<li>对于焊点不多的贴片，可以直接使用针筒式的锡膏挤上去，然后再用牙签或镊子去掉多余的锡膏，用镊子把贴片元件放上去（有点歪没事，加热时焊锡的张力会使它自动回正），最后直接上热风枪或加热台就能焊接 ok 了。</li>
<li>同样建议买无铅的，虽然贵点熔点高一点，但更环保，对身体也好。</li>
</ul>
</li>
<li><strong>高温海绵</strong>：可以说是焊接必备了，一定要加水湿润后再使用。可以多备几片，脏了洗洗，洗不干净就换。</li>
<li><strong>镀铜钢丝球</strong>：同样是用于清洁烙铁头的，前面讲焊接技术时已经说过了，这个确实比高温海绵好用很多。</li>
<li><strong>助焊剂 Flux</strong>：
<ul>
<li>在焊接工艺中能帮助和促进焊接过程，同时具有保护作用、阻止氧化反应的化学物质。</li>
<li>高纯度松香：便宜常用，一般焊个传感器跟普通 PCB 板子完全够用。
<ul>
<li>如果板子要长期使用，那焊完需要用酒精浸泡清洗，避免助焊剂碳化导致绝缘性能下降。（如果只是练手的板子，那就无所谓了）</li>
</ul>
</li>
<li>无铅无卤无酸助焊剂：高端助焊剂，免洗
<ul>
<li>无铅主要是为了环保，对身体好。</li>
<li>因为卤素离子很难清洗干净，助焊剂残留将导致绝缘性能下降，因此免洗助焊剂必须得无卤素。</li>
<li>无酸是为了避免助焊剂腐蚀电路板跟、引脚、烙铁头。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以及其他焊接相关工具：</p>
<ul>
<li>吸锡器：主要用于电器拆焊
<ul>
<li>场景：一是焊错了或者锡多了，拆焊后重新焊接。二是拆焊其他电路</li>
<li>这玩意儿一个便宜的才十多块，入门阶段买一个也行。不过也有说拿电烙铁热一下然后一磕，焊锡就自己掉下去了，自己玩不一定需要这玩意儿。</li>
</ul>
</li>
<li>吸锡带：拿来清理表贴焊盘上的残锡。就是一卷细铜丝编制的带子，融化的锡容易被它吸走
<ul>
<li>比吸锡器更便宜万用，缺点是需要更高的温度，可以考虑买一卷。</li>
</ul>
</li>
<li>热风枪：貌似主要是拆焊用的，当然用来吹热缩管也很好用。</li>
<li>焊台夹具：焊线焊板子都挺实用，相当于长出来四只手。而且相比放桌面，它的散热速度低很多，更难失温。</li>
<li>尖嘴钳：焊接完一些非贴片元件，必须要把多余的引脚剪掉，尖嘴钳感觉挺需要的。</li>
<li>维修工作台（耐高温硅胶垫）：淘宝上一二十块钱一块，可以保护桌子、方便放一些小元器件。</li>
</ul>
<p>还有就是跟焊接没啥关系，但是 DIY 常用的工具：</p>
<ul>
<li>切割垫：如果需要做一些切割，这个应该也很有用，看许多网友都有，不过我暂时没搞清楚自己是否需要。</li>
<li>螺丝磁性收纳垫：其实跟焊接关系不大了，不过也列一下</li>
<li>螺丝刀 + 万能扳手 + 水口钳：这个好像跟焊接没啥关系，不过也可以列一下
<ul>
<li>尤其是电动螺丝刀，刀头一定要买好一点的，并且最好是标准有替代品的。我以前用电动螺丝刀就遇到过刀头硬度不行被十字螺丝刀头磨平了的情况&hellip;</li>
<li>水口钳推荐德力西</li>
</ul>
</li>
<li>螺丝 + 螺母：螺丝刀跟扳手都有了，螺丝螺母不得买几套？
<ul>
<li>其中有些特别的是自锁螺母，这种螺母自带尼龙自锁圈，即使没拧到位也能自锁。不过需要用比较大的力气才能拧进去，这是正常现象。</li>
<li><a href="https://zhuanlan.zhihu.com/p/107820259" target="_blank" rel="noopener noreferrer">螺母防松的六种基本方法，你知道几个？（动图）</a></li>
<li>螺丝的型号，DIY 中常用的，M3即螺絲外徑為 3mm, M4 即螺絲外徑為 4mm，同理 M5 即 5mm
<ul>
<li>有時會註明螺絲牙距，如 M3x0.5，M4x0.70，M5x0.8，M6x1，但因為这是標準規範，通常不提</li>
</ul>
</li>
<li>对结构强度要求不高的场景，也可以自己用 3D 打印机打印螺丝螺母。</li>
<li>螺丝更详细的中英术语对照：<a href="https://www.weicheng-screw.com.tw/news-detail-1432955.html" target="_blank" rel="noopener noreferrer">螺絲規格與定義 - 緯丞螺絲</a></li>
</ul>
</li>
<li>游标卡尺 + 卷尺：最简单的是买数字的，不需要费心思读数&hellip;也推荐德力西的</li>
<li>3D 打印机、激光切割机等等其他 DIY 工具</li>
</ul>
<h2 id="五后续学习路线" class="headerLink">
    <a href="#%e4%ba%94%e5%90%8e%e7%bb%ad%e5%ad%a6%e4%b9%a0%e8%b7%af%e7%ba%bf" class="header-mark"></a>五、后续学习路线</h2><p>有了电路基础后，首先可以买一些入门的焊接套件练练焊接技术，并搞明白它的原理。
我在淘宝「电子爱好者之家」上买了几个焊接套件，如指尖陀螺、5v 升 12v 升压板、LED 摇摇棒、十二个实验洞洞板套件、高压发生器等。</p>
<p>边玩边学习相关知识是最有意思的，玩到一定阶段后，可以再考虑补一补基础知识。
基础理论方面我查到《<strong><a href="https://book.douban.com/subject/3171563/" target="_blank" rel="noopener noreferrer">模拟和数字电子电路基础</a></strong>》这本书比较受推荐，豆瓣评分也很高。</p>
<p>学习基础的电路理论时可以仿真软件同步学习，如：</p>
<ul>
<li>Multisim（元器件仿真）、Proteus（单片机仿真）
<ul>
<li>这两个软件都非常流行，不过基本都仅支持 Windows 系统</li>
</ul>
</li>
<li>EDA（Electronic Design Automation） 电路板原理图、PCB（Printed Circuit Board） 设计工具
<ul>
<li><a href="https://lceda.cn/" target="_blank" rel="noopener noreferrer">立创 EDA</a>: 国产 EDA，全平台支持，也提供 Web 版</li>
<li><a href="https://github.com/KiCad" target="_blank" rel="noopener noreferrer">KiCAD</a>: 开源电路板设计工具，功能强大，支持插件，社区资源多。</li>
</ul>
</li>
</ul>
<h3 id="1-单片机" class="headerLink">
    <a href="#1-%e5%8d%95%e7%89%87%e6%9c%ba" class="header-mark"></a>1. 单片机</h3><p>有一定电路基础后，就可以开始玩单片机了。</p>
<ul>
<li>介绍：单片机的英文名叫 Microcontroller Unit，缩写为 <strong>MCU</strong>. 它是把 CPU、RAM、定时/计数器（timer/counter）、I/O 接口等都集成在一块集成电路芯片上的微型计算机。</li>
<li>应用：主要用于前端的无操作系统、以实时控制为主的环境，如电子钟表、电机控制等。在硬件爱好者手中可用于机器人前端控制，四轴飞行器前端控制，3D打印机前端控制等。</li>
<li>典型产品：
<ul>
<li>Arduino: AVR 单片机为核心控制器的单片机应用开发板，是开源硬件，新手友好</li>
<li>STM32: 貌似是单片机从业人员的入行首选，使用 ARM Cortex-M 系列核心。</li>
</ul>
</li>
<li>补充说明：
<ul>
<li>单片机非常简单，因为很接近底层，而且硬件配置极差，干不了太多的事。主要的优势就是稳定、开发也简单。</li>
<li>单片机跟硬件的绑定很严重，经常出现一套代码换一个单片机平台，就得完全重写。</li>
</ul>
</li>
</ul>
<p>单片机学习顺序大概是：</p>
<ul>
<li>8051: 最简单最经典的单片机
<ul>
<li>我的学习笔记与代码：<a href="https://github.com/ryan4yin/learn-8051-asm" target="_blank" rel="noopener noreferrer">ryan4yin/learn-8051-asm</a></li>
</ul>
</li>
<li>STM32: 工业届应用最广泛的单片机，网上资料众多
<ul>
<li>我的学习笔记与代码（未完待续）：<a href="https://github.com/ryan4yin/learn-stm32f103c8t6" target="_blank" rel="noopener noreferrer">ryan4yin/learn-stm32f103c8t6</a></li>
</ul>
</li>
<li>ESP32/ESP8266: 包含 wifi 蓝牙功能的单片机，在物联网领域应用非常广泛，硬件发烧友的最爱。</li>
</ul>
<h3 id="2-嵌入式-linuxlinux-on-embedded-system" class="headerLink">
    <a href="#2-%e5%b5%8c%e5%85%a5%e5%bc%8f-linuxlinux-on-embedded-system" class="header-mark"></a>2. 嵌入式 Linux（Linux on Embedded System）</h3><blockquote>
<p>嵌入式系统（Embedded System），是指嵌入机械或电气系统内部、具有专一功能和实时计算性能的计算机系统。</p>
</blockquote>
<p>单片机玩够了后，就可以开始玩嵌入式 Linux了。</p>
<ul>
<li>介绍：嵌入式 Linux，即运行 Linux 操作系统的、性能比 MCU 更高的微型计算机，行业上最常用 ARM Cortex-A53 系列芯片与 Linux 开发一些嵌入式设备。</li>
<li>应用：路由器、电视盒子、智能家居等。在硬件爱好者手里可以用来做计算机视觉控制小车、WiFi、蓝牙控制中枢等等。</li>
<li>典型产品
<ul>
<li>Raspberry Pi: 使用 ARM Cortex-A 系列 CPU 的微型计算机，社区庞大，生态丰富。</li>
<li>其他各种派，如国产 Orange Pi、Rock Pi，比树莓派便宜一点，性能也更高，不过生态会差一些。</li>
<li>STM32/IMX6ULL 也有相关产品</li>
</ul>
</li>
<li>补充说明
<ul>
<li>嵌入式 Linux 代码的可移植性相对要好很多，因为硬件相关的逻辑都封装在驱动层了。</li>
</ul>
</li>
</ul>
<p>相关资料（大致按学习顺序排序）：</p>
<ul>
<li><a href="https://nju-projectn.github.io/ics-pa-gitbook/" target="_blank" rel="noopener noreferrer">南京大学 计算机科学与技术系 计算机系统基础 课程实验 (PA)</a></li>
<li><a href="https://github.com/isometimes/rpi4-osdev" target="_blank" rel="noopener noreferrer">从零开始为树莓派 4B 开发一个操作系统 - rpi4-osdev</a></li>
<li>《Linux/Unix 系统编程手册》</li>
<li><a href="https://github.com/d0u9/Linux-Device-Driver" target="_blank" rel="noopener noreferrer">Linux Device Drivers (LDD3) </a>: Linux 驱动开发经典书籍</li>
<li>《深入理解 Linux 内核》</li>
<li>《Linux 内核设计与实现》</li>
</ul>
<p>上面这些都学了一遍的话，业余玩玩硬件应该就很够用了，期待我完成这个学习路线的那一天&hellip;</p>
]]></content></entry><entry><title type="html">2022 年年终总结</title><link href="https://thiscute.world/posts/2022-summary/"/><id>https://thiscute.world/posts/2022-summary/</id><author><name>ryan4yin</name></author><published>2023-01-02T18:00:45+08:00</published><updated>2023-01-02T18:00:45+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/2022-summary/github-profile-2022-ryan4yin.webp" height="1772" width="882"><figcaption></figcaption>
        </figure><h2 id="闲言碎语" class="headerLink">
    <a href="#%e9%97%b2%e8%a8%80%e7%a2%8e%e8%af%ad" class="header-mark"></a>闲言碎语</h2><p>是的又过去一年，又到了一年一度的传统节目——年终总结时间。</p>
<h2 id="2022-年流水账" class="headerLink">
    <a href="#2022-%e5%b9%b4%e6%b5%81%e6%b0%b4%e8%b4%a6" class="header-mark"></a>2022 年流水账</h2><p>先简单过一下我 2022 年的流水账（有记录一个 <code>/history</code>，回顾起来就是方便）：</p>
<ul>
<li>1 月
<ul>
<li>购入 Synthesizer V + 青溯 AI 声库，简单调了几首歌试试，效果非常棒。然后就一直放了一年没碰它&hellip;还试用了免费的 ACE 虚拟歌姬，合成效果确实很强，跟收费的 Synthesizer V 有的一拼。</li>
<li>在家过春节，给家里二楼装了空调、加湿器跟地垫。但是没买地暖垫，导致开了空调后地上的垫子冰凉。后面补买了地暖垫但是已经要上班了没体验上。</li>
</ul>
</li>
<li>2 月跟 3 月
<ul>
<li>想学下区块链技术，结果发现课程一开始就讲加密哈希函数的基本性质，就决定先搞一波密码学，结果就是输出了一个<a href="https://thiscute.world/posts/practical-cryptography-basics-1/" target="_blank" rel="noopener noreferrer">《写给开发人员的实用密码学》系列文章</a>，内容大部分是翻译的，少部分是我自己补充。</li>
<li>主要工作：跟推荐系统大佬一起将服务从 HTTP 切换到 gRPC，效果立竿见影，服务流量下降 50% ~ 60%，延迟下降 30% ~ 50%。</li>
</ul>
</li>
<li>4 月份
<ul>
<li>读完了 <a href="https://github.com/ethereumbook/ethereumbook" target="_blank" rel="noopener noreferrer">Mastering Ethereum</a>，对以太坊有了基本的了解。</li>
<li>读了《Go 程序设计语言（英文版）》
<ul>
<li><figure><a class="lightgallery" href="/images/now/the-go-programming-language.webp" title="/images/now/the-go-programming-language.webp" data-thumbnail="/images/now/the-go-programming-language.webp" data-sub-html="<h2>Go 程序设计语言（英文版） 2022-08-19 补图</h2>">
        <img
            class="lazyload"
            data-src="/images/now/the-go-programming-language.webp"
            data-srcset="/images/now/the-go-programming-language.webp, /images/now/the-go-programming-language.webp 1.5x, /images/now/the-go-programming-language.webp 2x"
            data-sizes="auto"
            alt="/images/now/the-go-programming-language.webp">
    </a><figcaption class="image-caption">Go 程序设计语言（英文版） 2022-08-19 补图</figcaption>
    </figure></li>
</ul>
</li>
<li>很高兴通过了职级晋升，不再是 SRE 萌新了。</li>
<li>主要工作：使用 <a href="https://github.com/aws/karpenter" target="_blank" rel="noopener noreferrer">aws/karpenter</a> 实现离线计算集群的弹性扩缩容，省了一波成本。</li>
</ul>
</li>
<li>5 月份
<ul>
<li>主要是学完了《深入浅出 Kubernetes》这个极客时间专栏</li>
<li>通过《分布式协议与算法实战》等相关资料简单了解了下分布式共识算法的原理，记录了些笔记，8 月份的时候把笔记整理输出为了一篇博客 <a href="https://thiscute.world/posts/consistency-and-consensus-algorithm/" target="_blank" rel="noopener noreferrer">分布式系统的一致性问题与共识算法</a></li>
<li>还读了许多社区的区块链相关资料，包括但不限于 <a href="https://www.zhihu.com/special/1452635344142909440" target="_blank" rel="noopener noreferrer">Web 3.0：穿越十年的讨论 - 知乎</a>、<a href="https://guoyu.mirror.xyz/RD-xkpoxasAU7x5MIJmiCX4gll3Cs0pAd5iM258S1Ek" target="_blank" rel="noopener noreferrer">《Web3 DApp 最佳编程实践指南》</a>、<a href="https://github.com/dcbuild3r/blockchain-development-guide" target="_blank" rel="noopener noreferrer">dcbuild3r/blockchain-development-guide</a></li>
<li>因为 AI 发展迅猛，来了三分钟兴趣学了一点 <a href="https://github.com/d2l-ai/d2l-zh" target="_blank" rel="noopener noreferrer">动手学深度学习 - Pytorch 版</a>，但是进度条走了不到 15% 就不了了之了。</li>
<li>主要工作：研究跨云应用部署方案与跨云 kubernetes 网络方案，如 karmada/kubevela/istio，以及 L4/L7 层的开源/商业网关方案</li>
</ul>
</li>
<li>6 月份
<ul>
<li>读完了《在生命的尽头拥抱你-临终关怀医生手记》</li>
<li>读了一点买的新书：《语言学的邀请》跟《Intimate Relationship》</li>
</ul>
</li>
<li>7 月份
<ul>
<li>主要工作：确定并实施网关架构优化的初步方案，使用 Go 语言写了一个 Nginx Gateway 控制器，迁移流量到新容器化网关省了一波成本。</li>
</ul>
</li>
<li>8 月
<ul>
<li>读完了《在峡江的转弯处 - 陈行甲人生笔记》
<ul>
<li><figure><a class="lightgallery" href="/images/now/life-notes-of-chenxingjia.webp" title="/images/now/life-notes-of-chenxingjia.webp" data-thumbnail="/images/now/life-notes-of-chenxingjia.webp" data-sub-html="<h2>陈行甲人生笔记</h2>">
        <img
            class="lazyload"
            data-src="/images/now/life-notes-of-chenxingjia.webp"
            data-srcset="/images/now/life-notes-of-chenxingjia.webp, /images/now/life-notes-of-chenxingjia.webp 1.5x, /images/now/life-notes-of-chenxingjia.webp 2x"
            data-sizes="auto"
            alt="/images/now/life-notes-of-chenxingjia.webp">
    </a><figcaption class="image-caption">陈行甲人生笔记</figcaption>
    </figure></li>
</ul>
</li>
<li>延续上个月对 Linux 系统的兴趣，快速过了一遍 The ANSI C Programming Language 以熟悉 C 的语法，之后开始阅读 <a href="https://man7.org/tlpi/" target="_blank" rel="noopener noreferrer">Linux/Unix 系统编程手册（上册）</a>
<ul>
<li>写了一个小项目 <a href="https://github.com/ryan4yin/video2ascii-c" target="_blank" rel="noopener noreferrer">video2ascii-c</a> 练手 C 语言。</li>
<li><figure><a class="lightgallery" href="/images/now/the-asni-c-programming-language.webp" title="/images/now/the-asni-c-programming-language.webp" data-thumbnail="/images/now/the-asni-c-programming-language.webp" data-sub-html="<h2>The ANSI C Programming Language</h2>">
        <img
            class="lazyload"
            data-src="/images/now/the-asni-c-programming-language.webp"
            data-srcset="/images/now/the-asni-c-programming-language.webp, /images/now/the-asni-c-programming-language.webp 1.5x, /images/now/the-asni-c-programming-language.webp 2x"
            data-sizes="auto"
            alt="/images/now/the-asni-c-programming-language.webp">
    </a><figcaption class="image-caption">The ANSI C Programming Language</figcaption>
    </figure></li>
</ul>
</li>
<li>因为今年搞网关 APISIX/Nginx 接触比较多，看了一点极客时间《OpenResty 从入门到实战》但是因为兴趣并不强烈，又不了了之了。</li>
<li>主要工作：
<ul>
<li>搞网关优化省了一波成本，但是期间也搞出一个严重故障&hellip;</li>
<li>承接了一个数据上报网关的需求，需要在网关层支持一些稍微复杂点的功能确保升级流程的稳定性。跟 APISIX 官方沟通后得到了比较好的解决方案 <a href="https://github.com/apache/apisix/discussions/7773" target="_blank" rel="noopener noreferrer">custom plugin - set an upstream as a http fallback server</a></li>
</ul>
</li>
</ul>
</li>
<li>9 月
<ul>
<li>偶然发现手机桌面上有一个安装了好久但是一直没用过的 APP 英语流利说，顺手用它测了下自己的英文水平。然后就对英语感兴趣了，制定了英语学习计划并发布对应的博文 <a href="https://thiscute.world/posts/learn-english-again/" target="_blank" rel="noopener noreferrer">Learn English Again</a>，然后就开始坚持学英语，感觉整个过程都很顺利。</li>
<li>主要工作：
<ul>
<li>仍然是搞网关优化省成本，因为各种原因，再次输出一篇 Post Mortem</li>
<li>搞数据上报网关的需求</li>
</ul>
</li>
</ul>
</li>
<li>10 月
<ul>
<li>找了很多英语学习资料，通过每日的坚持学习，渐渐找到了自己的英语学习节奏，完善了学习规划。</li>
<li>《Linux/Unix 系统编程手册（上册）》阅读进度过半，但是业余时间就这么点，同时用来学习 Linux 跟英语实在有点吃力，这本书的阅读就慢慢放下了。
<ul>
<li><figure><a class="lightgallery" href="/images/now/the-linux-programming-interface.webp" title="/images/now/the-linux-programming-interface.webp" data-thumbnail="/images/now/the-linux-programming-interface.webp" data-sub-html="<h2>Linux/Unix 系统编程手册（上册）</h2>">
        <img
            class="lazyload"
            data-src="/images/now/the-linux-programming-interface.webp"
            data-srcset="/images/now/the-linux-programming-interface.webp, /images/now/the-linux-programming-interface.webp 1.5x, /images/now/the-linux-programming-interface.webp 2x"
            data-sizes="auto"
            alt="/images/now/the-linux-programming-interface.webp">
    </a><figcaption class="image-caption">Linux/Unix 系统编程手册（上册）</figcaption>
    </figure></li>
</ul>
</li>
<li>通过友链漫游，发现了 <a href="https://0xffff.one" target="_blank" rel="noopener noreferrer">0xFFFF 社区</a>，内容质量很高，也在社区的 QQ 群里跟群友们聊了些有意思有价值的内容。</li>
<li>打游戏学英语
<figure><a class="lightgallery" href="/images/learn-english-again/genshin-impact-noelle.webp" title="/images/learn-english-again/genshin-impact-noelle.webp" data-thumbnail="/images/learn-english-again/genshin-impact-noelle.webp" data-sub-html="<h2>超飒的重剑女仆 Noelle</h2>">
        <img
            class="lazyload"
            data-src="/images/learn-english-again/genshin-impact-noelle.webp"
            data-srcset="/images/learn-english-again/genshin-impact-noelle.webp, /images/learn-english-again/genshin-impact-noelle.webp 1.5x, /images/learn-english-again/genshin-impact-noelle.webp 2x"
            data-sizes="auto"
            alt="/images/learn-english-again/genshin-impact-noelle.webp">
    </a><figcaption class="image-caption">超飒的重剑女仆 Noelle</figcaption>
    </figure>
<figure><a class="lightgallery" href="/images/learn-english-again/demo2-talk-1.webp" title="/images/learn-english-again/demo2-talk-1.webp" data-thumbnail="/images/learn-english-again/demo2-talk-1.webp" data-sub-html="<h2>DEEMO 2 中丰富的对话内容</h2>">
        <img
            class="lazyload"
            data-src="/images/learn-english-again/demo2-talk-1.webp"
            data-srcset="/images/learn-english-again/demo2-talk-1.webp, /images/learn-english-again/demo2-talk-1.webp 1.5x, /images/learn-english-again/demo2-talk-1.webp 2x"
            data-sizes="auto"
            alt="/images/learn-english-again/demo2-talk-1.webp">
    </a><figcaption class="image-caption">DEEMO 2 中丰富的对话内容</figcaption>
    </figure></li>
<li>因为许多原因，中概股大跌，公司架构大调整，走了很多大佬，包括去年带我冲浪的算法部门前辈。</li>
<li>主要工作
<ul>
<li>搞数据上报网关的需求，一路踩坑，总算把数万 QPS 的流量全部迁移到新网关上了。</li>
</ul>
</li>
</ul>
</li>
<li>11 月
<ul>
<li>重新对搞 Homelab 产生了兴趣，买了三台 MINI 主机组了一个 Homelab，时隔一年多又开始折腾 Proxmox VE，做各种规划。</li>
<li>迭代了很多次后的个人 Homelab 文档：<a href="https://github.com/ryan4yin/knowledge/tree/master/homelab" target="_blank" rel="noopener noreferrer">ryan4yin/knowledge/homelab</a>
<ul>
<li><figure><a class="lightgallery" href="/images/now/dashy-homepage.webp" title="/images/now/dashy-homepage.webp" data-thumbnail="/images/now/dashy-homepage.webp" data-sub-html="<h2>我的 Homelab 导航页 2022-11-12</h2>">
        <img
            class="lazyload"
            data-src="/images/now/dashy-homepage.webp"
            data-srcset="/images/now/dashy-homepage.webp, /images/now/dashy-homepage.webp 1.5x, /images/now/dashy-homepage.webp 2x"
            data-sizes="auto"
            alt="/images/now/dashy-homepage.webp">
    </a><figcaption class="image-caption">我的 Homelab 导航页 2022-11-12</figcaption>
    </figure></li>
</ul>
</li>
<li>因为业余时间沉迷搞 Homelab，英语打卡就变得断断续续了&hellip;但是词汇量测试的效果出乎意料，进步速度喜人，阅读能力也能感觉到有明显提升。</li>
<li>月底搬家换了个新租房，床是挂天花板上的，房间就宽敞了很多，而且拉了独立的电信宽带，网速杠杠的。</li>
<li>11/25 去东莞松山湖跟高中同学聚会，然后跟几位同学打麻将打到半夜三点多&hellip; 还远远眺望了眼同学读博的地方——「<a href="http://english.ihep.cas.cn/csns/" target="_blank" rel="noopener noreferrer">中国散裂中子源</a>」，感觉很高大上
<a class="lightgallery" href="/images/now/play-mahjong-with-classmates.webp" title="/images/now/play-mahjong-with-classmates.webp" data-thumbnail="/images/now/play-mahjong-with-classmates.webp">
        <img
            class="lazyload"
            data-src="/images/now/play-mahjong-with-classmates.webp"
            data-srcset="/images/now/play-mahjong-with-classmates.webp, /images/now/play-mahjong-with-classmates.webp 1.5x, /images/now/play-mahjong-with-classmates.webp 2x"
            data-sizes="auto"
            alt="/images/now/play-mahjong-with-classmates.webp">
    </a>
<a class="lightgallery" href="/images/now/china-spallation-neutron-source.webp" title="/images/now/china-spallation-neutron-source.webp" data-thumbnail="/images/now/china-spallation-neutron-source.webp">
        <img
            class="lazyload"
            data-src="/images/now/china-spallation-neutron-source.webp"
            data-srcset="/images/now/china-spallation-neutron-source.webp, /images/now/china-spallation-neutron-source.webp 1.5x, /images/now/china-spallation-neutron-source.webp 2x"
            data-sizes="auto"
            alt="/images/now/china-spallation-neutron-source.webp">
    </a></li>
<li>主要工作：继续推进线上网关优化项目，以及调研 K8s / Istio 的新版本变化，为集群升级做预备工作。</li>
</ul>
</li>
<li>12 月
<ul>
<li>从 Homelab 折腾到 HomeAssistant/ESPHome，然后就折腾 ESP32/ESP8266，结果很意外地就买了一堆硬件，入手了电烙铁热风枪万用表等各种仪器，ESP/51/STM32 都玩了个遍&hellip;
<ul>
<li>输出内容有两个代码仓库：<a href="https://github.com/ryan4yin/learn-8051-asm" target="_blank" rel="noopener noreferrer">learn-8051-asm</a> 与 <a href="https://github.com/ryan4yin/learn-stm32f103c8t6" target="_blank" rel="noopener noreferrer">learn-stm32f103c8t6</a>，以及一份 EE 笔记：<a href="https://github.com/ryan4yin/knowledge/blob/master/electrical-engineering/Electrical%20Engineering.md" target="_blank" rel="noopener noreferrer">Electrical Engineering.md</a>
<figure><img src="/images/now/experience-of-electrical-engineering.webp" width="60%"/><figcaption>
                  <h4>我的电子电路初体验</h4>
              </figcaption>
      </figure>

<figure><img src="/images/now/8051-display-2023.webp" width="70%"/><figcaption>
                  <h4>8051 汇编 - 数码管显示 2023</h4>
              </figcaption>
      </figure>
</li>
</ul>
</li>
<li>ChatGPT 横空出世，引发全网热潮。有技术大佬感慨，这个时刻竟然来临得如此之快，惊喜之余也有点猝不及防。我也把玩了一波，也用它帮助我学了许多硬件相关的东西，很有帮助。
<ul>
<li>个人猜测未来 ChatGPT 成熟后大概率能极大提升技术人员的工作效率，很可能间接影响到许多人的工作。</li>
</ul>
</li>
<li>年底还入手了一台 3D 打印机 ELEGOO Neptune 3 Pro&hellip;</li>
<li>全国逐渐放开疫情管控，我得了新冠，然后康复&hellip;</li>
<li>这个月折腾硬件，英语漏打卡更严重了，但是词汇量仍然在稳步增长，阅读起来也是越来越顺畅。</li>
<li>主要工作：
<ul>
<li>线上网关优化项目基本落地，取得了预期收益，但是没达到之前设的激进目标。（旧网关仍留存极少部分流量，还需要时间去统一网关架构）</li>
<li>做 K8s 集群升级准备，然后月底公司大面积新冠，拖慢了这项工作的进度，即使后调了升级时间，仍然感觉有点虚&hellip;</li>
</ul>
</li>
</ul>
</li>
<li>最后是连续三年蝉联我年度歌手的天依同学，截图放这里纪念一下：
<figure><img src="/images/now/netease-cloud-music-2022-singer-of-ryan4yin.webp" width="50%"/><figcaption>
              <h4>我的网易云年度歌手</h4>
          </figcaption>
  </figure>
</li>
</ul>
<h2 id="2022-年-highlight" class="headerLink">
    <a href="#2022-%e5%b9%b4-highlight" class="header-mark"></a>2022 年 Highlight</h2><h3 id="1-英语" class="headerLink">
    <a href="#1-%e8%8b%b1%e8%af%ad" class="header-mark"></a>1. 英语</h3><p>英语也是我今年比较惊喜的一个部分，很长一段时间内，我都觉得英语的优先级并不高，一直没有把它的学习排上日程，水平也一直没啥显著提升。</p>
<p>但是从今年 9 月份开始到现在这四个月的英语学习中，我的进步相当明显，从去年大概  4700 词，到现在测试结果为 6583 词，涨了近 2000 词，月均接近 500 词（按这个速度，2023 年 10000 词的目标好像没啥难度了）。</p>
<p>词汇量测试结果按时间排序如下，使用的测试工具是 <a href="https://preply.com/en/learn/english/test-your-vocab" target="_blank" rel="noopener noreferrer">Test Your Vocabulary</a> ：</p>
<p><figure><img src="/images/now/2023-01-02-test-your-vocabulary-result.webp" width="70%"/><figcaption>
            <h4>2023-01-02 词汇量测试结果：6583 词</h4>
        </figcaption>
</figure>

<figure><img src="/images/now/2022-12-19-test-your-vocabulary-result.webp" width="40%"/><figcaption>
            <h4>2022-12-19 词汇量测试结果：6300 词</h4>
        </figcaption>
</figure>

<figure><img src="/images/learn-english-again/2022-11-17-test-your-vocabulary-result.webp" width="65%"/><figcaption>
            <h4>2022-11-17 词汇量测试结果：5600 词</h4>
        </figcaption>
</figure>

<figure><img src="/images/learn-english-again/2022-10-18-test-your-vocabulary-result.webp" width="40%"/><figcaption>
            <h4>2022-10-18 词汇量测试结果：5100 词</h4>
        </figcaption>
</figure>
</p>
<p>另外因为主要是靠读书来学英语，今年的英文阅读能力也有明显提升，跟 9 月份刚开始读的时候比，阅读体验要流畅多了。
一些英文原版书阅读成就：</p>
<figure><img src="/images/now/mintreading-first-100days-achivement.webp" width="35%"/><figcaption>
            <h4>在薄荷阅读上读完的第一本英语原版书</h4>
        </figcaption>
</figure>

<p>而口语、写作这些今年基本没练习，原地踏步。</p>
<h3 id="2-业余技术" class="headerLink">
    <a href="#2-%e4%b8%9a%e4%bd%99%e6%8a%80%e6%9c%af" class="header-mark"></a>2. 业余技术</h3><p>今年业余搞的技术，感觉这些都是我比较满意的：</p>
<ul>
<li>Web3: 今年上半年花了不少时间去了解 Web3，但是仍然没敢说自己已经懂了它。水比较深，浅尝辄止。</li>
<li>电子电路（硬件）：点亮这个技能完全是个意外&hellip;但也挺惊喜的，毕竟我大学学的建筑声学，以前都没接触过硬件。</li>
<li>Go 语言：去年底定的目标是将 Go 语言应用在至少两个项目上，实际上只用在了一个项目上，完成度 50% 吧。</li>
<li>Linux: Linux 今年主要是复习了一遍 C 语言，然后看了半本《Linux/Unix 系统编程手册（上册）》，之后因为学英语就给放下了。
<ul>
<li>毕竟英语的成果很不错，这个结果我觉得也是预期内的。</li>
</ul>
</li>
<li>博客：今年博客经营得尚可，数了下有 18 篇技术干货，四篇非技术文章。最主要是三月份翻译密码学的文章冲了一波内容量。虽然 12 月份又鸽掉了&hellip;总体还是满意的。</li>
</ul>
<h3 id="3-工作" class="headerLink">
    <a href="#3-%e5%b7%a5%e4%bd%9c" class="header-mark"></a>3. 工作</h3><p>SRE 组 2022 年工作的主旋律其实就是省钱，我 2022 年的工作上有更多的挑战，不过因为得心应手很多，反倒没什么想特别着墨描述的了。</p>
<p>我上半年工作成果比较突出，下半年虽然工作成果差一些，但是业余的学习成果相当突出，总体很满意自己今年的成绩。</p>
<p>单纯从工作方面讲，我给自己的评价仍然是「良好」。</p>
<h3 id="4-阅读" class="headerLink">
    <a href="#4-%e9%98%85%e8%af%bb" class="header-mark"></a>4. 阅读</h3><p>2022 年一共读完了这些书：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 《人间失格》</li>
<li><input checked="" disabled="" type="checkbox"> 《月宫》</li>
<li><input checked="" disabled="" type="checkbox"> 《<a href="https://github.com/nakov/Practical-Cryptography-for-Developers-Book" target="_blank" rel="noopener noreferrer">Practical Cryptography for Developers</a>》</li>
<li><input checked="" disabled="" type="checkbox"> 《<a href="https://github.com/ethereumbook/ethereumbook" target="_blank" rel="noopener noreferrer">Mastering Ethereum</a>》</li>
<li><input checked="" disabled="" type="checkbox"> 《Go 程序设计语言（英文版）》</li>
<li><input checked="" disabled="" type="checkbox"> 《深入浅出 Kubernetes - 张磊》</li>
<li><input checked="" disabled="" type="checkbox"> 《在生命的尽头拥抱你-临终关怀医生手记》</li>
<li><input checked="" disabled="" type="checkbox"> 《在峡江的转弯处 - 陈行甲人生笔记》</li>
<li><input checked="" disabled="" type="checkbox"> 《The ANSI C Programming Language》</li>
<li><input checked="" disabled="" type="checkbox"> The Time Machine</li>
<li><input checked="" disabled="" type="checkbox"> Learn Robotics With Raspberry Pi
<ul>
<li>学习使用树莓派控制智能小车，结合本书与网上资料，我制作了一台使用 Xbox One 手柄遥控的四驱小车，相当有意思~</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> Learn Robotics Programming, 2nd Edition
<ul>
<li>跟前面那本一样是讲树莓派小车的，不过这本书更深入，代码含量高很多。</li>
<li>快速翻了一遍，跳过了其中大部分代码，因为书中的小车不太符合我的需求。</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> The Unlikely Pilgrimage of Harold Fry</li>
<li><input checked="" disabled="" type="checkbox"> 51 单片机自学笔记</li>
</ul>
<p>看起来，去年定的一个月至少读一本书的目标，还是达成了滴~</p>
<h2 id="2023-年的展望" class="headerLink">
    <a href="#2023-%e5%b9%b4%e7%9a%84%e5%b1%95%e6%9c%9b" class="header-mark"></a>2023 年的展望</h2><h3 id="技术侧" class="headerLink">
    <a href="#%e6%8a%80%e6%9c%af%e4%be%a7" class="header-mark"></a>技术侧</h3><p>2022 年的结果跟年初的展望区别仍然是挺大的，但是我个人挺满意。</p>
<p>这里再记一下 2023 年技术上的展望，看看今年能实现多少，又会点出多少意料之外的技能吧哈哈：</p>
<ul>
<li>云原生
<ul>
<li>去年定的阅读 k8s 及相关生态的源码没任何进度，2023 年继续&hellip;</li>
<li>2019 年到现在，我的工作时长已经有三年半了，希望更多的东西能通过学习底层知识去知其所以然，而不是全靠网上找资料，人云亦云一知半解地去解决问题。</li>
</ul>
</li>
<li>Linux 与网络
<ul>
<li>2023 年把《Linux/Unix 系统编程手册》这套书看完，并且过完 <a href="https://0xffff.one/d/1085-mit6-s081-operating-system" target="_blank" rel="noopener noreferrer">0xFFFF - MIT6.S081 Operating System Engineering (Fall 2020)</a> 这个课，对 Linux 内核与操作系统形成较深入的理解。</li>
<li>借着对硬件的兴趣学一学 Linux 驱动开发。</li>
<li>学习学习时下超流行的 eBPF 技术</li>
</ul>
</li>
<li>3D 打印
<ul>
<li>2022 年底买了台打印机，那不必须得打印点自己设计的东西？</li>
<li>FreeCAD 学！Blender 可能跟 3D 打印没啥关系但是也要学！</li>
</ul>
</li>
<li>编程语言
<ul>
<li>今年 Go/C 两个语言的技能点感觉是点出来了，2023 年需要巩固下，用它们完成些更复杂的任务。</li>
<li>另外借着搞硬件的兴趣，把 Rust/C++ 两门语言也玩一玩
<ul>
<li>C++ 主要是用来玩 ESP32/ESP8266，rust 那可是时下最潮的系统级语言，2022 年虽然用 rust 写了点 demo 但离熟练还差很远。</li>
</ul>
</li>
</ul>
</li>
<li>其他
<ul>
<li>2022 年我给开源社区提交的代码贡献几乎没有，希望 2023 年能至少给三个开源项目提交一些代码贡献，这也是检验自己的代码水平。</li>
<li>制作一台自己的无人机或者穿越机（虽然还不太懂什么是穿越机&hellip;），并借此练习自己学习的软硬件知识。</li>
<li>更多地在公司内部、博客等地方分享自己所学的知识，提升所学知识的可复用性，同时也碰撞出更多的灵光，更深入地理解它们。</li>
</ul>
</li>
</ul>
<h3 id="生活侧" class="headerLink">
    <a href="#%e7%94%9f%e6%b4%bb%e4%be%a7" class="header-mark"></a>生活侧</h3><p>2022 年初我写的生活上的展望，貌似只有「阅读」这一项达标了&hellip;
不过今年也仍旧记录下 2023 年的展望：</p>
<ul>
<li>2022 年因为疫情以及自己懒，参与的户外活动相当少，2023 年希望能更多的做些户外运动，身体还是很重要的啊。</li>
<li>把轮滑水平练上去一点，轮滑鞋在 2022 年吃灰了几乎一整年&hellip;</li>
<li>音乐上，口琴、竹笛、midi 键盘、Synthesizer V / ACE Studio / Reaper，总要把其中一个练一练吧&hellip;（什么？学吉他？？不敢开新坑了，旧坑都还没填完呢&hellip;）</li>
<li>阅读：仍然跟去年保持一样的节奏就好，目标是一个月至少阅读一本书。</li>
<li>英语：英语的规划在 <a href="https://thiscute.world/posts/learn-english-again/" target="_blank" rel="noopener noreferrer">Learn English Again</a> 中已经做得比较详尽了，这里仅摘抄下目标。
<ul>
<li>2023 年达到 CEFR 的 C1 等级，报考并取得 BEC 高级证书</li>
<li>2023 年底词汇量超过 10000</li>
</ul>
</li>
</ul>
<h2 id="结语" class="headerLink">
    <a href="#%e7%bb%93%e8%af%ad" class="header-mark"></a>结语</h2><p>2021 年的年终总结文末，我给自己 2022 年的期许是「更上一层楼」，感觉确实应验了。</p>
<p>那么 2023 年，我希望自己能够「认识更多有趣的人，见识下更宽广的世界」~</p>
<blockquote>
<p>更多有趣的的 2022 年度总结：<a href="https://github.com/saveweb/review-2022" target="_blank" rel="noopener noreferrer">https://github.com/saveweb/review-2022</a></p>
</blockquote>
]]></content></entry><entry><title type="html">Proxmox Virtual Environment 使用指南</title><link href="https://thiscute.world/posts/proxmox-virtual-environment-instruction/"/><id>https://thiscute.world/posts/proxmox-virtual-environment-instruction/</id><author><name>ryan4yin</name></author><published>2022-11-27T22:38:03+08:00</published><updated>2022-11-27T22:38:03+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/proxmox-virtual-environment-instruction/proxmox-logo.webp" height="2019" width="854"><figcaption></figcaption>
        </figure><blockquote>
<p>本文介绍我使用 PVE 的一些心得（不保证正确 emmmm），可能需要一定使用经验才能顺畅阅读。</p>
</blockquote>
<h2 id="前言" class="headerLink">
    <a href="#%e5%89%8d%e8%a8%80" class="header-mark"></a>前言</h2><p>我在去年的文章 <a href="https://thiscute.world/posts/QEMU/KVM-usage/" target="_blank" rel="noopener noreferrer">「QEMU/KVM 虚拟化环境的搭建与使用」</a> 中介绍了如何使用 QEMU/KVM 作为桌面虚拟化软件，其功能对标开源免费的 <a href="https://www.virtualbox.org/" target="_blank" rel="noopener noreferrer">Oracle VM VirtualBox</a> 以及收费但是用户众多的 <a href="https://www.vmware.com/products/workstation-pro.html" target="_blank" rel="noopener noreferrer">VMware Workstation Pro</a>.</p>
<p>虽然我们也可以远程使用 QEMU/KVM，但是使用门槛比较高。而且如果要管理多台服务器，各种命令也比较繁琐。
我们显然需要更易用的软件来管理服务器场景下的虚拟化。</p>
<p>而这篇文章介绍的 <a href="https://pve.proxmox.com/wiki/Main_Page" target="_blank" rel="noopener noreferrer">Proxmox Virtual Environment</a>（后续简称 PVE），就是一个基于 QEMU/KVM 的虚拟机集群管理平台。</p>
<p>PVE 以 Debian + QEMU/KVM + LXC 为基础进行了深度定制，提供了一套比较完善的 Web UI，基本上 95% 的操作都可以直接通过它的 Web UI 完成，但是仍然有些功能只需要使用它的 CLI 完成，或者说需要手动修改一些配置文件。</p>
<p>PVE 完全基于 Linux 世界的各种开源技术，存储技术使用了 LVM（也支持 Ceph/iSCSI/NFS），也支持通过 cloudinit 预配置网络、磁盘扩容、设置 hostname（这其实是 libvirtd 的功能）。
它的文档也比较齐全，而且写得清晰易懂，还包含许多它底层的 QEMU/KVM/CEPH/Cloudinit 等开源技术的内容，对学习 Linux 虚拟化技术也有些帮助。（这里必须喷下 VMware 的文档，真的是写得烂得一批，不知所云）</p>
<p>总的来说，PVE 没有 <a href="https://www.vmware.com/cn/products/vsphere-hypervisor.html" target="_blank" rel="noopener noreferrer">vShpere Hypervisor</a> 跟 <a href="https://learn.microsoft.com/en-us/windows-server/virtualization/hyper-v/hyper-v-technology-overview" target="_blank" rel="noopener noreferrer">Windows Hyper-V</a> 那么成熟、完善、稳定，但是基于 QEMU/KVM 且能够免费使用，很适合 Linux/开源/虚拟化 爱好者折腾。</p>
<blockquote>
<p>你可能还听说过 OpenStack，不过这个玩意儿我没接触过，所以这里略过了它。</p>
</blockquote>
<p>因为这些原因，我选择了 PVE 作为我的 Homelab 系统。</p>
<p>先贴一张我当前 Homelab 的 PVE 控制台截图，然后就进入正文。</p>
<p><figure><a class="lightgallery" href="/images/proxmox-ve-instruction/ryan-pve-console.webp" title="/images/proxmox-ve-instruction/ryan-pve-console.webp" data-thumbnail="/images/proxmox-ve-instruction/ryan-pve-console.webp" data-sub-html="<h2>我的 PVE 集群</h2>">
        <img
            class="lazyload"
            data-src="/images/proxmox-ve-instruction/ryan-pve-console.webp"
            data-srcset="/images/proxmox-ve-instruction/ryan-pve-console.webp, /images/proxmox-ve-instruction/ryan-pve-console.webp 1.5x, /images/proxmox-ve-instruction/ryan-pve-console.webp 2x"
            data-sizes="auto"
            alt="/images/proxmox-ve-instruction/ryan-pve-console.webp">
    </a><figcaption class="image-caption">我的 PVE 集群</figcaption>
    </figure></p>
<h2 id="一安装-pve-系统" class="headerLink">
    <a href="#%e4%b8%80%e5%ae%89%e8%a3%85-pve-%e7%b3%bb%e7%bb%9f" class="header-mark"></a>一、安装 PVE 系统</h2><p>建议直接使用 <a href="https://github.com/ventoy/Ventoy" target="_blank" rel="noopener noreferrer">ventoy</a> 制作一个 U 盘启动盘，把官网下载的 PVE 拷贝进去即可进行系统安装。
安装过程中需要注意的点有：</p>
<ul>
<li>如果你有多台机器，每台机器需要使用不同的主机名称（hostname），否则后面组建 PVE 集群时会有麻烦。
<ul>
<li>建议使用机器型号 + 数字编号作为机器的 hostname</li>
</ul>
</li>
<li>最好是为每台机器配置静态 IP，避免 IP 变更。</li>
</ul>
<p>系统安装好后即可按照提示直接访问其 Web UI，会提示 HTTPS 证书无效，忽略即可。另外还会有一个烦人的 PVE 订阅提示，也可直接忽略（7.2 及以上版本，暂时没找到怎么禁用掉这个提示）。</p>
<p>此外对于国内环境，建议按下面这篇文章配置国内镜像源（提升软件安装速度）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 设置 debian 的阿里镜像源</span>
</span></span><span class="line"><span class="cl">cp /etc/apt/sources.list /etc/apt/sources.list.bak
</span></span><span class="line"><span class="cl">sed -i <span class="s2">&#34;s@\(deb\|security\).debian.org@mirrors.aliyun.com@g&#34;</span> /etc/apt/sources.list
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 设置 pve 国内镜像源</span>
</span></span><span class="line"><span class="cl"><span class="c1"># https://mirrors.bfsu.edu.cn/help/proxmox/</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s1">&#39;deb https://mirrors.bfsu.edu.cn/proxmox/debian buster pve-no-subscription&#39;</span> &gt; /etc/apt/sources.list.d/pve-no-subscription.list
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="组建-pve-集群" class="headerLink">
    <a href="#%e7%bb%84%e5%bb%ba-pve-%e9%9b%86%e7%be%a4" class="header-mark"></a>组建 PVE 集群</h3><blockquote>
<p>如果你仅使用单机 PVE，可忽略这一节内容。</p>
</blockquote>
<p>将多台 PVE 节点组成一个集群，可以获得很多新玩法，比如虚拟机在多节点间的热迁移。</p>
<p>这个也还挺简单的，首先随便登入一台机器的 Web Console，点击「Datacenter」=&gt;「Cluster」=&gt;「Create Cluster」即可创建一个 PVE 集群。</p>
<p>接着复制「Join Information」中的内容，在其他每台 PVE 节点的 Web Console 页面中，点击「Datacenter」=&gt;「Cluster」=&gt;「Join Cluster」，然后粘贴前面复制的「Join Information」，再输入前面节点的密码，等待大约一分钟，然后刷新页面，PVE 集群即组建完成。</p>
<p><figure><a class="lightgallery" href="/images/proxmox-ve-instruction/pve-cluster-configuration.webp" title="/images/proxmox-ve-instruction/pve-cluster-configuration.webp" data-thumbnail="/images/proxmox-ve-instruction/pve-cluster-configuration.webp" data-sub-html="<h2>PVE 集群配置</h2>">
        <img
            class="lazyload"
            data-src="/images/proxmox-ve-instruction/pve-cluster-configuration.webp"
            data-srcset="/images/proxmox-ve-instruction/pve-cluster-configuration.webp, /images/proxmox-ve-instruction/pve-cluster-configuration.webp 1.5x, /images/proxmox-ve-instruction/pve-cluster-configuration.webp 2x"
            data-sizes="auto"
            alt="/images/proxmox-ve-instruction/pve-cluster-configuration.webp">
    </a><figcaption class="image-caption">PVE 集群配置</figcaption>
    </figure></p>
<p>PVE 集群的所有节点是完全平等的，集群组建完成后，登录其中任意一个节点的 Web Console 都可以管理集群中所有节点的资源。</p>
<h2 id="二pve-控制台的使用" class="headerLink">
    <a href="#%e4%ba%8cpve-%e6%8e%a7%e5%88%b6%e5%8f%b0%e7%9a%84%e4%bd%bf%e7%94%a8" class="header-mark"></a>二、PVE 控制台的使用</h2><p>PVE 控制台的使用还挺简单的，多试试基本就会用了。这里不做详细介绍，主要说明下一些要点：</p>
<ul>
<li>CPU
<ul>
<li>将 CPU 类型设置为 <code>host</code> 可以提高性能，适合比较吃性能或者对实时性要求高的虚拟机如 windows/openwrt</li>
<li>对于虚拟机核数，建议将 <code>sockets</code> 设为 1（即 CPU 插槽数，一般物理服务器才会有 2 及以上的 CPU 插槽），cores 设为你想分配给该虚拟机的 CPU 核数</li>
<li>仅针对多物理 CPU 场景（多 <code>sockets</code>）才需要启用 NUMA（个人猜测，可能有错）</li>
</ul>
</li>
<li>磁盘、网卡
<ul>
<li>磁盘驱动建议用 <code>virtio SCSI</code>、网卡驱动建议用 <code>VirtIO(paravirtualized)</code>，它的性能更高。
<ul>
<li>Linux 虚拟机原生支持 virtio 半虚拟化，而 windows 想要完全开启半虚拟化，需要手动安装驱动，详见 <a href="https://pve.proxmox.com/wiki/Windows_VirtIO_Drivers" target="_blank" rel="noopener noreferrer">Windows_VirtIO_Drivers - Proxmox WIKI</a>，简单的说就是要下个 iso 挂载到 windows 主机中，并安装其中的驱动。</li>
</ul>
</li>
<li>如果硬盘是 SSD，虚拟机磁盘可以启用 <code>SSD Emulation</code>，对于 IO 性能要求高的场景还可以为磁盘勾选 <code>IO  Thread</code> 功能</li>
</ul>
</li>
<li>显示器
<ul>
<li>默认使用 std 类型，兼容性最好，但是是纯 CPU 模拟的，比较耗 CPU。</li>
<li>如果你有 windows 等需要显卡加速的桌面虚拟机，但是又不想搞复杂的显卡直通，可以选择 <code>VirtIO GPU(virtio-gl)</code> 类型，这是一项正在进行中的工作：以较小的性能损耗将虚拟机中的 3D/2D 运算 offload 到 host GPU，而且避免复杂的驱动配置。仅需要提前手动在 PVE 中先装下这几个包 <code>apt install libgl1 libegl1</code>，并且在主机内安装好 virtio 驱动（ 前面提过了，Linux 自带，Windows 需要手动安装 virtio drivers）</li>
<li>详见 <a href="https://wiki.archlinux.org/title/QEMU#Graphic_card" target="_blank" rel="noopener noreferrer">QEMU Graphic card - Arch WIKI</a></li>
</ul>
</li>
<li>其他选项
<ul>
<li>调整启动项顺序，对于 cloud image 建议只启用 scsi0 这个选项</li>
</ul>
</li>
<li>虚拟机模板（Template）与克隆（Clone）
<ul>
<li>建议首先使用 ubuntu/opensuse cloud image 配置好基础环境（比如安装好 vim/curl/qemu-guest-agent），然后转换为 template，其他所有 Linux 虚拟机都可以直接 clone 一个，改个新名字，再改改 cloudinit 配置跟磁盘大小，就能直接启动使用了。相当方便。</li>
<li>仅 Full Clone 的虚拟机才可以在 PVE 集群节点间随意迁移，因此如果你需要虚拟机迁移功能，请不要使用 Link Clone.</li>
</ul>
</li>
<li>BIOS 通常都建议使用默认的 SeaBIOS，仅 Windows 等场景才建议换成 OMVF(UEFI)
<ul>
<li>OMVF 的分辨率、Secure Boot 等参数，都可以在启动时按 ESC 进入 UEFI 配置界面来调整。</li>
</ul>
</li>
</ul>
<p>上面这些内容，官方有详细文档，能读英文的话可以直接看 <a href="https://pve.proxmox.com/wiki/Qemu/KVM_Virtual_Machines" target="_blank" rel="noopener noreferrer">Qemu/KVM Virtual Machines - Proxmox WIKI</a>.</p>
<p>而 PCIe 直通之类的高级功能，我现在还没玩到，建议看官方文档:</p>
<ul>
<li><a href="https://pve.proxmox.com/wiki/PCI%28e%29_Passthrough" target="_blank" rel="noopener noreferrer">PCI(e) Passthrough - Proxmox WIKI</a>.</li>
<li><a href="https://pve.proxmox.com/wiki/Pci_passthrough#GPU_OVMF_PCI_Passthrough_.28recommended.29" target="_blank" rel="noopener noreferrer">GPU OVMF PCI Passthrough (recommended) - Proxmox WIKI</a></li>
<li><a href="https://wiki.archlinux.org/title/QEMU/Guest_graphics_acceleration" target="_blank" rel="noopener noreferrer">QEMU/Guest graphics acceleration - Arch WIKI</a></li>
</ul>
<h3 id="1-使用-cloudinit-自动配置网卡ssh密钥存储空间" class="headerLink">
    <a href="#1-%e4%bd%bf%e7%94%a8-cloudinit-%e8%87%aa%e5%8a%a8%e9%85%8d%e7%bd%ae%e7%bd%91%e5%8d%a1ssh%e5%af%86%e9%92%a5%e5%ad%98%e5%82%a8%e7%a9%ba%e9%97%b4" class="header-mark"></a>1. 使用 cloudinit 自动配置网卡、SSH密钥、存储空间</h3><blockquote>
<p>完全参照官方文档 <a href="https://pve.proxmox.com/wiki/Cloud-Init_Support" target="_blank" rel="noopener noreferrer">Cloud-Init_Support - PVE Docs</a></p>
</blockquote>
<blockquote>
<p>注意：下面的几种镜像都分别有自己的坑点，仅 Ubuntu/OpenSUSE 测试通过，其他发行版的 Cloud 镜像都有各种毛病&hellip;</p>
</blockquote>
<p>首先下载 Cloud 版本的系统镜像：</p>
<ol>
<li><a href="https://cloud-images.ubuntu.com/releases/" target="_blank" rel="noopener noreferrer">Ubuntu Cloud Images (RELEASED)</a>: 提供 img 格式的裸镜像（PVE 也支持此格式）
<ul>
<li>请下载带有 .img 结尾的镜像，其中 <code>kvm.img</code> 结尾的镜像会更精简一点，而不带 kvm 的会稍微大一点，但是带了所有常用的内核模块。</li>
</ul>
</li>
<li><a href="https://download.opensuse.org/repositories/Cloud:/Images:/" target="_blank" rel="noopener noreferrer">OpenSUSE Cloud Images</a>
<ul>
<li>请下载带有 NoCloud 或者 OpenStack 字样的镜像。</li>
</ul>
</li>
<li>对于其他镜像，可以考虑手动通过 iso 来制作一个 cloudinit 镜像，参考 <a href="https://docs.openstack.org/image-guide/ubuntu-image.html" target="_blank" rel="noopener noreferrer">openstack - create ubuntu cloud images from iso</a></li>
</ol>
<blockquote>
<p>注：<a href="https://cdimage.debian.org/cdimage/cloud/" target="_blank" rel="noopener noreferrer">Debian Cloud Images</a> 的镜像无法使用，其他 ubuntu/opensuse 的 cloud 镜像也各有问题&hellip;在后面的常见问题中有简单描述这些问题。</p>
</blockquote>
<p>上述镜像和我们普通虚拟机使用的 ISO 镜像的区别，一是镜像格式不同，二是都自带了 <code>cloud-init</code>/<code>cloud-utils-growpart</code> 等 cloud 相关软件，三是如果你使用了。</p>
<p>其中 NoCloud 表示支持 cloudinit NoCloud 数据源——即使用 <code>seed.iso</code> 提供 user-data/meta-data/network-config 配置，PVE 就是使用的这种模式。
而 Openstack 镜像通常也都支持 NoCloud 模式，所以一般也是可以使用的。</p>
<p>cloud image 基本都没有默认密码，并且禁用了 SSH 密码登录，必须通过 cloud-init 设置私钥方式进行 ssh 登录。</p>
<p>建议在 cloud-init 配置中自行设置账号与私钥，不要使用默认的账号名。
比如测试环境，可以直接设置账号为 root，并设置相应的私钥。</p>
<p>接下来我们需要将得到的 qcow2 镜像导入 PVE，并用它创建一个虚拟机模板。</p>
<p>首先创建虚拟机，并以导入的磁盘为该虚拟机的硬盘</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 创建新虚拟机</span>
</span></span><span class="line"><span class="cl">qm create <span class="m">9000</span> --name ubuntu-bionic-template --memory <span class="m">2048</span> --net0 virtio,bridge<span class="o">=</span>vmbr0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 将下载好的 img/qcow2 镜像导入为新虚拟机的硬盘</span>
</span></span><span class="line"><span class="cl">qm importdisk <span class="m">9000</span> ubuntu-20.10-server-cloudimg-amd64.img local-lvm
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 通过 scsi 方式，将导入的硬盘挂载到虚拟机上</span>
</span></span><span class="line"><span class="cl">qm <span class="nb">set</span> <span class="m">9000</span> --scsihw virtio-scsi-pci --scsi0 local-lvm:vm-9000-disk-0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># qcow2 镜像默认仅 2G 大小，需要手动扩容到 32G，否则虚拟机启动会报错</span>
</span></span><span class="line"><span class="cl">qm resize <span class="m">9000</span> scsi0 32G
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 创建一个 cloud-init 需要使用的 CDROM 盘(sr0)</span>
</span></span><span class="line"><span class="cl">qm <span class="nb">set</span> <span class="m">9000</span> --ide2 local-lvm:cloudinit
</span></span><span class="line"><span class="cl"><span class="c1"># 设置系统引导盘</span>
</span></span><span class="line"><span class="cl">qm <span class="nb">set</span> <span class="m">9000</span> --boot c --bootdisk scsi0
</span></span><span class="line"><span class="cl"><span class="c1"># 设置 serial0 为显示终端，很多云镜像都需要这个。（？感觉我不需要？）</span>
</span></span><span class="line"><span class="cl">qm <span class="nb">set</span> <span class="m">9000</span> --serial0 socket --vga serial0
</span></span></code></pre></td></tr></table>
</div>
</div><p>后续配置：</p>
<ol>
<li>手动设置 cloud-init 参数，<strong>重新生成 cloudinit image</strong>，启动虚拟机，并通过 ssh 登入远程终端
<ol>
<li>貌似启动虚拟机时 PVE 会自动重新生成 seed.iso，但是手动生成下肯定更保险&hellip;</li>
</ol>
</li>
<li>检查 qemu-guest-agent，如果未自带，一定要手动安装它！
<ol>
<li>ubuntu 需要通过 <code>sudo apt install qemu-guest-agent</code> 手动安装它</li>
</ol>
</li>
<li>安装所需的基础环境，如 docker/docker-compose/vim/git/python3</li>
<li>关闭虚拟机，然后将虚拟机设为模板</li>
<li>接下来就可以从这个模板虚拟机，克隆各类新虚拟机了~</li>
</ol>
<p><figure><a class="lightgallery" href="/images/proxmox-ve-instruction/pve-cloudinit-configuration.webp" title="/images/proxmox-ve-instruction/pve-cloudinit-configuration.webp" data-thumbnail="/images/proxmox-ve-instruction/pve-cloudinit-configuration.webp" data-sub-html="<h2>改完配置后一定要点击 Regenerate Image!</h2>">
        <img
            class="lazyload"
            data-src="/images/proxmox-ve-instruction/pve-cloudinit-configuration.webp"
            data-srcset="/images/proxmox-ve-instruction/pve-cloudinit-configuration.webp, /images/proxmox-ve-instruction/pve-cloudinit-configuration.webp 1.5x, /images/proxmox-ve-instruction/pve-cloudinit-configuration.webp 2x"
            data-sizes="auto"
            alt="/images/proxmox-ve-instruction/pve-cloudinit-configuration.webp">
    </a><figcaption class="image-caption">改完配置后一定要点击 Regenerate Image!</figcaption>
    </figure></p>
<p>其他 cloudinit 相关文档：</p>
<ul>
<li><a href="https://support.huaweicloud.com/usermanual-ims/ims_01_0407.html" target="_blank" rel="noopener noreferrer">配置 Cloud-Init 工具 - 华为云</a></li>
<li><a href="https://github.com/canonical/cloud-init" target="_blank" rel="noopener noreferrer">canonical/cloud-init - github</a></li>
<li><a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/amazon-linux-2-virtual-machine.html" target="_blank" rel="noopener noreferrer">Run Amazon Linux 2 as a virtual machine on premises</a></li>
</ul>
<h3 id="2-虚拟机硬盘扩容" class="headerLink">
    <a href="#2-%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%a1%ac%e7%9b%98%e6%89%a9%e5%ae%b9" class="header-mark"></a>2. 虚拟机硬盘扩容</h3><p>CentOS/Ubuntu/Debian 提供的 Cloud 镜像，都自带了 <code>cloud-utils-growpart</code> 这个组件，可以实现在扩容物理硬盘时，自动调整 Linux 的分区大小。</p>
<p>因此需要扩容虚拟机时，直接通过 UI 面板/命令行扩容虚拟机的硬盘即可， Linux 的分区会被 <code>cloud-utils-growpart</code> 自动扩容。</p>
<p>而其他非 Cloud 镜像，则需要在扩容磁盘后再进入虚拟机手动扩容分区跟磁盘，具体命令就不介绍了，请自行查阅相关文档吧。</p>
<blockquote>
<p>因为这个方便的特性，也为了减少虚拟化的开销，Cloud 镜像默认是不使用 LVM 逻辑分区的。
LVM 逻辑分区虽然方便，但是它对物理机的作用更大些。虚拟机因为本身就能动态扩容“物理硬盘”的大小，基本不用不到 LVM。</p>
</blockquote>
<blockquote>
<p>还有一点，就是虚拟机通常只需要一个根分区就行，尤其是归 openstack/kubernetes 管的虚拟机。
只有在使用分布式存储之类的场景下，数据需要独立存储，才需要用到额外的分区(<code>/data</code> 之类的)。
一般只有物理机，才需要像网上很多文章提的那样，为 <code>/boot</code> <code>/</code> <code>/home</code> 去单独分区。
而且现在大家都用 SSD 了，物理机这样做分区的都少了，比如我个人电脑，就是一个 <code>/</code> 分区打天下。。。</p>
</blockquote>
<h2 id="三常见问题" class="headerLink">
    <a href="#%e4%b8%89%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98" class="header-mark"></a>三、常见问题</h2><h3 id="1-导入已有的-qcow2-镜像" class="headerLink">
    <a href="#1-%e5%af%bc%e5%85%a5%e5%b7%b2%e6%9c%89%e7%9a%84-qcow2-%e9%95%9c%e5%83%8f" class="header-mark"></a>1. 导入已有的 qcow2 镜像</h3><blockquote>
<p>必须要命令行操作</p>
</blockquote>
<p>先通过 scp 将 qcow2 传输到 PVE 上，然后命令行使用如下命令导入镜像：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 命令格式</span>
</span></span><span class="line"><span class="cl">qm importdisk &lt;vmid&gt; &lt;source&gt; &lt;storage&gt;
</span></span><span class="line"><span class="cl"><span class="c1"># 示例</span>
</span></span><span class="line"><span class="cl">qm importdisk <span class="m">201</span> vm-201-disk-1.qcow2 local-lvm
</span></span></code></pre></td></tr></table>
</div>
</div><p>导入完成后，在 WebUI 界面的左侧会看到多了一个「未使用的磁盘 0」，
现在新建一台新虚拟机，然后删除掉默认的磁盘（分离+删除，要两步），然后挂载这个「未使用的磁盘 0」就大功告成了。</p>
<h3 id="2-点击-shutdown-后-pve-系统卡住" class="headerLink">
    <a href="#2-%e7%82%b9%e5%87%bb-shutdown-%e5%90%8e-pve-%e7%b3%bb%e7%bb%9f%e5%8d%a1%e4%bd%8f" class="header-mark"></a>2. 点击 shutdown 后 PVE 系统卡住</h3><p>PVE 的 <code>shutdown</code> 功能依赖 <code>qemu-guest-agent</code>，对于还没有安装 <code>qemu-guest-agent</code> 的任何主机，或者已经卡死无响应的虚拟机，千万不要点 <code>shutdown</code> 按钮，因为一定会卡住很久，最后失败！</p>
<p><code>shutdown</code> 卡住的解决办法：手动在下方的「Tasks」面板中双击卡住的「Shutdown」操作，然后点击「stop」停止该操作。</p>
<p>该如何关闭这类没有 <code>qemu-guest-agent</code> 或者已经卡死无响应的主机？答案是使用 <code>stop</code>！</p>
<h3 id="3-cant-lock-file-varlockqemu-serverlock-xxxconf--got-timeout" class="headerLink">
    <a href="#3-cant-lock-file-varlockqemu-serverlock-xxxconf--got-timeout" class="header-mark"></a>3. can’t lock file ‘/var/lock/qemu-server/lock-xxx.conf’ – got timeout</h3><p>PVE 虚拟机卡在 BIOS 系统引导这一步，无法启动，也无法 <code>stop</code>！</p>
<p>解决方法：手动删除掉 lockfile: <code>/var/lock/qemu-server/lock-xxx.conf</code></p>
<p>因为虚拟机还卡在 BIOS 引导这一步，删除掉 lockfile 再关闭虚拟机并不会导致数据丢失。</p>
<h3 id="4-pve-集群有一个节点宕机如何解除关联" class="headerLink">
    <a href="#4-pve-%e9%9b%86%e7%be%a4%e6%9c%89%e4%b8%80%e4%b8%aa%e8%8a%82%e7%82%b9%e5%ae%95%e6%9c%ba%e5%a6%82%e4%bd%95%e8%a7%a3%e9%99%a4%e5%85%b3%e8%81%94" class="header-mark"></a>4. PVE 集群有一个节点宕机，如何解除关联？</h3><p>将多个节点组成一个 PVE Cluster 是很自然的一个选择，它能提供虚拟机热迁移（同 CPU 供应商）、统一管理面板等非常方便的功能。
但是这会带来集群级别的高可用问题。</p>
<p>根据官方文档 <a href="https://pve.proxmox.com/wiki/Cluster_Manager" target="_blank" rel="noopener noreferrer">Cluster_Manager - Proxmox</a>，如果你需要容忍一定数量的节点宕机，PVE Cluster 至少需要三台主机（这跟 Etcd 一样，大概是 Raft 共识算法的要求），并且所有节点的 PVE 版本要完全一致。</p>
<p>那么如果个别节点出了问题，无法修复，该如何将它踢出集群呢？</p>
<p>如果需要踢出的节点仍然处于可用状态，而且在线节点占比超过 50%，则修改流程如下：</p>
<ul>
<li>首先通过访问节点的 shell 界面，通过命令 <code>pvecm nodes</code> 确认集群的所有节点</li>
<li>将需要移除的节点彻底关机，并且确保它不会以当前配置再次启动（也就是说关机后需要清空硬盘，避免数据混乱）</li>
<li>通过命令 <code>pvecm delnode xxx</code> 将问题节点移除集群</li>
<li>重置旧节点硬盘，并重新装机，用做其他用途。</li>
</ul>
<p>如果你的集群只有 2 个节点，或者有超过 3 个节点但是宕机节点数不低于 50%，那出于数据一致性要求 Raft 算法会禁止更新集群数据，上面的流程就走不通了。如果你直接走上面的流程，它会报错 <code>cluster not ready - no quorum?</code> 这时需要首先修改配置，使剩下的节点重新达成一致。其实就是修改选主节点时的投票数。</p>
<p>对于 2 个节点但挂掉 1 个的情况，首先执行如下指令允许当前节点自己选主：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 设置只需要 1 票就能当前主节点</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 潜在问题是可能有些集群元数据只在损坏节点上有，这么改会导致这些数据丢失，从而造成一些问题。</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 安全起见，建议在修复集群后，再重启一遍节点...</span>
</span></span><span class="line"><span class="cl">pvecm expected <span class="m">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在 quorum 就已经恢复了，可以走前面给出的节点移除流程。</p>
<p>如果节点已经删除，但是 Web GUI 上仍然显示有被删除的节点，可以在集群的所有剩余节点上，手动删除掉 <code>/etc/pve/nodes/node-name/</code> 文件夹，即可从集群中彻底删除该节点的数据，注意千万别删错了，不然就尴尬了&hellip;</p>
<p>如果 corosync 完全无法启动，上面给出的命令也会修改选主投票参数也会失败，这时可以直接手动修改 <code>/etc/corosync/corosync.conf</code> 删除掉有问题的节点对应的配置，调低 expceted 投票数，使 corosync 能正常启动，再执行前述操作。</p>
<h3 id="5-cloud-image-的坑" class="headerLink">
    <a href="#5-cloud-image-%e7%9a%84%e5%9d%91" class="header-mark"></a>5. cloud image 的坑</h3><h4 id="ubuntu-cloud-image-的坑" class="headerLink">
    <a href="#ubuntu-cloud-image-%e7%9a%84%e5%9d%91" class="header-mark"></a>ubuntu cloud image 的坑</h4><ul>
<li>ubuntu 启动时会报错 <code>no such device: root</code>，但是过一会就会正常启动。
<ul>
<li>这是 ubuntu cloud image 的 bug: <a href="https://bugs.launchpad.net/cloud-images/&#43;bug/1726476" target="_blank" rel="noopener noreferrer">https://bugs.launchpad.net/cloud-images/+bug/1726476</a></li>
</ul>
</li>
<li>ubuntu 启动后很快就会进入登录界面，但是 root 密码可能还没改好，登录会报密码错误，等待一会再尝试登录就 OK 了</li>
<li>ubuntu 的默认网卡名称是 ens3，不是 eth0，注意修改 network_config 的网卡名称，否则网络配置不会生效</li>
<li>以 kvm 结尾的 Ubuntu Cloud Image 无法识别到 USB 设备，将 USB 端口映射到该虚拟机中没有任何作用。
<ul>
<li>kvm 使用了精简版的 linux 内核，去掉了 USB 等在云上用不到的驱动，建议改用无 kvm 结尾的镜像。</li>
</ul>
</li>
</ul>
<h5 id="ubuntu-cloud-image-无法识别到-usb-设备的排查记录" class="headerLink">
    <a href="#ubuntu-cloud-image-%e6%97%a0%e6%b3%95%e8%af%86%e5%88%ab%e5%88%b0-usb-%e8%ae%be%e5%a4%87%e7%9a%84%e6%8e%92%e6%9f%a5%e8%ae%b0%e5%bd%95" class="header-mark"></a>「Ubuntu Cloud Image 无法识别到 USB 设备」的排查记录</h5><p>现象：</p>
<ul>
<li>在尝试使用 PVE 将 USB 接口直通到 Ubuntu Cloud Image 启动的虚拟机作为 NAS 系统时，发现 <code>lsblk</code> 根本无法找到我的 USB 硬盘</li>
<li>换成我笔记本接硬盘盒，能够正常识别并挂载硬盘</li>
<li>使用 <code>lsusb</code> 不会报错，但是也看不到任何内容</li>
<li>使用 <code>lspci</code> 能找到 USB 对应的 PCI 设备</li>
<li>进一步使用 <code>cat /proc/modules | grep usb</code> 与 <code>lsmod | grep usb</code> 均查不到任何 usb 相关的内核模块
<ul>
<li>而在我笔记本上 <code>lsmod | grep usb</code> 能够输出 <code>usb_storage</code> <code>usb_core</code> 等多项内核模块。</li>
</ul>
</li>
<li>再用 <code>modprobe usb</code> 会提示 <code>modprobe: FATAL: Module usb not found in directory /lib/modules/5.15.0-1021-kvm</code></li>
</ul>
<p>问题原因很明显了，Ubuntu 根本没有为 cloud image 预置 usb 内核模块，所以才有这个问题&hellip;</p>
<p>进一步搜索发现这个帖子：<a href="https://askubuntu.com/questions/1315370/whats-the-difference-between-ubuntus-amd64-disk-kvm-img-and-the-regular-amd64" target="_blank" rel="noopener noreferrer">What&rsquo;s the difference between ubuntu&rsquo;s amd64-disk-kvm.img and the regular amd64.img cloud images?</a>，解答了我的疑惑。</p>
<p>原因是，我使用了 ubuntu 为 cloud 环境做了精简的 kvm 内核，非常轻量，但是缺少 usb 等常用内核模块。</p>
<p>对于 NAS 外接存储这个场景，我应该使用不以 kvm 结尾的 ubuntu cloud image，换了个基础镜像后问题就解决了~</p>
<h4 id="opensuse-cloud-image-的坑" class="headerLink">
    <a href="#opensuse-cloud-image-%e7%9a%84%e5%9d%91" class="header-mark"></a>opensuse cloud image 的坑</h4><ul>
<li>opensuse leap 15 只支持 network_config v1，对 v2 的支持有 bug，<code>gateway4</code> 不会生效</li>
</ul>
<h4 id="debian-cloud-image-的坑" class="headerLink">
    <a href="#debian-cloud-image-%e7%9a%84%e5%9d%91" class="header-mark"></a>debian cloud image 的坑</h4><p>debian 的 cloud 镜像根本没法用，建议避免使用它。</p>
<ul>
<li>debian 启动时会彻底卡住，或者直接报错 kernel panic
<ul>
<li>原因是添加了 spice 图形卡，换成 vnc 就正常了</li>
</ul>
</li>
<li><a href="https://cdimage.debian.org/cdimage/cloud/" target="_blank" rel="noopener noreferrer">Debian Cloud Images</a> 中的 nocloud 镜像不会在启动时运行 cloudinit，cloudinit 完全不生效
<ul>
<li>不知道是啥坑，没解决</li>
</ul>
</li>
</ul>
<h3 id="6-克隆创建的虚拟机卡在-booting-from-hard-disk-状态" class="headerLink">
    <a href="#6-%e5%85%8b%e9%9a%86%e5%88%9b%e5%bb%ba%e7%9a%84%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%8d%a1%e5%9c%a8-booting-from-hard-disk-%e7%8a%b6%e6%80%81" class="header-mark"></a>6. 克隆创建的虚拟机，卡在 <code>Booting from Hard Disk...</code> 状态</h3><p>被用做模板的虚拟机可以正常启动，但是克隆的虚拟机就卡住了。</p>
<p>可能的原因：</p>
<ol>
<li>磁盘有问题，出这个问题的 cloud image 是 <code>ubuntu-20.10-server-cloudimg-amd64.img</code>，我更换成 <code>ubuntu-20.10-server-cloudimg-amd64-disk-kvm.img</code> 就没问题了。
<ol>
<li>磁盘镜像均下载自 <a href="https://cloud-images.ubuntu.com/releases/groovy/release-20201210/" target="_blank" rel="noopener noreferrer">https://cloud-images.ubuntu.com/releases/groovy/release-20201210/</a></li>
</ol>
</li>
<li>BIOS 不匹配：将 BIOS 从 SeaBIOS 切换到 OVMF(UEFI)
<ol>
<li>如果仍然无法启动，请进入 OVMF 的 BIOS 界面关闭「Secure Boot」后再重启看看</li>
</ol>
</li>
</ol>
<h3 id="7-虚拟机启动时-cloudinit-报错-faild-to-start-openbsd-secure-shell-server" class="headerLink">
    <a href="#7-%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%90%af%e5%8a%a8%e6%97%b6-cloudinit-%e6%8a%a5%e9%94%99-faild-to-start-openbsd-secure-shell-server" class="header-mark"></a>7. 虚拟机启动时 cloudinit 报错 faild to start OpenBSD Secure Shell server</h3><p>有如下几种可能：</p>
<ul>
<li><strong>可能性一：虚拟机名称包含非法字符</strong>
<ul>
<li>pve 的 cloudinit 配置会在启动时尝试将虚拟机 hostname 修改为与虚拟机一致，但是又没有对虚拟机名称做合法性校验&hellip;</li>
<li>当你使用的虚拟机名称包含了非法字符时就会出这个问题，比如 <code>ubuntu-22.10-cloudimage-template</code>，其中的 <code>.</code> 就是非法的， <code>.</code> 在 DNS 中用于划分不同的域！</li>
<li><strong>解决方法</strong>：克隆个新虚拟机并改用合法名称，再删除旧虚拟机，问题就解决了。</li>
</ul>
</li>
<li><strong>可能性二：磁盘空间不足</strong>
<ul>
<li>qcow 镜像转换成的虚拟机磁盘很小，只有 2G，如果不扩容，启动时就会出各种奇怪的问题。</li>
<li><strong>解决方法</strong>：通过 Web UI 扩容磁盘大小，建议至少给 32G。</li>
</ul>
</li>
</ul>
<h3 id="8-修改-linux-虚拟机的-hostname" class="headerLink">
    <a href="#8-%e4%bf%ae%e6%94%b9-linux-%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%9a%84-hostname" class="header-mark"></a>8. 修改 Linux 虚拟机的 Hostname</h3><p>如前所述，pve 的 cloudinit 配置会在启动时尝试将虚拟机 hostname 修改为与虚拟机一致，这导致手动修改无法生效无效。</p>
<p>解决方法：从旧的虚拟机克隆一个新虚拟机，将新虚拟机名称设为你期望的 hostname，然后删除旧虚拟机，启动新克隆的虚拟机，即完成了 hostname 重命名。</p>
<h3 id="9-虚拟机迁移时报错-host-key-verification-failed" class="headerLink">
    <a href="#9-%e8%99%9a%e6%8b%9f%e6%9c%ba%e8%bf%81%e7%a7%bb%e6%97%b6%e6%8a%a5%e9%94%99-host-key-verification-failed" class="header-mark"></a>9. 虚拟机迁移时报错 <code>Host key verification failed</code></h3><blockquote>
<p>社区相关帖子：https://forum.proxmox.com/threads/host-key-verification-failed-when-migrate.41666/</p>
</blockquote>
<p>这通常是因为节点增删，或者不小心动到了 <code>~/.ssh/known_hosts</code> 文件，导致的问题。</p>
<p>可以通过手动在每台节点上执行如下命令解决：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ssh -o <span class="s1">&#39;HostKeyAlias=&lt;Target node Name&gt;&#39;</span> root@&lt;Target node IP&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意将上述命令中的 <code>Target node Name&gt;</code> 改为节点名称，将 <code>&lt;Target node IP&gt;</code> 改为节点 IP 地址。</p>
<h3 id="10-pve-的-vm-不支持-vmxsvm-虚拟化指令集" class="headerLink">
    <a href="#10-pve-%e7%9a%84-vm-%e4%b8%8d%e6%94%af%e6%8c%81-vmxsvm-%e8%99%9a%e6%8b%9f%e5%8c%96%e6%8c%87%e4%bb%a4%e9%9b%86" class="header-mark"></a>10. PVE 的 vm 不支持 vmx/svm 虚拟化指令集</h3><p>在 Linux 虚拟机中运行如下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">egrep <span class="s1">&#39;(vmx|svm)&#39;</span> --color<span class="o">=</span>always /proc/cpuinfo
</span></span></code></pre></td></tr></table>
</div>
</div><p>有输出则说明此虚拟机本身也支持 vmx/svm 虚拟化指令集（vmx 是 intel 指令集，svm 是 amd 的指令集）。</p>
<p>如果没有任何输出，说明此虚拟机不支持嵌套虚拟机，无法在其内部运行 Hyper-V 或者 kvm 虚拟化程序。</p>
<p>一般来说 PVE 宿主机默认就会启用嵌套虚拟化功能，可通过如下指令验证：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># intel 用这个命令，输出 Y 则表示启用了嵌套虚拟化</span>
</span></span><span class="line"><span class="cl">cat /sys/module/kvm_intel/parameters/nested
</span></span><span class="line"><span class="cl"><span class="c1"># amd 用如下指令，输出 1 则表示启用了嵌套虚拟化</span>
</span></span><span class="line"><span class="cl">cat /sys/module/kvm_amd/parameters/nested
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果输出不是 <code>Y</code>/<code>1</code>，则需要手动启用嵌套虚拟化功能。</p>
<p>如果是 intel cpu，需要使用如下命令启用嵌套虚拟化功能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1">## 1. 关闭所有虚拟机，并卸载 kvm_intel 内核模块</span>
</span></span><span class="line"><span class="cl">sudo modprobe -r kvm_intel
</span></span><span class="line"><span class="cl"><span class="c1">## 2. 启用嵌套虚拟化功能</span>
</span></span><span class="line"><span class="cl">sudo modprobe kvm_intel <span class="nv">nested</span><span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="c1">## 3. 保存配置，使嵌套虚拟化功能在重启后自动启用</span>
</span></span><span class="line"><span class="cl">cat <span class="s">&lt;&lt;EOF | sudo tee /etc/modprobe.d/kvm.conf
</span></span></span><span class="line"><span class="cl"><span class="s">options kvm_intel nested=1
</span></span></span><span class="line"><span class="cl"><span class="s">EOF</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果是 amd cpu，则应使用如下命令启用嵌套虚拟化功能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1">## 1. 关闭所有虚拟机，并卸载 kvm_intel 内核模块</span>
</span></span><span class="line"><span class="cl">sudo modprobe -r kvm_amd
</span></span><span class="line"><span class="cl"><span class="c1">## 2. 启用嵌套虚拟化功能</span>
</span></span><span class="line"><span class="cl">sudo modprobe kvm_amd <span class="nv">nested</span><span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="c1">## 3. 保存配置，使嵌套虚拟化功能在重启后自动启用</span>
</span></span><span class="line"><span class="cl">cat <span class="s">&lt;&lt;EOF | sudo tee /etc/modprobe.d/kvm.conf
</span></span></span><span class="line"><span class="cl"><span class="s">options kvm_amd nested=1
</span></span></span><span class="line"><span class="cl"><span class="s">EOF</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面这么一堆操作后，宿主机就已经启用了嵌套虚拟化，但是虚拟机内部却仍然不一定能有虚拟化指令集。</p>
<p><strong>根本原因是 PVE 默认使用 kvm64 这种虚拟化的 CPU 类型，它不支持 vmx/svm 指令集！将虚拟机的 CPU 类型改为 <code>host</code>，然后重启虚拟机，问题就解决了</strong>。</p>
<h3 id="11-如何在多台主机间同步-iso-镜像backup-文件" class="headerLink">
    <a href="#11-%e5%a6%82%e4%bd%95%e5%9c%a8%e5%a4%9a%e5%8f%b0%e4%b8%bb%e6%9c%ba%e9%97%b4%e5%90%8c%e6%ad%a5-iso-%e9%95%9c%e5%83%8fbackup-%e6%96%87%e4%bb%b6" class="header-mark"></a>11. 如何在多台主机间同步 iso 镜像、backup 文件</h3><p>PVE 自动创建的 iso 镜像、backup 文件，默认都只会保存到本机的 <code>local</code> 分区中，那万一机器出了问题，很可能备份就一起丢了。</p>
<p>极简解决方案，每台机器放一个 crontab 脚本，定期使用 rsync 将本机的 <code>/var/lib/vz/template/</code> 与其他几台主机同步，同时还可以将数据备份一份到外部 HDD 存储确保安全。</p>
<p>示例脚本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 将本机的 /var/lib/vz/template/ 文件夹与另外两台主机同步</span>
</span></span><span class="line"><span class="cl">rsync -avz --progress /var/lib/vz/template/ root@192.168.5.162:/var/lib/vz/template/
</span></span><span class="line"><span class="cl">rsync -avz --progress /var/lib/vz/template/ root@192.168.5.163:/var/lib/vz/template/
</span></span></code></pre></td></tr></table>
</div>
</div><p>不过好像 PVE 官方也提供一个 <a href="https://www.proxmox.com/en/proxmox-backup-server" target="_blank" rel="noopener noreferrer">proxmox-backup-server</a>，感觉可以搞个容器跑这玩意儿，把数据备份到 USB 硬盘盒或者 SMB 挂载的硬盘里，待研究。</p>
<ul>
<li><a href="https://github.com/proxmox/proxmox-backup" target="_blank" rel="noopener noreferrer">proxmox/proxmox-backup</a></li>
<li><a href="https://github.com/ayufan/pve-backup-server-dockerfiles" target="_blank" rel="noopener noreferrer">ayufan/pve-backup-server-dockerfiles</a></li>
</ul>
<p>另外开源社区也有 restic/rclone 等工具也可用于备份，备份方案还在研究中，未确定。</p>
<h2 id="四pve-网络配置" class="headerLink">
    <a href="#%e5%9b%9bpve-%e7%bd%91%e7%bb%9c%e9%85%8d%e7%bd%ae" class="header-mark"></a>四、PVE 网络配置</h2><h3 id="1-桥接多张物理网卡" class="headerLink">
    <a href="#1-%e6%a1%a5%e6%8e%a5%e5%a4%9a%e5%bc%a0%e7%89%a9%e7%90%86%e7%bd%91%e5%8d%a1" class="header-mark"></a>1. 桥接多张物理网卡</h3><p>示例如下，主要就是在 vmbr0 网桥的 <code>Bridge Ports</code> 里面：</p>
<p><figure><a class="lightgallery" href="/images/proxmox-ve-instruction/pve-multiple-nic.webp" title="/images/proxmox-ve-instruction/pve-multiple-nic.webp" data-thumbnail="/images/proxmox-ve-instruction/pve-multiple-nic.webp" data-sub-html="<h2>桥接多张物理网卡</h2>">
        <img
            class="lazyload"
            data-src="/images/proxmox-ve-instruction/pve-multiple-nic.webp"
            data-srcset="/images/proxmox-ve-instruction/pve-multiple-nic.webp, /images/proxmox-ve-instruction/pve-multiple-nic.webp 1.5x, /images/proxmox-ve-instruction/pve-multiple-nic.webp 2x"
            data-sizes="auto"
            alt="/images/proxmox-ve-instruction/pve-multiple-nic.webp">
    </a><figcaption class="image-caption">桥接多张物理网卡</figcaption>
    </figure></p>
<h3 id="2-手动添加-usb-物理网卡" class="headerLink">
    <a href="#2-%e6%89%8b%e5%8a%a8%e6%b7%bb%e5%8a%a0-usb-%e7%89%a9%e7%90%86%e7%bd%91%e5%8d%a1" class="header-mark"></a>2. 手动添加 USB 物理网卡</h3><blockquote>
<p>参考官方文档: <a href="https://pve.proxmox.com/pve-docs/chapter-sysadmin.html#sysadmin_network_configuration" target="_blank" rel="noopener noreferrer">SysAdmin - Network Configuration</a></p>
</blockquote>
<p>我遇到这个问题的场景是：我的 mini 主机（GTR5）只有两个 2.5G 网卡，不太够用。而家里的路由器剩下的都是千兆网口，路由器也难以拓展网卡。
网上搜了下 2.5G 交换机又发现价格 429 起步，所以决定买两张 USB 2.5GbE 网卡插在这台小主机上作为便宜的网口拓展方案。</p>
<p>现在网卡有了，有两种方式可以让 PVE 识别到这张网卡：</p>
<blockquote>
<p>好像 PVE 偶尔也能自动识别到网卡，就是比较慢&hellip;</p>
</blockquote>
<ol>
<li>方法一：直接重启机器，然后就能在 Web UI 的 <code>Network</code> 配置中见到这张 USB 网卡了。之后直接把该网卡加入到 vmbr 网桥的 <code>Bridge Ports</code> 中并应用配置，就大功告成了。</li>
<li>方法二：不重启机器实现添加 USB 网卡。如果机器不能重启，就可以走这个流程：
<ol>
<li>首先，使用 <code>ip link</code> 命令打印出当前的所有网络接口</li>
<li>将 2.5GbE 网卡插到 USB3.0 端口上，Linux 将自动识别到它</li>
<li>现在再使用 <code>ip link</code> 命令查看所有网络接口，找到新增的接口名称（通常在输出内容最末尾）。
<ol>
<li>在我的环境中新的 USB 网卡名称为 <code>enx00e04c680178</code></li>
</ol>
</li>
<li>在配置文件 <code>/etc/network/interfaces</code> 的末尾新增一行：<code>iface enx00e04c680178 inet manual</code>（注意替换网卡名称）</li>
<li>现在直接刷新 Web UI 页面， USB 网卡就会出现了。之后直接把该网卡加入到 vmbr 网桥的 <code>Bridge Ports</code> 中并应用配置，就大功告成了。</li>
</ol>
</li>
</ol>
<h3 id="3-配置-wifi-网卡" class="headerLink">
    <a href="#3-%e9%85%8d%e7%bd%ae-wifi-%e7%bd%91%e5%8d%a1" class="header-mark"></a>3. 配置 WiFi 网卡</h3><p>如果主机自带了 WiFi 网卡，启动后 Proxmox VE 能识别到该网卡，但是无法通过 Web UI 修改它的任何配置。</p>
<p>那么本着物尽其用的精神，该如何利用上这张 WiFi 网卡呢？</p>
<p>根据 PVE 官方文档 <a href="https://pve.proxmox.com/wiki/WLAN" target="_blank" rel="noopener noreferrer">WLAN - Proxmox VE Docs</a>，并不建议在 PVE 上使用 WLAN，它存在如下问题：</p>
<ul>
<li>WiFi 自身必须是一个 Linux Bridge 设备，无法被桥接到 vmbr0 等网桥上。因为大多数 Access Point 都会直接拒绝掉未授权的源地址发过来的数据包&hellip;</li>
<li>与有线连接相比，WiFi 的延迟要高得多，而且不太稳定。</li>
</ul>
<p>如果要配置 WLAN 网卡的话，可以直接参考 Debian 的官方文档进行配置：<a href="https://wiki.debian.org/WiFi/HowToUse" target="_blank" rel="noopener noreferrer">How to use a WiFi interface - Debian</a></p>
<p>因此，我觉得将 WiFi 网卡直接 USB 直通给机器内的 OpenWRT 虚拟机来玩，可能是更好的主意。</p>
<p>后续将会更新相关内容&hellip;待续</p>
<h2 id="拓展---cloudinit-高级配置" class="headerLink">
    <a href="#%e6%8b%93%e5%b1%95---cloudinit-%e9%ab%98%e7%ba%a7%e9%85%8d%e7%bd%ae" class="header-mark"></a>拓展 - cloudinit 高级配置</h2><p>PVE 使用 CDROM 只读盘(<code>/dev/sr0</code>)来进行 cloud-init 的配置。
在虚拟机启动后，<code>/dev/sr0</code> 将被卸载。</p>
<p>可挂载上该只读盘，查看其中的初始化配置内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ mkdir cloud-config
</span></span><span class="line"><span class="cl">$ mount /dev/sr0 cloud-config
</span></span><span class="line"><span class="cl">mount: /dev/sr0 is write-protected, mounting read-only
</span></span><span class="line"><span class="cl">$ ls cloud-config
</span></span><span class="line"><span class="cl">meta-data  network-config  user-data
</span></span></code></pre></td></tr></table>
</div>
</div><p>查看其中内容，会发现 <code>user-data</code> 有很多参数都被硬编码了，没有通过 PVE Web Console 暴露出来，导致我们无法自定义这些配置。</p>
<p>比如它硬编码了 <code>manage_etc_hosts: true</code>，强制每次都使用虚拟机的名称作为 hostname.</p>
<p>如果确认有修改这些配置的需求，完全可以修改掉 PVE 代码里的硬编码参数。
通过全文搜索即可找到硬编码参数的位置，以 <code>manage_etc_hosts</code> 为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 在 /usr/share 中全文搜索 manage_etc_hosts 这个关键字</span>
</span></span><span class="line"><span class="cl">grep -r manage_etc_hosts /usr/share
</span></span></code></pre></td></tr></table>
</div>
</div><p>直接就搜索到了硬编码位置是 <code>/usr/share/perl5/PVE/QemuServer/Cloudinit.pm</code>，修改对应的 cloudinit 配置模板，然后重启节点（重启才能重新加载对应的 ruby 程序），即可实现对该硬编码参数的修改。</p>
<h2 id="拓展---自动化配置与监控告警" class="headerLink">
    <a href="#%e6%8b%93%e5%b1%95---%e8%87%aa%e5%8a%a8%e5%8c%96%e9%85%8d%e7%bd%ae%e4%b8%8e%e7%9b%91%e6%8e%a7%e5%91%8a%e8%ad%a6" class="header-mark"></a>拓展 - 自动化配置与监控告警</h2><p>自动化配置相关工具：</p>
<ol>
<li><a href="https://github.com/Telmate/terraform-provider-proxmox/" target="_blank" rel="noopener noreferrer">Telmate/terraform-provider-proxmox</a>: 用户最多，但是只支持管理虚拟机资源</li>
<li><a href="https://github.com/danitso/terraform-provider-proxmox" target="_blank" rel="noopener noreferrer">danitso/terraform-provider-proxmox</a>: stars 少，但是可以管理 PVE 的大部分资源，包括节点、用户、资源池、TLS证书等等
<ul>
<li>代码更顺眼，但是作者忙，没时间合并 pr，导致 Bug 更多一些，而且很久没更新了&hellip;</li>
</ul>
</li>
<li><a href="https://github.com/ryan4yin/pulumi-proxmox" target="_blank" rel="noopener noreferrer">ryan4yin/pulumi-proxmox</a>: 我维护的一个 proxmox 自动配置工具</li>
<li><a href="https://github.com/proxmoxer/proxmoxer" target="_blank" rel="noopener noreferrer">Python SDK</a></li>
</ol>
<p>监控告警：</p>
<ul>
<li><a href="https://github.com/prometheus-pve/prometheus-pve-exporter" target="_blank" rel="noopener noreferrer">prometheus pve expoter</a>: 通过 prometheus+grafana 监控 PVE 集群</li>
</ul>
<h2 id="拓展" class="headerLink">
    <a href="#%e6%8b%93%e5%b1%95" class="header-mark"></a>拓展</h2><h2 id="拓展---其他-qemukvm-相关的虚拟化平台" class="headerLink">
    <a href="#%e6%8b%93%e5%b1%95---%e5%85%b6%e4%bb%96-qemukvm-%e7%9b%b8%e5%85%b3%e7%9a%84%e8%99%9a%e6%8b%9f%e5%8c%96%e5%b9%b3%e5%8f%b0" class="header-mark"></a>拓展 - 其他 QEMU/KVM 相关的虚拟化平台</h2><p>PVE 毕竟是一个商业系统，虽然目前可以免费用，但是以后就不一定了。</p>
<p>如果你担心 PVE 以后会不提供免费使用的功能，或者单纯想折腾折腾的技术，还可以试试下面这些虚拟化平台：</p>
<ul>
<li><a href="https://github.com/retspen/webvirtcloud" target="_blank" rel="noopener noreferrer">webvirtcloud</a>: 其前身是 webvirtmgr，一个完全开源的 QEMU/KVM Web UI，额外提供了用户管理功能。</li>
<li><a href="https://github.com/kubevirt/kubevirt" target="_blank" rel="noopener noreferrer">kubevirt</a>: 基于 Kubernetes 进行虚拟化管理</li>
<li><a href="https://github.com/rancher/harvester" target="_blank" rel="noopener noreferrer">rancher/harvester</a>: Rancher 开源的基于 Kubernetes 的超融合平台(HCI)
<ul>
<li>其底层使用 kubevirt 提供虚拟化能力，通过 longhorn 提供分布式存储能力。</li>
<li>HCI 超融合 = 计算虚拟化 + 网络虚拟化 + 分布式存储，它和传统的虚拟化软件最大的不同是：分布式存储。</li>
<li>企业级场景下一般至少得 10GbE 网络 + SSD 才能 hold 住 HCI 超融合架构。</li>
<li>超融合对存储的一些要求：
<ul>
<li>软件定义 – 解除硬件绑定，可通过升级拓展更丰富的功能，自动化能力高</li>
<li>全分布式架构 - 扩展性好，消除单点故障风险</li>
<li>高可靠性 - 智能的故障恢复功能，丰富的数据保护手段</li>
<li>高性能 – 支持多种存储介质，充分挖掘和利用新式硬件的性能</li>
<li>高度融合 – 架构简单并易于管理</li>
</ul>
</li>
<li>超融合架构可以降低私有云的构建与维护难度，让私有云的使用维护和公有云一样简单。</li>
<li>超融合架构下，虚拟机的计算和存储是完全高可用的：计算资源能智能动态更换，存储也是分布式存储，底层计算和存储也可以很简单的扩缩容。</li>
</ul>
</li>
</ul>
<p>我打算有时间在 PVE 集群里跑个 rancher/harvester 玩玩 emmmm</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/49118355" target="_blank" rel="noopener noreferrer">KVM 虚拟化环境搭建 - ProxmoxVE</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/49120559" target="_blank" rel="noopener noreferrer">KVM 虚拟化环境搭建 - WebVirtMgr</a></li>
<li><a href="https://pve.proxmox.com/wiki/Main_Page" target="_blank" rel="noopener noreferrer">Proxmox Virtual Environment - Proxmox WIKI</a></li>
<li><a href="https://wiki.archlinux.org/title/QEMU#top-page" target="_blank" rel="noopener noreferrer">QEMU - Arch Linux WIKI</a></li>
<li><a href="https://foxi.buduanwang.vip/category/virtualization/pve/" target="_blank" rel="noopener noreferrer">佛西博客 - PVE 相关</a>: 这位博主写了很多 pve 相关的内容，而且比较有深度</li>
</ul>
]]></content></entry><entry><title type="html">刻意练习</title><link href="https://thiscute.world/posts/deliberate-practice/"/><id>https://thiscute.world/posts/deliberate-practice/</id><author><name>ryan4yin</name></author><published>2022-10-05T13:31:00+08:00</published><updated>2022-10-05T13:31:00+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/deliberate-practice/deliberate-practice-achieve-mastery-in-anything.webp" height="1280" width="720"><figcaption></figcaption>
        </figure><p>我最近理解到一个事实——<strong>许多知识或者技能，都是可以通过正确的学习方法，加上短时间大量的练习，就能达到 60 分及格标准的</strong>。
而这个及格水平，相对于完全没有进行过这样训练的其他人而言，可能就已经很惊艳了。</p>
<p>如果你总是半途而废，可能只是你受了快餐式短期快乐的诱惑而放弃，或者你潜意识觉得它并不重要从而无法坚持。</p>
<h2 id="佐证之一---英语口语" class="headerLink">
    <a href="#%e4%bd%90%e8%af%81%e4%b9%8b%e4%b8%80---%e8%8b%b1%e8%af%ad%e5%8f%a3%e8%af%ad" class="header-mark"></a>佐证之一 - 英语口语</h2><p>受限于国内英语教育的方法，很多的同学朋友口语发音都比较糟糕。
但我实践发现，纠正自己的口语发音，达到到 60 分水平，并不是一件很难的事。
真正的问题在于，绝大多数人从没有去查过相关资料、并进行大量的练习。</p>
<p>我大三之前发音也惨不忍睹，然后因为个人兴趣与需求想把英语学好，就查了很多资料，跟着恶魔奶爸给出的英语口语学习方法，花了大概一个月的时间专门练了一波，效果立竿见影。</p>
<h2 id="佐证之二---练字" class="headerLink">
    <a href="#%e4%bd%90%e8%af%81%e4%b9%8b%e4%ba%8c---%e7%bb%83%e5%ad%97" class="header-mark"></a>佐证之二 - 练字</h2><p>我堂弟之前分享过他练字的经历给我。</p>
<p>他大学之前的字跟我一样丑不拉几。
大学期间因为无聊，就专门查了很多资料，定下了练字计划。
统共就练了两三个月，现在他写的字的美观程度，已经吊打我这个菜鸡。</p>
<h2 id="佐证之三---减肥" class="headerLink">
    <a href="#%e4%bd%90%e8%af%81%e4%b9%8b%e4%b8%89---%e5%87%8f%e8%82%a5" class="header-mark"></a>佐证之三 - 减肥</h2><p>我有一个同村的朋友，也是我小学同学。
他从初中开始就胖得不行，一直到结婚工作，体重都没减下来。</p>
<p>但是在去年因为婚姻变故以及一些其他原因，比较失意，突然就打算减肥，就开始坚持跑步。</p>
<p>跑多远忘了，可能慢慢加量到每天十公里吧。
他晚饭不吃，饿了就疯狂喝水。一开始因为体重太高，一趟下来膝关节直接跑到浮肿。</p>
<p>就这样坚持了大概三个月，直接瘦了 50 斤，整个人清爽帅气太多了。</p>
<h2 id="结语" class="headerLink">
    <a href="#%e7%bb%93%e8%af%ad" class="header-mark"></a>结语</h2><p>经常听人说要「<strong>踏出舒适区</strong>」、「<strong>延迟满足</strong>」，其实是一个道理。</p>
<p>即使掌握了正确的练习方法，如果因为坚持了三天发现没效果，就坚持不下去了，那无论如何都不会有好的效果。
可如果把这个时间放大十倍——三十天，视目标的难度，就会开始出现比较明显的效果了。</p>
<p>如果你对自己比较狠（高强度练习），再把坚持的时间再放大到三个月，你的技能水平就能获得相当显著的提升！就像我那位减肥的朋友、我练字的堂弟一样！</p>
<p>三个月的时间，对于学习一项技能而言，真的是很短的一段时间，但是却有能力使你入门一项终生受益的技能。
对未来的自己好一点，多投资投资自己，诸君共勉。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://www.youtube.com/watch?v=1-sjUoGO250" target="_blank" rel="noopener noreferrer">Deliberate Practice: Achieve Mastery in Anything - Youtube</a></li>
</ul>
]]></content></entry><entry><title type="html">Learn English Again</title><link href="https://thiscute.world/posts/learn-english-again/"/><id>https://thiscute.world/posts/learn-english-again/</id><author><name>ryan4yin</name></author><published>2022-09-04T13:22:00+08:00</published><updated>2022-09-04T13:22:00+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/learn-english-again/english-word.webp" height="626" width="313"><figcaption></figcaption>
        </figure><h3 id="一缘起与学习目标" class="headerLink">
    <a href="#%e4%b8%80%e7%bc%98%e8%b5%b7%e4%b8%8e%e5%ad%a6%e4%b9%a0%e7%9b%ae%e6%a0%87" class="header-mark"></a>一、缘起与学习目标</h3><p>工作了三年多了，我的英语阅读水平大致一直处在「能较流畅地阅读各类技术文档，但是阅读与理解速度不够快」的程度。
工作以来没有专门去学过英语，不过会有意识地尽量去阅读英文技术文档、英文技术书籍，或者在 Youtube 上找一些国际技术会议视频学习（如 KubeCon、IstioCon），所以这三年多我的英语水平提升应该是有一个缓慢的提升。</p>
<p>这周五的时候（是的就是 2022-09-02），偶然发现自己手机里还装了个英语流利说 APP，安装了两年多但一直没碰过它 emmmm 突然来了兴趣就打算试用一波，由此开始了我的重学英语之旅&hellip;</p>
<p>首先肯定是要测试一下自己的英文水平，确定英语学习的起点。流利说 APP 把英语分成 7 个 Level，它评价我属于 Lv.5，大致对应 CEFR 评级 B2。五个评级维度中我的发音是最好的，口语是最差的。而词汇量大概在 5000 这个档位（我觉得如果算上我懂的计算机名词可能会更高些 emmmm）。</p>
<p>测出的结果跟我的自我感觉基本吻合。
之前有跟 AWS 工程师做过几次英语沟通，发现我的口语勉强可以支撑日常技术沟通，但是感觉很费劲，原因显然是口语基本没怎么练过。
而我的发音之所以还不错，主要是大三的时候专门跟着奶爸推荐的《赖世雄美语音标》、《American Spoken English》等资料练习过，我当时还写过篇文章讲这个——<a href="https://thiscute.world/posts/learning-english/" target="_blank" rel="noopener noreferrer">学英语啊学英语</a>。</p>
<p>先不提细节，总之我就是这么着，突然对学英语又来了兴趣~ 当天就深入探索了下英语流利说这个 APP，又花 49 元买了一个月的「懂你英语 A+ 个性化学习计划」，这个计划还给分配微信学习社群跟班主任，每天坚持 30 到 60 分钟。第一天体验这个学习计划，感觉确实跟我比较契合，而且也不枯燥，打算坚持一个月试试。</p>
<p>最后，为了更有目的性地提升自己的英语，我总结了下我此次「重学英语」的目的，以及当前的水平（按优先级排序）：</p>
<ul>
<li><strong>能流畅地用英语交流</strong>：流利说测试显示我这项技能很差，亟待提升。</li>
<li><strong>流畅阅读各类英文资料</strong>：我目前可以无障碍阅读大多数编程相关的英文博客跟文档，但是阅读速度不够快，有些长句经常要读好几次才能理解大意。另外词汇量偏低，非技术类的资料我读起来非常吃力。</li>
<li><strong>无障碍看美剧</strong>：我的听力水平跟词汇水平大概差不多，看美剧还是得有个英文字幕，还需要提升。</li>
<li><strong>写英文博客</strong>：高中毕业后就没学过语法，也没怎么练过写作，词汇量又低，我的写作能力显然还有很大的提升空间。</li>
</ul>
<h3 id="二英语自学路线完全指南" class="headerLink">
    <a href="#%e4%ba%8c%e8%8b%b1%e8%af%ad%e8%87%aa%e5%ad%a6%e8%b7%af%e7%ba%bf%e5%ae%8c%e5%85%a8%e6%8c%87%e5%8d%97" class="header-mark"></a>二、英语自学路线完全指南</h3><p>因为最近对英语来了电，就打算深入了解下市面上常见的英语学习路径，争取找到最佳学习路线。</p>
<h4 id="1-不花钱的自学路线" class="headerLink">
    <a href="#1-%e4%b8%8d%e8%8a%b1%e9%92%b1%e7%9a%84%e8%87%aa%e5%ad%a6%e8%b7%af%e7%ba%bf" class="header-mark"></a>1. 不花钱的自学路线</h4><p>首先是不花钱的自学路线，这个我在大三时有过实践，当时打算考研，专门练过一波英语，大致路线是这样的：</p>
<ul>
<li>恶魔奶爸总结的 <a href="https://zhuanlan.zhihu.com/p/20836532" target="_blank" rel="noopener noreferrer"><strong>练习英语口语的办法</strong></a>，本人实测效果显著
<ul>
<li>其中介绍的 ESLPod、EnglishPod 等材料，不仅可以提升语感，也能帮助提升听力。</li>
</ul>
</li>
<li>如果是进阶的话，可以<strong>去 Youtube 上看一些流行的 Talk Show</strong>，这类视频很有意思、语速快信息量又大，是很合适的进阶学习材料
<ul>
<li>以看视频的方式学英语，一个要点就是「<strong>重复</strong>」或者说「<strong>精听</strong>」。</li>
<li>「一点英语」就是在这上面下了不少功夫，要选那种第一遍听有难度的视频，最好内容还比较有趣（比如 Talk Show 就比较有意思）。</li>
<li>可行的学习方法：第一遍带字幕看视频，但是尽量别看字幕；第二遍带字幕反复精看听不懂的部分，第三遍再完全关掉字幕验证学习效果。</li>
</ul>
</li>
<li>还有就是很多人推荐的<strong>阅读英文原版书</strong>
<ul>
<li>一开始可能会读得很慢，这个时候最重要的就是坚持！阅读量上来了，速度自然就提升了。</li>
<li>让自己更容易坚持的阅读方法：
<ul>
<li>要找一些<strong>你感兴趣的</strong>、难度适中的原版书（比如感兴趣的小说、专业相关的技术书等）。因为阅读的首要点是要能感受到乐趣，否则会很枯燥，很难坚持。</li>
<li>然后<strong>要做好规划并坚持执行</strong>，比如每天读 10 页。</li>
</ul>
</li>
</ul>
</li>
<li>当然你也可以走传统的背单词、词组、例句这样的路线，这条路线的好处是能快速提升自己的英语能力，但是相对的也很难坚持。
<ul>
<li>常见的有新东方的词汇录播课（网上能找到免费的资料分享），以前听过新东方朱伟老师的《恋练有词》，感觉挺不错的。</li>
<li>不背单词、百词斩这类 APP 也可以试试，不过我个人体验是基本坚持不了多久&hellip;</li>
</ul>
</li>
<li><strong>每日英语听力</strong>
<ul>
<li>跟欧路词典是同一家公司做的，很良心。</li>
<li>不过因为我已经买了其他课程了，这个 APP 目前用得比较少。</li>
</ul>
</li>
<li><a href="https://www.bilibili.com/video/BV1U7411a7xG/" target="_blank" rel="noopener noreferrer">每日英语听写 Daily English Dictation 1-400</a>
<ul>
<li>这是 Youtube 上相当火的一个英语听写系列视频，做得非常棒，坚持听完 400 期，听力就神功大成了！</li>
<li>个人感觉起码得有个 CET4 水平，才能比较舒服地跟这个课程。</li>
</ul>
</li>
<li>一些对话、角色设定、世界观设定较多的游戏也是学英语的好材料，比如「Genshin Imapct」、「DEEMO 2」，或者一些 Galgame 都可。娱乐跟英语两不误 emmm</li>
</ul>
<p><figure><a class="lightgallery" href="/images/learn-english-again/genshin-impact-noelle.webp" title="/images/learn-english-again/genshin-impact-noelle.webp" data-thumbnail="/images/learn-english-again/genshin-impact-noelle.webp" data-sub-html="<h2>Genshin Impact 里超飒的重剑女仆 Noelle</h2>">
        <img
            class="lazyload"
            data-src="/images/learn-english-again/genshin-impact-noelle.webp"
            data-srcset="/images/learn-english-again/genshin-impact-noelle.webp, /images/learn-english-again/genshin-impact-noelle.webp 1.5x, /images/learn-english-again/genshin-impact-noelle.webp 2x"
            data-sizes="auto"
            alt="/images/learn-english-again/genshin-impact-noelle.webp">
    </a><figcaption class="image-caption">Genshin Impact 里超飒的重剑女仆 Noelle</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="/images/learn-english-again/demo2-talk-1.webp" title="/images/learn-english-again/demo2-talk-1.webp" data-thumbnail="/images/learn-english-again/demo2-talk-1.webp" data-sub-html="<h2>DEEMO 2 中丰富的对话内容</h2>">
        <img
            class="lazyload"
            data-src="/images/learn-english-again/demo2-talk-1.webp"
            data-srcset="/images/learn-english-again/demo2-talk-1.webp, /images/learn-english-again/demo2-talk-1.webp 1.5x, /images/learn-english-again/demo2-talk-1.webp 2x"
            data-sizes="auto"
            alt="/images/learn-english-again/demo2-talk-1.webp">
    </a><figcaption class="image-caption">DEEMO 2 中丰富的对话内容</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="/images/learn-english-again/demo2-collections.webp" title="/images/learn-english-again/demo2-collections.webp" data-thumbnail="/images/learn-english-again/demo2-collections.webp" data-sub-html="<h2>DEEMO 2 的一些设定</h2>">
        <img
            class="lazyload"
            data-src="/images/learn-english-again/demo2-collections.webp"
            data-srcset="/images/learn-english-again/demo2-collections.webp, /images/learn-english-again/demo2-collections.webp 1.5x, /images/learn-english-again/demo2-collections.webp 2x"
            data-sizes="auto"
            alt="/images/learn-english-again/demo2-collections.webp">
    </a><figcaption class="image-caption">DEEMO 2 的一些设定</figcaption>
    </figure></p>
<p>上面主要是针对 CET4 四级以上水平的英语学习者，如果基础比较差，可以考虑按照恶魔奶爸推荐的零基础英语学习路线进行自学：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/19768351" target="_blank" rel="noopener noreferrer">英语：壹章 - 恶魔奶爸</a>：针对零基础/基础超级不好的同学</li>
<li><a href="https://zhuanlan.zhihu.com/p/19768409" target="_blank" rel="noopener noreferrer">英语：贰章 - 恶魔奶爸</a>：针对处于英语初级阶段的同学</li>
<li><a href="https://zhuanlan.zhihu.com/p/19768454" target="_blank" rel="noopener noreferrer">英语：叁章 - 恶魔奶爸</a>：针对大学四六级水平的同学（就跟我上面列的差不多了）</li>
</ul>
<h4 id="2-花钱抄捷径" class="headerLink">
    <a href="#2-%e8%8a%b1%e9%92%b1%e6%8a%84%e6%8d%b7%e5%be%84" class="header-mark"></a>2. 花钱抄捷径</h4><p>而对于我这种上班族或者其他有闲钱的学生，而且不求快速提升英语能力的人而言，如果愿意花点小钱，也是有捷径可以抄的。</p>
<p>首先就是线下课程跟线上视频课程（比如新东方、山姆英语），这个没时间参加，时间安排也不够灵活，而且可能会比较枯燥，直接 Pass.</p>
<p>其次就是英语学习类 APP 了，这个市面上还有挺多的，我试用了一波后感觉很适合我，并且筛选出了下面几个比较中意的 APP：<strong>欧路词典</strong>、<strong>知米阅读</strong>、<strong>开言英语</strong>以及<strong>一点英语</strong>。</p>
<p>并且使用上述几款软件提供的英语能力测试，完整评估了下我的英语水平。下图从左至右依次是一点英语、开言英语，以及英语流利说的整体英语水平跟口语水平两项测试结果（结果偏高，仅供参考）：</p>
<p><figure><a class="lightgallery" href="/images/now/ryan4yin-english-level.webp" title="/images/now/ryan4yin-english-level.webp" data-thumbnail="/images/now/ryan4yin-english-level.webp" data-sub-html="<h2>各 APP 的英语水平测评结果（一点英语的结果明显偏高）</h2>">
        <img
            class="lazyload"
            data-src="/images/now/ryan4yin-english-level.webp"
            data-srcset="/images/now/ryan4yin-english-level.webp, /images/now/ryan4yin-english-level.webp 1.5x, /images/now/ryan4yin-english-level.webp 2x"
            data-sizes="auto"
            alt="/images/now/ryan4yin-english-level.webp">
    </a><figcaption class="image-caption">各 APP 的英语水平测评结果（一点英语的结果明显偏高）</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="/images/learn-english-again/%e6%b5%81%e5%88%a9%e8%af%b4-English-Level.webp" title="/images/learn-english-again/流利说-English-Level.webp" data-thumbnail="/images/learn-english-again/流利说-English-Level.webp" data-sub-html="<h2>流利说英语评级对照表</h2>">
        <img
            class="lazyload"
            data-src="/images/learn-english-again/%e6%b5%81%e5%88%a9%e8%af%b4-English-Level.webp"
            data-srcset="/images/learn-english-again/%e6%b5%81%e5%88%a9%e8%af%b4-English-Level.webp, /images/learn-english-again/%e6%b5%81%e5%88%a9%e8%af%b4-English-Level.webp 1.5x, /images/learn-english-again/%e6%b5%81%e5%88%a9%e8%af%b4-English-Level.webp 2x"
            data-sizes="auto"
            alt="/images/learn-english-again/流利说-English-Level.webp">
    </a><figcaption class="image-caption">流利说英语评级对照表</figcaption>
    </figure></p>
<p>下面详细介绍下我比较推荐的英语学习类 APP 跟课程：</p>
<ul>
<li><strong>欧路词典</strong>
<ul>
<li>最牛逼的词典软件，非常适合用于日常查词。</li>
<li>最强的一点在于它能导入各种离线词典，<a href="https://site.douban.com/195274/widget/notes/12076215/note/265205135/" target="_blank" rel="noopener noreferrer">详见恶魔奶爸有分享的词典文章</a>，我用到的有如下几本：
<ul>
<li>中英双解词典
<ul>
<li><strong>柯林斯双解 Collins Cobuild Advanced Learner&rsquo;s English Dictionary</strong>：包含中文翻译、英英释义跟句子示例，还提供 1-5 的单词使用频率标识</li>
<li><strong>Microsoft Bing Dictionary</strong>：是网友抓取制作的必应大词典，跟 Collins Cobuild 类似，包含级别（CET4/CET6/GRE）、中文翻译、英英释义跟句子翻译</li>
</ul>
</li>
<li>英英词典
<ul>
<li><strong>LDOCE朗文当代5 英英版</strong>: 光体积就 1G，包含了所有单词例句的录音，是非常详尽的一本英英学习词典。收词量相当大，短语、用法完备</li>
</ul>
</li>
<li>词组搭配、同义词词典
<ul>
<li>牛津搭配词典第二版</li>
<li>Collins Thesaurus</li>
<li>Collins COBUILD English Usage</li>
<li>WordNet 3.0</li>
<li><strong>USE THE RIGHT WORD</strong>: 同义近义词用法解释，很详细</li>
<li>Merriam-Webster&rsquo;s Vocabulary Builder: 通过词根词缀来关联起各种相关单词</li>
<li>英语常用词疑难用法手册</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>薄荷阅读</strong>：199 元 / 100 天
<ul>
<li><strong>阅读原版书学习英语</strong></li>
<li>用它辅助阅读原版书的好处有：
<ul>
<li>会提前帮你选出生词进行预习</li>
<li>提供配套的有声书，可以听书也可以看书</li>
<li>随时双击查词，查词非常方便</li>
<li>学习完成后还有提供配套的讲义，对各项单词、词组、疑难句进行详细解释，这个感觉会非常有用！</li>
</ul>
</li>
<li>缺点
<ul>
<li>每逢购物活动就开始打广告，让人有点烦。</li>
<li>相比后面的竞品，价格有点太高了&hellip;</li>
</ul>
</li>
</ul>
</li>
<li><strong>知米阅读</strong>：199 元，365 天畅读所有书单
<ul>
<li><strong>阅读原版书学习英语</strong></li>
<li>跟薄荷阅读几乎一样的模式，功能大同小异。
<ul>
<li>但是它的年费会员仅为薄荷阅读 VIP 的 1/5，而且还能畅读所有书单！</li>
</ul>
</li>
<li>个人感觉它的小程序设计感比薄荷阅读更好</li>
</ul>
</li>
<li><strong>一点英语</strong>：
<ul>
<li>折后 1998 元 270 天</li>
<li>如果坚持打卡 270 天，期末还返 1000 现金 + 500 续课券（实测大半年下来意外太多，基本不可能拿到、但是万一就成功了呢&hellip;）</li>
<li><strong>通过「演讲/动漫/喜剧/音乐现场」等各种视频内容学习英语单词，同时练习听力跟口语</strong></li>
<li>相比其他 APP，它的课程<strong>会有趣很多，不那么枯燥</strong>。我觉得用它练习听力非常合适。</li>
<li>缺陷：
<ul>
<li>它的视频语料有部分跟单词有点对不上，有时候会遇上，不过无伤大雅。</li>
<li>它背单词的功能跟「不背单词」或者「欧路词典」差距较大。其中英解释比较简陋、记忆算法强度没不背单词高，也没有词根词缀功能，此外例句偶尔会有些错误。</li>
</ul>
</li>
</ul>
</li>
<li><strong>开言英语</strong>
<ul>
<li><strong>通过外教录制的视频 + 程序控制实现了一定的可交互性</strong>，感觉课程比英语流利说做得要有趣些。</li>
<li><strong>开言英语的 WeMeet 英语角体验真的超棒</strong>，而且还免费！
<ul>
<li>第一次参加时，一起聊天的两位朋友，一位在万豪酒店工作了差不多 10 年，另一位是产品经理，在腾讯、搜狐、美团等公司工作了差不多 15 年，聊得非常开心，很有收获！</li>
</ul>
</li>
<li>价格
<ul>
<li>外教系统课是 2598 一年，提供海量外教视频互动课跟音频课</li>
<li>还有个外教视频课，互动性会更高，价格是 1598 一年</li>
</ul>
</li>
<li>《潘吉 Jenny 告诉你》这个口碑在，我觉得开言英语的外教课程是可以考虑的</li>
</ul>
</li>
<li><a href="https://www.koolearn.com" target="_blank" rel="noopener noreferrer"><strong>新东方在线</strong></a>
<ul>
<li>在线录播课、直播课，从以前学过的考研英语看，还是很专业、很成体系的。</li>
<li>对 BEC、雅思、托福都有对应的课程可选，价格对工作党而言问题不大。</li>
</ul>
</li>
<li><strong>VoiceTube</strong>：价格还不太清楚
<ul>
<li>应该是最早做「看视频学英语」功能的 APP 之一，它最初发布于 2013/09，而前面介绍的「一点英语」最初发布于 2018 年（而且 UI 布局也跟 VoiceTube 很类似）。</li>
<li>获得了 Facebook 2016 年年度最佳 APP 奖项</li>
<li>但是（因为版权原因）它基本都是直接内嵌的 Youtube 视频，它需要同时安装 Youtube（同时还需要一些使你能访问 Youtube 的特殊手段）。</li>
</ul>
</li>
</ul>
<p>另外一些我用过但是不推荐的 APP 也简单说下问题所在：</p>
<ul>
<li>英语流利说 懂你英语 A+
<ul>
<li>课程质量确实不错，但是<strong>全都是 AI 语音，虽然很标准，但是太机械了，不带啥感情</strong>，我学了才 6 天就开始厌倦了。个人不推荐选它</li>
</ul>
</li>
<li>百词斩
<ul>
<li>更适合用于趣味性背单词</li>
</ul>
</li>
</ul>
<blockquote>
<p>对很多学生党（比如大学期间的我）而言这些 APP 一年下来好几千的费用确实是难以承担，但是对我这样的工作党而言，不失为一个很好的学习手段。</p>
</blockquote>
<p>上述这些软件最大的优势是「互动」，这会使它比单纯自学有趣很多，更容易坚持。</p>
<p>除薄荷英语外，其他三个 APP 都有提供长短不一的会员体验时间，有兴趣的话可以自己试用下~</p>
<p>总结下，目前已买课程：</p>
<ul>
<li>「<strong>知米阅读</strong>」199 元，365 天畅读所有书单。看的第一本书是「Time Machine」。阅读体验很不错，而且比薄荷阅读便宜太多了。</li>
<li>「<strong>一点英语</strong>」看视频/听歌学英语真的非常棒！已经花 1998 元买了 270 天的会员
<ul>
<li><del>争取每天打卡，赚到 1000 现金返还</del>目前（2022-11-07）进度是 62 天，已经漏打卡 5 天&hellip;部分原因是漏打卡第一天后，争取每天打卡的执念就没那么强烈了，偶尔哪一天太累了或者别的事没搞完，就直接不打卡了&hellip;</li>
</ul>
</li>
<li>「薄荷英语」花了 199 元买了《一个人的朝圣》这个原版书，书已经看完了。内容不错，就是跟知米阅读比太贵了。</li>
<li>「英语流利说」花了 49 元，买了个 30 天的懂你英语 A+ 体验课，但是因为前述原因（AI 语音太死板，听多了烦）就用了一周就没继续用了。</li>
</ul>
<h2 id="三如何练习英语口语" class="headerLink">
    <a href="#%e4%b8%89%e5%a6%82%e4%bd%95%e7%bb%83%e4%b9%a0%e8%8b%b1%e8%af%ad%e5%8f%a3%e8%af%ad" class="header-mark"></a>三、如何练习英语口语？</h2><p>首先，上面已经提过了，「开言英语」的线上英语角 WeMeet 非常的棒。这个功能是免费的，但是需要交 5 块钱押金，我觉得这 5 块钱的押金大大提升了这个英语角的队友质量，能确保大家都是有强烈意愿去用英语聊天的。
实际的体验也非常棒，不仅能练习口语，还能交到各行各业喜欢英语的朋友。</p>
<p>其次，如果你的上网工具能使你用上 Discord，也有一些英语学习的 Discord Server 非常值得推荐，你能在上面跟各种母语、各个国家、各种口音的朋友一起用英语聊天，体验还不错，还能交到有意思的国外朋友。</p>
<p>英语学习 Discord Server 地址:</p>
<ul>
<li><a href="https://discord.gg/english" target="_blank" rel="noopener noreferrer">https://discord.gg/english</a></li>
<li><a href="https://discord.gg/c-e" target="_blank" rel="noopener noreferrer">https://discord.gg/c-e</a></li>
</ul>
<p>加入 Server 后要往下翻很多页才能到 English Practice 部分，目前分别有 8 个「Beginner English」聊天室跟 8 个「Intermeidate/Advanced English」聊天室，赶快加入开聊吧~</p>
<p>此外，如果你想走高效的氪金路线，也有很多<strong>线上真人上外教</strong>平台供你选择，主要有如下几个：</p>
<ul>
<li><a href="https://www.lingoda.com/en/" target="_blank" rel="noopener noreferrer">Lingoda</a>: 被认为是最佳成人英语学习平台之一，它有部分课还提供了学费返还机制，可以了解下。</li>
<li><a href="https://www.cambly.com/english" target="_blank" rel="noopener noreferrer">Cambly</a>: twitter 上推友推荐的，最流行的英语学习平台之一，真人外教一对一教学
<ul>
<li>据说打折时很便宜，优惠价只要人民币 30 元 30 分钟</li>
</ul>
</li>
<li><a href="https://preply.com/en/online/english-tutors" target="_blank" rel="noopener noreferrer">Preply</a>: 我用的词汇测试站点，现在就属于这家公司的产品。据说比较专业，提供 4-5 人小组教学跟一对一教学两种学习模式
<ul>
<li>貌似比较贵：$15-20 per hour</li>
<li>你还可以在这个站点上面应聘汉语教学（有 20%-30% 的抽成，150 美刀才能提现）</li>
</ul>
</li>
<li><a href="https://www.verbling.com/zh" target="_blank" rel="noopener noreferrer">Verbling</a>: 一样也是一个老牌语言学习站点
<ul>
<li>据说价格比较优惠，还支持免费试课。</li>
<li>跟 Preply 一样你也可以在这个站点上面应聘汉语教学作为兼职。</li>
</ul>
</li>
<li><a href="https://www.italki.com/en" target="_blank" rel="noopener noreferrer">ITalk</a>: 国内创办的比较大的语言交换平台，据说是最 casual 的学习平台，所以不太适合自我驱动力不强的朋友。</li>
</ul>
<h2 id="四总而言之" class="headerLink">
    <a href="#%e5%9b%9b%e6%80%bb%e8%80%8c%e8%a8%80%e4%b9%8b" class="header-mark"></a>四、总而言之</h2><p>嗯，毕竟是花了钱的，这次的大目标就是用近一年的时间，全面提升英语水平。</p>
<p>听说考 BEC 高级对英语水平提升帮助很大，为了提供一点压力与动力，就定一个硬性目标：</p>
<ul>
<li>2023 年达到 CEFR 的 C1 等级，报考并取得 BEC 高级证书</li>
<li>2023 年底词汇量超过 10000</li>
</ul>
<h2 id="其他资料" class="headerLink">
    <a href="#%e5%85%b6%e4%bb%96%e8%b5%84%e6%96%99" class="header-mark"></a>其他资料</h2><p>文末再分享几篇我收藏的英语学习相关的资料，个人感觉读了有些帮助：</p>
<ul>
<li><a href="https://www.zhihu.com/question/35779181/answer/64441076" target="_blank" rel="noopener noreferrer">编程的技术资料好多都是全英文的该怎么学习？</a>
<ul>
<li>关键点总结：你要能接受自己不能 100% 看懂资料</li>
</ul>
</li>
<li><a href="https://www.zhihu.com/question/20364185/answer/68330933" target="_blank" rel="noopener noreferrer">如何做到流畅阅读英文资料和听懂国外公开课？</a>
<ul>
<li>提升阅读速度过程中<strong>一个最基本的因素就是阅读量</strong>，跳出舒适区，刻意练习。</li>
</ul>
</li>
<li><a href="https://www.zhihu.com/question/20727479/answer/57511389" target="_blank" rel="noopener noreferrer">如何有效提高英语写作？</a>
<ul>
<li>关键点总结：提高英文写作水平的第一步是「大量阅读」</li>
</ul>
</li>
<li><a href="https://www.zhihu.com/question/26757493/answer/33915992" target="_blank" rel="noopener noreferrer">YouTube 上有哪些质量不错的英文教学视频和英文视频？</a>
<ul>
<li>这些视频很多都能在 Bilibili 上搜到</li>
</ul>
</li>
<li><a href="https://www.zhihu.com/question/20189363/answer/29690361" target="_blank" rel="noopener noreferrer">通过「听写」学习英语，效果怎么样？</a></li>
<li><a href="https://www.zhihu.com/question/25379922/answer/30602611" target="_blank" rel="noopener noreferrer">英语学习过程中如何有效地提升词汇功底？</a>
<ul>
<li>关键点总结：学习一门语言文字的最短最佳途径，是掌握它的词根（root），也就是那些其他单词借以形成的原生词</li>
</ul>
</li>
<li><a href="https://www.zhihu.com/topic/19558435/top-answers" target="_blank" rel="noopener noreferrer">知乎「英语学习」话题下的精华回答</a></li>
</ul>
<hr>
<h2 id="学习成果记录---持续更新" class="headerLink">
    <a href="#%e5%ad%a6%e4%b9%a0%e6%88%90%e6%9e%9c%e8%ae%b0%e5%bd%95---%e6%8c%81%e7%bb%ad%e6%9b%b4%e6%96%b0" class="header-mark"></a>学习成果记录 - 持续更新</h2><p>先简单记录下学习时间线：</p>
<ul>
<li>2022/9 - 2022/12
<ul>
<li>平均每天大概花 30 分钟学习英语（偶尔兴之所至可能会花 1 小时甚至更多，也偶尔会断几天）。</li>
<li>主要学习方法就是通过「薄荷阅读」「知米阅读」读英文原版书，以及通过「<strong>一点英语</strong>」看视频练听力、记单词。</li>
</ul>
</li>
<li>2023/1: 基本算是休息了一个月，没怎么学。</li>
<li>未完待续</li>
</ul>
<h3 id="1-词汇量" class="headerLink">
    <a href="#1-%e8%af%8d%e6%b1%87%e9%87%8f" class="header-mark"></a>1. 词汇量</h3><p>词汇量测试结果按时间排序如下，使用的测试工具是 <a href="https://preply.com/en/learn/english/test-your-vocab" target="_blank" rel="noopener noreferrer">Test Your Vocabulary</a> ：</p>
<ul>
<li>2022 年 9 月初，测试结果：4700 词（无截图）</li>
<li>2022-10-18 词汇量测试结果：5100 词 <figure><img src="/images/learn-english-again/2022-10-18-test-your-vocabulary-result.webp" width="40%"/><figcaption>
            <h4>2022-10-18 词汇量测试结果：5100 词</h4>
        </figcaption>
</figure>
</li>
<li>2022-11-17 词汇量测试结果：5600 词 <figure><img src="/images/learn-english-again/2022-11-17-test-your-vocabulary-result.webp" width="65%"/>
</figure>
</li>
<li>2022-12-19 词汇量测试结果： 6300 词 <figure><img src="/images/now/2022-12-19-test-your-vocabulary-result.webp" width="40%"/>
</figure>
</li>
<li>2023-01-02 词汇量测试结果：6583 词 <figure><img src="/images/now/2023-01-02-test-your-vocabulary-result.webp" width="70%"/>
</figure>
</li>
<li>2023 年 1 月份暂停了学习，词汇量基本没涨，算是休息了一个月。</li>
</ul>
<h3 id="2-口语交流能力" class="headerLink">
    <a href="#2-%e5%8f%a3%e8%af%ad%e4%ba%a4%e6%b5%81%e8%83%bd%e5%8a%9b" class="header-mark"></a>2. 口语交流能力</h3><p>2022 年只是参与了两次「开言英语」的线上英语角 WeMeet，另外探索了下学习方法，但是时间原因未持续推进。</p>
<p>计划在 2023 年进行专门练习，未完待续&hellip;</p>
<h3 id="3-其他进展" class="headerLink">
    <a href="#3-%e5%85%b6%e4%bb%96%e8%bf%9b%e5%b1%95" class="header-mark"></a>3. 其他进展</h3><ul>
<li>写作能力
<ul>
<li>计划在 2023 年进行专门练习，未完待续&hellip;</li>
</ul>
</li>
<li>阅读能力
<ul>
<li>2022 年的 4 个月里，阅读是我提升词汇量的主要手段之一，看统计读了有 15 万词，词汇量跟阅读速度都有明显提升。</li>
<li><figure><img src="/images/now/mintreading-first-100days-achivement.webp" width="35%"/><figcaption>
            <h4>在薄荷阅读上读完的第一本英语原版书</h4>
        </figcaption>
</figure>
</li>
</ul>
</li>
</ul>
]]></content></entry><entry><title type="html">分布式数据库的一致性问题与共识算法</title><link href="https://thiscute.world/posts/consistency-and-consensus-algorithm/"/><id>https://thiscute.world/posts/consistency-and-consensus-algorithm/</id><author><name>ryan4yin</name></author><published>2022-08-07T04:11:23+08:00</published><updated>2022-08-07T04:11:23+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/consistency-and-consensus-algorithm/featured-image.webp" height="974" width="312"><figcaption></figcaption>
        </figure><blockquote>
<p>个人笔记，不保证正确！</p>
</blockquote>
<p>谈到分布式数据库，不论是 Etcd/Zookeeper 这样的中心化数据库，还是 Ethereum 区块链这样的去中心化数据库，都避免不了两个关键词：「<strong>一致性</strong>」跟「<strong>共识</strong>」。</p>
<p>本文是笔者学习「<strong>一致性</strong>」和「<strong>共识</strong>」以及相关的理论知识时记录的笔记，这些知识能帮助我们了解 Etcd/Zookeeper/Consul/MySQL/PostgreSQL/DynamoDB/Cassandra/MongoDB/CockroachDB/TiDB 等一众数据库的区别，理解各数据库的优势与局限性，搞懂数据库隔离级别的含义以及应该如何设置，并使我们能在各种应用场景中选择出适用的数据库。</p>
<p>如果你对区块链感兴趣，那这篇文章也能帮助你了解区块链这样的去中心化数据库，跟业界流行的分布式数据库在技术上有何区别，又有哪些共同点，具体是如何实现。</p>
<h2 id="一一致性---consistency" class="headerLink">
    <a href="#%e4%b8%80%e4%b8%80%e8%87%b4%e6%80%a7---consistency" class="header-mark"></a>一、一致性 - Consistency</h2><p>「一致性」本身是一个比较模糊的定义，视使用场景的不同，存在许多不同的含义。
由于数据库仍然是一个新兴领域，目前存在许多不同的一致性模型，其中的一些术语描述的一致性之间可能还有重叠关系，这些关系甚至会困扰专业的数据库开发人员。</p>
<p>但是究其根本，实际上在谈论一致性时，我们是在谈论<strong>事务一致性</strong>跟<strong>数据一致性</strong>，下面我们分别介绍下这两个一致性。</p>
<h3 id="1-事务一致性---transactions-consistency" class="headerLink">
    <a href="#1-%e4%ba%8b%e5%8a%a1%e4%b8%80%e8%87%b4%e6%80%a7---transactions-consistency" class="header-mark"></a>1. 事务一致性 - Transactions Consistency</h3><p>「事务一致性」指的是数据库中事务的一致性，它是 ACID 理论中最不起眼的特性，也并不是本文的重点。
但是这里就写这么一句话也说不过去，所以下面就仔细介绍下事务与 ACID 理论。</p>
<h4 id="事务与-acid-理论" class="headerLink">
    <a href="#%e4%ba%8b%e5%8a%a1%e4%b8%8e-acid-%e7%90%86%e8%ae%ba" class="header-mark"></a>事务与 ACID 理论</h4><p>事务是一种「要么全部完成，要么完全不做（All or Nothing）」的指令运行机制。</p>
<p><strong>ACID 理论</strong>定义，拥有如下四个特性的「数据库指令序列」，就被称为事务：</p>
<ul>
<li><strong>原子性 Atomicity</strong>：事务是一个不可分割的工作单元，事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在某个中间状态。
<ul>
<li>比如 A 转账 100 元给 B，要么转账失败，要么转账成功，不可能卡在 A 被扣除了 100 元，而 B 还没收到 100 元的中间状态。</li>
<li>原子性在单机数据库上已得到妥善解决，但是在分布式数据库上它成为一项新的挑战。要在分布式架构下支持原子性并不容易，所以不少 NoSQL 产品都选择绕过这个问题，聚焦到那些对原子性不敏感的细分场景。</li>
</ul>
</li>
<li><strong>一致性 Consistency</strong>：也叫数据的「<strong>正确性 Correctness</strong>」或者完整性，指事务对数据库状态的变更必须满足所有预定义的规则，包括「约束 constraints」、「级联 cascades」、「触发器 triggers」以及这些规则的任何组合。
<ul>
<li>比如如果用户为某个字段设置了约束条件 <code>unique</code>，那么事务对该表的所有修改都必须保证此约束成立，否则它将会失败。</li>
<li>是存在感最低的特性</li>
</ul>
</li>
<li><strong>隔离性 Isolation</strong>：<strong>并发执行的多个事务之间是完全隔离的</strong>，它们的执行效果跟按事务的开始顺序串行执行完全一致。
<ul>
<li>事务中最复杂的特性</li>
</ul>
</li>
<li><strong>持久性 Durability</strong>：事务执行完毕后，结果就保存不变了。这个最好理解。</li>
</ul>
<p>ACID 是传统的单机数据库的核心特性，比如 MySQL/PostgreSQL.</p>
<h4 id="acid-中最复杂的特性---隔离性" class="headerLink">
    <a href="#acid-%e4%b8%ad%e6%9c%80%e5%a4%8d%e6%9d%82%e7%9a%84%e7%89%b9%e6%80%a7---%e9%9a%94%e7%a6%bb%e6%80%a7" class="header-mark"></a>ACID 中最复杂的特性 - 隔离性</h4><p>完全地实现 ACID 得到的数据库，性能是非常差的。
因此在关系数据库中，设计者通常会选择牺牲相对不重要的「隔离性」来获取更好的性能。</p>
<p>而一旦隔离不够彻底，就可能会遇到一些事务之间互相影响的异常情况，这些异常被分为如下几种：</p>
<ul>
<li><strong>脏写 Dirty writes</strong>：即事务 T1 跟事务 T2 同时在原数据的基础上更新同一个数据，导致结果不符合预期。
<ul>
<li>案例：两个事务同时尝试从账户中扣款 1000 元，但是它们读到的初始状态都是 5000 元，于是都尝试将账户修改为 4000 元，结果就是少扣了 1000 元。</li>
<li>最简单的解决方法：针对 <code>UPDATE table SET field = field - 1000 WHERE id = 1</code> 这类数据增删改的逻辑，需要对被更新的行加一把「行写锁」，使其他需要写此数据的事务等待。</li>
</ul>
</li>
<li><strong>脏读 Dirty reads</strong>：事务 T1 读取了事务 T2 未提交的数据。这个数据不一定准确，被称为脏数据，因为假如事务 T2 回滚了，T1 拿到的就是一个错误的数据
<ul>
<li>案例：假设小明小红在一个银行账户存了 5000 元，小明小红在用这同一个账户消费 1000 元，这中间小明付款的事务读取到账户已经被小红的事务修改为了 4000 元，于是它把余额修改为 3000 元，然后付款成功。但是在小明的付款事务成功后，小红的付款失败回滚了，余额又从 3000 被修改回 5000 元。小明就完成了 0 元购的壮举。</li>
<li>最简单的解决方法：事务 T2 写数据时对被修改的行加「行写锁」，T2 结束后再释放锁，这样事务 T1 的读取就会被阻塞，直到锁释放。</li>
</ul>
</li>
<li><strong>不可重复读 Non-repeatable reads</strong>：事务 T1 读取数据后，紧接着事务 T2 就更新了数据并提交，事务 T1 再次读取的时候发现数据不一致了
<ul>
<li>案例：
<ul>
<li>小明在京东上抢购商品，抢购事务启动时事务读到还剩 36 件商品，于是继续执行抢购逻辑，之后事务因为某种原因需要再读一次商品数量，结果发现商品数量已经变成 0 了，抢购失败。</li>
<li>更麻烦的是，不可重复读导致 SELECT 跟 UPDATE 之间也可能出现数据变更，如果你在事务中先通过 <code>SELECT field INTO myvar FROM mytable WHERE uid = 1</code> 读到余额，再在此基础上通过 <code>UPDATE</code> 去更新余额，很可能导致数据变得一团糟！
<ul>
<li>正确的做法是使用 <code>UPDATE mytable SET field = field - 1000 WHERE id = 1</code>，因为每一条 SQL 命令本身都是原子的，这个 SQL 不会有问题。</li>
</ul>
</li>
</ul>
</li>
<li>最简单的解决办法：事务 T1 读数据时，也加一把「行」锁，直到不再需要读该数据了，再释放锁。</li>
</ul>
</li>
<li><strong>幻读 Phantom reads</strong>：事务 T1 在多次批量读数据时，事务 T2 往其中执行了插入/删除操作，导致 T1 读到的是旧数据的一个残影，而非当前真实的数据状态。
<ul>
<li>最简单的解决办法：事务 T1 在批量读数据时，先加一把范围锁，在事务 T1 结束读取之后，再释放这把锁。这能同时解决「幻读」跟「不可重复读」的问题。</li>
</ul>
</li>
</ul>
<p>根据隔离程度，ANSI SQL-92 标准中将「隔离性」细分为四个等级（避免「脏写」是数据库的必备要求，因此未记录在下面的四个等级中）：</p>
<ul>
<li><strong>串行化 Serializable</strong>：也就是完全的隔离，只要事务之间存在互相影响的可能，就（通过锁机制）强制它们串行执行。</li>
<li><strong>可重复读 Repeatable read</strong>：可避免脏读、不可重复读的发生，但是解决不了幻读的问题。</li>
<li><strong>读已提交 Read committed</strong>：只能避免脏读</li>
<li><strong>读未提交 Read uncommitted</strong>：最低级别，完全放弃隔离性</li>
</ul>
<p>MySQL 默认的隔离级别为「可重复读 Repeatable Read」，PostgreSQL 和 Oracle 默认隔离级别为「读已提交 Read committed」。</p>
<p>为什么 MySQL/PostgreSQL/Oracle 的默认隔离级别是这样设置的呢？该如何选择正确的隔离级别呢？
我们针对普通的高并发业务场景做个简单分析：</p>
<ul>
<li>首先，「脏读」是必须避免的，它会使事务读到错误的数据！最低的「读未提交」级别直接排除</li>
<li>「串行化」的性能太差，也直接排除</li>
<li>只要 SQL 用得对，「不可重复读」问题对业务逻辑的正确性通常并无影响，所以是可以容忍的。</li>
<li><strong>因此一般「读已提交」是最佳的隔离级别</strong>，这也是 PostgreSQL/Oracle 将其设为默认隔离级别的原因。</li>
<li>那么为什么 MySQL 这么特立独行，将默认隔离级别提高到了「可重复读」呢？为啥阿里这种大的互联网公司又会把 MySQL 默认的隔离级别改成「读已提交」？
<ul>
<li>根据网上查到的资料，这是 MySQL 的历史问题导致的。MySQL 5.0 之前只支持 statement 这种 binlog 格式，此格式在「读已提交」的隔离级别下会出现诸多问题，最明显的就是可能会导致主从数据库的数据不一致。</li>
<li>除了设置默认的隔离级别外，MySQL 还禁止在使用 statement 格式的 binlog 时，使用 READ COMMITTED 作为事务隔离级别，尝试修改隔离级别会报错 <code>Transaction level 'READ-COMMITTED' in InnoDB is not safe for binlog mode 'STATEMENT'</code></li>
<li>而互联网公司将隔离级别改为「读已提交」的原因也很好理解，正如前文所述「读已提交」是最佳的隔离级别，这样修改能够提升数据库的性能。</li>
</ul>
</li>
</ul>
<p>「隔离性」的本质其实就是<strong>事务的并发控制</strong>，不同的隔离级别代表了对并发事务的隔离程度，主要的实现手段是「<strong>多版本并发控制 MVCC</strong>」与「锁」。
锁机制前面已经简单介绍过了，而 MVCC 其实就是为每个事务创建一个特定隔离级别的快照，这样读写不会互相阻塞，性能就提升了。（MVCC 暂时也是超纲知识，后面再研究吧 emmmm）</p>
<p>ANSI SQL-92 对异常现象的分析仍然太过简单了，1995 年新发布的论文 <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf" target="_blank" rel="noopener noreferrer">A Critique of ANSI SQL Isolation Levels</a> 丰富和细化了 SQL-92 的内容，定义了六种隔离级别和八种异常现象（有大佬强烈建议通读此论文，重点是文中的快照隔离（Snapshot Isolation, SI）级别）。</p>
<h3 id="2-数据一致性-data-consistency" class="headerLink">
    <a href="#2-%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7-data-consistency" class="header-mark"></a>2. 数据一致性 Data Consistency</h3><p>「数据一致性」是指对数据库的每一次读操作都应该读到最新写入的数据，或者直接报错。</p>
<p>对单机数据库而言「数据一致性」往往不是问题，因为它通常只有一份保存在磁盘或内存中的数据。
但是在分布式系统中，为了数据安全性或者为了性能，往往每一份数据都在多个节点上存有其副本，这就引出了数据副本们的一致性问题。
因此，我们通常谈论的「数据一致性」就是指分布式系统的「数据一致性」。</p>
<p><strong>CAP 原则</strong>是分布式系统领域一个著名的理论，它告诉我们在分布式系统中如下三种属性不可能全部达成，因此也被称作「<strong>CAP 不可能三角</strong>」：</p>
<ul>
<li><strong>数据一致性 Data Consistency</strong>：客户端的每次读操作，不管访问系统的哪个节点，要么读到的都是同一份最新写入的数据，要么读取失败
<ul>
<li>强调数据完全正确</li>
</ul>
</li>
<li><strong>可用性 Availability</strong>：任何来自客户端的请求，不管访问哪个非故障节点，都能得到响应数据，但不保证是同一份最新数据
<ul>
<li>强调的是服务可用，但不保证数据正确</li>
</ul>
</li>
<li><strong>分区容错性 Partition Tolerance</strong>：即使节点之间出现了任意数量的消息丢失或者高延迟，系统仍能正常运行
<ul>
<li>就是说网络丢包或延迟会导致系统被分成多个 Partition，系统能够容忍这种情况</li>
</ul>
</li>
</ul>
<p>为了保证分区容错性 P，考虑当分布式系统因为网络问题被割裂成多个分区时，每个分区只有如下两种选择，A 跟 C 必须牺牲掉其中之一：</p>
<ul>
<li>取消操作并拒绝提供服务，这降低了可用性，但是能确保数据一致性</li>
<li>继续处理请求，这确保了可用性，但是数据一致性就无法保证了</li>
</ul>
<p>如果系统的多个分区都在同时提供服务，导致数据不一致并且存在冲突无法合并，这就被称为分布式系统的「<strong>脑裂</strong>」，显然任何分布式系统都不会希望发生「脑裂」。</p>
<p>因为分布式系统与单机系统不同，它涉及到多节点间的网络通讯和交互，但是只要有网络交互就一定会有延迟和数据丢失，节点间的分区故障是很有可能发生的。因此为了正常运行，P 是分布式系统必须保证的特性，<strong>在出现分区故障时，为了 P 只能牺牲掉 A 或者 C</strong>。</p>
<p>工程上是要 AP 还是 CP，得视情况而定：</p>
<ul>
<li>Etcd/Zookeeper/Consul: 它们通常被用于存储系统运行的关键元信息，每次读，都要能读取到最新数据。因此它们实现了 CP，牺牲了 A</li>
<li>DynamoDB/Cassandra/MongoDB：不要求数据一致性，一段时间内用旧的缓存问题也不大，但是要求可用性，因此应该实现 AP，牺牲掉 C</li>
</ul>
<h4 id="数据一致性模型" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7%e6%a8%a1%e5%9e%8b" class="header-mark"></a>数据一致性模型</h4><p>分布式系统中，多副本数据上的一组读写策略，被称为「（数据）一致性模型 Consistency Model」。
一致性模型数量很多，让人难以分辨。
为了便于理解，我们先从状态视角出发区分一下强一致与弱一致的概念，在这个的基础上再从操作视角去理解这众多的一致性模型。</p>
<h5 id="1-状态视角---强一致与弱一致" class="headerLink">
    <a href="#1-%e7%8a%b6%e6%80%81%e8%a7%86%e8%a7%92---%e5%bc%ba%e4%b8%80%e8%87%b4%e4%b8%8e%e5%bc%b1%e4%b8%80%e8%87%b4" class="header-mark"></a>1. 状态视角 - 强一致与弱一致</h5><p>我们首先把整个分布式系统看作一个<strong>白盒</strong>，从状态视角看，任何变更操作后，分布式系统的多个数据副本只有如下三种状态：</p>
<ul>
<li>在某些条件下，各副本状态不一致的现象只是暂时的，后续还会转换到一致的状态，这被称为「<strong>弱一致</strong>」；
<ul>
<li>这通常是使用<strong>异步复制</strong>来同步各副本的状态。</li>
</ul>
</li>
<li>相对的说，如果系统各副本不存在「不一致」这种状态，只要变更操作成功数据就一定完全一致，那它就被称为「<strong>强一致</strong>」。
<ul>
<li>这要求所有副本之间的数据更新必须完全同步，就必须使用<strong>全同步复制</strong>。</li>
</ul>
</li>
<li><strong>永远不会一致</strong>：这在分布式系统中就是 bug 了，也被称为「脑裂」。</li>
</ul>
<p>上面描述的是整个系统的客观、实际状态，但对于绝大部分用户而言分布式系统更多的是一个<strong>黑盒</strong>，因此更流行的是基于「黑盒」的分类方式，它根据系统的对外状态将系统分成两种类型：</p>
<ul>
<li><strong>强一致</strong>：指对系统的任何节点/进程，写操作完成后，任何用户对任何节点的后续访问都能读到新的值。就好像系统只存在一个副本一样。
<ul>
<li>最常用算法是 Raft/Paxos，它们的写操作只要求超过半数节点写入成功，因此写入完成时，内部状态实际是不一致的，但是对它进行读写，效果跟「全同步复制」没有区别。</li>
</ul>
</li>
<li><strong>弱一致</strong>：指对系统的任何节点/进程，写操作完成后，后续的任何访问可能会拿到的值是不确定的，但经过一段时间后，后续的任何访问都能读到新的值。
<ul>
<li>弱一致是非常模糊的定义。如果我们把最终所有用户都能访问到新的值被称为「<strong>系统收敛</strong>」，系统收敛的用时可以有明确边界，也可以没有。系统收敛前的访问行为可以有明确规范，也可以不存在规范。一切都看具体系统的实现。</li>
<li>如果系统能够在有限时间内收敛，那它就是「<strong>最终一致</strong>」，否则可以认为它是「<strong>不一致</strong>」。</li>
</ul>
</li>
</ul>
<p>为了实际需要，数据库专家对系统收敛之前的读写效果进行各种限制，对系统的收敛时间进行各种限制，得到了许多一致性模型。</p>
<h5 id="2-操作视角---多种一致性模型" class="headerLink">
    <a href="#2-%e6%93%8d%e4%bd%9c%e8%a7%86%e8%a7%92---%e5%a4%9a%e7%a7%8d%e4%b8%80%e8%87%b4%e6%80%a7%e6%a8%a1%e5%9e%8b" class="header-mark"></a>2. 操作视角 - 多种一致性模型</h5><p>从每个客户端的操作角度看，有四种一致性模型：</p>
<ul>
<li><strong>写后读一致性 Read after Write Consistency</strong>：也被称作「读自己所写一致性」，即自己写完数据版本 N 后，后续读到的版本一定不小于版本 N。
<ul>
<li>它解决的问题：A 发了个抖音视频，刷新页面后却莫名其妙消失了（旧版本），几分钟后才重新刷出来。</li>
<li>实现方式之一：为写入者单独添加一个读取规则，他的读都由已更新其写入数据的副本来处理。</li>
</ul>
</li>
<li><strong>单调读一致性 Monotonic Read Consistency</strong>：保证多个读操作的顺序，即客户端一旦读到某个数据版本 N，后续不会读到比 N 更低的版本。
<ul>
<li>它解决的问题是：A 删除了一个抖音视频，可多次刷新，偶尔刷不到视频，偶尔又能刷到被删除视频（旧版本），几分钟后才彻底被删除。</li>
<li>实现方式之一：为每个用户的读都创建一个副本映射，后续的读都由一个固定的副本处理，避免随机切换副本而读到更老的值。</li>
</ul>
</li>
<li><strong>单调写一致性 Monotonic Write Consistency</strong>：保证多个写操作的顺序，即客户端对同一数据的两次写入操作，一定按其被提交的顺序被执行。</li>
<li><strong>读后写一致性 Write after Read Consistency</strong>：读后写一致性，保证一个客户端读到数据版本 N 后（可能是其他客户端写入的），随后对同一数据的写操作必须要在版本号大于等于 N 的副本上执行。</li>
</ul>
<p>上述四个一致性模型都只从每个客户端自身的角度定义规则，比较片面，因此它们都是「弱一致模型」。</p>
<p>而不考虑客户端，直接从所有数据库用户的操作视角看，有如下几种一致性模型：</p>
<ul>
<li><strong>线性一致性 Linearizability</strong>：线性一致性利用了事件的提交顺序，它保证任何读操作得到的数据，其顺序跟读/写事件的提交顺序一致。
<ul>
<li>简单的说它要求<strong>整个系统表现得像只存在一个副本</strong>，所有操作的执行结果就跟这些事件按提交顺序完全串行执行一样。这实际也是在说所有并发事件都是原子的，一旦互相之间存在冲突，就一定得按顺序执行，因此也有人称它为「原子一致性」。</li>
<li>线性一致性，完全等价于系统对外状态的「强一致性」</li>
<li>线性一致性的系统是完全确定性的</li>
<li>实现方式：需要一个所有节点都一致的「<strong>全局时钟</strong>」，这样才可以对所有事件进行全局排序。
<ul>
<li>大多数分布式数据库如 TiDB/Etcd 都是通过 NTP 等协议进行单点授时与同步实现的全局时钟。</li>
<li>有全球化部署需要的 Google Spanner 是使用 GPS + 原子钟实现的全局时钟 TrueTime，全局误差可以控制在 7ms 以内。</li>
</ul>
</li>
<li>局限性：根据爱因斯坦相对论，「时间是相对的」，实际上并不存在绝对的时间，因此线性一致性只在经典物理学范围内适用。</li>
</ul>
</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Consistency_model" target="_blank" rel="noopener noreferrer">顺序一致性 Sequentially Consistent</a></strong>：顺序一致性最早是 Leslie Lamport 用来描述多核 CPU 的行为的，在分布式系统领域用得较少。
<ul>
<li>顺序一致性的要求有两点：
<ul>
<li>从单个进程（副本）的角度看，所有指令的执行顺序跟代码逻辑的顺序完全一致。</li>
<li>从所有的处理器（整个分布式系统）角度看，写操作不必立即对所有用户可见，但是所有副本必须以相同的顺序接收这些写操作。</li>
</ul>
</li>
<li>顺序一致性和线性一致性都是要找到一个满足「写后读」的一组操作历史，差异在于<strong>线性一致性要求严格的时间序，而顺序一致性只要求满足代码的逻辑顺序</strong>，而其他代码逻辑未定义的事件顺序（比如多副本上各事件之间的顺序），具体是什么样的顺序无所谓，只要所有副本看到的事件顺序都相同就行。</li>
<li>顺序一致性并不能提供「确定性」，相同的两次操作仍然可能得到不同的事件顺序。</li>
<li>实现方式：因为不要求严格的全局时间序，它就不需要一个全局时钟了，但实际上为了满足全局的确定性，仍然需要一些复杂的操作。</li>
</ul>
</li>
<li><strong>因果一致性 Causal Consistency</strong>：线性一致性的全局时钟有其局限性，而因果一致性基于写事件的「偏序关系」提出了「<strong>逻辑时钟</strong>」的概念，并保证读顺序与逻辑时钟上的写事件顺序一致。
<ul>
<li>写事件的「偏序关系」关系是指，至少部分事件（比如一个节点内部的事件）是可以使用本地时钟直接排序的，而节点之间发生通讯时，接收方的事件一定晚于调用方的事件。基于这一点可以实现一个「<strong>逻辑时钟</strong>」，但逻辑时钟的缺点在于，如果某两个事件不存在相关性，那逻辑时钟给出的顺序就没有任何意义。</li>
<li>多数观点认为，因果一致性弱于线性一致性，但<strong>在并发性能上具有优势，也足以处理多数的异常现象</strong>，所以因果一致性也在工业界得到了应用。</li>
<li>CockroachDB 和 YugabyteDB 都在设计中采用了逻辑混合时钟（Hybrid Logical Clocks），这个方案源自 Lamport 的逻辑时钟，也取得了不错的效果</li>
</ul>
</li>
<li><strong>前缀一致性 Consistent Prefix</strong>：副本之间的同步过程中，会存在一些副本接收数据的顺序并不一致。「前缀一致性」是说所有用户读到的数据顺序的前缀永远是一致的。
<ul>
<li>「前缀」是指程序在执行写操作时，需要显式声明其「前缀」事件，这样每个事件就都存在一个由其他写事件排列而成的前缀。比如当前有写事件排列「A B C D」，那所有用户读到的数据都拥有同样的写事件前缀，比如「A」、「A B」、「A B C」、「A B C D」，但不可能出现「A C」或者「C A」等结果。</li>
<li>它解决的是<strong>分片分布式数据库</strong>的一致性问题：A B C 因为地域区别读写的是不同的副本，B 在抖音评论区问了个问题，然后 A 作出了回答。但是问题跟回答两个数据如果处于不同的分片，副本同步时这两个数据的顺序是无法保证的，C 可能会先读到回答信息，之后才刷新出 B 的提问，历史事件的顺序就乱了。</li>
<li>实现方式：需要程序主动为消息之间添加显式的依赖关系，再据此控制其读取顺序，实现比较复杂。</li>
<li>存在的问题：只有被显式定义了因果关系的事件，它们之间的顺序才能被保证。</li>
</ul>
</li>
</ul>
<p>其中<strong>线性一致性</strong>就是<strong>强一致性</strong>，其他所有的模型都是<strong>弱一致性模型</strong>或者说<strong>最终一致性模型</strong>。所有这些模型按强度降序排列如下：</p>
<ul>
<li>线性一致性/强一致性：系统对外表现得好像整个系统完全一致，不存在不一致的情况。</li>
<li>顺序一致性：只保证每个节点上的事件顺序一致，对节点之间的事件顺序只有非常宽松的要求。</li>
<li>因果一致性：同样只保证每个节点上的事件顺序一致，但是对节点之间的事件顺序的要求比顺序一致性更宽松。</li>
<li>有界旧一致性（Bounded Staleness）：保证读到的数据与最新版本的差距不超过 K 个版本</li>
<li>会话一致性（Session Consistency）：在一个会话内保证单调读，单调写，和读自己所写，会话之间不保证</li>
<li>前缀一致性：在每个会话内保证了单调读，会话之间不保证</li>
<li>客户端角度的四个一致性模型：写后读、单调读、单调写、读后写。这四个模型的视角都非常片面，通常被包含在前述的一致性模型中。</li>
</ul>
<p>更完整的关系树状图：<a href="https://jepsen.io/consistency" target="_blank" rel="noopener noreferrer">Consistency Models</a></p>
<h2 id="二分布式系统的-base-与最终一致性" class="headerLink">
    <a href="#%e4%ba%8c%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e7%9a%84-base-%e4%b8%8e%e6%9c%80%e7%bb%88%e4%b8%80%e8%87%b4%e6%80%a7" class="header-mark"></a>二、分布式系统的 BASE 与最终一致性</h2><p>BASE 理论：</p>
<ul>
<li><strong>基本可用 Basically Available</strong>：当分布式系统在出现不可预知的故障时，允许损失部分功能的可用性，保障核心功能的可用性
<ul>
<li>四种实现基本可用的手段：流量削峰、延迟响应、体验降级、过载保护</li>
</ul>
</li>
<li><strong>软状态 Soft state</strong>：在柔性事务中，允许系统存在中间状态，且这个中间状态不会影响系统整体可用性。比如，数据库读写分离，写库同步到读库（主库同步到从库）会有一个延时，其实就是一种柔性状态。</li>
<li><strong>最终一致性 Eventually consistent</strong>：前面已经说得很详细了，它指对系统的任何节点/进程，写操作完成后，后续的任何访问可能会拿到的值是不确定的，但经过有限的一段时间后，后续的任何访问都能读到新的值。</li>
</ul>
<p>ACID 与 BASE 实质上是分布式系统实现中的的两个极端：</p>
<ul>
<li>ACID 理论就如它的含义「<strong>酸</strong>」一样，是 CAP 原则中一致性的边界——<strong>最强的一致性</strong>，是牺牲掉 A 后达到 CP 的极致。</li>
<li>BASE 翻译过来就是「<strong>碱</strong>」，它是 CAP 原则中可用性的边界——<strong>最高的可用性，最弱的一致性</strong>，通过牺牲掉 C 来达到 AP 的极致。</li>
</ul>
<p>根据 CAP 理论，如果在分布式系统中实现了一致性，可用性必然受到影响。
比如，如果出现一个节点故障，则整个分布式事务的执行都是失败的。实际上，绝大部分场景对一致性要求没那么高，短暂的不一致是能接受的，另外，也基于可用性和并发性能的考虑，建议在开发实现分布式系统时，<strong>如果不是必须，尽量不要实现事务，可以考虑采用最终一致性</strong>。</p>
<p>最终一致性的实现手段：</p>
<ul>
<li><strong>读时修复</strong>：在读取数据时，检测数据的不一致，进行修复</li>
<li><strong>写时修复</strong>：在写入数据时，检测数据的不一致，进行修复</li>
<li><strong>异步修复</strong>：这个是最常用的方式，通过定时对账，检测副本数据的一致性并修复</li>
</ul>
<p>在实现最终一致性的时候，还推荐同时实现自定义写一致性级别（比如 All、Quorum、One、Any），许多分布式数据库的最终一致性级别都是可调的。</p>
<p>但是随着 TiDB 等分布式关系数据库的兴起，分布式领域的 BASE 理论实际上正在被 ACID 赶超，ACID 焕发又一春了。</p>
<h2 id="三共识算法" class="headerLink">
    <a href="#%e4%b8%89%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95" class="header-mark"></a>三、共识算法</h2><p>共识算法，也被称为一致性协议，是指在分布式系统中多个节点之间对某个提案 Proposal（例如多个事务请求，先执行谁？）达成一致看法的一套流程。</p>
<p>提案的含义在分布式系统中十分宽泛，如多个事件发生的顺序、某个键对应的值、谁是主节点……等等。可以认为任何可以达成一致的信息都是一个提案。</p>
<p>对于分布式系统来讲，各个节点通常都是相同的确定性状态机模型（又称为状态机复制问题，State-Machine Replication），从相同初始状态开始接收相同顺序的指令，则可以保证相同的结果状态。因此，系统中多个节点最关键的是对多个事件的顺序进行共识，即排序。</p>
<p><strong>共识算法是达成数据一致性的一种手段，而且是数据强一致性的必要非充分条件</strong>。比如直接使用 Raft 算法，但是允许读取集群的任何节点，只能得到数据的最终一致性，还需要其他手段才能确保强一致性。</p>
<h3 id="拜占庭将军问题与拜占庭容错" class="headerLink">
    <a href="#%e6%8b%9c%e5%8d%a0%e5%ba%ad%e5%b0%86%e5%86%9b%e9%97%ae%e9%a2%98%e4%b8%8e%e6%8b%9c%e5%8d%a0%e5%ba%ad%e5%ae%b9%e9%94%99" class="header-mark"></a>拜占庭将军问题与拜占庭容错</h3><p>拜占庭错误是 1982 年兰伯特在《拜占庭将军问题》中提出的一个错误模型，描述了在少数节点不仅存在故障，还存在恶意行为的场景下，能否达成共识这样一个问题，论文描述如下：</p>
<blockquote>
<p>9 位拜占庭将军分别率领一支军队要共同围困一座城市，因为这座城市很强大，如果不协调统一将军们的行动策略，部分军队进攻、部分军队撤退会造成围困失败，因此各位将军必须通过投票来达成一致策略，要么一起进攻，要么一起撤退。</p>
<p>因为各位将军分别占据城市的一角，他们只能通过信使互相联系。在协调过程中每位将军都将自己投票“进攻”还是“撤退”的消息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他将军送过来的投票，就可以知道投票结果，从而决定是进攻还是撤退。</p>
<p>而问题的复杂性就在于：将军中可能出现叛徒，他们不仅可以投票给错误的决策，还可能会选择性地发送投票。假设 9 位将军中有 1 名叛徒，8 位忠诚的将军中出现了 4 人投“进攻”，4 人投“撤退”，这时候叛徒可能故意给 4 名投“进攻”的将军投“进攻”，而给另外 4 名投“撤退”的将军投“撤退”。这样在 4 名投“进攻”的将军看来，投票是 5 人投“进攻”，从而发动进攻；而另外 4 名将军看来是 5 人投“撤退”，从而撤退。这样，一致性就遭到了破坏。</p>
<p>还有一种情况，因为将军之间需要通过信使交流，即便所有的将军都是忠诚的，派出去的信使也可能被敌军截杀，甚至被间谍替换，也就是说将军之间进行交流的信息通道是不能保证可靠性的。所以在没有收到对应将军消息的时候，将军们会默认投一个票，例如“进攻”。</p>
</blockquote>
<p>更一般地，在已知有 N 个将军谋反的情况下，其余 M 个忠诚的将军在不受叛徒的影响下能否达成共识？有什么样的前提条件，该如何达成共识？这就是拜占庭将军问题。</p>
<p>如果一个共识算法在一定条件下能够解决拜占庭将军问题，那我们就称这个算法是「<strong>拜占庭容错 Byzantine Fault Tolerance（BFT）</strong>」算法。
反之如果一个共识算法无法接受任何一个节点作恶，那它就被称为「<strong>非拜占庭容错 Crash Fault Tolerance (CFT)</strong>」算法。</p>
<p>可以通过简单穷举发现，二忠一叛是无法达成共识的，这个结论结合反证法可证明，<strong>拜占庭容错算法要求叛徒的比例必须低于 1/3</strong>。</p>
<h3 id="常用共识算法" class="headerLink">
    <a href="#%e5%b8%b8%e7%94%a8%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95" class="header-mark"></a>常用共识算法</h3><p>对于「<strong>非拜占庭容错 Crash Fault Tolerance (CFT)</strong>」的情况，已经存在不少经典的算法，包括 Paxos（1990 年）、Raft（2014 年）及其变种等。这类容错算法往往性能比较好，处理较快，容忍不超过一半的故障节点。</p>
<p>对于「<strong>拜占庭容错 Byzantine Fault Tolerance（BFT）</strong>」的情况，目前有 PBFT（Practical Byzantine Fault Tolerance，1999 年）为代表的确定性系列算法、PoW（1999 年）为代表的概率算法等算法可选。
确定性算法一旦达成共识就不可逆转，即共识是最终结果；
而概率类算法的共识结果则是临时的，随着时间推移或某种强化，共识结果被推翻的概率越来越小，最终成为事实上结果。
拜占庭类容错算法往往性能较差，容忍不超过 1/3 的故障节点。</p>
<p>此外，XFT（Cross Fault Tolerance，2015 年）等最近提出的改进算法可以提供类似 CFT 的处理响应速度，并能在大多数节点正常工作时提供 BFT 保障。
Algorand 算法（2017 年）基于 PBFT 进行改进，通过引入可验证随机函数解决了提案选择的问题，理论上可以在容忍拜占庭错误的前提下实现更好的性能（1000+ TPS）。</p>
<blockquote>
<p>注：实践中，对客户端来说要拿到共识结果需要自行验证，典型地，可访问足够多个服务节点来比对结果，确保获取结果的准确性。</p>
</blockquote>
<p>常见共识算法列举如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>拜占庭容错</th>
<th>一致性</th>
<th>性能</th>
<th>可用性（能容忍多大比例的节点出现故障）</th>
</tr>
</thead>
<tbody>
<tr>
<td>两阶段提交 2PC</td>
<td>否</td>
<td>强一致性</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>TCC(try-confirm-cancel)</td>
<td>否</td>
<td>最终一致性</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>Paxos</td>
<td>否</td>
<td>强一致性</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>ZAB</td>
<td>否</td>
<td>最终一致性</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>Raft</td>
<td>否</td>
<td>强一致性</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>Gossip</td>
<td>否</td>
<td>最终一致性</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>Quorum NWR</td>
<td>否</td>
<td>强一致性</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>PBFT</td>
<td>是</td>
<td>N/A</td>
<td>低</td>
<td>中</td>
</tr>
<tr>
<td>PoW</td>
<td>是</td>
<td>N/A</td>
<td>低</td>
<td>中</td>
</tr>
<tr>
<td>PoS</td>
<td>是</td>
<td>N/A</td>
<td>低</td>
<td>中</td>
</tr>
<tr>
<td><a href="https://medium.com/solana-labs/proof-of-history-explained-by-a-water-clock-e682183417b8" target="_blank" rel="noopener noreferrer">PoH</a></td>
<td>是</td>
<td>N/A</td>
<td>中</td>
<td>中</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注：这里虽然列出了 PoW/PoS/PoH 等应用在区块链中的一致性算法，但是它们跟 PBFT 等其他拜占庭容错算法存在很大的区别，后面会给出介绍。</p>
</blockquote>
<h3 id="不同共识算法的应用场景" class="headerLink">
    <a href="#%e4%b8%8d%e5%90%8c%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" class="header-mark"></a>不同共识算法的应用场景</h3><p>在不可信环境中，因为可能存在恶意行为，就需要使用支持拜占庭容错的共识算法如 PoW/PoS，使系统在存在部分节点作恶的情况下仍然能达成共识。这就是区块链使用 PoW/PoS 算法而不是 Paxos/Raft 算法的原因。</p>
<p>而在企业内网等场景下，可以认为是可信环境，基本不会出现恶意节点或者可以通过 mTLS 等手段进行节点身份认证，这种场景下系统具有故障容错能力就够了，就没必要做到拜占庭容错，因此常用 Raft/Paxos 等算法。</p>
<h3 id="非拜占庭错误共识算法-paxos-与-raft" class="headerLink">
    <a href="#%e9%9d%9e%e6%8b%9c%e5%8d%a0%e5%ba%ad%e9%94%99%e8%af%af%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95-paxos-%e4%b8%8e-raft" class="header-mark"></a>非拜占庭错误共识算法 Paxos 与 Raft</h3><p>受限于篇幅与笔者精力，这部分暂时跳过&hellip;后面可能会写篇新的文章专门介绍 Paxos/Raft 算法。</p>
<h3 id="能容忍拜占庭错误的-pow-概率共识算法" class="headerLink">
    <a href="#%e8%83%bd%e5%ae%b9%e5%bf%8d%e6%8b%9c%e5%8d%a0%e5%ba%ad%e9%94%99%e8%af%af%e7%9a%84-pow-%e6%a6%82%e7%8e%87%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95" class="header-mark"></a>能容忍拜占庭错误的 PoW 概率共识算法</h3><p>PoW 即 Proof of Work 工作量证明，指系统为达到某一目标而设置的度量方法。简单理解就是一份证明，用来确认你做过一定量的工作。
监测工作的整个过程通常是极为低效的，而通过对工作的结果进行认证来证明完成了相应的工作量，这个认证流程是非常简单高效的，这就是 PoW 的优势所在。</p>
<p>在 1993 年，<a href="http://www.wisdom.weizmann.ac.il/~naor/PAPERS/pvp.ps" target="_blank" rel="noopener noreferrer">Cynthia Dwork 和 Moni Naor 设计了一个系统用于反垃圾邮件、避免资源被滥用</a>，这是 PoW 算法的雏形。其核心思想如下：</p>
<blockquote>
<p>The main idea is to require a user to compute a moderately hard but not intractable function in order to gain access to the resource, thus preventing frivolous use.</p>
</blockquote>
<p>翻译成中文：</p>
<blockquote>
<p>其主要思想是要求用户计算一个中等难度但不难处理的函数，以获得对资源的访问，从而防止（系统资源被）滥用。</p>
</blockquote>
<p>在 1999 年，<a href="https://link.springer.com/chapter/10.1007/978-0-387-35568-9_18" target="_blank" rel="noopener noreferrer">Markus Jakobsson 与 Ari Juels 第一次从各种协议中提炼出 Proofs of Work 这个概念</a>。</p>
<p>POW 系统中一定有两个角色，工作者和验证者，他们需要具有以下特点：</p>
<ul>
<li>工作者需要完成的工作必须有一定的量，这个量由工作验证者给出。</li>
<li>验证者可以迅速的检验工作量是否达标。</li>
<li>工作者无法自己&quot;创造工作&quot;，必须由验证者发布工作。</li>
<li>工作者无法找到很快完成工作的办法。</li>
</ul>
<p>说到这里，我们对 PoW 应该有足够的理解了，它就是让工作者消耗一定的资源作为使用系统的成本。
对于正常的用户而言这部分被消耗的资源是完全可以接受的，但是对于恶意攻击者而言，它如果想滥用系统的资源或者发送海量的垃圾邮件，就需要消耗海量的计算资源作为成本，这样就极大地提升了攻击成本。</p>
<p>再总结下，PoW 算法的核心是<strong>它为信息发送加入了成本，降低了信息传递的速率</strong>。</p>
<p>把比特币区块链转换成拜占庭将军问题来看，它的思路是这样的：</p>
<ul>
<li>限制一段时间内提案的个数，只有拥有对应权限的节点（将军）可以发起提案。
<ul>
<li>这是通过 PoW 工作量证明实现的，比特币区块链要求节点进行海量的哈希计算作为<strong>获得提案权限的代价</strong>，算法难度每隔两周调整一次以保证整个系统找到正确 Hash 值的平均用时大约为 10 分钟。</li>
</ul>
</li>
<li>由强一致性放宽至最终一致性。
<ul>
<li>对应一次提案的结果不需要全部的节点马上跟进，只需要在节点能搜寻到的全网络中的所有链条中，选取最长的链条进行后续拓展就可以。</li>
</ul>
</li>
<li>使用非对称加密算法对节点间的消息传递提供签名技术支持，每个节点（将军）都有属于自己的秘钥（公钥私钥），唯一标识节点身份。
<ul>
<li>使用非对称加密算法传递消息，能够保证消息传递的私密性。而且消息签名不可篡改，这避免了消息被恶意节点伪造。</li>
</ul>
</li>
</ul>
<p>我们前面有给出一个结论：<strong>拜占庭容错算法要求叛徒的比例必须低于 1/3</strong>。</p>
<p>但是区块链与拜占庭将军问题的区别很大，举例如下：</p>
<ul>
<li>区块链允许任何节点随时加入或离开区块链，而拜占庭将军问题是预设了节点数，而且不考虑节点的添加或删除。</li>
<li>比特币区块链的 PoW 算法只能保证整个系统找到正确 Hash 值的<strong>平均用时</strong>大约为 10 分钟，那肯定就存在性能更好的节点用时更短，性能更差的节点用时更长，甚至某些节点运气好几秒钟就算出了结果，这都是完全可能的。而越早算出这个 Hash 值的节点，它的提案（区块）成为最长链条的概率就越大。</li>
<li>PoW 由强一致性放宽至最终一致性，系统总会选取最长的链进行后续拓展，那如果某个链条一开始不长，但是它的拓展速度足够快，它就能成为最长的链条。而拜占庭将军问题不允许任何分支，只存在一个结果！
<ul>
<li>只是受限于算力，随着时间的推移，短的链条追上最长链条的概率会越来越小。</li>
</ul>
</li>
</ul>
<p>总之因为区块链这样的特点，它会产生一些跟拜占庭容错算法不同的结果：</p>
<ul>
<li>攻击者拥有的节点数量占比是毫无意义的，核心是算力，也就对应着区块链中的提案权。
<ul>
<li>即使攻击者拥有了 99% 的节点，但是它的总体算力很弱的话，它的提案（区块）成为最长链条的概率也会很低。</li>
</ul>
</li>
<li><strong>区块链的 51% 攻击</strong>：因为「系统总是选取最长链条进行后续拓展」这个原则，只有某个攻击者拥有了超过 50% 算力的情况下，它才拥有绝对性的优势，使它的区块在一定时间后一定能成为最长的链条，并且始终维持这样一个优势，从而达成攻击目的。</li>
</ul>
<p>至于 PoW 算法的具体实现，以及它的替代算法 PoS/PoH 等新兴算法的原理与实现，将在后续的区块链系列文章中详细介绍，尽请期待&hellip;</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li>《Designing Data-Intensive Applications - The Big Ideas Behind Reliable, Scalable, and Maintainable Systems (Martin Kleppmann)》</li>
<li>极客时间《分布式数据库 30 讲》</li>
<li>极客时间《分布式协议与算法实战》</li>
<li><a href="https://zhuanlan.zhihu.com/p/34656939" target="_blank" rel="noopener noreferrer">分布式存储系统的一致性是什么？- OceanBase</a></li>
<li><a href="https://pingcap.com/zh/blog/linearizability-and-raft" target="_blank" rel="noopener noreferrer">线性一致性和 Raft - PingCAP</a></li>
<li><a href="https://int64.me/2020/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0.html" target="_blank" rel="noopener noreferrer">一致性模型笔记</a></li>
<li><a href="http://zhangtielei.com/posts/blog-distributed-strong-weak-consistency.html" target="_blank" rel="noopener noreferrer">条分缕析分布式：浅析强弱一致性 -  张铁蕾</a></li>
<li><a href="https://cloud.google.com/blog/products/databases/why-you-should-pick-strong-consistency-whenever-possible" target="_blank" rel="noopener noreferrer">Why you should pick strong consistency, whenever possible - Google Spanner</a></li>
<li><a href="https://www.infoq.cn/article/the-byzantine-generals-problem-and-blockchain" target="_blank" rel="noopener noreferrer">拜占庭将军问题与区块链</a></li>
<li><a href="https://paper.seebug.org/1643/" target="_blank" rel="noopener noreferrer">区块链协议安全系列— —当拜占庭将军犯错时，区块链共识还安全么？（上集）</a></li>
<li><a href="https://www.allthingsdistributed.com/2008/12/eventually_consistent.html" target="_blank" rel="noopener noreferrer">Eventually Consistent - Revisited</a></li>
</ul>
]]></content></entry><entry><title type="html">Kubernetes 中的证书管理工具 - cert-manager</title><link href="https://thiscute.world/posts/kubernetes-cert-management/"/><id>https://thiscute.world/posts/kubernetes-cert-management/</id><author><name>ryan4yin</name></author><published>2022-07-31T15:11:46+08:00</published><updated>2022-07-31T15:11:46+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/kubernetes-cert-management/cert-manager.webp" height="2020" width="630"><figcaption></figcaption>
        </figure><p>我在之前的文章 <a href="https://thiscute.world/posts/about-tls-cert/" target="_blank" rel="noopener noreferrer">写给开发人员的实用密码学（八）—— 数字证书与 TLS 协议</a> 中，介绍了如何使用 openssl 生成与管理各种用途的数字证书，也简单介绍了如何通过 certbot 等工具与 ACME 证书申请与管理协议，进行数字证书的申请与自动更新（autorenew）。</p>
<p>这篇文章要介绍的 cert-mangager，跟 certbot 这类工具有点类似，区别在于它是工作在 Kubernetes 中的。</p>
<p>cert-manager 是一个证书的自动化管理工具，用于在 Kubernetes 集群中自动化地颁发与管理各种来源、各种用途的数字证书。它将确保证书有效，并在合适的时间自动更新证书。</p>
<p>多的就不说了，证书相关的内容请参见我的 <a href="https://thiscute.world/posts/about-tls-cert/" target="_blank" rel="noopener noreferrer">写给开发人员的实用密码学（八）—— 数字证书与 TLS 协议</a> 或者其他资料，现在直接进入正题。</p>
<blockquote>
<p>注：cert-manager 的管理对象是「证书」，如果你仅需要使用非对称加密的公私钥对进行 JWT 签名、数据加解密，可以考虑直接使用 <a href="https://thiscute.world/posts/experience-of-vault/" target="_blank" rel="noopener noreferrer">secrets 管理工具 Vault</a>.</p>
</blockquote>
<h2 id="一部署" class="headerLink">
    <a href="#%e4%b8%80%e9%83%a8%e7%bd%b2" class="header-mark"></a>一、部署</h2><blockquote>
<p><a href="https://cert-manager.io/docs/installation/helm/" target="_blank" rel="noopener noreferrer">https://cert-manager.io/docs/installation/helm/</a></p>
</blockquote>
<p>官方提供了多种部署方式，使用 helm3 安装的方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 添加 cert-manager 的 helm 仓库</span>
</span></span><span class="line"><span class="cl">helm repo add jetstack https://charts.jetstack.io
</span></span><span class="line"><span class="cl">helm repo update
</span></span><span class="line"><span class="cl"><span class="c1"># 查看版本号</span>
</span></span><span class="line"><span class="cl">helm search repo jetstack/cert-manager -l <span class="p">|</span> head
</span></span><span class="line"><span class="cl"><span class="c1"># 下载并解压 chart，目的是方便 gitops 版本管理</span>
</span></span><span class="line"><span class="cl">helm pull jetstack/cert-manager --untar --version 1.8.2
</span></span><span class="line"><span class="cl">helm install <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  cert-manager ./cert-manager <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --namespace cert-manager <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --create-namespace <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  <span class="c1"># 下面这个参数会导致使用 helm 卸载的时候，会删除所有 CRDs，可能导致所有 CRDs 资源全部丢失！要格外注意</span>
</span></span><span class="line"><span class="cl">  --set <span class="nv">installCRDs</span><span class="o">=</span><span class="nb">true</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="二创建-issuer" class="headerLink">
    <a href="#%e4%ba%8c%e5%88%9b%e5%bb%ba-issuer" class="header-mark"></a>二、创建 Issuer</h2><p>cert-manager 支持多种 issuer，你甚至可以通过它的标准 API 创建自己的 Issuer。</p>
<p>但是总的来说不外乎三种：</p>
<ul>
<li>由权威 CA 机构签名的「公网受信任证书」: 这类证书会被浏览器、小程序等第三方应用/服务商信任</li>
<li>本地签名证书: 即由本地 CA 证书签名的数字证书</li>
<li>自签名证书: 即使用证书的私钥为证书自己签名</li>
</ul>
<p>下面介绍下如何申请公网证书以及本地签名证书。</p>
<h3 id="1-通过权威机构创建公网受信证书" class="headerLink">
    <a href="#1-%e9%80%9a%e8%bf%87%e6%9d%83%e5%a8%81%e6%9c%ba%e6%9e%84%e5%88%9b%e5%bb%ba%e5%85%ac%e7%bd%91%e5%8f%97%e4%bf%a1%e8%af%81%e4%b9%a6" class="header-mark"></a>1. 通过权威机构创建公网受信证书</h3><p>通过权威机构创建的公网受信证书，可以直接应用在边界网关上，用于给公网用户提供 TLS 加密访问服务，比如各种 HTTPS 站点、API。
这是需求最广的一类数字证书服务。</p>
<p>cert-manager 支持两种申请公网受信证书的方式：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Automatic_Certificate_Management_Environment" target="_blank" rel="noopener noreferrer">ACME（Automated Certificate Management Environment (ACME) Certificate Authority server）</a>证书自动化申请与管理协议。</li>
<li><a href="https://cert-manager.io/docs/configuration/venafi/#creating-a-venafi-as-a-service-issuer" target="_blank" rel="noopener noreferrer">venafi-as-a-service</a>: venafi 是一个证书的集中化管理平台，它也提供了 cert-manager 插件，可用于自动化申请 DigiCert/Entrust/GlobalSign/Let&rsquo;s Encrypt 四种类型的公网受信证书。</li>
</ul>
<p>这里主要介绍使用 ACMEv2 协议申请公网证书，支持使用此开放协议申请证书的权威机构有：</p>
<ul>
<li>免费服务
<ul>
<li>Let&rsquo;s Encrypt: 众所周知，它提供三个月有效期的免费证书。</li>
<li><a href="https://zerossl.com/documentation/acme/" target="_blank" rel="noopener noreferrer">ZeroSSL</a>:  貌似也是一个比较有名的 SSL 证书服务
<ul>
<li>通过 ACME 协议支持不限数量的 90 天证书，也支持多域名证书与泛域名证书。</li>
<li>它提供了一个额外的 Dashboard 查看与管理所有申请的证书，这是比较方便的地方。</li>
</ul>
</li>
</ul>
</li>
<li>付费服务
<ul>
<li>DigiCert: 这个非常有名（但也是相当贵），官方文档 <a href="https://docs.digicert.com/certificate-tools/Certificate-lifecycle-automation-index/acme-user-guide/" target="_blank" rel="noopener noreferrer">Digicert - Third-party ACME client automation</a></li>
<li>Google Public Authority(Google Trust Services): Google 推出的公网证书服务，也是三个月有效期，其根证书交叉验证了 GlobalSign，OCSP 服务器在国内速度也很快。
<ul>
<li>详见 <a href="https://github.com/acmesh-official/acme.sh/wiki/Google-Public-CA" target="_blank" rel="noopener noreferrer">acme.sh/wiki/Google-Public-CA</a></li>
<li>此功能目前（2022-08-10）仍处于 beta 状态，需要提表单申请才能获得使用</li>
<li>官方地址：https://pki.goog/</li>
</ul>
</li>
<li>Entrust: 官方文档 <a href="https://www.entrust.com/knowledgebase/ssl/how-to-use-acme-to-install-ssl-tls-certificates-in-entrust-certificate-services-apache#step1" target="_blank" rel="noopener noreferrer">Entrust&rsquo;s ACME implementation</a></li>
<li>GlobalSign: 官方文档 <a href="https://www.globalsign.com/en/acme-automated-certificate-management" target="_blank" rel="noopener noreferrer">GlobalSign ACME Service</a></li>
</ul>
</li>
</ul>
<p>这里也顺便介绍下收费证书服务对证书的分级，以及该如何选用：</p>
<ul>
<li>Domain Validated（DV）证书
<ul>
<li><strong>仅验证域名所有权</strong>，验证步骤最少，价格最低，仅需要数分钟即可签发。</li>
<li>优点就是易于签发，很适合做自动化。</li>
<li>各云厂商（AWS/GCP/Cloudflare，以及 Vercel/Github 的站点服务）给自家服务提供的免费证书都是 DV 证书，Let&rsquo;s Encrypt 的证书也是这个类型。
<ul>
<li>很明显这些证书的签发都非常方便，而且仅验证域名所有权。</li>
<li>但是 AWS/GCP/Cloudflare/Vercel/Github 提供的 DV 证书都仅能在它们的云服务上使用，不提供私钥导出功能！</li>
</ul>
</li>
</ul>
</li>
<li>Organization Validated (OV) 证书
<ul>
<li>是企业 SSL 证书的首选，通过企业认证确保企业 SSL 证书的真实性。</li>
<li>除域名所有权外，CA 机构还会审核组织及企业的真实性，包括注册状况、联系方式、恶意软件等内容。</li>
<li>如果要做合规化，可能至少也得用 OV 这个级别的证书。</li>
</ul>
</li>
<li>Extended Validation（EV）证书
<ul>
<li>最严格的认证方式，CA 机构会深度审核组织及企业各方面的信息。</li>
<li>被认为适合用于大型企业、金融机构等组织或企业。</li>
<li>而且仅支持签发单域名、多域名证书，不支持签发泛域名证书，安全性杠杠的。</li>
</ul>
</li>
</ul>
<p>ACME 支持 HTTP01 跟 DNS01 两种域名验证方式，其中 DNS01 是最简便的方法。</p>
<p>下面分别演示如何使用 AWS Route53 跟 AliDNS，通过 DNS 验证方式申请一个 Let&rsquo;s Encrypt 证书。（其他 DNS 提供商的配置方式请直接看官方文档）</p>
<h4 id="11-使用-aws-route53-创建一个证书签发者certificate-issuer" class="headerLink">
    <a href="#11-%e4%bd%bf%e7%94%a8-aws-route53-%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e8%af%81%e4%b9%a6%e7%ad%be%e5%8f%91%e8%80%85certificate-issuer" class="header-mark"></a>1.1 使用 AWS Route53 创建一个证书签发者「Certificate Issuer」</h4><blockquote>
<p>非 AWS Route53 用户可忽略这一节</p>
</blockquote>
<blockquote>
<p><a href="https://cert-manager.io/docs/configuration/acme/dns01/route53/" target="_blank" rel="noopener noreferrer">https://cert-manager.io/docs/configuration/acme/dns01/route53/</a></p>
</blockquote>
<h5 id="111-通过-iam-授权-cert-manager-调用-aws-route53-api" class="headerLink">
    <a href="#111-%e9%80%9a%e8%bf%87-iam-%e6%8e%88%e6%9d%83-cert-manager-%e8%b0%83%e7%94%a8-aws-route53-api" class="header-mark"></a>1.1.1 通过 IAM 授权 cert-manager 调用 AWS Route53 API</h5><blockquote>
<p>这里介绍一种不需要创建 ACCESS_KEY_ID/ACCESS_SECRET，直接使用 AWS EKS 官方的免密认证的方法。会更复杂一点，但是更安全可维护。</p>
</blockquote>
<p>首先需要为 EKS 集群创建 OIDC provider，参见 <a href="https://github.com/ryan4yin/knowledge/blob/master/kubernetes/security/aws-iam-and-kubernetes.md" target="_blank" rel="noopener noreferrer">aws-iam-and-kubernetes</a>，这里不再赘述。</p>
<p>cert-manager 需要查询与更新 Route53 记录的权限，因此需要使用如下配置创建一个 IAM Policy，可以命名为 <code>&lt;ClusterName&gt;CertManagerRoute53Access</code>（注意替换掉 <code>&lt;ClusterName&gt;</code>）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;Version&#34;</span><span class="p">:</span> <span class="s2">&#34;2012-10-17&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;Statement&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Effect&#34;</span><span class="p">:</span> <span class="s2">&#34;Allow&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Action&#34;</span><span class="p">:</span> <span class="s2">&#34;route53:GetChange&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Resource&#34;</span><span class="p">:</span> <span class="s2">&#34;arn:aws:route53:::change/*&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Effect&#34;</span><span class="p">:</span> <span class="s2">&#34;Allow&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Action&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl"> <span class="s2">&#34;route53:ChangeResourceRecordSets&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="s2">&#34;route53:ListResourceRecordSets&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="p">],</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Resource&#34;</span><span class="p">:</span> <span class="s2">&#34;arn:aws:route53:::hostedzone/*&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Effect&#34;</span><span class="p">:</span> <span class="s2">&#34;Allow&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Action&#34;</span><span class="p">:</span> <span class="s2">&#34;route53:ListHostedZonesByName&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Resource&#34;</span><span class="p">:</span> <span class="s2">&#34;*&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>比如使用 awscli 创建此 policy：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">aws iam create-policy <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --policy-name XxxCertManagerRoute53Access <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --policy-document file://cert-manager-route53-access.json
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后通过上述配置创建一个 IAM Role 并自动给 cert-manager 所在的 EKS 集群添加信任关系：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">CLUSTER_NAME</span><span class="o">=</span><span class="s2">&#34;xxx&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">AWS_ACCOUNT_ID</span><span class="o">=</span><span class="s2">&#34;112233445566&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 eksctl 自动创建对应的 role 并添加信任关系</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 需要先安装好 eksctl</span>
</span></span><span class="line"><span class="cl">eksctl create iamserviceaccount <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --cluster <span class="s2">&#34;</span><span class="si">${</span><span class="nv">CLUSTER_NAME</span><span class="si">}</span><span class="s2">&#34;</span> --name cert-manager --namespace cert-manager <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --role-name <span class="s2">&#34;</span><span class="si">${</span><span class="nv">CLUSTER_NAME</span><span class="si">}</span><span class="s2">-cert-manager-route53-role&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --attach-policy-arn <span class="s2">&#34;arn:aws:iam::</span><span class="si">${</span><span class="nv">AWS_ACCOUNT_ID</span><span class="si">}</span><span class="s2">:policy/&lt;ClusterName&gt;CertManagerRoute53Access&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --role-only <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --approve
</span></span></code></pre></td></tr></table>
</div>
</div><p>之后需要为 cert-manager 的 ServiceAccount 添加注解来绑定上面刚创建好的 IAM Role，首先创建如下 helm values 文件 <code>cert-manager-values.yaml</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># 如果把这个改成 false，也会导致 cert-manager 的所有 CRDs 及相关资源被删除！</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">installCRDs</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">serviceAccount</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">annotations</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 注意修改这里的 ${AWS_ACCOUNT_ID} 以及 ${CLUSTER_NAME}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">eks.amazonaws.com/role-arn</span><span class="p">:</span><span class="w"> </span><span class="p">&gt;-</span><span class="sd">
</span></span></span><span class="line"><span class="cl"><span class="sd">      </span><span class="w">      </span><span class="l">arn:aws:iam::${AWS_ACCOUNT_ID}:role/${CLUSTER_NAME}-cert-manager-route53-role</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">securityContext</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 根据官方文档，还得修改下这个，允许 cert-manager 读取 ServiceAccount Token，从而获得授权</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">fsGroup</span><span class="p">:</span><span class="w"> </span><span class="m">1001</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然后重新部署 cert-manager:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">helm upgrade -i cert-manager ./cert-manager -n cert-manager -f cert-manager-values.yaml
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样就完成了授权。</p>
<h5 id="112-创建一个使用-aws-route53-进行验证的-acme-issuer" class="headerLink">
    <a href="#112-%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e4%bd%bf%e7%94%a8-aws-route53-%e8%bf%9b%e8%a1%8c%e9%aa%8c%e8%af%81%e7%9a%84-acme-issuer" class="header-mark"></a>1.1.2 创建一个使用 AWS Route53 进行验证的 ACME Issuer</h5><p>在 xxx 名字空间创建一个 Iusser：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">cert-manager.io/v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Issuer</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">letsencrypt-prod-aws</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">xxx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">acme</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 用于接受域名过期提醒的邮件地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">email</span><span class="p">:</span><span class="w"> </span><span class="l">user@example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># ACME 服务器，比如 let&#39;s encrypt、Digicert 等</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># let&#39;s encrypt 的测试 URL，可用于测试配置正确性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># server: https://acme-staging-v02.api.letsencrypt.org/directory</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># let&#39;s encrypt 的正式 URL，有速率限制</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">server</span><span class="p">:</span><span class="w"> </span><span class="l">https://acme-v02.api.letsencrypt.org/directory</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 用于存放 ACME 账号私钥的 Secret 名称，Issuer 创建时会自动生成此 secret</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">privateKeySecretRef</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">letsencrypt-prod-aws</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># DNS 验证设置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">solvers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># 在有多个 solvers 的情况下，会根据每个 solvers 的 selector 来确定优先级，选择其中合适的 solver 来处理证书申请事件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># 以 dnsZones 为例，越长的 Zone 优先级就越高</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># 比如在为 www.sys.exapmle.com 申请证书时，sys.example.com 的优先级就比 example.com 更高</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">dnsZones</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="s2">&#34;example.com&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">dns01</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># 使用 route53 进行验证</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">route53</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">region</span><span class="p">:</span><span class="w"> </span><span class="l">us-east-1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="c"># cert-manager 已经通过 ServiceAccount 绑定了 IAM Role</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="c"># 这里不需要补充额外的 IAM 授权相关信息！</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="12-使用-alidns-创建一个证书签发者certificate-issuer" class="headerLink">
    <a href="#12-%e4%bd%bf%e7%94%a8-alidns-%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e8%af%81%e4%b9%a6%e7%ad%be%e5%8f%91%e8%80%85certificate-issuer" class="header-mark"></a>1.2 使用 AliDNS 创建一个证书签发者「Certificate Issuer」</h4><blockquote>
<p><a href="https://cert-manager.io/docs/configuration/acme/dns01/#webhook" target="_blank" rel="noopener noreferrer">https://cert-manager.io/docs/configuration/acme/dns01/#webhook</a></p>
</blockquote>
<p>cert-manager 官方并未提供 alidns 相关的支持，而是提供了一种基于 WebHook 的拓展机制。社区有第三方创建了对 alidns 的支持插件：</p>
<ul>
<li><a href="https://github.com/DEVmachine-fr/cert-manager-alidns-webhook" target="_blank" rel="noopener noreferrer">cert-manager-alidns-webhook</a></li>
</ul>
<p>下面我们使用此插件演示下如何创建一个证书签发者。</p>
<h5 id="111-通过-iam-授权-cert-manager-调用-aws-route53-api-1" class="headerLink">
    <a href="#111-%e9%80%9a%e8%bf%87-iam-%e6%8e%88%e6%9d%83-cert-manager-%e8%b0%83%e7%94%a8-aws-route53-api-1" class="header-mark"></a>1.1.1 通过 IAM 授权 cert-manager 调用 AWS Route53 API</h5><p>首先需要在阿里云上创建一个子账号，名字可以使用 <code>alidns-acme</code>，给它授权 DNS 修改权限，然后为该账号生成 ACCESS_KEY_ID/ACCESS_SECRET。</p>
<p>完成后，使用如下命令将 key/secret 内容创建为 secret 供后续步骤使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 注意替换如下命令中的 &lt;xxx&gt; 为你的 key/secret</span>
</span></span><span class="line"><span class="cl">kubectl -n cert-manager create secret generic alidns-secrets <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --from-literal<span class="o">=</span><span class="s2">&#34;access-token=&lt;your-access-key-id&gt;&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --from-literal<span class="o">=</span><span class="s2">&#34;secret-key=&lt;your-access-secret-key&gt;&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来需要部署 <a href="https://github.com/DEVmachine-fr/cert-manager-alidns-webhook" target="_blank" rel="noopener noreferrer">cert-manager-alidns-webhook</a> 这个 cert-manager 插件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 添加 helm 仓库</span>
</span></span><span class="line"><span class="cl">helm repo add cert-manager-alidns-webhook https://devmachine-fr.github.io/cert-manager-alidns-webhook
</span></span><span class="line"><span class="cl">helm repo update
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 安装插件</span>
</span></span><span class="line"><span class="cl"><span class="c1">## 其中的 groupName 是一个全局唯一的标识符，用于标识创建此 webhook 的组织，建议使用公司域名</span>
</span></span><span class="line"><span class="cl"><span class="c1">## groupName 必须与后面创建的 Issuer 中的 groupName 一致，否则证书将无法通过验证！</span>
</span></span><span class="line"><span class="cl">helm -n cert-manager install alidns-webhook <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  cert-manager-alidns-webhook/alidns-webhook <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --set <span class="nv">groupName</span><span class="o">=</span>example.com
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="112-创建一个使用-alidns-进行验证的-acme-issuer" class="headerLink">
    <a href="#112-%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e4%bd%bf%e7%94%a8-alidns-%e8%bf%9b%e8%a1%8c%e9%aa%8c%e8%af%81%e7%9a%84-acme-issuer" class="header-mark"></a>1.1.2 创建一个使用 AliDNS 进行验证的 ACME Issuer</h5><p>在 xxx 名字空间创建一个 Iusser：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">cert-manager.io/v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Issuer</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">letsencrypt-prod-alidns</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">xxx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">acme</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 用于接受域名过期提醒的邮件地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">email</span><span class="p">:</span><span class="w"> </span><span class="l">user@example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># ACME 服务器，比如 let&#39;s encrypt、Digicert 等</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># let&#39;s encrypt 的测试 URL，可用于测试配置正确性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># server: https://acme-staging-v02.api.letsencrypt.org/directory</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># let&#39;s encrypt 的正式 URL，有速率限制</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">server</span><span class="p">:</span><span class="w"> </span><span class="l">https://acme-v02.api.letsencrypt.org/directory</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 用于存放 ACME 账号私钥的 Secret 名称，Issuer 创建时会自动生成此 secret</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">privateKeySecretRef</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">letsencrypt-prod-alidns</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># DNS 验证设置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">solvers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># 在有多个 solvers 的情况下，会根据每个 solvers 的 selector 来确定优先级，选择其中合适的 solver 来处理证书申请事件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># 以 dnsZones 为例，越长的 Zone 优先级就越高</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># 比如在为 www.sys.exapmle.com 申请证书时，sys.example.com 的优先级就比 example.com 更高</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># 适用场景：如果你拥有多个域名，使用了多个域名提供商，就可能需要用到它</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">dnsZones</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="s2">&#34;example.com&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">dns01</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">webhook</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">config</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="nt">accessTokenSecretRef</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">access-token</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">alidns-secrets</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="nt">regionId</span><span class="p">:</span><span class="w"> </span><span class="l">cn-beijing</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="nt">secretKeySecretRef</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">secret-key</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">alidns-secrets</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c"># 这个 groupName 必须与之前部署插件时设置的一致！</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">groupName</span><span class="p">:</span><span class="w"> </span><span class="l">example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">solverName</span><span class="p">:</span><span class="w"> </span><span class="l">alidns-solver</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="13-通过-acme-创建证书" class="headerLink">
    <a href="#13-%e9%80%9a%e8%bf%87-acme-%e5%88%9b%e5%bb%ba%e8%af%81%e4%b9%a6" class="header-mark"></a>1.3 通过 ACME 创建证书</h4><blockquote>
<p><a href="https://cert-manager.io/docs/usage/certificate/#creating-certificate-resources" target="_blank" rel="noopener noreferrer">https://cert-manager.io/docs/usage/certificate/#creating-certificate-resources</a></p>
</blockquote>
<p>在创建证书前，先简单过一下证书的申请流程，示意图如下（出问题时需要靠这个来排查）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(  +---------+  )
</span></span><span class="line"><span class="cl">  (  | Ingress |  ) Optional                                              ACME Only!
</span></span><span class="line"><span class="cl">  (  +---------+  )
</span></span><span class="line"><span class="cl">         |                                                     |
</span></span><span class="line"><span class="cl">         |   +-------------+      +--------------------+       |  +-------+       +-----------+
</span></span><span class="line"><span class="cl">         |-&gt; | Certificate |----&gt; | CertificateRequest | ----&gt; |  | Order | ----&gt; | Challenge | 
</span></span><span class="line"><span class="cl">             +-------------+      +--------------------+       |  +-------+       +-----------+
</span></span><span class="line"><span class="cl">                                                               |
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用如下配置创建证书，并将证书保存到指定的 Secret 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">cert-manager.io/v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Certificate</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">example-com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">xxx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># Secret names are always required.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># Istio Gateway/Ingress/Gateway API 都可以通过直接引用这个 secret 来添加 TLS 加密。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">secretName</span><span class="p">:</span><span class="w"> </span><span class="l">tls-example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># secretTemplate is optional. If set, these annotations and labels will be</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># copied to the Secret named tls-example.com. These labels and annotations will</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># be re-reconciled if the Certificate&#39;s secretTemplate changes. secretTemplate</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># is also enforced, so relevant label and annotation changes on the Secret by a</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># third party will be overwriten by cert-manager to match the secretTemplate.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">secretTemplate</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">annotations</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">my-secret-annotation-1</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;foo&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">my-secret-annotation-2</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;bar&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">my-secret-label</span><span class="p">:</span><span class="w"> </span><span class="l">foo</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">duration</span><span class="p">:</span><span class="w"> </span><span class="l">2160h</span><span class="w"> </span><span class="c"># 90d</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">renewBefore</span><span class="p">:</span><span class="w"> </span><span class="l">360h</span><span class="w"> </span><span class="c"># 15d</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># https://cert-manager.io/docs/reference/api-docs/#cert-manager.io/v1.CertificatePrivateKey</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">privateKey</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">algorithm</span><span class="p">:</span><span class="w"> </span><span class="l">ECDSA </span><span class="w"> </span><span class="c"># RSA/ECDSA/Ed25519，其中 RSA 应用最广泛，Ed25519 被认为最安全</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">encoding</span><span class="p">:</span><span class="w"> </span><span class="l">PKCS1 </span><span class="w"> </span><span class="c"># 对于 TLS 加密，通常都用 PKCS1 格式</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">size</span><span class="p">:</span><span class="w"> </span><span class="m">256</span><span class="w">  </span><span class="c"># RSA 默认为 2048，ECDSA 默认为 256，而 Ed25519 不使用此属性！</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">rotationPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">Always </span><span class="w"> </span><span class="c"># renew 时总是重新创建新的私钥</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># The use of the common name field has been deprecated since 2000 and is</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># discouraged from being used.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">commonName</span><span class="p">:</span><span class="w"> </span><span class="l">example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># At least one of a DNS Name, URI, or IP address is required.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">dnsNames</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="l">example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="s1">&#39;*.example.com&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">isCA</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">usages</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="l">server auth</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="l">client auth</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># uris:  # 如果想在证书的 subjectAltNames 中添加 URI，就补充在这里</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c">#   - spiffe://cluster.local/ns/sandbox/sa/example</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># ipAddresses:  # 如果想在证书的 subjectAltNames 添加 ip 地址，就补充在这里</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c">#   - 192.168.0.5</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">subject</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 证书的补充信息</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 字段索引：https://cert-manager.io/docs/reference/api-docs/#cert-manager.io/v1.X509Subject</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">organizations</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">xxx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># Issuer references are always required.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">issuerRef</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">letsencrypt-prod-aws</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># name: letsencrypt-prod-alidns  # 如果你前面创建的是 alidns 那就用这个</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Issuer </span><span class="w"> </span><span class="c"># 如果你创建的是 ClusterIssuer 就需要改下这个值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">group</span><span class="p">:</span><span class="w"> </span><span class="l">cert-manager.io</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>部署好 Certificate 后，describe 它就能看到当前的进度：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Events: 
</span></span><span class="line"><span class="cl">  Type    Reason     Age   From    Message 
</span></span><span class="line"><span class="cl">  ----    ------     ----  ----    ------- 
</span></span><span class="line"><span class="cl">  Normal  Issuing    117s  cert-manager-certificates-trigger   Issuing certificate as Secret does not exist      
</span></span><span class="line"><span class="cl">  Normal  Generated  116s  cert-manager-certificates-key-manager      Stored new private key in temporary Secret resource &#34;example.com-f044j&#34;     
</span></span><span class="line"><span class="cl">  Normal  Requested  116s  cert-manager-certificates-request-manager  Created new CertificateRequest resource &#34;example.com-unv3d&#34;   
</span></span><span class="line"><span class="cl">  Normal  Issuing    20s   cert-manager-certificates-issuing   The certificate has been successfully issued
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果发现证书长时间未 Ready，可以参照<a href="https://cert-manager.io/docs/faq/acme/" target="_blank" rel="noopener noreferrer">官方文档 - Troubleshooting Issuing ACME Certificates</a>，按证书申请流程进行逐层排查：</p>
<ul>
<li>首先 cert-manager 发现 Certificate 描述的 Secret 不存在，于是启动证书申请流程</li>
<li>首先生成私钥，存放在一个临时 Secret 中</li>
<li>然后通过私钥以及 Certificate 资源中的其他信息，生成 CSR 证书申请请求文件
<ul>
<li>这也是一个 CRD 资源，可以通过 <code>kubectl get csr -n xxx</code> 查看</li>
</ul>
</li>
<li>接着将 CSR 文件提交给 ACME 服务器，申请权威机构签发证书
<ul>
<li>这对应 CRD 资源 <code>kubectl get order</code></li>
</ul>
</li>
<li>对于上述 ACME 证书申请流程，Order 实际上会生成一个 DNS1 Challenge 资源
<ul>
<li>可以通过 <code>kubectl get challenge</code> 检查此资源</li>
</ul>
</li>
<li>challenge 验证通过后会逐层往回走，前面的 Order CSR 状态都会立即变成 valid</li>
<li>最终证书签发成功，Certificate 状态变成 Ready，所有 Order CSR challenge 资源都被自动清理掉。</li>
</ul>
<h4 id="14-通过-csi-driver-创建证书" class="headerLink">
    <a href="#14-%e9%80%9a%e8%bf%87-csi-driver-%e5%88%9b%e5%bb%ba%e8%af%81%e4%b9%a6" class="header-mark"></a>1.4 通过 csi-driver 创建证书</h4><blockquote>
<p><a href="https://cert-manager.io/docs/projects/csi-driver/" target="_blank" rel="noopener noreferrer">https://cert-manager.io/docs/projects/csi-driver/</a></p>
</blockquote>
<p>直接使用 <code>Certificate</code> 资源创建的证书，会被存放在 Kubernetes Secrets 中，被认为并非足够安全。
而 cert-manager csi-driver 则避免了这个缺陷，具体而言，它提升安全性的做法有：</p>
<ul>
<li>确保私钥仅保存在对应的节点上，并挂载到对应的 Pod，完全避免私钥被通过网络传输。</li>
<li>应用的每个副本都使用自己生成的私钥，并且能确保在 Pod 的生命周期中证书跟私钥始终存在。</li>
<li>自动 renew 证书</li>
<li>副本被删除时，证书就会被销毁</li>
</ul>
<p>总的说 csi-driver 主要是用来提升安全性的，有需要可以自己看文档，就不多介绍了。</p>
<h3 id="2-通过私有-ca-颁发证书" class="headerLink">
    <a href="#2-%e9%80%9a%e8%bf%87%e7%a7%81%e6%9c%89-ca-%e9%a2%81%e5%8f%91%e8%af%81%e4%b9%a6" class="header-mark"></a>2. 通过私有 CA 颁发证书</h3><p>Private CA 是一种企业自己生成的 CA 证书，通常企业用它来构建自己的 PKI 基础设施。</p>
<p>在 TLS 协议这个应用场景下，Private CA 颁发的证书仅适合在企业内部使用，必须在客户端安装上这个 CA 证书，才能正常访问由它签名的数字证书加密的 Web API 或者站点。<strong>Private CA 签名的数字证书在公网上是不被信任的</strong>！</p>
<p>cert-manager 提供的 Private CA 服务有：</p>
<ul>
<li><a href="https://cert-manager.io/docs/configuration/vault/" target="_blank" rel="noopener noreferrer">Vault</a>: 鼎鼎大名了，Vault 是一个密码即服务工具，可以部署在 K8s 集群中，提供许多密码、证书相关的功能。
<ul>
<li>开源免费</li>
</ul>
</li>
<li><a href="https://github.com/cert-manager/aws-privateca-issuer" target="_blank" rel="noopener noreferrer">AWS Certificate Manager Private CA</a>: 跟 Vault 的 CA 功能是一致的，区别是它是托管的，由 AWS 负责维护。
<ul>
<li>每个 Private CA 证书：$400/month</li>
<li>每个签发的证书（仅读取了私钥及证书内容后才会收费）：按梯度一次性收费，0-1000 个以内是 $0.75 每个</li>
</ul>
</li>
<li>其他的自己看文档&hellip;</li>
</ul>
<p>这个因为暂时用不上，所以还没研究，之后有研究再给补上。</p>
<p>TO BE DONE.</p>
<h2 id="三cert-manager-与-istioingress-等网关集成" class="headerLink">
    <a href="#%e4%b8%89cert-manager-%e4%b8%8e-istioingress-%e7%ad%89%e7%bd%91%e5%85%b3%e9%9b%86%e6%88%90" class="header-mark"></a>三、cert-manager 与 istio/ingress 等网关集成</h2><p>cert-manager 提供的 <code>Certificate</code> 资源，会将生成好的公私钥存放在 Secret 中，而 Istio/Ingress 都支持这种格式的 Secret，所以使用还是挺简单的。</p>
<p>以 Istio Gateway 为例，直接在 Gateway 资源上指定 Secret 名称即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">networking.istio.io/v1alpha3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Gateway</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">example-gateway</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">istio</span><span class="p">:</span><span class="w"> </span><span class="l">ingressgateway</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">servers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">port</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">number</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">http</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">protocol</span><span class="p">:</span><span class="w"> </span><span class="l">HTTP</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">hosts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="l">product.example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">tls</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">httpsRedirect</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># sends 301 redirect for http requests</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">port</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">number</span><span class="p">:</span><span class="w"> </span><span class="m">8443</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">https</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">protocol</span><span class="p">:</span><span class="w"> </span><span class="l">HTTPS</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">tls</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">mode</span><span class="p">:</span><span class="w"> </span><span class="l">SIMPLE</span><span class="w"> </span><span class="c"># enables HTTPS on this port</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">credentialName</span><span class="p">:</span><span class="w"> </span><span class="l">tls-example.com</span><span class="w"> </span><span class="c"># This should match the Certificate secretName</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">hosts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="l">product.example.com</span><span class="w"> </span><span class="c"># This should match a DNS name in the Certificate</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">networking.istio.io/v1alpha3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">VirtualService</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">product</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">hosts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="l">product.example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">gateways</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="l">example-gateway</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">http</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">route</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">destination</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">host</span><span class="p">:</span><span class="w"> </span><span class="l">product</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">port</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">number</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">product</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">product</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">prod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">grpc</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">9090</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">protocol</span><span class="p">:</span><span class="w"> </span><span class="l">TCP</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">9090</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">http</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">protocol</span><span class="p">:</span><span class="w"> </span><span class="l">TCP</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">product</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">sessionAffinity</span><span class="p">:</span><span class="w"> </span><span class="l">None</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">ClusterIP</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">networking.istio.io/v1alpha3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">DestinationRule</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">product</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">host</span><span class="p">:</span><span class="w"> </span><span class="l">product</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 定义了两个 subset</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">subsets</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="l">v2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">v2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 其他 deployment 等配置</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>之后再配合 VirtualService 等资源，就可以将 Istio 跟 cert-manager 结合起来啦。</p>
<h2 id="四将-cert-manager-证书挂载到自定义网关中" class="headerLink">
    <a href="#%e5%9b%9b%e5%b0%86-cert-manager-%e8%af%81%e4%b9%a6%e6%8c%82%e8%bd%bd%e5%88%b0%e8%87%aa%e5%ae%9a%e4%b9%89%e7%bd%91%e5%85%b3%e4%b8%ad" class="header-mark"></a>四、将 cert-manager 证书挂载到自定义网关中</h2><blockquote>
<p>注意，千万别使用 <code>subPath</code> 挂载，根据<a href="https://kubernetes.io/docs/concepts/configuration/secret/#mounted-secrets-are-updated-automatically" target="_blank" rel="noopener noreferrer">官方文档</a>，这种方式挂载的 Secret 文件不会自动更新！</p>
</blockquote>
<p>既然证书被存放在 Secret 中，自然可以直接当成数据卷挂载到 Pods 中，示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">nginx:latest</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">tls-example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;/certs/example.com&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">readOnly</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">tls-example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">secret</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">secretName</span><span class="p">:</span><span class="w"> </span><span class="l">tls-example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">optional</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="c"># default setting; &#34;mysecret&#34; must exist</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于 nginx 而言，可以简单地搞个 sidecar 监控下，有配置变更就 reload 下 nginx，实现证书自动更新。</p>
<p>或者可以考虑直接写个 k8s informer 监控 secret 的变更，有变更就直接 reload 所有 nginx 实例，总之实现的方式有很多种。</p>
<h2 id="五注意事项" class="headerLink">
    <a href="#%e4%ba%94%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9" class="header-mark"></a>五、注意事项</h2><p>服务端 TLS 协议的配置有许多的优化点，有些配置对性能的提升是很明显的，建议自行网上搜索相关资料，这里仅列出部分相关信息。</p>
<h3 id="ocsp-证书验证协议会大幅拖慢-https-协议的响应速度" class="headerLink">
    <a href="#ocsp-%e8%af%81%e4%b9%a6%e9%aa%8c%e8%af%81%e5%8d%8f%e8%ae%ae%e4%bc%9a%e5%a4%a7%e5%b9%85%e6%8b%96%e6%85%a2-https-%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%93%8d%e5%ba%94%e9%80%9f%e5%ba%a6" class="header-mark"></a>OCSP 证书验证协议会大幅拖慢 HTTPS 协议的响应速度</h3><blockquote>
<p><a href="https://www.ssl.com/blogs/how-do-browsers-handle-revoked-ssl-tls-certificates/" target="_blank" rel="noopener noreferrer">https://www.ssl.com/blogs/how-do-browsers-handle-revoked-ssl-tls-certificates/</a></p>
</blockquote>
<blockquote>
<p><a href="https://imququ.com/post/why-can-not-turn-on-ocsp-stapling.html" target="_blank" rel="noopener noreferrer">https://imququ.com/post/why-can-not-turn-on-ocsp-stapling.html</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.digicert.com/help/" target="_blank" rel="noopener noreferrer">https://www.digicert.com/help/</a></p>
</blockquote>
<p>前面提到除了数字证书自带的有效期外，为了在私钥泄漏的情况下，能够吊销对应的证书，PKI 公钥基础设施还提供了 OCSP（Online Certificate Status Protocol）证书状态查询协议。</p>
<p>可以使用如下命令测试，确认站点是否启用了 ocsp stapling:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ openssl s_client -connect www.digicert.com:443 -servername www.digicert.com -status -tlsextdebug &lt; /dev/null 2&gt;&amp;1 | grep -i &#34;OCSP response&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果输出包含 <code>OCSP Response Status: successful</code> 就说明站点支持 ocsp stapling，
如果输出内容为 <code>OCSP response: no response sent</code> 则说明站点不支持ocsp stapling。</p>
<blockquote>
<p>实际上 Google/AWS 等大多数站点都不会启用也不需要启用 ocsp stapling，一是因为它们自己就是证书颁发机构，OCSP 服务器也归它们自己管，不存在隐私的问题。二是它们的 OCSP 服务器遍布全球，也不存在性能问题。
这种情况下开个 OCSP Stapling 反而是浪费流量，因为每次 TLS 握手都得发送一个 OCSP 状态信息。</p>
</blockquote>
<blockquote>
<p>我测试发现只有 <a href="https://www.digicert.com/www.douban.com" target="_blank" rel="noopener noreferrer">www.digicert.com/www.douban.com</a> 等少数站点启用了 ocsp stapling，www.baidu.com/www.google.com/www.zhihu.com 都未启用 ocsp stapling.</p>
</blockquote>
<p>这导致了一些问题：</p>
<ul>
<li>Chrome/Firefox 等浏览器都会定期通过 OCSP 协议去请求 CA 机构的 OCSP 服务器验证证书状态，这可能会拖慢 HTTPS 协议的响应速度。
<ul>
<li>所谓的定期是指超过上一个 OCSP 响应的 <code>nextUpdate</code> 时间（一般为 7 天），或者如果该值为空的话，Firefox 默认 24h 后会重新查询 OCSP 状态。</li>
</ul>
</li>
<li>因为客户端直接去请求 CA 机构的 OCSP 地址获取证书状态，这就导致 CA 机构可以获取到一些对应站点的用户信息（IP 地址、网络状态等）。</li>
</ul>
<p>为了解决这两个问题，<a href="https://www.rfc-editor.org/rfc/rfc6066" target="_blank" rel="noopener noreferrer">rfc6066</a> 定义了 OCSP stapling 功能，它使服务器可以提前访问 OCSP 获取证书状态信息并缓存到本地，基本 Nginx/Caddy 等各大 Web 服务器或网关，都支持 OCSP stapling 协议。</p>
<p>在客户端使用 TLS 协议访问 HTTPS 服务时，服务端会直接在握手阶段将缓存的 OCSP 信息发送给客户端。
因为 OCSP 信息会带有 CA 证书的签名及有效期，客户端可以直接通过签名验证 OCSP 信息的真实性与有效性，这样就避免了客户端访问 OCSP 服务器带来的开销。</p>
<p>而另一个方法，就是选用 ocsp 服务器在目标用户区域速度快的 CA 机构签发证书。</p>
]]></content></entry><entry><title type="html">Death Is But a Dream</title><link href="https://thiscute.world/posts/death-is-but-a-dream/"/><id>https://thiscute.world/posts/death-is-but-a-dream/</id><author><name>ryan4yin</name></author><published>2022-05-24T02:17:00+08:00</published><updated>2022-05-24T02:17:00+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/death-is-but-a-dream/death-is-but-a-dream.webp" height="1100" width="619"><figcaption></figcaption>
        </figure><blockquote>
<p>我并不知道何时才是死期，<br>
却日日问自己，<br>
会不会有幽灵来牵我的手，<br>
引我一路向西？<br>
可他们看到的光明又在哪里？<br>
会不会也为我亮起？<br>
这一切快来吧，我已等不及！<br>
——《红色地带的沉思》 by 临终患者 Patricia</p>
</blockquote>
<p>我最近在看一本书，《在生命的尽头拥抱你-临终关怀医生手记》，它的英文原名即本文的标题。
李白在《春夜宴从弟桃花园序》中写「而浮生若梦，为欢几何？」，仿照下文法，本文的标题「Death Is But a Dream」大概可以直译成「临终若梦」，跟此书的中文版名称有些不同的韵味在。</p>
<p>这书讲的是死亡的过程——临终梦境。
随着年龄渐长，老一辈们慢慢老去，我们都不可避免地会越来越多地接触到死亡。
这世间轮替更迭，爱恨情仇是不变的主题，但是死亡始终是配角，实在是因为每人一生都只有唯一一次机会去真正体味死亡，难有实感。
而且死亡往往代表着终结，我们做为生者，当然更向往书写生者的世界。</p>
<p>救人一命胜造七级浮屠，珍爱生命是我们从小到大被教育的思想。
但是这样的思想却也造成了许多悲剧，全世界有许多的患者痛苦不堪地活在世上，求死不能，最终在病魔的折磨下凄惨离世，如果我们能谨慎承认「死亡」的价值，从这个角度看也是拯救了许多的患者与家庭。</p>
<p>而关于死亡，在我亲身经历的几次长辈葬礼中，我发现父辈们对死亡大都看得很开，他们说「人总有一死，老人家过世了我们当子女的肯定要送最后一程，但是不需要想太多，魂归天地罢了。」，我佩服这种豁达。</p>
<p>但是说到临终梦境，我是真的没什么了解。
我从来没跟长辈交流过生命末期的梦境，脑海中也挖掘不出相关的记忆。
送走我爷爷的时候，看着爷爷因为呼吸困难而大口喘气，堂哥跪在我前面，双眼泛红隐含泪光，但我完全没有实感——一切都显得那么不真实。
听着爷爷被痰堵塞气管、艰难的呼吸声，我甚至感到害怕，想要逃离。</p>
<p>爷爷过世后，奶奶就是一个人生活了，一个人起居、一个人给菜苗松土，然后在菜地里不小心跌了一跤，就随着爷爷去了。</p>
<blockquote>
<p>2023/1/7 补充：跟堂弟印照记忆后发现，这里我的记忆或许已经不对了&hellip;</p>
</blockquote>
<p>我后来在爷爷奶奶房里一个壁橱上，找到三四枚铜钱，还沾着泥土，有些锈蚀痕迹。
我把其中一枚通宝红线串好，贴身带了好几年，心情不好的时候就凝视着这枚铜钱黯然神伤，心情好的时候也要捂着它入睡。</p>
<p>我还喜欢上了戏曲，缠着同学读了她的《中国戏剧史》。
大学的时候又喜欢上越剧，吴侬软语。
又因为初中时学过点竹笛，喜欢上了传统乐曲，我对一些经典老歌也情有独钟。
在很多同学跟同事的眼中，我的音乐品味是很「独特」的，这或许都源自爷爷奶奶的熏陶。
实际上我小的时候并不喜欢戏剧，我跟爷爷奶奶去看庙戏的目的，通常都只是为了吃一碗凉粉，或者为了去玩耍、看个热闹。偶尔去爷爷奶奶家玩，也只是觉得他们太孤单了，跟他们随便聊聊天，实际上这么多年，跟爷爷奶奶看过的戏曲，我就没听懂过几句台词。</p>
<p>那是多少年前了呢？只知道是很多年前了，不仔细回忆回忆、掐指算算，都搞不清具体过了多少年月。
这么多个日日夜夜里，我幼稚过、热血过，也迷茫过、颓废过，倒也不算庸庸碌碌，我还是知足的，这种心态貌似是被称作现充 emmm</p>
<p>高三时曾经看过一本超级喜欢的励志书，这么多年来我一直带在身边，名字叫《这一生再也不会有的奇遇》。书的扉页只有一句话：「当明天再也不是无限，你还会像今天一样度过你的人生吗？」</p>
<figure><img src="/images/death-is-but-a-dream/an-adventure-that-will-never-happen-again-in-this-life_cover.webp"/><figcaption>
            <h4>《这一生再也不会有的奇遇》已陪我度过了七八个春秋</h4>
        </figcaption>
</figure>

<figure><img src="/images/death-is-but-a-dream/an-adventure-that-will-never-happen-again-in-this-life_title-page.webp"/><figcaption>
            <h4>当明天再也不是无限</h4>
        </figcaption>
</figure>

<p>写到这儿，我又想起我高中时还看过一本书《刺猬的优雅》，它同样陪伴我度过了四年大学岁月，后来又辗转到了深圳，但现在倒是不在身边。书中有几句话我印象深刻，放在这篇文章里也挺应景的：</p>
<blockquote>
<p>话又说回来，不能因为有想死的心，往后就要像烂菜帮一样的过日子，甚至应该完全相反。</p>
</blockquote>
<blockquote>
<p>重要的不是死亡，而是在死亡的那一刻我们在做什么。<br>
我在做什么呢？<br>
我曾遇到一个人，而且我正准备爱上他。</p>
</blockquote>
<p>随意写下这些文字，脑子里各种想法恣意流淌，我打算提前写写我的临终遗言，把一切都准备好。</p>
<p>但在死亡到来之前，我仍要精彩的活！</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://book.douban.com/subject/35435120/" target="_blank" rel="noopener noreferrer">《在生命的尽头拥抱你-临终关怀医生手记》</a></li>
<li><a href="https://www.youtube.com/watch?v=vh-nacCekR4" target="_blank" rel="noopener noreferrer">Death Is But A Dream (2021) Official trailer</a></li>
<li><a href="https://www.youtube.com/watch?v=rbnBe-vXGQM" target="_blank" rel="noopener noreferrer">I See Dead People: Dreams and Visions of the Dying | Dr. Christopher Kerr | TEDxBuffalo</a></li>
<li><a href="https://www.drchristopherkerr.com/tools" target="_blank" rel="noopener noreferrer">End-of-Life Experiences - Dr. Christopher Kerr</a></li>
<li><a href="https://www.zhihu.com/question/21174281/answer/122969510" target="_blank" rel="noopener noreferrer">有谁看过《刺猬的优雅》这本书吗？如何？ - 於清樂</a></li>
<li><a href="https://www.zhihu.com/question/52078970/answer/128900485" target="_blank" rel="noopener noreferrer">有什么人生中值得一读的小说或名著？（最好现代作家的书）？ - 於清樂</a></li>
</ul>
]]></content></entry><entry><title type="html">NAT 网关、NAT 穿越以及虚拟网络</title><link href="https://thiscute.world/posts/about-nat/"/><id>https://thiscute.world/posts/about-nat/</id><author><name>ryan4yin</name></author><published>2022-05-13T11:46:00+08:00</published><updated>2022-05-13T11:46:00+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/about-nat/nat.webp" height="728" width="250"><figcaption></figcaption>
        </figure><blockquote>
<p>个人笔记，不一定正确&hellip;</p>
</blockquote>
<blockquote>
<p>当前文章完成度 - 70%</p>
</blockquote>
<h2 id="前言" class="headerLink">
    <a href="#%e5%89%8d%e8%a8%80" class="header-mark"></a>前言</h2><p>NAT，即 Network Address Translation，是 IPv4 网络中非常重要的一个功能，用于执行 IP 地址与端口的转换。</p>
<p>IPv4 的设计者没预料到因特网技术的发展会如此之快，在设计时只使用了 32bits 的地址空间，随着因特网的飞速发展，它很快就变得不够用了。
后来虽然设计了新的 IPv6 协议，但是它与 IPv4 不兼容，需要新的硬件设备以及各种网络程序支持，无法快速普及。</p>
<p>NAT 就是在 IPv6 普及前，临时解决 IPv4 地址空间不够用而开发的技术，通俗地讲 NAT 就是用来给 IPv4 续命的。它解决 IPv4 地址短缺问题的方法是：</p>
<ul>
<li>每个家庭、组织、企业，在内部都使用局域网通讯，不占用公网 IPv4 资源</li>
<li>在局域网与上层网络的交界处（路由器），使用 NAT 技术进行 IP/port 转换，使用户能正常访问上层网络</li>
</ul>
<p>在曾经 IPv4 地址还不是特别短缺的时候，普通家庭的网络架构通常是：「家庭局域网」=&gt;「NAT 网关（家庭路由器）」=&gt;「因特网」。</p>
<p>但是互联网主要发展于欧美，因此许多欧美的组织与机构在初期被分配了大量的 IPv4 资源，而后入场的中国分配到的 IPv4 地址就不太能匹配上我们的人口。
因此相比欧美，中国的 IPv4 地址是非常短缺的，即使使用上述这样的网络架构——也就是给每个家庭（或组织）分配一个 IPv4 地址——都有点捉襟见肘了。
于是中国电信等运营商不得不再加一层 NAT，让多个家庭共用同一个 IP 地址，这时网络架构会变成这样：「家庭局域网」=&gt;「家庭 NAT 网关」=&gt;「运营商广域网」=&gt;「运营商 NAT 网关」=&gt;「公共因特网」。
由于此架构通过两层 NAT 网关串联了三个不同的 IPv4 网络，它也被形象地称为 <strong>NAT444</strong> 技术，详见 <a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E4%BF%A1%E7%BA%A7NAT" target="_blank" rel="noopener noreferrer">电信级NAT - 维基百科</a>。</p>
<blockquote>
<p><a href="https://v2ex.com/t/876430" target="_blank" rel="noopener noreferrer">据 v2ex 上传闻</a>因为 IPv4 地址紧缺，国内运营商甚至开始尝试使用 <strong>NAT4444</strong> 了，就是中间加两层运营商的私有网络&hellip;</p>
</blockquote>
<blockquote>
<p>不过 IPv6 也正在变得越来越流行，看 v2ex 上最近（2022-08）就很多人在聊，一些城市在试点 ipv4 over ipv6 隧道技术，底层完全换成 IPv6 协议加 IPoE 拨号了，带来的问题是没法桥接，详见 <a href="https://www.v2ex.com/t/875362" target="_blank" rel="noopener noreferrer">电信又一新动作：上网业务不再使用 PPPoE 新装宽带无法改桥接 - v2ex</a>。</p>
</blockquote>
<p>总的来说，NAT 是一项非常成功的技术，它成功帮 IPv4 续命了几十年，甚至到如今 2022 年，全球网络仍然是 IPv4 的天下。</p>
<h2 id="nat-如何工作" class="headerLink">
    <a href="#nat-%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c" class="header-mark"></a>NAT 如何工作</h2><p>NAT 的工作方式，使用图例描述是这样的：</p>
<figure><img src="/images/about-nat/NAT-demo.webp"/><figcaption>
            <h4>NAT 示例</h4>
        </figcaption>
</figure>

<p>从外部网络看一个 NAT 网关（一个启用了 NAT 的路由器），它只是拥有一个 IPv4 地址的普通设备，所有从局域网发送到公网的流量，其 IP 地址都是这个路由器的 WAN IP 地址，在上图中，这个 IP 地址是 <code>138.76.29.7</code>.</p>
<p>本质上，NAT 网关隐藏了家庭网络的细节，从外部网络上看，整个家庭网络就像一台普通的网络设备。</p>
<p>下面我们会学习到，上述这个 NAT 工作方式实际上是 NAPT，它同时使用 L3/L4 的信息进行地址转换工作。</p>
<h2 id="nat-的地址映射方式" class="headerLink">
    <a href="#nat-%e7%9a%84%e5%9c%b0%e5%9d%80%e6%98%a0%e5%b0%84%e6%96%b9%e5%bc%8f" class="header-mark"></a>NAT 的地址映射方式</h2><p>NAT 的具体实现有许多的变种，不存在统一的规范，但是大体上能分为两种模型：「一对一 NAT」与「一对多 NAT」，下面分别进行介绍。</p>
<h3 id="1-一对一-nat" class="headerLink">
    <a href="#1-%e4%b8%80%e5%af%b9%e4%b8%80-nat" class="header-mark"></a>1. 一对一 NAT</h3><p>一对一 NAT，这种类型的 NAT 在 <a href="https://datatracker.ietf.org/doc/html/rfc2663" target="_blank" rel="noopener noreferrer">RFC2663</a> 中被称为  Basic NAT。
它在技术上比较简单，只利用网络层的信息，对 IP 地址进行转换。</p>
<p>简单的说，Basic NAT 要求每个内网 IP 都需要绑定一个唯一的公网 IP，才能连通外部网络。</p>
<p>其<strong>主要应用场景是，公网用户需要访问到内网主机</strong>。</p>
<p>Basic NAT 有三种类型：「<strong>静态 NAT</strong>」、「<strong>动态 NAT</strong>」以及「<strong>NAT Server</strong>」。</p>
<p>现在的很多家庭路由器都自带一个被称为 DMZ 主机的功能，它是「Demilitarized Zone」的缩写，意为隔离区。
它允许将某一台内网主机设置为 DMZ 主机（或者叫隔离区主机，仅此主机可供外网访问），所有从外部进来的流量，都会被通过 Basic NAT 修改为对应的内网 IP 地址，然后直接发送到该主机。
路由器的这种 DMZ 技术就是「静态 NAT」，因为 DMZ 主机对应的内网 IP 需要手动配置，不会动态变化。</p>
<figure><img src="/images/about-nat/dmz-host-topology.webp"/><figcaption>
            <h4>DMZ 主机拓扑结构</h4>
        </figcaption>
</figure>

<p>而「<strong>动态 NAT</strong>」则需要一个公网 IP 地址池，每次用户需要访问公网时，动态 NAT 会给它分配一个动态公网 IP 并自动配置相应的 NAT 规则，使用完再回收。</p>
<p>第三种是「<strong>NAT Server</strong>」，云服务商提供的「<strong>公网 IP</strong>」就是通过「<strong>NAT Server</strong>」实现的，在云服务器中使用 <code>ip addr ls</code> 查看你会发现，该主机上实际只配了局域网 IP 地址，但是它却能正常使用公网 IP 通信，原因就是云服务商在「<strong>NAT Server</strong>」上为这些服务器配置了 IP 转发规则。
为一台云服务器绑定一个公网 IP，实际上就是请求「<strong>NAT Server</strong>」从公网 IP 地址池中取出一个，并配置对应的 NAT 规则到这台云服务器的局域网 IP。</p>
<p>示例如下，其中的 Internet Gateway 实际上就是个一对一 NAT Server：</p>
<figure><img src="/images/about-nat/aws-vpc-nat-internet-gateway.webp"/><figcaption>
            <h4>AWS VPC 中的 NAT 网关以及 Internet 网关</h4>
        </figcaption>
</figure>

<blockquote>
<p>云服务 VPC 中的公有子网，实际上就是一个 DMZ(Demilitarized Zone) 隔离区，是不安全的。而私有子网则是安全区，公网无法直接访问到其中的主机。</p>
</blockquote>
<p>而「动态 NAT」则需要路由器维护一个<strong>公网 IP 地址池</strong>，内网服务器需要访问公网时，动态 NAT 就从地址池中拿出一个公网 IP 给它使用，用完再回收。
这种场景需要一个公网 IP 地址池，每当内部有服务需要请求外网时，就动态地为它分配一个公网 IP 地址，使用完再回收。</p>
<p>Basic NAT 的好处是，它仅工作在 L3 网络层，网络层上的协议都可以正常使用（比如 P2P），不需要啥「内网穿越」技术。</p>
<h3 id="2-一对多-nat---napt" class="headerLink">
    <a href="#2-%e4%b8%80%e5%af%b9%e5%a4%9a-nat---napt" class="header-mark"></a>2. 一对多 NAT - NAPT</h3><p>一对多 NAT，也被称为 NAPT（network address and port translation），同样在 <a href="https://datatracker.ietf.org/doc/html/rfc2663#section-4.0" target="_blank" rel="noopener noreferrer">RFC2663</a> 中被定义。Easy IP 是 NAPT 的一个特殊形式。</p>
<p><strong>NAPT 的主要应用场景是，内网用户需要访问到公网主机</strong>。绝大多数的家庭网络、办公网络都是 NAPT 类型的。
原因应该很好理解——家庭网络或办公网络都包含许多联网设备，但是这类网络通常只有一个或数个公网 IP，使用一对一 NAT 的话公网 IP 显然是不够用的，所以需要使用一对多 NAT.</p>
<p>NAPT 通过同时利用 L3 的 IP 信息，以及 L4 传输层的端口信息，来为局域网设备提供透明的、配置方便的、支持超高并发连接的外部网络通信，示意图如下：</p>
<figure><img src="/images/about-nat/napt.webp"/>
</figure>

<p>NAPT 的端口分配与转换规则（<strong>Mapping Behavior</strong>）以及对外来流量的过滤规则（<strong>Filtering Behavior</strong>）都存在许多不同的实现，没有统一的规范与标准，但是存在两种分类规范，这种分类方法主要用在 NAT 穿越技术中。</p>
<h4 id="rfc3489-定义的-nat-类型四种" class="headerLink">
    <a href="#rfc3489-%e5%ae%9a%e4%b9%89%e7%9a%84-nat-%e7%b1%bb%e5%9e%8b%e5%9b%9b%e7%a7%8d" class="header-mark"></a>RFC3489 定义的 NAT 类型（四种）</h4><p>在 <a href="https://datatracker.ietf.org/doc/html/rfc3489#section-5" target="_blank" rel="noopener noreferrer">RFC3489</a> 中将 NAPT 分为四种类型，这也是应用最为广泛的 NAT 分类方法，如下图：</p>
<figure><img src="/images/about-nat/nat-types-defined-in-stun.webp"/>
</figure>

<p>下面我们逐一介绍这四种不同的 NAPT 类型。</p>
<blockquote>
<p>从这里开始，下文中的 NAT 特指 NAPT，如果涉及「一对一 NAT」会使用它的全名。</p>
</blockquote>
<h5 id="1-full-cone-nat" class="headerLink">
    <a href="#1-full-cone-nat" class="header-mark"></a>1. Full-cone NAT</h5><p>Full-cone NAT 的特点如下：</p>
<ul>
<li>数据包流出：一旦内部地址（iAddr:iPort）映射到外部地址（eAddr:ePort），所有发自 iAddr:iPort 的数据包都经由 eAddr:ePort 向外发送。</li>
<li>数据包流入：任意主机发送到 eAddr:ePort 的数据包，都能通过 NAT 到达 iAddr:iPort.
<ul>
<li>也就是不对外部进来的数据做任何限制，全部放行。</li>
<li>cone 圆锥，个人理解是一个比喻，任意发送进来的数据（多），都能通过 NAT 到达这个内部地址（一），就像一个圆锥。</li>
</ul>
</li>
</ul>
<p>允许任意主机发送到 eAddr:ePort 的数据到达内部地址是很危险的行为，因为内部主机不一定配置了合适的安全策略。
因此 <strong>Full-cone NAT 比较少见</strong>，就算路由器等 NAT 设备支持 Full-cone NAT，通常也不会是默认选项。我们会在后面更详细地介绍它。</p>
<h5 id="2-address-restricted-cone-nat" class="headerLink">
    <a href="#2-address-restricted-cone-nat" class="header-mark"></a>2. (Address-)Restricted cone NAT</h5><ul>
<li>数据包流出：（跟 Full-cone NAT 完全一致）一旦内部地址（iAddr:iPort）映射到外部地址（eAddr:ePort），所有发自 iAddr:iPort 的数据包都经由 eAddr:ePort 向外发送。</li>
<li>数据包流入：只有内部地址（iAddr:iPort）主动连接过的<strong>外部主机</strong>（nAddr:<strong>any</strong>），发送到 eAddr:ePort 的数据包，才能通过 NAT 到达 iAddr:iPort.
<ul>
<li>跟 Full-cone NAT 的区别在于，它<strong>限制了外部主机的 IP 地址</strong>。只有主动连接过的主机，才能发送数据到 NAT 内部。这<strong>提升了一些安全性</strong>。</li>
</ul>
</li>
</ul>
<h5 id="3-port-restricted-cone-nat" class="headerLink">
    <a href="#3-port-restricted-cone-nat" class="header-mark"></a>3. Port-Restricted cone NAT</h5><ul>
<li>数据包流出：（跟 Full-cone NAT 完全一致）一旦内部地址（iAddr:iPort）映射到外部地址（eAddr:ePort），所有发自 iAddr:iPort 的数据包都经由 eAddr:ePort 向外发送。</li>
<li>数据包流入：只有内部地址（iAddr:iPort）主动连接过的<strong>外部程序</strong>（nAddr:<strong>nPort</strong>），发送到 eAddr:ePort 的数据包，才能通过 NAT 到达 iAddr:iPort.
<ul>
<li>与 Address-Restricted cone NAT 的区别在于，它<strong>同时限制了外部主机的 IP 与端口</strong>，可以说是更<strong>进一步地提升了安全性</strong>。</li>
</ul>
</li>
</ul>
<h5 id="4-symmetric-nat" class="headerLink">
    <a href="#4-symmetric-nat" class="header-mark"></a>4. Symmetric NAT</h5><ul>
<li>数据包流出：同一个内部地址（iAddr:iPort）与不同外部主机（nAddr:nPort）的通信，会随机使用不同的 NAT 外部端口（eAddr:<strong>randomPort</strong>）。也就是说内部地址与 NAT 外部地址的关系也是<strong>一对多</strong>！
<ul>
<li>为每个连接都随机选择一个不同的 NAT 端口，这实际是进一步强化了 NAT 内网的安全性。<strong>但这也是 NAT 穿越最大的难点——它导致 Symmetric NAT 的端口难以预测</strong>！</li>
</ul>
</li>
<li>数据包流入：只有内部地址（iAddr:iPort）主动连接过的外部程序（nAddr:nPort），发送到 eAddr:ePort 的数据包，才能通过 NAT 到达 iAddr:iPort.
<ul>
<li>这个数据流入规则，与 Port-Restricted cone NAT 是完全一致的。</li>
</ul>
</li>
</ul>
<p><strong>对称 NAT 是最安全的一种 NAT 结构，限制最为严格，应该也是应用最广泛的 NAT 结构</strong>。
但是它导致所有的 TCP 连接都只能由从内部主动发起，外部发起的 TCP 连接请求会直接被 NAT 拒绝，因此它也是 P2P 玩家最头疼的一种 NAT 类型。
解决方案是通过 UDP 迂回实现连接的建立，我们会在后面讨论这个问题。</p>
<h5 id="5-linux-中的-napt" class="headerLink">
    <a href="#5-linux-%e4%b8%ad%e7%9a%84-napt" class="header-mark"></a>5. Linux 中的 NAPT</h5><p>Linux 的网络栈中，可通过 <code>iptables/netfilter</code> 的 <code>SNAT/MASQUERADE</code> 实现 NAPT 网关，这种方式只能实现一个 Symmetric NAT.</p>
<p>也就是说绝大多数基于 Linux 实现的家庭局域网、Docker 虚拟网络、Kubernetes 虚拟网络、云服务的虚拟网络，都是 Symmetric NAT.</p>
<p>只有一些有 Full-cone NAT 需求的网吧、ISP 的 LSN(Large Scale NAT) 网关等组织，会使用非 Linux 内核的企业级路由器提供 Full-cone NAT 能力，这些设备可能是基于 FPGA 等专用芯片设计的。</p>
<p>想要将 Symmetric NAT 内的主机提供给外部访问，只能通过端口映射、一对一 NAT 等方式实现，后面会详细介绍这些方法。</p>
<h4 id="rfc5389-定义的-nat-类型九种" class="headerLink">
    <a href="#rfc5389-%e5%ae%9a%e4%b9%89%e7%9a%84-nat-%e7%b1%bb%e5%9e%8b%e4%b9%9d%e7%a7%8d" class="header-mark"></a>RFC5389 定义的 NAT 类型（九种）</h4><p>RFC3489 这个早期 RFC 存在一些问题，问题之一就是它对 NAT 归类过于笼统，很多 NAPT 网关都无法很好的匹配上其中某个类别。</p>
<p>于是后来，RFC3489 被废弃并由 <a href="https://www.rfc-editor.org/rfc/rfc5389" target="_blank" rel="noopener noreferrer">RFC5389</a> 来替代，在 RFC5389 中，将 Mapping Behavior（映射规则）和 Filtering Behavior（过滤规则）分开来，定义了 3 种 Mapping Behavior（映射规则）和 3 种 Filtering Behavior（过滤规则），一共有 9 种组合。</p>
<h5 id="1-映射规则" class="headerLink">
    <a href="#1-%e6%98%a0%e5%b0%84%e8%a7%84%e5%88%99" class="header-mark"></a>1. 映射规则</h5><p>三种映射规则如图所示，假设一个内网主机 HostX 的内网 IP 地址为 X，端口号为 x，经 NAT 映射后的外网 IP 地址为 M，端口号为 m。为方便描述，将内网的 Endpoint 记为 <code>Endpoint(X,x)</code>，映射后外网的 Endpoint 记为 <code>Endpoint(M,m)</code>。内网 <code>Endpoint(X,x)</code> 发往外网 HostD1 的 IP 地址和端口号记为目的 <code>Endpoint(D1,d1)</code>；发往外网 HostD2 的 IP 地址和端口号记为目的 <code>Endpoint(D2,d2)</code>。</p>
<figure><img src="/images/about-nat/rfc5389-mapping-behavior.webp"/><figcaption>
            <h4>NAT 映射规则</h4>
        </figcaption>
</figure>

<ul>
<li><strong>EIM</strong>(Endpoint-Independent Mapping) 外部地址无关映射
<ul>
<li>对于一个内网 <code>Endpoint(X,x)</code>，其映射的外网 <code>Endpoint(M,m)</code> 是固定的。即从相同的 <code>Endpoint(X,x)</code> 发送到任何外部 IP 地址和任何外部端口的报文在 NAT 设备上使用相同的映射。</li>
</ul>
</li>
<li><strong>ADM</strong>(Address-Dependent Mapping) 外部地址相关映射：对于一个内网 <code>Endpoint(X,x)</code>，发往目的 <code>Endpoint(D1,d1)</code> 的报文，<code>Endpoint(X,x)</code> 被映射成 <code>Endpoint(M1,m1)</code>；发往目的 <code>Endpoint(D2,d2)</code> 的报文，<code>Endpoint(X,x)</code> 被映射成 <code>Endpoint(M2,m2)</code>。只要D1=D2，不管d1和d2是多少，都有 <code>Endpoint(M1,m1)=Endpoint(M2,m2)</code>。即从相同的 <code>Endpoint(X,x)</code> 发送到相同外部 IP 地址和任何外部端口的报文在 NAT 设备上使用相同的映射。</li>
<li><strong>APDM</strong>（Address and Port-Dependent Mapping）外部地址和端口相关映射：对于一个内网 <code>Endpoint(X,x)</code>，发往目的 <code>Endpoint(D1,d1)</code> 的报文，<code>Endpoint(X,x)</code> 被映射成 <code>Endpoint(M1,m1)</code>；发往目的 <code>Endpoint(D2,d2)</code> 的报文， <code>Endpoint(X,x)</code> 被映射成 <code>Endpoint(M2,m2)</code>。只有当D1=D2，且d1=d2，才有 <code>Endpoint(M1,m1)=Endpoint(M2,m2)</code>。即从相同的 Endpoint(X,x) 发送到相同外部IP地址和相同外部端口的报文在NAT设备上使用相同的映射。</li>
</ul>
<h5 id="2-过滤规则" class="headerLink">
    <a href="#2-%e8%bf%87%e6%bb%a4%e8%a7%84%e5%88%99" class="header-mark"></a>2. 过滤规则</h5><figure><img src="/images/about-nat/rfc5389-filtering-behavior.webp"/><figcaption>
            <h4>NAT 过滤规则</h4>
        </figcaption>
</figure>

<ul>
<li>
<p><strong>EIF</strong>（Endpoint-Independent Filtering）外部地址无关过滤：对于一个内网 <code>Endpoint(X,x)</code>，只要它曾经向外网发送过数据，外网主机就可以获取到它经 NAT 映射后的外网 <code>Endpoint(M,m)</code> 。那么只要是发给 <code>Endpoint(M,m)</code> 的报文，不管来源于 D1 还是 D2，都能被转换并发往内网，其他报文被过滤掉。</p>
</li>
<li>
<p><strong>ADF</strong>（Address-Dependent Filtering）外部地址相关过滤：对于一个内网 <code>Endpoint(X,x)</code> ，只有它曾经向 IP 地址为 D1 的外网主机发送过报文，那么来自外网 HostD1 返回的任何端口的报文，都能被转换并发往内网，其他报文被过滤掉。</p>
</li>
<li>
<p><strong>APDF</strong>（Address and Port-Dependent Filtering）外部地址和端口相关过滤：对于一个内网 <code>Endpoint(X,x)</code> ，只有它曾经向 IP 地址为 D1，端口号为 d1 的外网目的 <code>Endpoint(D1,d1)</code> 发送过报文，那么也只有外网 HostD1 中来自<code>Endpoint(D1,d1)</code>返回的报文，才能被转换并发往内网，其他报文被过滤掉。</p>
</li>
</ul>
<h5 id="3-rfc3489-与-rfc5389-的-nat-类型定义关系" class="headerLink">
    <a href="#3-rfc3489-%e4%b8%8e-rfc5389-%e7%9a%84-nat-%e7%b1%bb%e5%9e%8b%e5%ae%9a%e4%b9%89%e5%85%b3%e7%b3%bb" class="header-mark"></a>3. RFC3489 与 RFC5389 的 NAT 类型定义关系</h5><ul>
<li>Full Cone NAT 是 EIM 和 EIF 的组合。</li>
<li>Restricted Cone NAT 是 EIM 和 ADF 的组合。</li>
<li>Port Restricted Cone NAT 是 EIM 和 APDF 的组合。</li>
<li>Symmetric NAT 是 APDM 和 APDF 的组合。</li>
</ul>
<h2 id="nat-的弊端" class="headerLink">
    <a href="#nat-%e7%9a%84%e5%bc%8a%e7%ab%af" class="header-mark"></a>NAT 的弊端</h2><ul>
<li><strong>IP 会话的保持时效变短</strong>：NAT 需要维护一个会话列表，如果会话静默时间超过一个阈值，将会被从列表中移除。
<ul>
<li>为了避免这种情况，就需要定期发送心跳包来维持 NAT 会话。俗称心跳保活</li>
</ul>
</li>
<li><strong>IP 跟踪机制失效</strong>：一对多 NAT 使得多个局域网主机共用一个公网 IP，这导致基于公网 IP 进行流量分析的逻辑失去意义。
<ul>
<li>比如很多站点都加了基于 IP 的访问频率限制，这会造成局域网内多个用户之间的服务抢占与排队。</li>
</ul>
</li>
<li><strong>NAT 的工作机制依赖于修改IP包头的信息，这会妨碍一些安全协议的工作</strong>。
<ul>
<li>因为 NAT 篡改了 IP 地址、传输层端口号和校验和，这会导致 IP 层的认证协议彻底不能工作，因为认证目的就是要保证这些信息在传输过程中没有变化。</li>
<li>对于一些隧道协议，NAT 的存在也导致了额外的问题，因为隧道协议通常用外层地址标识隧道实体，穿过 NAT 的隧道会有 IP 复用关系，在另一端需要小心处理。</li>
<li>ICMP 是一种网络控制协议，它的工作原理也是在两个主机之间传递差错和控制消息，因为IP的对应关系被重新映射，ICMP 也要进行复用和解复用处理，很多情况下因为 ICMP 报文载荷无法提供足够的信息，解复用会失败。</li>
<li>IP 分片机制是在信息源端或网络路径上，需要发送的 IP 报文尺寸大于路径实际能承载最大尺寸时，IP 协议层会将一个报文分成多个片断发送，然后在接收端重组这些片断恢复原始报文。IP 这样的分片机制会导致传输层的信息只包括在第一个分片中，NAT难以识别后续分片与关联表的对应关系，因此需要特殊处理。</li>
</ul>
</li>
</ul>
<h2 id="nat-穿越---nat-traversal" class="headerLink">
    <a href="#nat-%e7%a9%bf%e8%b6%8a---nat-traversal" class="header-mark"></a>NAT 穿越 - NAT Traversal</h2><p>天下苦 NAT 久矣，尤其是对各种 P2P 玩家，如 NAS 玩家、P2P 游戏玩家，以及需要搭建 VPN 虚拟私有网络的网络管理员而言。
在常见的联机游戏、BitTorrent 文件共享协议、P2P 聊天等点对点通讯场景中，通讯双方客户端通常都运行在家庭局域网中，也就是说中间隔着两层家庭路由器的 NAT，路由器的默认配置都是安全优先的，存在很多安全限制，直接进行 P2P 通讯大概率会失败。</p>
<p>为了穿越这些 NAT 网关进行 P2P 通讯，就需要借助 <a href="https://en.wikipedia.org/wiki/NAT_traversal" target="_blank" rel="noopener noreferrer">NAT 穿越技术</a>。</p>
<blockquote>
<p>这里讨论的前提是，你的网络只有单层 NAT，如果外部还存在公寓 NAT、ISP 广域网 NAT，那下面介绍的 NAT 提升技术实际上就没啥意义了。</p>
</blockquote>
<h3 id="1-dmz-主机或者定向-dnat-转发" class="headerLink">
    <a href="#1-dmz-%e4%b8%bb%e6%9c%ba%e6%88%96%e8%80%85%e5%ae%9a%e5%90%91-dnat-%e8%bd%ac%e5%8f%91" class="header-mark"></a>1. 「DMZ 主机」或者「定向 DNAT 转发」</h3><p>最简单的方法是 DMZ 主机功能，前面已经介绍过了，DMZ 可以直接给内网服务器绑定路由器的外部 IP，从该 IP 进来的所有流量都会直接被发送给这台内网服务器。
被指定的 DMZ 主机，其 NAT 类型将从 NAPT 变成一对一 NAT，而一对一 NAT 对 P2P 通讯而言是透明的，这样就可以愉快地玩耍了。</p>
<p>在 Linux 路由器上实现类似 DMZ 的功能，只需要两行 iptables 命令，这可以称作「定向 DNAT 转发」：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE <span class="c1"># 普通的SNAT</span>
</span></span><span class="line"><span class="cl">iptables -t nat -A PREROUTING -i eth0 -j DNAT --to-destination 192.168.1.3 <span class="c1"># 将入站流量DNAT转发到内网主机192.168.1.3</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这两项技术的缺点是只能将一台主机提供给外网访问，而且将整台主机开放到公网实际上是很危险的，如果不懂网络<strong>很容易被黑客入侵</strong>。</p>
<h3 id="2-静态端口转发" class="headerLink">
    <a href="#2-%e9%9d%99%e6%80%81%e7%ab%af%e5%8f%a3%e8%bd%ac%e5%8f%91" class="header-mark"></a>2. 静态端口转发</h3><p>退一步，可以直接用静态端口转发功能，就是在路由器上手动设置某个端口号的所有 TCP/UDP 流量，都直接 NAT 转发到到内网的指定地址。也就是往 NAT 的转发表中手动添加内容，示意图：</p>
<figure><img src="/images/about-nat/NAPT-en.svg"/><figcaption>
            <h4>NAPT tables</h4>
        </figcaption>
</figure>

<p>设置好端口转发后，只要使用的是被设定的端口，NAT 对 P2P 通信而言将完全透明。
绝大多数路由器都支持这项功能，NAS 发烧友们想玩 P2P 下载分享，基本都是这么搞的。</p>
<h3 id="3-upnp-动态端口转发" class="headerLink">
    <a href="#3-upnp-%e5%8a%a8%e6%80%81%e7%ab%af%e5%8f%a3%e8%bd%ac%e5%8f%91" class="header-mark"></a>3. UPnP 动态端口转发</h3><blockquote>
<p>最流行的 UPnP 实现是 <a href="https://github.com/miniupnp/miniupnp" target="_blank" rel="noopener noreferrer">https://github.com/miniupnp/miniupnp</a></p>
</blockquote>
<p>静态端口转发对用户的技术要求较高，我作为一个网络小白，希望有一个傻瓜式的开关能让我愉快地玩耍 Xbox/PS5 联机游戏，该怎么办呢？
你需要的只是在路由器上启用 UPnP(Universal Plug and Play) 协议，启用它后，内网游戏设备就可以通过 UPnP 向路由器动态申请一个端口号供其使用，UPnP 会自动配置对应的端口转发规则。
<strong>现在新出的路由器基本都支持 UPnP 功能，它是最简单有效的 NAT 提升方式</strong>。</p>
<p>UPnP 解决了「静态端口转发」需要手动配置的问题，在启用了 UPnP 后，对所有支持 UPnP 的内网程序而言，NAT 类型将提升到 Full-cone NAT.</p>
<h3 id="4-nat-穿越协议---stunturnice" class="headerLink">
    <a href="#4-nat-%e7%a9%bf%e8%b6%8a%e5%8d%8f%e8%ae%ae---stunturnice" class="header-mark"></a>4. NAT 穿越协议 - STUN/TURN/ICE</h3><p>如果很不幸前面提到的「DMZ 主机」/「静态端口转发」/「UPnP」 三项技术，你的路由器都不支持，那你就只能借助 NAT 穿越协议了。</p>
<p>目前有如下几个 NAT 穿越协议标准：</p>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc3489" target="_blank" rel="noopener noreferrer">RFC3489</a> Classic STUN
<ul>
<li>Classic STUN 是一个早期的 STUN 规范，它定义了一整套完整的 NAT 穿越方案，但是因为存在许多问题，已经被废弃。</li>
</ul>
</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc5389" target="_blank" rel="noopener noreferrer">RFC5389 - Simple Traversal of UDP Through NATs (STUN)</a>
<ul>
<li>RFC5389 所定义的 STUN 协议是对 Classic STUN 的改进，它的定位不再是一个完整的 NAT 穿越解决方案，而是作为其他协议（例如SIP、FTP、DNS）处理 NAT 穿越问题的一个工具。</li>
<li>其可以用于检查网络中NAT设备的存在，并确定两个通信端点被NAT设备分配的IP地址和端口号。然后，通过ICE（Interactive Connectivity Establishment），自动创建一条能够进行NAT穿越的数据通道。</li>
<li>STUN 支持除 Symmetric NAT 之外的另外三种 NAT 类型</li>
</ul>
</li>
<li><a href="https://tools.ietf.org/html/rfc5766" target="_blank" rel="noopener noreferrer">RFC5766 - Traversal Using Relays around NAT (TURN)</a>
<ul>
<li>TURN 在 STUN 协议之上添加了一个中继，以确保在无法实现 NAT 穿越的情况下，可以 fallback 到直接使用中继服务器进行通信。</li>
<li>这个中继的原理类似反向代理，单纯负责数据的转发</li>
<li>在美国有一项数据表示在进行 P2P 穿越的时候，穿越成功的概率为 70%，但是在国内这个成功率 50% 可能都到不了。因此就有必要使用 TURN 协议，这样才能保证在穿越失败的情况下，用户仍然能正常通信。</li>
</ul>
</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8445" target="_blank" rel="noopener noreferrer">RFC8445 - Interactive Connectivity Establishment (ICE)</a>
<ul>
<li>一个 NAT 穿越的协商协议，它统一了 STUN 与 TURN 两种协议，会尝试遍历所有可能的连接方案。</li>
</ul>
</li>
</ul>
<p>总的来说，标准的 NAT 穿越协议优先使用打洞（<strong><a href="https://en.wikipedia.org/wiki/Hole_punching_%28networking%29" target="_blank" rel="noopener noreferrer">NAT Hole Pounching</a></strong>）技术，如果打洞失败，就使用中继服务器技术兜底，确保能成功穿越。</p>
<h4 id="stunturnice-的-nat-类型检测" class="headerLink">
    <a href="#stunturnice-%e7%9a%84-nat-%e7%b1%bb%e5%9e%8b%e6%a3%80%e6%b5%8b" class="header-mark"></a>STUN/TURN/ICE 的 NAT 类型检测</h4><p>RFC5389 定义了对 NAT 映射类型以及过滤类型的检测方法。</p>
<p>TBD</p>
<h4 id="stunturnice-协议如何实现-nat-打洞" class="headerLink">
    <a href="#stunturnice-%e5%8d%8f%e8%ae%ae%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0-nat-%e6%89%93%e6%b4%9e" class="header-mark"></a>STUN/TURN/ICE 协议如何实现 NAT 打洞</h4><p>首先 P2P 双方如果只隔着 0-1 层 NAT，那是不需要使用 NAT 打洞技术的，可以直连或者反向连接。</p>
<p>下面就讨论下 P2P 双方隔着 2 层及以上 NAT 的场景下，如何利用 UDP 协议实现 NAT 打洞。</p>
<p>一个完整的 NAT 打洞方案，需要包含如下功能：</p>
<ul>
<li>A 跟 B 需要知道对方的公网 IP 以及监听的端口号
<ul>
<li>解决方法：需要一个公网<strong>中介</strong>来介绍双方认识（交换 IP/port）</li>
</ul>
</li>
<li>NAT 连通性测试，需要借助公网主机，<strong>检测双方中间网络的类型</strong></li>
<li>针对不同的 NAT 类型，存在哪些穿越手段？以何种顺序进行<strong>穿越尝试</strong>？</li>
</ul>
<p>NAT 打洞可以使用 UDP/TCP 两种 L4 协议，但是 TCP 面向连接的特性使它在这个场景中限制性更大（具体限制见参考文章，我有空再补充），因此各种 NAT 穿越协议通常都基于 UDP 实现。</p>
<p>此外，因为 NAT 的具体行为是非标准化的，路由器的防火墙策略也存在很大变动空间，再有就是 RF3489 的这种 NAT 分类方法不够精确，这些因素导致 NAT 穿透能否成功通常都是谈概率。</p>
<h5 id="1-a-与-b-在同一局域网中" class="headerLink">
    <a href="#1-a-%e4%b8%8e-b-%e5%9c%a8%e5%90%8c%e4%b8%80%e5%b1%80%e5%9f%9f%e7%bd%91%e4%b8%ad" class="header-mark"></a>1. A 与 B 在同一局域网中</h5><p>这是最简单的情况，最佳方案是直接走内网通讯，不经过 NAT.</p>
<p>第二个方案是，这两个同一局域网内的客户端不走内网，仍然通过 NAT 通讯。这种通讯方式被称作「回环 NAT(Loopback NAT)」或者「发夹 NAT(Hairpin NAT)」。
对于不支持或未启用「Hairpin NAT」的网关设备而言，这样的通讯尝试将会失败！</p>
<h5 id="2-a-与-b-分别在不同的局域网中" class="headerLink">
    <a href="#2-a-%e4%b8%8e-b-%e5%88%86%e5%88%ab%e5%9c%a8%e4%b8%8d%e5%90%8c%e7%9a%84%e5%b1%80%e5%9f%9f%e7%bd%91%e4%b8%ad" class="header-mark"></a>2. A 与 B 分别在不同的局域网中</h5><p>这样实际上 A 与 B 中间就隔了两个 NAT 网关，这是最普遍的一种情况。</p>
<p>STUN/TURN 的 NAT 穿透流程大致如下：</p>
<ul>
<li>首先，A 跟 B 两个程序启动时，需要把自己的内外网 IP 及端口信息上报到一台中介服务器 S</li>
<li>现在假设 A 想要跟 B 建立一个 P2P 连接，首先他们需要从 S 获得对方的 ID</li>
<li>A 将 B 的 ID 发送给中介服务器 S，请求与 B 建立 P2P 连接</li>
<li>中介服务器将 B 的内外网 IP 及端口信息发送给 A，同时将 A 的网络信息发送给 B</li>
<li>A 尝试请求 B 的公网地址 <code>B_public_ip:B_public_port</code>
<ul>
<li>这肯定会失败，但是会在 A 的 NAT 网关上留下记录：A 曾经请求过这个地址，那之后这个地址发到 A 的 NAT 网关的流量就可以进来了。</li>
</ul>
</li>
<li>B 尝试请求 A 的公网地址 <code>A_public_ip:A_public_port</code>
<ul>
<li>同样这肯定也会失败，但是会在 B 的 NAT 网关上流量记录：B 曾经请求过这个地址，那之后这个地址发到 B 的 NAT 网关的流量就可以进来了</li>
</ul>
</li>
<li>中间的两层 NAT 网关均形成 NAT 穿越记录，<strong>穿越完成</strong>。</li>
<li>现在 A 尝试请求 B 的公网地址 <code>B_public_ip:B_public_port</code>，由于 B 的 NAT 已有记录，流量顺利通过 NAT 到达程序 B</li>
<li>B 发送给 A 的数据也同样，可以顺利到达 A</li>
</ul>
<p>上述流程中的关键点在于，如何查出内网服务器被 NAT 分配的外部 IP 及端口，只要有了这两个信息，就可以通过 STUN 中介服务器交换这个信息，然后完成连接的建立了。
家庭服务器通常都只有一个公网 IP，所以基本可以认为 IP 是固定的，因此最关键的问题就是「<strong>如何知道 NAT 为会话分配的端口地址</strong>」。</p>
<p>对端口的限制严格程度跟 NAPT 的类型有关，<strong>Full-cone 跟 Restricted cone 对端口都没有任何限制，所以上述流程肯定可以成功</strong>；</p>
<p>TBD</p>
<p>一个穿越 Symmetric NATs 的 STUN 草案：<a href="https://tools.ietf.org/id/draft-takeda-symmetric-nat-traversal-00.txt" target="_blank" rel="noopener noreferrer">Symmetric NAT Traversal using STUN</a></p>
<p>在使用 STUN/TURN 进行 NAT 穿越时，支持的的 NAT 类型如下表。行与列分别代表双方的 NAT 类型，✅ 表示支持 UDP 穿越，❌ 表示 TURN 无法进行 UDP 穿越：</p>
<table>
<thead>
<tr>
<th>NAT 类型</th>
<th>Full Cone</th>
<th>Restricted</th>
<th>Port-Restricted</th>
<th>Symmetric</th>
</tr>
</thead>
<tbody>
<tr>
<td>Full Cone</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Restricted</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Port-Restricted</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>Symmetric</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>这种场景下 TURN 协议给出的解决方案是，fallback 到中继服务器策略作为兜底方案，保证连接能成功，但是这会给中继服务器带来很大压力，延迟等参数将不可避免地变差。</p>
<h5 id="3-a-与-b-之间隔着三层以上的-nat" class="headerLink">
    <a href="#3-a-%e4%b8%8e-b-%e4%b9%8b%e9%97%b4%e9%9a%94%e7%9d%80%e4%b8%89%e5%b1%82%e4%bb%a5%e4%b8%8a%e7%9a%84-nat" class="header-mark"></a>3. A 与 B 之间隔着三层以上的 NAT</h5><p>这种情况较为常见的有：</p>
<ul>
<li>ISP 为了节约使用公网 IP，给用户分配了个广域网 IP，中间就多了个广域网 NAT</li>
<li>大城市的各种租房公寓通常只会从 ISP 购买一两根宽带，二次分销给整栋楼的租客共用，这就造成中间多了一层公寓的 NAT</li>
</ul>
<p>这是最复杂的一种情况，基本上就没什么 NAT 穿透的希望了，只能走下面介绍的兜底策略——服务器中继。</p>
<p>TBD 待续</p>
<h5 id="4-特殊穿越方案---服务器中继" class="headerLink">
    <a href="#4-%e7%89%b9%e6%ae%8a%e7%a9%bf%e8%b6%8a%e6%96%b9%e6%a1%88---%e6%9c%8d%e5%8a%a1%e5%99%a8%e4%b8%ad%e7%bb%a7" class="header-mark"></a>4. 特殊穿越方案 - 服务器中继</h5><p>Relay 服务器中继是兼容性最佳，但是性能最差的方案，因为这个方案下，所有的 P2P 连接都需要经过中继服务器转发，在使用人数众多时这会给中继服务器造成很大的压力。</p>
<p>因此这个方案通常是用于兜底的。</p>
<h3 id="特定协议的自穿越技术" class="headerLink">
    <a href="#%e7%89%b9%e5%ae%9a%e5%8d%8f%e8%ae%ae%e7%9a%84%e8%87%aa%e7%a9%bf%e8%b6%8a%e6%8a%80%e6%9c%af" class="header-mark"></a>特定协议的自穿越技术</h3><p>在所有方法中最复杂也最可靠的就是自己解决自己的问题。比如 IKE 和 IPsec 技术，在设计时就考虑了到如何穿越 NAT 的问题。因为这个协议是一个自加密的协议并且具有报文防修改的鉴别能力，其他通用方法爱莫能助。因为实际应用的 NAT 网关基本都是 NAPT 方式，所有通过传输层协议承载的报文可以顺利通过 NAT。IKE 和 IPsec 采用的方案就是用 UDP 在报文外面再加一层封装，而内部的报文就不再受到影响。IKE 中还专门增加了 NAT 网关是否存在的检查能力以及绕开 NAT 网关检测 IKE 协议的方法。</p>
<h3 id="nat-algapplication-level-gateway" class="headerLink">
    <a href="#nat-algapplication-level-gateway" class="header-mark"></a>NAT ALG(Application Level Gateway)</h3><p>NAT ALG 是一种解决应用层协议（例如DNS、FTP）报文穿越 NAT 的技术，已经被 NAT 设备产商广泛采用，是 NAT 设备的必备功能。</p>
<p>TLDR 一句话介绍：NAT ALG 通过识别协议，直接修改报文数据部分（payload）的 IP 地址和端口信息，解决某些应用协议的报文穿越 NAT 问题。NAT ALG 工作在 L3-L7 层。</p>
<p>NAT ALG 的原理是利用带有 ALG 功能的 NAT 设备对特定应用层协议的支持，当设备检测到新的连接请求时，先根据传输层端口信息判断是否为已知应用类型。如果判断为已知应用，则调用该应用协议的 ALG 功能对报文的深层内容进行检查。若发现任何形式表达的 IP 地址和端口信息，NAT 都会将这些信息同步进行转换，并为这个新的连接建立一个附加的转换表项。当报文到达外网侧的目的主机时，应用层协议中携带的信息就是 NAT 设备转换后的IP地址和端口号，这样，就可以解决某些应用协议的报文穿越 NAT 问题。</p>
<p>目前支持NAT ALG功能的协议包括：DNS、FTP、SIP、PPTP和RTSP。NAT ALG 在对这些特定应用层协议进行 NAT 转换时，通过 NAT 的状态信息来改变封装在 IP 报文数据部分的特定数据，最终使应用层协议可以跨越不同范围运行。</p>
<h2 id="使用-go-实验-nat-穿透" class="headerLink">
    <a href="#%e4%bd%bf%e7%94%a8-go-%e5%ae%9e%e9%aa%8c-nat-%e7%a9%bf%e9%80%8f" class="header-mark"></a>使用 Go 实验 NAT 穿透</h2><p>Go 可用的 NAT 穿越库有：</p>
<ul>
<li><a href="https://github.com/coturn/coturn" target="_blank" rel="noopener noreferrer">coturn</a>: 貌似是最流行的 STUN/TURN/ICE server</li>
<li><a href="https://github.com/ccding/go-stun" target="_blank" rel="noopener noreferrer">go-stun</a>: 一个简洁的 stun client 实现，大概适合用于学习？</li>
<li><a href="https://github.com/pion/turn" target="_blank" rel="noopener noreferrer">pion/turn</a>: 一个 STUN/TURN/ICE client/client 实现</li>
<li><a href="https://github.com/pion/ice" target="_blank" rel="noopener noreferrer">pion/ice</a>: 一个 ice 实现</li>
</ul>
<p>TBD 待完善</p>
<h2 id="虚拟网络overlay-与-underlay" class="headerLink">
    <a href="#%e8%99%9a%e6%8b%9f%e7%bd%91%e7%bb%9coverlay-%e4%b8%8e-underlay" class="header-mark"></a>虚拟网络、Overlay 与 Underlay</h2><p>虚拟网络就是在物理网络之上，构建的逻辑网络，也被称作 overlay 网络。
比如 AWS VPC、Docker 容器网络、QEMU 的默认网络，都是虚拟网络。</p>
<p>而 underlay 网络，则是指承载 overlay 网络的底层网络。
我个人理解，它是一个相对的概念，物理网络一定是 underlay 网络，但是虚拟网络之上如果还承载了其他虚拟网络（套娃），那它相对上层网络而言，也是一个 underlay 网络。</p>
<p>overlay 本质上就是一种隧道技术，将原生态的二层数据帧报文进行封装后通过隧道进行传输。常见的 overlay 网络协议主要是 vxlan 以及新一代的 geneve，它俩都是使用 UDP 包来封装链路层的以太网帧。</p>
<p>vxlan 在 2014 年标准化，而 geneve 在 2020 年底才通过草案阶段，目前尚未形成最终标准。但是目前 linux/cilium 都已经支持了 geneve.</p>
<p>geneve 相对 vxlan 最大的变化，是它更灵活——它的 header 长度是可变的。</p>
<p>目前所有 overlay 的跨主机容器网络方案，几乎都是基于 vxlan 实现的（例外：cilium 也支持 geneve）。</p>
<p>vxlan/geneve 的详细介绍，参见 <a href="https://thiscute.world/posts/linux-virtual-network-interfaces/#vxlan-geneve" target="_blank" rel="noopener noreferrer">Linux 中的虚拟网络接口 - vxlan/geneve</a></p>
<p>顺带再提一嘴，cilium/calico/kube-ovn 等 overlay 容器网络，都是 SDN 软件定义网络。</p>
<h3 id="相关工具" class="headerLink">
    <a href="#%e7%9b%b8%e5%85%b3%e5%b7%a5%e5%85%b7" class="header-mark"></a>相关工具</h3><p>有一些专门用于跨网搭建私有虚拟网络的工具，由于家庭网络设备前面通常都有至少一层 NAT（家庭路由器），因此这些工具都重度依赖 NAT 穿越技术。
如果 NAT 层数太多无法穿越，它们会 fallback 到代理模式，也就是由一台公网服务器进行流量中继，但是这会对中继服务器造成很大压力，延迟跟带宽通常都会差很多。</p>
<p>如下是两个比较流行的 VPN 搭建工具：</p>
<ul>
<li><a href="https://github.com/zerotier/ZeroTierOne" target="_blank" rel="noopener noreferrer">zerotier</a>: 在 P2P 网络之上搭建的 SDN overlay 网络，使用自定义协议。</li>
<li><a href="https://github.com/tailscale/tailscale" target="_blank" rel="noopener noreferrer">tailscales</a>: 基于 wireguard 协议快速搭建私有虚拟网络 VPN</li>
</ul>
<h3 id="vpn-协议" class="headerLink">
    <a href="#vpn-%e5%8d%8f%e8%ae%ae" class="header-mark"></a>VPN 协议</h3><p>主流的 VPN 协议有：PPTP、L2TP、IPSec、OpenVPN、SSTP，以及最新潮的 Wireguard.</p>
<p>TBD</p>
<h2 id="拓展知识" class="headerLink">
    <a href="#%e6%8b%93%e5%b1%95%e7%9f%a5%e8%af%86" class="header-mark"></a>拓展知识</h2><h3 id="symmetric-nat-允许的最大并发-tcp-连接数是多少" class="headerLink">
    <a href="#symmetric-nat-%e5%85%81%e8%ae%b8%e7%9a%84%e6%9c%80%e5%a4%a7%e5%b9%b6%e5%8f%91-tcp-%e8%bf%9e%e6%8e%a5%e6%95%b0%e6%98%af%e5%a4%9a%e5%b0%91" class="header-mark"></a>Symmetric NAT 允许的最大并发 TCP 连接数是多少？</h3><p>TCP 并发连接数受许多参数的限制，以 Linux 服务器为例，默认参数无法满足需要，通常都会手动修改它的参数，放宽文件描述符限制以及 TCP 连接队列、缓存相关的限制。</p>
<p>单纯从网络协议层面分析，对于一个仅有一个公网 IP 的 Symmetric NAT 网关，它与某个外部站点 <code>http://x.x.x.x:xx</code> 要建立连接。
考虑到 TCP 连接的定义实际上是一个四元组 <code>(srcIP, srcPort, dstIP, dstPort)</code>，其中就只有 NAT 网关自己的 <code>srcPort</code> 是唯一的变量了，而端口号是一个 16bits 数字，取值范围为 0 - 65535。
此外低于 1024 的数字是操作系统的保留端口，因此 NAT 一般只会使用 1024-65535 这个区间的端口号，也就是说这个 NAT 网关最多只能与该站点建立 64512 个连接。</p>
<p>那么对于不同的协议 NAT 是如何处理的呢？NAT 肯定可以通过协议特征区分不同协议的流量，因此不同协议通过 NAT 建立的并发连接不会相互影响。</p>
<p>对于家庭网络而言 64512 个连接已经完全够用了，但是对于数据中心或者云上的 VPC 而言，就不一定够用了。
举个例子，在 <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html" target="_blank" rel="noopener noreferrer">AWS NAT 网关的文档</a>中就有提到，AWS NAT 网关最高支持与每个不同的地址建立 55000 个并发连接。destination 的 IP 地址、端口号、(TCP/UDP/ICMP) 任一个发生改变，都可以再建立其他 55000 个并发连接。
如果超过这个限制，就会发生「ErrorPortAllocation」错误。如果在 AWS 上遇到这个错误，那就说明你们的云上网络规划有问题了。</p>
<p>当然除了端口限制外，受限于 NAT 硬件、以太网协议以及其他影响，NAT 网关肯定还有包处理速率、带宽的限制，这个就略过不提了。</p>
<h3 id="aws-vpc-与-nat" class="headerLink">
    <a href="#aws-vpc-%e4%b8%8e-nat" class="header-mark"></a>AWS VPC 与 NAT</h3><p>AWS VPC(virtual private cloud) 是一个逻辑隔离的虚拟私有网络，云服务架构的最佳实践之一就是通过 VPC 搭建云上私有网络，提升网络安全性。</p>
<p>AWS VPC 提供两种网关类型：</p>
<ul>
<li><a href="https://docs.aws.amazon.com/zh_cn/vpc/latest/userguide/vpc-nat-gateway.html" target="_blank" rel="noopener noreferrer">NAT 网关</a>
<ul>
<li>支持三种协议：TCP, UDP, ICMP</li>
<li>支持 IPv4 与 IPv6 两种 IP 协议</li>
<li>支持 5 Gbps 带宽，可自动扩展到 45 Gbps
<ul>
<li>可通过划分子网并在多个子网中添加 NAT 网关的方式，获得超过 45Gbps 的带宽</li>
</ul>
</li>
<li>最高支持与每个不同的地址建立 55000 个并发连接</li>
<li>NAT 网关从属于 VPC 的子网</li>
<li>每个 NAT 网关只能绑定一个 IP
<ul>
<li>可通过划分子网并在多个子网中添加 NAT 网关的方式获得多个 IP</li>
</ul>
</li>
<li>可达到 100w packets 每秒的处理速度，并能自动扩展到 400w packets 每秒
<ul>
<li>同样，需要更高的处理速度，请添加更多 NAT 网关</li>
</ul>
</li>
<li>按处理数据量收费</li>
<li>默认路由到 NAT 子网，被称为「私有子网」（或者没默认路由，那就是无法访问公网的私有子网），连接只能由内网程序主动发起。</li>
<li>NAT 网关为流量执行「<strong>Symmetric NAT</strong>」</li>
</ul>
</li>
<li><a href="https://docs.aws.amazon.com/zh_cn/vpc/latest/userguide/VPC_Internet_Gateway.html" target="_blank" rel="noopener noreferrer">IGW 因特网网关</a>
<ul>
<li>IGW 是一个高度可用的逻辑组件，不会限制 VPC 的总带宽、处理能力。</li>
<li>IGW 实例直接关联 VPC，不从属于任何可用区或子网</li>
<li>IGW 实质上是一个 NAT 设备，为绑定了公网 IP 地址的 ENI/EC2 实例，执行「<strong>一对一 NAT</strong>」</li>
<li>默认路由到 IGW 的子网，被称为「公有子网」</li>
</ul>
</li>
</ul>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://info.support.huawei.com/info-finder/encyclopedia/en/NAT.html" target="_blank" rel="noopener noreferrer">What Is Network Address Translation (NAT)? - Huawei Docs</a></li>
<li><a href="https://info.support.huawei.com/info-finder/encyclopedia/en/STUN.html" target="_blank" rel="noopener noreferrer">What Is STUN? - Huawei Docs</a></li>
<li><a href="https://support.huawei.com/enterprise/zh/doc/EDOC1100112409/fd829977#ZH-CN_CONCEPT_0227014768" target="_blank" rel="noopener noreferrer">NetEngine AR V300R019 配置指南-IP业务 - NAT 穿越 - 华为文档</a></li>
<li><a href="http://www.52im.net/thread-50-1-1.html" target="_blank" rel="noopener noreferrer">P2P技术详解(一)：NAT详解——详细原理、P2P简介</a></li>
<li><a href="http://www.52im.net/thread-542-1-1.html" target="_blank" rel="noopener noreferrer">P2P技术详解(二)：P2P中的NAT穿越(打洞)方案详解</a></li>
<li><a href="http://www.52im.net/thread-2872-1-1.html" target="_blank" rel="noopener noreferrer">P2P技术详解(三)：P2P中的NAT穿越(打洞)方案详解(进阶分析篇)</a></li>
<li><a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Internet_Gateway.html" target="_blank" rel="noopener noreferrer">Connect to the internet using an internet gateway - AWS VPC Internet Gateway</a></li>
<li><a href="https://blog.chionlab.moe/2018/02/09/full-cone-nat-with-linux/" target="_blank" rel="noopener noreferrer">从DNAT到netfilter内核子系统，浅谈Linux的Full Cone NAT实现</a></li>
<li><a href="https://en.wikipedia.org/wiki/Network_address_translation" target="_blank" rel="noopener noreferrer">Network address translation - wikipedia</a></li>
<li><a href="https://www.liveswitch.io/blog/webrtc-nat-traversal-methods-a-case-for-embedded-turn" target="_blank" rel="noopener noreferrer">WebRTC NAT Traversal Methods: A Case for Embedded TURN</a></li>
<li><a href="https://icloudnative.io/posts/wireguard-endpoint-discovery-nat-traversal/" target="_blank" rel="noopener noreferrer">WireGuard 教程：使用 DNS-SD 进行 NAT-to-NAT 穿透 - 云原生实验室</a></li>
</ul>
]]></content></entry><entry><title type="html">FinOps for Kubernetes - 如何拆分 Kubernetes 成本</title><link href="https://thiscute.world/posts/finops-for-kubernetes/"/><id>https://thiscute.world/posts/finops-for-kubernetes/</id><author><name>ryan4yin</name></author><published>2022-05-04T23:15:00+08:00</published><updated>2022-05-05T19:31:00+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/finops-for-kubernetes/finops-for-kubernetes.webp" height="900" width="460"><figcaption></figcaption>
        </figure><blockquote>
<p>FinOps 是一种不断发展的云财务管理学科和文化实践，通过帮助工程、财务、技术和业务团队在数据驱动的预算分配上进行协作，使成本预算能够产生最大的业务价值。</p>
</blockquote>
<h2 id="云计算成本管控" class="headerLink">
    <a href="#%e4%ba%91%e8%ae%a1%e7%ae%97%e6%88%90%e6%9c%ac%e7%ae%a1%e6%8e%a7" class="header-mark"></a>云计算成本管控</h2><p>随着越来越多的企业上云，云计算的成本管控也越来越受关注。在讨论 Kubernetes 成本之前，先简单聊下如何管控云计算成本，有一个新名词被用于形容这项工作——FinOps.</p>
<p>传统的数据中心的成本是比较固定的，所有的成本变动通常都伴随着硬件更替。
而在云上环境就很不一样了，由于云服务的按量收费特性，以及五花八门的计费规则，开发人员稍有不慎，云成本就可能会出现意料之外的变化。另一方面由于计费的复杂性，业务扩容对成本的影响也变得难以预测。</p>
<p>目前的主流云服务商（AWS/GCP/Alicloud/&hellip;）基本都提供基于资源标签的成本查询方法，也支持将成本导出并使用 SQL 进行细致分析。
因此其实要做到快速高效的<strong>云成本分析与管控</strong>，主要就涉及到如下几个点：</p>
<ul>
<li><strong>契合需求的标签规范</strong>: 从公司业务侧需求出发，制定出合理的、多维度的（Department/Team/Product/&hellip;）、有扩展空间的标签规范，这样才能按业务侧需要进行成本分析。</li>
<li><strong>资源标签的准确率</strong>: 随着公司业务的发展，标签规范的迭代，标签的准确率总是会上下波动。而标签准确率越高，我们对云计算成本的管控能力就越强。</li>
</ul>
<p>但是也存在许多特殊的云上资源，云服务商目前并未提供良好的成本分析手段，Kubernetes 集群成本就是其中之一。</p>
<h2 id="kubernetes-成本分析的难点" class="headerLink">
    <a href="#kubernetes-%e6%88%90%e6%9c%ac%e5%88%86%e6%9e%90%e7%9a%84%e9%9a%be%e7%82%b9" class="header-mark"></a>Kubernetes 成本分析的难点</h2><p>目前许多企业应该都面临着这样的场景：所有的服务都运行在一或多个 Kubernetes 集群上，其中包含多条业务线、多个产品、多个业务团队的服务，甚至除了业务服务，可能还包含 CICD、数据分析、机器学习等多种其他工作负载。而这些 Kubernetes 集群通常都由一个独立的 SRE 部门管理。</p>
<p>但是 Kubernetes 集群本身并不提供成本拆分的能力，我们只能查到集群的整体成本、每个节点组的成本等这样粗粒度的成本信息，缺乏细粒度的成本分析能力。
此外，Kubernetes 集群是一个非常动态的运行环境，其节点的数量、节点规格、Pod 所在的节点/Zone/Region，都可能会随着时间动态变动，这为成本分析带来了更大的困难。</p>
<p>这就导致我们很难回答这些问题：<strong>每条业务线、每个产品、每个业务团队、或者每个服务分别花了多少钱？是否存在资源浪费？有何优化手段</strong>？</p>
<p>而 FinOps for Kubernetes，就是通过工程化分析、可视化成本分析等手段，来回答这些成本问题，分析与管控 Kubernetes 的成本。</p>
<p>接下来我会先介绍下云上 Kubernetes 成本分析的思路与手段，最后再介绍如何使用 Kubecost 分析 Kubernetes 集群的成本。</p>
<p>要做好 Kubernetes 成本工作，有如下三个要点：</p>
<ul>
<li>理解 Kubernetes 成本的构成，搞懂准确分析 Kubernetes 成本有哪些难点</li>
<li>寻找优化 Kubernetes 集群、业务服务的手段</li>
<li>确定 Kubernetes 集群的成本拆分手段，建立能快速高效地分析与管控集群成本的流程</li>
</ul>
<h2 id="kubernetes-成本的构成" class="headerLink">
    <a href="#kubernetes-%e6%88%90%e6%9c%ac%e7%9a%84%e6%9e%84%e6%88%90" class="header-mark"></a>Kubernetes 成本的构成</h2><p>以 AWS EKS 为例，它的成本有这些组成部分：</p>
<ul>
<li>AWS EKS 本身有 $0.1 per hour 的固定费用，这个很低</li>
<li>EKS 的所有节点会收对应的 EC2 实例运行费用、EBS 数据卷费用</li>
<li>EKS 中使用的 PV 会带来 EBS  数据卷的费用</li>
<li>跨区流量传输费用
<ul>
<li>所有节点之间的通讯（主要是服务之间的互相访问），如果跨了可用区，会收跨区流量传输费用</li>
<li>EKS 中的服务访问其他 AWS 服务如 RDS/ElastiCache，如果是跨可用区，会收取跨区流量费用</li>
<li>如果使用了 Istio IngressGateway 或 traefik 等网关层代理 Pod，那这些 Pod 与服务实例之间，有可能会产生跨区流量</li>
</ul>
</li>
<li>NAT 网关费用
<ul>
<li>EKS 中的容器如果要访问因特网，就需要通过 NAT 网关，产生 NAT 费用</li>
<li>如果 VPC 未配置 endpoints 使访问 AWS 服务（dynamodb/s3 等）时直接走 AWS 内部网络，这些流量会经过 VPC 的 NAT 网关，从而产生 NAT 网关费用</li>
<li>对于托管版 NAT 网关，费用又包含两部分：公网流量费 + NAT 数据处理费用。其中数据处理费用可通过自建 NAT 实例来缩减。</li>
</ul>
</li>
<li>服务如果要对外提供访问，最佳实践是通过 aws-load-balancer-controller 绑定 AWS ALB, 这里会产生 ALB 费用</li>
<li>监控系统成本
<ul>
<li>Kubernetes 的监控系统是不可或缺的</li>
<li>如果你使用的是 Datadog/NewRelic 等云服务，会造成云服务的成本；如果是自建 Prometheus，会造成 Prometheus 的运行成本，以及 Pull 指标造成的跨区流量成本</li>
</ul>
</li>
</ul>
<p><strong>总结下，其实就是三部分成本：计算、存储、网络</strong>。其中计算与存储成本是相对固定的，而网络成本就比较动态，跟是否跨区、是否通过 NAT 等诸多因素有关。</p>
<h2 id="kubernetes-资源分配的方式" class="headerLink">
    <a href="#kubernetes-%e8%b5%84%e6%ba%90%e5%88%86%e9%85%8d%e7%9a%84%e6%96%b9%e5%bc%8f" class="header-mark"></a>Kubernetes 资源分配的方式</h2><p>Kubernetes 提供了三种资源分配的方式，即服务质量 QoS，不同的分配方式，成本的计算难度也有区别：</p>
<ul>
<li>Guaranteed resource allocation(保证资源分配): 即将 requests 与 limits 设置为相等，确保预留所有所需资源
<ul>
<li>最保守的策略，服务性能最可靠，但是成本也最高</li>
<li>这种方式分配的资源，拆分起来是最方便的，因为它的计算成本是静态的</li>
</ul>
</li>
<li>Burstable resource allocation(突发性能): 将 requests 设置得比 limits 低，这样相差的这一部分就是服务的可 Burst 资源量。
<ul>
<li>最佳实践，选择合适的 requests 与 limits，可达成性能与可靠性之间的平衡</li>
<li>这种资源，它 requests 的计算成本是静态的，Burstable 部分的计算成本是动态的</li>
</ul>
</li>
<li>Best effort resource allocation(尽力而为): 只设置 limits，不设置 requests，让 Pod 可以调度到任何可调度的节点上
<ul>
<li>下策，这个选项会导致服务的性能无法保证，通常只在开发测试等资源受限的环境使用</li>
<li>这种方式分配的资源，完全依赖监控指标进行成本拆分</li>
</ul>
</li>
</ul>
<h2 id="最佳实践" class="headerLink">
    <a href="#%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5" class="header-mark"></a>最佳实践</h2><p>要做到统一分析、拆分 Kubernetes 与其他云资源的成本，如下是一些最佳实践：</p>
<ul>
<li>按产品或者业务线来划分名字空间，不允许跨名字空间互相访问。
<ul>
<li>如果存在多个产品或业务线共用的服务，可以在每个产品的名字空间分别部署一个副本，并把它们当成不同的服务来处理。</li>
<li>这样名字空间就是成本划分的一个维度，我们还可以在名字空间上为每个产品设置资源上限与预警。</li>
</ul>
</li>
<li>按产品或业务线来划分节点组，通过节点组的标签来进行成本划分
<ul>
<li>这是第二个维度，但是节点组划分得太细，可能会导致资源利用不够充分。</li>
<li>这个方案仅供参考，不一定好用</li>
</ul>
</li>
<li>为 Kubernetes 服务设计与其他云资源一致的成本标签，添加到 Pod 的 label 中，通过 kubecost 等手段，基于 label 进行更细致的成本分析
<ul>
<li>标签一致的好处是可以统一分析 Kubernetes 与其他云资源的成本</li>
</ul>
</li>
<li>定期（比如每周一） check 云成本变化，定位并解决成本异常</li>
<li>建立自动化的成本异常检测与告警机制（部分云服务有提供类似的服务，也可自建），收到告警即触发成本异常分析任务</li>
<li>始终将资源标签准确率维持在较高数值，准确率低于一定数值即自动告警，触发标签修正任务</li>
<li>将成本上升的压力与成本下降的效益覆盖到开发人员，授权他们跟踪服务的 Kubernetes 利用率与成本，以激励开发人员与 SRE 合作管控服务成本。</li>
</ul>
<p>成本优化实践：</p>
<ul>
<li>多种工作负载混合部署，提升资源利用率。但是需要合理规划避免资源竞争</li>
<li>调节集群伸缩组件，在保障 SLA 的前提下提升资源利用率
<ul>
<li>比如 aws 就可以考虑在一些场景下用 karpenter 来做扩缩容、引入 <a href="https://github.com/aws/aws-node-termination-handler" target="_blank" rel="noopener noreferrer">AWS Node Termination Handler</a> 提升 Spot 实例的 SLA</li>
</ul>
</li>
<li>尽量使用竞价实例，AWS 的竞价实例单价平均优惠超过 50%</li>
<li>合理地购买 Saving Plans 与 Reserved Instances，达成成本节约。</li>
</ul>
<h2 id="多云环境" class="headerLink">
    <a href="#%e5%a4%9a%e4%ba%91%e7%8e%af%e5%a2%83" class="header-mark"></a>多云环境</h2><p>上述讨论的绝大部分策略，都适用于多云环境。在这种涉及多个云服务提供商的场景，最重要的一点是：<strong>搭建平台无关的成本分析与管控平台</strong>。而其核心仍然是文章最前面提到的两点，只需要补充两个字 <strong>一致</strong>：</p>
<ul>
<li><strong>一致的资源标签规范</strong>: 从公司业务侧需求出发，制定出<strong>跨平台一致的</strong>标签规范，这样才能统一分析多云成本。</li>
<li><strong>资源标签的准确率</strong>: 随着公司业务的发展，标签规范的迭代，标签的准确率总是会上下波动。而标签准确率越高，我们对云计算成本的管控能力就越强。</li>
</ul>
<p>这样就可以把不同云服务商的数据转换成统一的格式，然后在自有的成本平台上进行统一的分析了。</p>
<p>搭建一个这样的成本分析平台其实并不难，许多大公司都是这么干的，小公司也可以从一个最小的平台开始做起，再慢慢完善功能。</p>
<p>以我现有的经验看，其实主要就包含这么几个部分：</p>
<ul>
<li>成本数据转换模块：将来自不同云的成本数据，转换成与云服务无关的格式，方便统一处理</li>
<li>折扣模块：处理不同资源的折扣
<ul>
<li>比如 CDN 在用量高的时候通常会有很高的折扣比例</li>
<li>还有 SavingPlans/CommitmentDiscounts 也需要特殊的处理</li>
</ul>
</li>
<li>标签修整模块
<ul>
<li>随着标签体系的发展，总会有些标签的变更，不方便直接在资源上执行，就需要在成本计算这里进行修正、增补或者删除</li>
</ul>
</li>
<li>成本拆分模块
<ul>
<li>有些资源的成本是共用的，就需要结合其他来源的数据进行成本拆分，比如 Kubernetes 集群的成本</li>
</ul>
</li>
<li>成本报表：将最终的数据制作成符合各类人员需求的可视化图表，按需求还可以考虑添加交互式特征
<ul>
<li>可使用 Grafana/Google DataStudio 等报表工具</li>
</ul>
</li>
</ul>
<p>此外这样一个跨云的成本管控平台也不一定需要完全自己来做，已经有很多公司看到了这块的前景，做出了现成的方案，可以看看 Gartner 的如下报告：</p>
<ul>
<li><a href="https://www.gartner.com/reviews/market/cloud-management-tooling" target="_blank" rel="noopener noreferrer">Cloud Management Tooling Reviews and Ratings - Gartner</a></li>
</ul>
<p>多云场景下其实要考虑的还有很多，目前多云网络（multicloud networking）、多云财务（multicloud finops）、多云应用管理（multicloud application management）领域的需求越来越强劲，相关产品也越来越多，有需要可以自行研究。</p>
<h2 id="kubernetes-成本分析" class="headerLink">
    <a href="#kubernetes-%e6%88%90%e6%9c%ac%e5%88%86%e6%9e%90" class="header-mark"></a>Kubernetes 成本分析</h2><p>前面讨论的内容都很「虚」，下面来点更「务实」的：Kubernetes 成本分析实战。</p>
<p>目前据我所知，主要有如下两个相关的开源工具：</p>
<ul>
<li><a href="https://github.com/opencost/opencost" target="_blank" rel="noopener noreferrer">Kubecost/Opencost</a>: kubecost 应该是目前最优秀的开源成本分析工具了，self-hosted 是免费的，支持按 deployment/service/label 等多个维度进行成本拆分，而且支持拆分网络成本。收费版提供更丰富的功能以及更长的数据存储时间。
<ul>
<li>kubecost 的核心部分已捐献给 CNCF，并改名为 opencost.</li>
</ul>
</li>
<li><a href="https://github.com/gocrane/crane" target="_blank" rel="noopener noreferrer">crane</a>: 腾讯开源的一款 Kubernetes 成本优化工具，支持成本报表以及 EHPA 两个功能，（截止 2022-05-04）才刚开源几个月，目前还比较简陋。
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1960014" target="_blank" rel="noopener noreferrer">腾讯推出国内首个云原生成本优化开源项目 Crane</a></li>
<li>腾讯云在国内上线了 crane 的闭源版本「<a href="https://cloud.tencent.com/document/product/457/64169" target="_blank" rel="noopener noreferrer">容器服务成本大师</a>」，如果你使用的是腾讯云，可以体验看看（感觉跟 kubecost 很像）</li>
</ul>
</li>
</ul>
<p>其中 kubecost 是最成熟的一个，我们接下来以 kubecost 为例介绍下如何分析 Kubernetes 成本。</p>
<h3 id="安装-kubecost" class="headerLink">
    <a href="#%e5%ae%89%e8%a3%85-kubecost" class="header-mark"></a>安装 kubecost</h3><p>kubecost 有两种推荐的安装方法：</p>
<ul>
<li>使用 helm 安装免费版
<ul>
<li>包含如下组件：
<ul>
<li>frontend 前端 UI 面板</li>
<li>cost-model 核心组件，提供基础的成本拆分能力</li>
<li>postgres 长期存储，仅企业版支持</li>
<li>kubecost-network-costs 一个 daemonset，提供网络指标用于计算网络成本（貌似未开源）</li>
<li>cluster-controller 提供集群「大小调整（RightSizing）」以及「定时关闭集群」的能力</li>
</ul>
</li>
<li>只保留 15 天的指标，无 SSO/SAML 登录支持，无 alerts/notification, 不可保存 reportes 报表</li>
<li>每个 kubecost 只可管理一个集群</li>
</ul>
</li>
<li>只安装 Apache License 开源的 cost-model，它仅提供基础的成本拆分功能以及 API，无 UI 面板、长期存储、网络成本拆分、SAML 接入及其他商业功能。</li>
</ul>
<p>开源的 cost-model 直接使用此配置文件即可部署：<a href="https://github.com/kubecost/cost-model/blob/master/kubernetes/exporter/exporter.yaml" target="_blank" rel="noopener noreferrer">https://github.com/kubecost/cost-model/blob/master/kubernetes/exporter/exporter.yaml</a></p>
<p>而如果要部署带 UI 的商业版，需要首先访问 <a href="https://www.kubecost.com/install#show-instructions" target="_blank" rel="noopener noreferrer">https://www.kubecost.com/install#show-instructions</a> 获取到 <code>kubecostToken</code>，然后使用 helm 进行部署。</p>
<p>首先下载并编辑 values.yaml 配置文件：<a href="https://github.com/kubecost/cost-analyzer-helm-chart/blob/develop/cost-analyzer/values.yaml" target="_blank" rel="noopener noreferrer">https://github.com/kubecost/cost-analyzer-helm-chart/blob/develop/cost-analyzer/values.yaml</a>，示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># kubecost-values.yaml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 通过 http://kubecost.com/install 获取 token，用于跟踪商业授权状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kubecostToken</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;xxx&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">global</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 自动部署 prometheus + nodeExporter，也可以直接对接外部 prometheus</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">prometheus</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 如果 enable=false，则使用如下地址连接外部 prometheus</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">fqdn</span><span class="p">:</span><span class="w"> </span><span class="l">http://cost-analyzer-prometheus-server.default.svc</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 自动部署 grafana，也可对接外部 grafana 面板</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">grafana</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 如果 enable=false，则使用如下地址连接外部 grafana</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">domainName</span><span class="p">:</span><span class="w"> </span><span class="l">cost-analyzer-grafana.default.svc</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">scheme</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;http&#34;</span><span class="w"> </span><span class="c"># http or https, for the domain name above.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">proxy</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># If true, the kubecost frontend will route to your grafana through its service endpoint</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># grafana 子 chart 的配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c">## 更好的选择是单独部署 grafana，不使用 kubecost 的 subchart</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">grafana</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">image</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">repository</span><span class="p">:</span><span class="w"> </span><span class="l">grafana/grafana </span><span class="w"> </span><span class="c"># 建议替换成私有镜像仓库地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">tag</span><span class="p">:</span><span class="w"> </span><span class="m">8.3.2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># prometheus 子 chart 的配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c">## 更好的选择是单独部署 prometheus，不使用 kubecost 的 subchart</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">prometheus</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">server</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">persistentVolume</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">size</span><span class="p">:</span><span class="w">  </span><span class="l">32Gi</span><span class="w"> </span><span class="c"># 这个大小得视情况调整，集群较大的话 32Gi 肯定不够</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">retention</span><span class="p">:</span><span class="w"> </span><span class="l">15d </span><span class="w"> </span><span class="c"># p8s 指标保留时长</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">nodeExporter</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c">## If true, node-exporter pods share the host network namespace</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">hostNetwork</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c">## If true, node-exporter pods share the host PID namespace</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">hostPID</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c">## node-exporter container name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">node-exporter</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c">## node-exporter container image</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">repository</span><span class="p">:</span><span class="w"> </span><span class="l">quay.io/prometheus/node-exporter </span><span class="w"> </span><span class="c"># 替换成 quay 仓库避免 docker 仓库拉取限制</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">tag</span><span class="p">:</span><span class="w"> </span><span class="l">v0.18.1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">pullPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">IfNotPresent</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c">## Monitors ConfigMap changes and POSTs to a URL</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c">## Ref: https://github.com/jimmidyson/configmap-reload</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c">##</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">configmapReload</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">prometheus</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c">## If false, the configmap-reload container will not be deployed</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c">## configmap-reload container name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">configmap-reload</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c">## configmap-reload container image</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">image</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">repository</span><span class="p">:</span><span class="w"> </span><span class="l">jimmidyson/configmap-reload </span><span class="w"> </span><span class="c"># 建议替换成私有仓库避免 docker 仓库拉取限制</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">tag</span><span class="p">:</span><span class="w"> </span><span class="l">v0.7.1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">persistentVolume</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">size</span><span class="p">:</span><span class="w"> </span><span class="l">32Gi </span><span class="w"> </span><span class="c"># 同前所述</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># storageClass: &#34;-&#34; #</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 配置 ingress 入口，供外部访问</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">ingress</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># className: nginx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">annotations</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># kubernetes.io/ingress.class: nginx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># kubernetes.io/tls-acme: &#34;true&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">paths</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;/&#34;</span><span class="p">]</span><span class="w"> </span><span class="c"># There&#39;s no need to route specifically to the pods-- we have an nginx deployed that handles routing</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">pathType</span><span class="p">:</span><span class="w"> </span><span class="l">ImplementationSpecific</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">hosts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="l">cost-analyzer.local</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">nodeSelector</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 提升网络安全性的配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">networkPolicy</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">denyEgress</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># create a network policy that denies egress from kubecost</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">sameNamespace</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># Set to true if cost analyser and prometheus are on the same namespace</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># namespace: kubecost # Namespace where prometheus is installed</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 分析网络成本，需要额外部署一个 daemonset</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">networkCosts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">config</span><span class="p">:</span><span class="w"> </span>{}<span class="w">  </span><span class="c"># 详见 values.yaml 内容</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">serviceAccount</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">create</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">annotations</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 如果是 aws 上的集群，可以通过 serviceAccount 授权访问 ec2 pricing API 及 cur 数据</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 也可以直接为服务提供 AccessKeyID/Secret 进行授权</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 与 AWS 的集成会在后面详细介绍</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">eks.amazonaws.com/role-arn</span><span class="p">:</span><span class="w"> </span><span class="l">arn:aws:iam:112233445566:role/KubecostRole </span><span class="w"> </span><span class="c"># 注意替换这个 role-arn</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 如下配置也可通过 Kubecost product UI 调整</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 但是此处的配置优先级更高，如果在这里配置了默认值，容器重启后就会使用此默认值，UI 上的修改将失效</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kubecostProductConfigs</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然后部署：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 添加 repo</span>
</span></span><span class="line"><span class="cl">helm repo add kubecost https://kubecost.github.io/cost-analyzer/
</span></span><span class="line"><span class="cl"><span class="c1"># 查看版本号</span>
</span></span><span class="line"><span class="cl">helm search repo kubecost/cost-analyzer -l <span class="p">|</span> head
</span></span><span class="line"><span class="cl"><span class="c1"># 下载并解压某个 chart</span>
</span></span><span class="line"><span class="cl">helm pull kubecost/cost-analyzer --untar --version 1.92.0
</span></span><span class="line"><span class="cl"><span class="c1"># 使用自定义 values 配置安装或更新本地的 chart</span>
</span></span><span class="line"><span class="cl">helm upgrade --create-namespace --install kubecost ./cost-analyzer -n kubecost -f kubecost-values.yaml
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 port-forward 访问：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">kubectl port-forward --namespace kubecost deployment/kubecost-cost-analyzer <span class="m">9090</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在访问 <a href="http://localhost:9090" target="_blank" rel="noopener noreferrer">http://localhost:9090</a> 就能进入 Kubecost 的 UI 面板，其中最主要的就是 Allocation 成本拆分功能。</p>
<figure><img src="/images/finops-for-kubernetes/kubecost-demo.webp"/><figcaption>
            <h4>Kubecost 示例</h4>
        </figcaption>
</figure>

<h3 id="kubecost-的成本统计原理" class="headerLink">
    <a href="#kubecost-%e7%9a%84%e6%88%90%e6%9c%ac%e7%bb%9f%e8%ae%a1%e5%8e%9f%e7%90%86" class="header-mark"></a>kubecost 的成本统计原理</h3><h4 id="1-cpuramgpustorage-成本分析" class="headerLink">
    <a href="#1-cpuramgpustorage-%e6%88%90%e6%9c%ac%e5%88%86%e6%9e%90" class="header-mark"></a>1. CPU/RAM/GPU/Storage 成本分析</h4><p>Kubecost 通过 AWS/GCP 等云服务商 API 动态获取各 region/zone 的上述四项资源的每小时成本：CPU-hour, GPU-hour, Storage Gb-hour 与 RAM Gb-hour，或者通过 json 文件静态配置这几项资源的成本。
OD 按需实例的资源价格通常比较固定，而 AWS Spot 实例的成本波动会比较大，可以通过 SpotCPU/SpotRAM 这两个参数来设置 spot 的默认价格，也可以为 kubecost 提供权限使它动态获取这两项资源的价格。</p>
<p>kubecost 根据每个容器的资源请求 requests 以及资源用量监控进行成本分配，对于未配置 requests 的资源将仅按实际用量监控进行成本分配。</p>
<p>kubecost 的成本统计粒度为 container，而 deployment/service/namespace/label 只是按不同的维度进行成本聚合而已。</p>
<h4 id="2-网络成本的分析" class="headerLink">
    <a href="#2-%e7%bd%91%e7%bb%9c%e6%88%90%e6%9c%ac%e7%9a%84%e5%88%86%e6%9e%90" class="header-mark"></a>2. 网络成本的分析</h4><blockquote>
<p><a href="https://github.com/kubecost/docs/blob/b7e9d25994ce3df6b3936a06023588f2249554e5/network-allocation.md" target="_blank" rel="noopener noreferrer">https://github.com/kubecost/docs/blob/b7e9d25994ce3df6b3936a06023588f2249554e5/network-allocation.md</a></p>
</blockquote>
<p>对提供线上服务的云上 Kubernetes 集群而言，网络成本很可能等于甚至超过计算成本。这里面最贵的，是跨区/跨域传输的流量成本，以及 NAT 网关成本。NAT 网关成本可以通过自建 NAT 实例来部分缩减（这里仅考察了 AWS 云服务，其他云服务商的收费模式可能存在区别）。
使用单个可用区风险比较高，资源池也可能不够用，因此我们通常会使用多个可用区，这就导致跨区流量成本激增。</p>
<p>kubecost 也支持使用 Pod network 监控指标对整个集群的流量成本进行拆分，kubecost 会部署一个绑定 hostNetwork 的 daemonset 来采集需要的网络指标，提供给 prometheus 拉取，再进行进一步的分析。</p>
<p>kubecost 将网络流量分成如下几类：</p>
<ul>
<li>in-zone: 免费流量</li>
<li>in-region: 跨区流量，国外的云服务商基本都会对跨区流量收费</li>
<li>cross-region: 跨域流量</li>
</ul>
<p>更多的待研究，看 kubecost 官方文档吧。</p>
<blockquote>
<p>另外还看到 kubecost 有忽略 s3 流量（因为不收费）的 issue: <a href="https://github.com/kubecost/cost-model/issues/517" target="_blank" rel="noopener noreferrer">https://github.com/kubecost/cost-model/issues/517</a></p>
</blockquote>
<h3 id="kubecost-api" class="headerLink">
    <a href="#kubecost-api" class="header-mark"></a>kubecost API</h3><blockquote>
<p><a href="https://github.com/kubecost/docs/blob/b7e9d25994ce3df6b3936a06023588f2249554e5/apis.md" target="_blank" rel="noopener noreferrer">https://github.com/kubecost/docs/blob/b7e9d25994ce3df6b3936a06023588f2249554e5/apis.md</a></p>
</blockquote>
<ul>
<li>成本拆分文档：https://github.com/kubecost/docs/blob/b7e9d25994ce3df6b3936a06023588f2249554e5/cost-allocation.md</li>
<li>成本拆分 API 文档：https://github.com/kubecost/docs/blob/b7e9d25994ce3df6b3936a06023588f2249554e5/allocation.md</li>
</ul>
<p>查询成本拆分结果的 API 示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">requests</span>
</span></span><span class="line"><span class="cl"><span class="n">resp</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;http://localhost:9090/model/allocation&#34;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;window&#34;</span><span class="p">:</span> <span class="s2">&#34;2022-05-05T00:00:00Z,2022-05-06T00:00:00Z&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;aggregate&#34;</span><span class="p">:</span> <span class="s2">&#34;namespace,label:app&#34;</span><span class="p">,</span>  <span class="c1"># 以这几个纬度进行成本聚合</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;external&#34;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>     <span class="c1"># 拆分集群外部的成本（比如 s3/rds/es 等），需要通过其他手段提供外部资源的成本</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;accumulate&#34;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>   <span class="c1"># 累加指定 window 的所有成本</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;shareIdle&#34;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>   <span class="c1"># 将空闲成本拆分到所有资源上</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;idleByNode&#34;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>  <span class="c1"># 基于节点进行空闲资源的统计</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;shareTenancyCosts&#34;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>  <span class="c1"># 在集群的多个租户之间共享集群管理成本、节点数据卷成本。这部分成本将被添加到 `sharedCost` 字段中</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;shareNamespaces&#34;</span><span class="p">:</span> <span class="s2">&#34;kube-system,kubecost,istio-system,monitoring&#34;</span><span class="p">,</span>  <span class="c1"># 将这些名字空间的成本设为共享成本</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;shareLabels&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;shareCost&#34;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;shareSplit&#34;</span><span class="p">:</span> <span class="s2">&#34;weighted&#34;</span><span class="p">,</span>  <span class="c1"># 共享成本的拆分方法，weight 加权拆分，even 均分</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">resp_json</span> <span class="o">=</span> <span class="n">resp</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">resp_json</span><span class="p">[</span><span class="s1">&#39;code&#39;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">result</span> <span class="o">=</span> <span class="n">resp_json</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>查询结果中有这几种特殊成本类别：</p>
<ul>
<li><code>__idle__</code>: 未被占用的空闲资源消耗的成本</li>
<li><code>__unallocated_</code>: 不含有 <code>aggregate</code> 对应维度的成本，比如按 <code>label:app</code> 进行聚合，不含有 <code>app</code> 这个 label 的 pod 成本就会被分类到此标签</li>
<li><code>__unmounted__</code>: 未挂载 PV 的成本</li>
</ul>
<p>此外如果使用 kubecost 可视化面板，可能还会看到一个 <code>other</code> 类别，这是为了方便可视化，把成本太低的一些指标聚合展示了。</p>
<h3 id="kubecost-与-aws-集成" class="headerLink">
    <a href="#kubecost-%e4%b8%8e-aws-%e9%9b%86%e6%88%90" class="header-mark"></a>Kubecost 与 AWS 集成</h3><blockquote>
<p><a href="https://github.com/kubecost/docs/blob/b7e9d25994ce3df6b3936a06023588f2249554e5/aws-cloud-integrations.md" target="_blank" rel="noopener noreferrer">https://github.com/kubecost/docs/blob/b7e9d25994ce3df6b3936a06023588f2249554e5/aws-cloud-integrations.md</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/kubecost/docs/blob/main/aws-node-price-reconcilitation-methodology.md" target="_blank" rel="noopener noreferrer">https://github.com/kubecost/docs/blob/main/aws-node-price-reconcilitation-methodology.md</a></p>
</blockquote>
<p>TBD</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://github.com/kubecost/cost-model" target="_blank" rel="noopener noreferrer">kubecost</a>: kubecost 应该是目前最优秀的开源成本分析工具了，self-hosted 是免费的，也提供收费的云上版本，值得研究。
<ul>
<li>文档：https://github.com/kubecost/docs</li>
</ul>
</li>
<li><a href="https://github.com/gocrane/crane" target="_blank" rel="noopener noreferrer">crane</a>: 腾讯开源的一款 Kubernetes 成本优化工具，支持成本报表以及 EHPA 两个功能，才刚开源几个月，目前还比较简陋。</li>
<li><a href="https://www.finops.org/projects/calculating-container-costs/" target="_blank" rel="noopener noreferrer">Calculating Container Costs - FinOps</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/523045177" target="_blank" rel="noopener noreferrer">CPU利用率从10%提升至60%：中型企业云原生成本优化实战指南 - 星汉未来(Galaxy-Future)</a></li>
<li><a href="https://cloud.tencent.com/document/product/457/57732" target="_blank" rel="noopener noreferrer">资源利用率分析和优化建议 - 腾讯云容器服务</a></li>
</ul>
]]></content></entry><entry><title type="html">变革与创新</title><link href="https://thiscute.world/posts/revolution-and-innovation/"/><id>https://thiscute.world/posts/revolution-and-innovation/</id><author><name>ryan4yin</name></author><published>2022-03-28T00:40:00+08:00</published><updated>2022-03-28T00:40:00+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/revolution-and-innovation/rolling-girls.webp" height="2657" width="1468"><figcaption></figcaption>
        </figure><p>最近在学区块链技术，跟群友讨论时，一位群友抛出了他的观点：「所以智能合约，本质上依然是一个特殊的协议吧，只是套上了一个看起来高大上的词语而本质依然属于一种通信协议的东西，这么一想如果拆解开来实际上也应该没什么特别的。」</p>
<p>是啊，这样说的话，区块链技术确实挺简单的，没啥新的东西。底层就是各种现代密码学算法跟通讯协议而已，这些都是经过了几十年发展，已经很成熟的技术或者概念了。
但是中本聪把这些旧技术组合到一起，搞了个比特币，没几年就引发了加密货币狂潮，就连 GPU 都因为加密货币的发展价格一路狂飙。
2015 年以太坊往区块链上加了个功能：可以运行任何图灵完备的计算机程序（合约），编译成 EVM 字节码即可丢到以太坊区块链上运行。运行程序这样一件事本身有什么特殊的么？是台计算机都可以跑程序，但是以太坊第一个提出在区块链上跑图灵完备的程序，这导致以太坊成为了目前世界上第二大区块链系统，并且形成了一个庞大的开发者社区，目前网络上有多不胜数的以太坊开发教程及资料。</p>
<p>区块链技术仅仅只是以新的方式，组合使用了一系列成熟的工具而已，但是却引发了世界性的金融变革，甚至以太坊还在这之上研究出了更多的妙用，提出了 Web3.0 的概念。</p>
<p><strong>现有技术的新用法，也完全可以形成一场革命性的变革，甚至这个新用法可以非常简单，关键在于你能否发现这样一种用法，并且意识到它可能存在的价值</strong>。
这个是非常非常难的，微软曾经没看懂开源跟云计算的威力，诺基亚曾经觉得安卓就是垃圾不足为惧，很多搞金融的曾经觉得加密货币就是个笑话。
恰如很多现在丢了工作的传统运维，可能以前也是觉得容器跟云计算没啥特别的，影响不到自己吧。</p>
<p><strong>在没被新技术骑脸之前，一般人是很难感知到它对自己的影响的</strong>。</p>
<p>所以作为一名普通的技术人，我们也只能时时关注自己核心领域内各项新技术的发展，评估它们的潜力与价值，尽力看清它们的本质。
甚至偶尔也要拓展自己的视野去了解下其他关联领域的变化，这样才能降低自己被时代抛弃的概率。</p>
<p>每个新兴领域都不缺乏时代的弄潮儿，而我们普通人，只能未雨绸缪，尽量打造好自己的技术小船，不致被时代的大潮倾翻。</p>
<p>最后回到正题，我这个周末才刚学了两天区块链，还没搞明白智能合约是个啥，更遑论看清「智能合约的潜在价值」了，但是既然区块链是目前的一个风口，这么多人鼓吹，我觉得是值得花点时间搞清楚它导致是个啥的。
区块链、Web3.0 DAO NFT DeFi 这样的新概念，单单执着眼于别人的鼓吹或者贬低，只会是雾里看花一知半解。只有自己搞懂它，才有机会把握住它的本质。</p>
<p>路途漫漫，诸君共勉。</p>
]]></content></entry><entry><title type="html">写给开发人员的实用密码学（八）—— 数字证书与 TLS 协议</title><link href="https://thiscute.world/posts/about-tls-cert/"/><id>https://thiscute.world/posts/about-tls-cert/</id><author><name>ryan4yin</name></author><published>2022-03-14T00:00:00+08:00</published><updated>2022-03-14T00:00:00+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/about-tls-cert/https-secure.webp" height="1500" width="450"><figcaption></figcaption>
        </figure><blockquote>
<p>本文基本上是一篇原创文章，但是行文有点生硬，仍然在优化中，不太适合初学者阅读。</p>
</blockquote>
<p>《写给开发人员的实用密码学》系列文章目录:</p>
<ul>
<li><a href="/posts/practical-cryptography-basics-1/" rel="">写给开发人员的实用密码学（一）—— 概览</a></li>
<li><a href="/posts/practical-cryptography-basics-2-hash/" rel="">写给开发人员的实用密码学（二）—— 哈希函数</a></li>
<li><a href="/posts/practical-cryptography-basics-3-key-derivation-function/" rel="">写给开发人员的实用密码学（三）—— MAC 与密钥派生函数 KDF</a></li>
<li><a href="/posts/practical-cryptography-basics-4-secure-random-generators/" rel="">写给开发人员的实用密码学（四）—— 安全随机数生成器 CSPRNG</a></li>
<li><a href="/posts/practical-cryptography-basics-5-key-exchange/" rel="">写给开发人员的实用密码学（五）—— 密钥交换 DHKE 与完美前向保密 PFS</a></li>
<li><a href="/posts/practical-cryptography-basics-6-symmetric-key-ciphers/" rel="">写给开发人员的实用密码学（六）—— 对称密钥加密算法</a></li>
<li><a href="/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/" rel="">写给开发人员的实用密码学（七）—— 非对称密钥加密算法 RSA/ECC</a></li>
<li><a href="/posts/about-tls-cert" rel="">写给开发人员的实用密码学（八）—— 数字证书与 TLS 协议</a></li>
<li>待续</li>
</ul>
<h2 id="更新记录" class="headerLink">
    <a href="#%e6%9b%b4%e6%96%b0%e8%ae%b0%e5%bd%95" class="header-mark"></a>更新记录</h2><ul>
<li><strong>2021-01-17</strong>: 完成 TLS 协议简介、数字证书介绍、数字证书的申请或生成方法、mTLS 介绍、TLS 协议的破解手段</li>
<li><strong>2022-03-13</strong> ~ <strong>2022-03-14</strong>: 重新整理补充，改写为《写给开发人员的实用密码学（八）—— 数字证书与 TLS 协议》，整合进我的实用密码学系列文章中
<ul>
<li>补充 PKI 公钥基础架构及 X509 证书标准介绍</li>
</ul>
</li>
<li>TODO:
<ul>
<li>补充 TLS 协议的逆向手段</li>
<li>基于 <a href="https://shoujo.ink/2021/11/cfssl-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/" target="_blank" rel="noopener noreferrer">cfssl</a> 详细介绍 PKI 的各项组件</li>
<li>基于 PKI 的应用服务间身份识别技术：<a href="https://github.com/spiffe/spiffe" target="_blank" rel="noopener noreferrer">SPIFF ID</a>
<ul>
<li>SPIFF ID 是云原生领域的标准，<a href="https://shoujo.ink/2021/10/istio-%E5%AE%89%E5%85%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-pki-%E4%B8%8E%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/" target="_blank" rel="noopener noreferrer">服务网格项目 Istio 就使用了 SPIFF ID 作为安全命名</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="零前言" class="headerLink">
    <a href="#%e9%9b%b6%e5%89%8d%e8%a8%80" class="header-mark"></a>零、前言</h2><p>现代人的日常生活中，HTTPS 协议几乎无处不在，我们每天浏览网页时、用手机刷京东淘宝时、甚至每天秀自己绿色的健康码时，都在使用 HTTPS 协议。</p>
<p>作为一个开发人员，我想你应该多多少少有了解一点 HTTPS 协议。
你可能知道 HTTPS 是一种加密传输协议，能保证数据传输的保密性。
如果你拥有部署 HTTPS 服务的经验，那你或许还懂如何申请权威 HTTPS 证书，并配置在 Nginx 等 Web 程序上。</p>
<p>但是你是否清楚 HTTPS 是由 HTTP + TLS 两种协议组合而成的呢？
更进一步你是否有抓包了解过 TLS 协议的完整流程？是否清楚它加解密的底层原理？是否清楚 Nginx 的 HTTPS 配置中一堆密码学参数的真正含义？是否知道 TLS 协议有哪些弱点、存在哪些攻击手段、如何防范？</p>
<p>我们在《写给开发人员的实用密码学》的前七篇文章中已经学习了许多的密码学概念与算法，接下来我们就利用这些知识，深度剖析下 HTTPS 协议中的数字证书以及 TLS 协议。</p>
<h2 id="一数字证书与-pki-公钥基础架构" class="headerLink">
    <a href="#%e4%b8%80%e6%95%b0%e5%ad%97%e8%af%81%e4%b9%a6%e4%b8%8e-pki-%e5%85%ac%e9%92%a5%e5%9f%ba%e7%a1%80%e6%9e%b6%e6%9e%84" class="header-mark"></a>一、数字证书与 PKI 公钥基础架构</h2><p>我们在前面已经学习了「对称密码算法」与「非对称密码算法」两个密码学体系，这里做个简单的总结。</p>
<ul>
<li><strong>对称密码算法（如 AES/ChaCha20）</strong>: <strong>计算速度快、安全强度高，但是缺乏安全交换密钥的手段、密钥的保存和管理也很困难</strong>。</li>
<li><strong>非对称密码算法（如 RSA/ECC）: 计算速度慢，但是它解决了上述对称密码算法最大的两个缺陷，一是给出了安全的密钥交换算法 DHE/ECDHE，二呢它的公钥是可公开的，这降低了密钥的保存与管理难度</strong>。</li>
</ul>
<p>但是非对称密码算法仍然存在一些问题:</p>
<ul>
<li><strong>公钥该如何分发</strong>？比如 Alice 跟 Bob 交换公钥时，如何确定收到的确实是对方的公钥，也就是说如何确认公钥的真实性、完整性、认证其来源身份？
<ul>
<li>前面我们已经学习过，DH/ECDH 密钥交换协议可以防范嗅探攻击（窃听），但是<strong>无法抵挡中间人攻击</strong>（中继）。</li>
</ul>
</li>
<li>如果 Alice 的私钥泄漏了，她该<strong>如何作废自己旧的公钥</strong>？</li>
</ul>
<p>数字证书与公钥基础架构就是为了解决上述问题而设计的。</p>
<p>首先简单介绍下公钥基础架构（Public Key Infrastructure），它是一组由硬件、软件、参与者、管理政策与流程组成的基础架构，其目的在于创造、管理、分配、使用、存储以及撤销数字证书。
PKI 是一个总称，而并非指单独的某一个规范或标准，因此显然数字证书的规范（X.509）、存储格式（PKCS系列标准、DER、PEM）、TLS 协议等都是 PKI 的一部分。</p>
<p>我们下面从公钥证书开始逐步介绍 PKI 中的各种概念及架构。</p>
<h3 id="1-公钥证书" class="headerLink">
    <a href="#1-%e5%85%ac%e9%92%a5%e8%af%81%e4%b9%a6" class="header-mark"></a>1. 公钥证书</h3><p>前面我们介绍了公钥密码系统存在的一个问题是「在分发公钥时，难以确认公钥的真实性、完整性及其来源身份」。
PKI 通过「数字证书」+「证书认证机构」来解决这个问题，下面先简单介绍下「数字证书」。</p>
<p><strong>数字证书</strong>指的其实就是<strong>公钥证书</strong>（也可直接简称为<strong>证书</strong>）。
在现代网络通讯中通行的公钥证书标准名为 <a href="https://zh.wikipedia.org/wiki/X.509" target="_blank" rel="noopener noreferrer">X.509</a> v3, 由 <a href="https://tools.ietf.org/html/rfc5280" target="_blank" rel="noopener noreferrer">RFC5280</a> 定义。
X.509 v3 格式被广泛应用在 TLS/SSL 等众多加密通讯协议中，它规定公钥证书应该包含如下内容:</p>
<ul>
<li>证书
<ul>
<li><strong>序列号</strong>（Serial Number）: 用以识别每一张证书，在作废证书的时候会用到它</li>
<li><strong>版本</strong>: 证书的规范版本</li>
<li><strong>公钥</strong>（Public Key）: 我们的核心目的就是分发公钥，因此显然要把公钥放在证书里面</li>
<li><strong>公钥指纹</strong>: 即公钥的 Hash 值，当前大部分证书都使用 SHA256 计算此指纹</li>
<li><strong>公钥用途</strong>（Key Usage + Extended Key Usage）: 记录了此证书可用于哪些用途——数字签名、身份认证等</li>
<li><strong>主体</strong>（Subject）: 即姓名、组织、邮箱、地址等证书拥有者的个人信息。
<ul>
<li>有了这个我们就能确认证书的拥有者了</li>
</ul>
</li>
<li><strong>证书有效期的开始时间、结束时间</strong>（Not Before + Not After）: 为了确保安全性，每个证书都会记录一个自身的有效期
<ul>
<li>证书一旦签发并公开，随着科技的发展、时间的推移，其公钥的安全性会慢慢减弱</li>
<li>因此每个证书都应该包含一个合理的有效期，证书的拥有者应该在有效期截止前更换自身的证书以确保安全性</li>
</ul>
</li>
<li><strong>签发者</strong>（Issuer）: 签发此证书的「签发者」信息</li>
<li>其他拓展信息</li>
</ul>
</li>
<li><strong>数字签名</strong>（Signature）: 我们还需要对上面整个证书计算一个数字签名，来确保这些数据的真实性、完整性，确保证书未被恶意篡改/伪造
<ul>
<li>此数字签名由「证书签发者（Issuer）」使用其私钥+证书内容计算得出</li>
</ul>
</li>
<li><strong>数字签名算法</strong>（Signature Algorithm）: 证书所使用的签名算法，常用的有 <code>RSA-SHA-256</code> 与 <code>ECDSA-SHA-256</code></li>
</ul>
<p>每个证书都有唯一的 ID，这样在私钥泄漏的情况下，我们可以通过公钥基础设施的 OCSP（Online Certificate Status Protocol）协议吊销某个证书。</p>
<p>吊销证书的操作还是比较罕见的，毕竟私钥泄漏并不容易遇到，因此这里就略过不提了，有需要的可以自行搜索。</p>
<p>使用 Firefox 查看网站 <code>https://www.google.com</code> 的证书信息如下：</p>
<figure><img src="/images/about-tls-cert/cert-content.webp"/><figcaption>
            <h4>Google 证书内容</h4>
        </figcaption>
</figure>

<h3 id="2-证书链" class="headerLink">
    <a href="#2-%e8%af%81%e4%b9%a6%e9%93%be" class="header-mark"></a>2. 证书链</h3><p>前面介绍证书内容时，提到了每个证书都包含「签发者（Issuer）」信息，并且还包含「签发者」使用「证书内容」与「签发者私钥」生成的数字签名。</p>
<p>那么在证书交换时，如何验证证书的真实性、完整性及来源身份呢？
根据「数字签名」算法的原理，显然需要使用「签发者公钥」来验证「被签发证书」中的签名。</p>
<p>仍然辛苦 Alice 与 Bob 来演示下这个流程:</p>
<ul>
<li>假设现在 Alice 生成了自己的公私钥对，她想将公钥发送给远在千里之外的 Bob，以便与 Bob 进行加密通讯</li>
<li>但是如果 Alice 直接发送公钥给 Bob，Bob 并无法验证其来源是 Alice，也无法验证证书是否被篡改</li>
</ul>
<p>PKI 引入了一个<strong>可信赖的第三者</strong>（Trusted third party，TTP）来解决这个问题。
在 Alice 与 Bob 的案例中，就是说还有个第三者 <strong>Eve</strong>，他使用自己的私钥为自己的公钥证书签了名，生成了一个「自签名证书」，并且已经提前将这个「自签名证书」分发（比如当面交付、物理分发 emmm）给了 Alice 跟 Bob.</p>
<ul>
<li>现在 Alice 首先使用自己的公钥以及个人信息制作了自己的公钥证书，但是这个证书还缺乏一个 Issuer 属性以及数字签名，我们把它叫做「证书签名请求（Certificate Signing Request, CSR）」</li>
<li>为了实现将证书安全传递给远在千里之外的 Bob，Alice 找到 Eve，将这个 CSR 文件提交给 Eve</li>
<li>Eve 验证了 Alice 的身份后，再使用这个 CSR 签发出完整的证书文件（Issuer 就填 Eve，然后 Eve 使用自己的私钥计算出证书的数字签名）交付给 Alice
<ul>
<li>Eve 可是曾经跨越千里之遥，将自己的公钥证书分发给了 Bob，所以在给 Alice 签发证书时，他显然可能会要求 Alice 给付「签名费」。目前许多证书机构就是靠这个赚钱的，当然也有非盈利的证书颁发机构如 Let&rsquo;s Encrypt.</li>
</ul>
</li>
<li>现在 Alice 再将经 Eve 签名的证书发送给 Bob</li>
<li>Bob 收到证书后，看到 Issuer 是 Eve，于是找出以前 Eve 给他的「自签名证书」，然后使用其中的公钥验证收到的证书</li>
<li>如果验证成功，就说明证书的内容是经过 Eve 认证的。如果 Eve 没老糊涂了，那这个证书应该确实就是 Alice 的。</li>
<li>如果验证失败，那说明这是某个攻击者伪造的证书。</li>
</ul>
<p>在现实世界中，Eve 这个角色被称作「<strong>证书认证机构</strong>（Certification Authority, CA）」，全世界只有几十家这样的权威机构，它们都通过了各大软件厂商的严格审核，从而将根证书（CA 证书）直接内置于主流操作系统与浏览器中，也就是说早就提前分发给了因特网世界的几乎所有用户。</p>
<p>由于许多操作系统或软件的更新迭代缓慢（2022 年了还有人用 XP 你敢信？），根证书的有效期通常都在十年以上。</p>
<p>但是，如果 CA 机构直接使用自己的私钥处理各种证书签名请求，这将是非常危险的。
因为全世界有海量的 HTTPS 网站，也就是说有海量的证书需求，可一共才几十家 CA 机构。
频繁的动用私钥会产生私钥泄漏的风险，如果这个私钥泄漏了，那将直接影响海量网站的安全性。</p>
<p>PKI 架构使用「<strong>数字证书链</strong>（也叫做<strong>信任链</strong>）」的机制来解决这个问题:</p>
<ul>
<li>CA 机构首先生成自己的根证书与私钥，并使用私钥给根证书签名
<ul>
<li>因为私钥跟证书本身就是一对，因此根证书也被称作「自签名证书」</li>
</ul>
</li>
<li>CA 根证书被直接交付给各大软硬件厂商，内置在主流的操作系统与浏览器中</li>
<li>然后 CA 机构再使用私钥签发一些所谓的「<strong>中间证书</strong>」，之后就把私钥雪藏了，非必要不会再拿出来使用。
<ul>
<li>根证书的私钥通常<strong>离线存储</strong>在安全地点</li>
<li>中间证书的有效期通常会比根证书短一些</li>
<li>部分中间证书会被作为备份使用，平常不会启用</li>
</ul>
</li>
<li>CA 机构使用这些中间证书的私钥，为用户提交的所有 CSR 请求签名</li>
</ul>
<p>画个图来表示大概是这么个样子：</p>
<figure><img src="/images/about-tls-cert/chain-of-trust.webp"/>
</figure>

<p>CA 机构也可能会在经过严格审核后，为其他机构签发中间证书，这样就能赋予其他机构签发证书的权利，而且根证书的安全性不受影响。</p>
<p>如果你访问某个 HTTPS 站点发现浏览器显示小绿锁，那就说明这个证书是由某个权威<strong>认证机构</strong>签发的，其信息是经过这些机构认证的。</p>
<p>上述这个全球互联网上，由<strong>证书认证机构</strong>、操作系统与浏览器内置的根证书、TLS 加密认证协议、OCSP 证书吊销协议等等组成的架构，我们可以称它为 <strong>Web PKI</strong>.</p>
<p><strong>Web PKI</strong> 通常是可信的，但是并不意味着它们可靠。历史上出现过许多由于安全漏洞（<a href="http://www.ip-guard.net/blog/?p=834" target="_blank" rel="noopener noreferrer">2011 DigiNotar 攻击</a>）或者政府要求，证书认证机构将假证书颁发给黑客或者政府机构的情况。获得假证书的人将可以随意伪造站点，而所有操作系统或浏览器都认为这些假站点是安全的（显示小绿锁）。</p>
<p>因为<strong>证书认证机构</strong>的可靠性问题以及一些其他的原因，部分个人、企业或其他机构（比如金融机构）会生成自己的根证书与中间证书，然后自行签发证书，构建出自己的 PKI 认证架构，我们可以将它称作<strong>内部 PKI</strong>或者<strong>私有 PKI</strong>。
但是这种自己生成的根证书是未内置在操作系统与浏览器中的，为了确保安全性，用户就需要先手动在设备上安装好这个数字证书。
自行签发证书的案例有：</p>
<ul>
<li>微信、支付宝及各种银行客户端中的数字证书与安全性更高的 USB 硬件证书（U 盾），这种涉及海量资金安全甚至国家安全的场景，显然不能直接使用前述普通权威 CA 机构签发的证书。</li>
<li>局域网通信，通常是网络管理员生成一个本地 CA 证书安装到所有局域网设备上，再用它的私钥签发其他证书用于局域网安全通信
<ul>
<li>典型的例子是各企业的内部通讯网络，比如 Kubernetes 容器集群</li>
</ul>
</li>
</ul>
<p>现在再拿出前面 <code>https://www.google.com</code> 的证书截图看看，最上方有三个标签页，从左至右依次是「服务器证书」、「中间证书」、「根证书」，可以点进去分别查看这三个证书的各项参数，各位看官可以自行尝试：</p>
<figure><img src="/images/about-tls-cert/cert-content.webp"/><figcaption>
            <h4>Google 证书内容</h4>
        </figcaption>
</figure>

<h4 id="交叉签名" class="headerLink">
    <a href="#%e4%ba%a4%e5%8f%89%e7%ad%be%e5%90%8d" class="header-mark"></a>交叉签名</h4><p>按前面的描述，每个权威认证机构都拥有一个正在使用的根证书，使用它签发出几个中间证书后，就会把它离线存储在安全地点，平常仅使用中间证书签发终端实体证书。
这样实际上每个权威认证机构的证书都形成一颗证书树，树的顶端就是根证书。</p>
<p>实际上在 PKI 体系中，一些证书链上的中间证书会被使用多个根证书进行签名——我们称这为交叉签名。
交叉签名的主要目的是提升证书的兼容性——客户端只要安装有其中任何一个根证书，就能正常验证这个中间证书。
从而使中间证书在较老的设备也能顺利通过证书验证。</p>
<h3 id="3-证书的存储格式与编码标准" class="headerLink">
    <a href="#3-%e8%af%81%e4%b9%a6%e7%9a%84%e5%ad%98%e5%82%a8%e6%a0%bc%e5%bc%8f%e4%b8%8e%e7%bc%96%e7%a0%81%e6%a0%87%e5%87%86" class="header-mark"></a>3. 证书的存储格式与编码标准</h3><blockquote>
<p>证书的格式这一块，是真的五花八门&hellip;沉重的历史包袱&hellip;</p>
</blockquote>
<p>X509 只规定了证书应该包含哪些信息，但是未定义证书该如何存储。为了解决证书的描述与编码存储问题，又出现了如下标准：</p>
<ul>
<li>ASN.1 结构：是一种描述证书格式的方法。
<ul>
<li>它类似 protobuf 数据描述语言、SQL DDL</li>
<li>ASN.1 只规定了该如何描述证书，未定义该如何编码。</li>
</ul>
</li>
<li>将 ASN.1 结构编码存储的格式有
<ul>
<li>DER：一种二进制编码格式</li>
<li>PEM：DER 是二进制格式，不便于复制粘贴，因此出现了 PEM，它是一个文本编码格式（其实就是把 DER 编码后的数据再 Base64 编码下&hellip;）</li>
</ul>
</li>
<li>某些场景下，X.509 信息不够丰富，因此又设计了一些信息更丰富（例如可以包含证书链、公私钥对）的证书封装格式，包括 PKCS #7 和 PKCS #12
<ul>
<li>仍然用 ASN.1 格式描述</li>
<li>基本都是用 DER 编码</li>
</ul>
</li>
</ul>
<p>下面详细介绍下这些相关的标准与格式。</p>
<h4 id="编码存储格式-der-与-pem" class="headerLink">
    <a href="#%e7%bc%96%e7%a0%81%e5%ad%98%e5%82%a8%e6%a0%bc%e5%bc%8f-der-%e4%b8%8e-pem" class="header-mark"></a>编码存储格式 DER 与 PEM</h4><p>DER 是由国际电信联盟（ITU）在 <a href="https://www.itu.int/ITU-T/recommendations/rec.aspx?rec=x.690" target="_blank" rel="noopener noreferrer"> ITU-T X.690</a>标准中定义的一种数据编码规则，用于将 ASN.1 结构的信息编码为二进制数据。
直接以 DER 格式存储的证书，大都使用 <code>.cer</code> <code>.crt</code> <code>.der</code> 拓展名，在 Windows 系统比较常见。</p>
<p>而 PEM 格式，即 Privacy-Enhanced Mail，是 openssl 默认使用的证书格式。可用于编码公钥、私钥、公钥证书等多种密码学信息。
PEM 其实就是在 DER 的基础上多做一步——使用 Base64 将 DER 编码出的二进制数据再处理一次，编码成字符串再存储。好处是存储、传输要方便很多，可以直接复制粘贴。</p>
<p>一个 2048 位 RSA 公钥的 PEM 文件内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-----BEGIN PUBLIC KEY-----
</span></span><span class="line"><span class="cl">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyl6q6BkEcEUi9V1/Q7il
</span></span><span class="line"><span class="cl">bngnh1YzG1tM4Hd6XCZQ35OzDN4my9eXWtjoL8YvLYqlYTJqhTHpuptgjF/lmlhg
</span></span><span class="line"><span class="cl">WIMKNNcuDAbvmWExRyZateVrjO9OtgkyJCuGhaum0TIUC+dbZ9L9xsdK/fU1L5BB
</span></span><span class="line"><span class="cl">nPRSYMloH8uE1CbK/DhFUiKp36aHZFfqLPicY3c6/N+k2kIJCEWBY0SROqpqy2Iz
</span></span><span class="line"><span class="cl">yCIP54JSoOoGz6pdtWhd5cEeicr9e7f/WixEES6fgavqIHzhSJBVctpMgFPjFZ/x
</span></span><span class="line"><span class="cl">JJhQVf23WKb3YQQ/0Uc8O7OTDXoUfuJP9UgqvKNh4hPfJA+a4nxkDYhTPfrLHfKY
</span></span><span class="line"><span class="cl">YwIDAQAB
</span></span><span class="line"><span class="cl">-----END PUBLIC KEY-----
</span></span></code></pre></td></tr></table>
</div>
</div><p>PEM 格式的数据通常以 <code>.pem</code> <code>.key</code> <code>.crt</code> <code>.cer</code> 等拓展名存储，直接 <code>cat</code> 一下是不是字符串，就能确认该文件是否是 PEM 格式了。</p>
<p>因为纯文本格式处理起来很方便，大部分场景下证书、公钥、私钥等信息都会被编码成 PEM 格式再进行存储、传输。</p>
<p>openssl 默认使用的输入输出均 PEM 格式。</p>
<h4 id="pkcs1" class="headerLink">
    <a href="#pkcs1" class="header-mark"></a>PKCS#1</h4><p>PKCS#1 是专用于编码 RSA 公私钥的标准，通常被编码为 PEM 格式存储。openssl 生成的 RSA 密钥对默认使用此格式。</p>
<p>这是一个比较陈旧的格式，openssl 之所以默认使用它，主要是为了兼容性。通常建议使用更安全的 PKCS#8 而不是这个。</p>
<p>一个使用 PKCS#1 标准的 2048 位 RSA 公钥文件，内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-----BEGIN PUBLIC KEY-----
</span></span><span class="line"><span class="cl">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyl6q6BkEcEUi9V1/Q7il
</span></span><span class="line"><span class="cl">bngnh1YzG1tM4Hd6XCZQ35OzDN4my9eXWtjoL8YvLYqlYTJqhTHpuptgjF/lmlhg
</span></span><span class="line"><span class="cl">WIMKNNcuDAbvmWExRyZateVrjO9OtgkyJCuGhaum0TIUC+dbZ9L9xsdK/fU1L5BB
</span></span><span class="line"><span class="cl">nPRSYMloH8uE1CbK/DhFUiKp36aHZFfqLPicY3c6/N+k2kIJCEWBY0SROqpqy2Iz
</span></span><span class="line"><span class="cl">yCIP54JSoOoGz6pdtWhd5cEeicr9e7f/WixEES6fgavqIHzhSJBVctpMgFPjFZ/x
</span></span><span class="line"><span class="cl">JJhQVf23WKb3YQQ/0Uc8O7OTDXoUfuJP9UgqvKNh4hPfJA+a4nxkDYhTPfrLHfKY
</span></span><span class="line"><span class="cl">YwIDAQAB
</span></span><span class="line"><span class="cl">-----END PUBLIC KEY-----
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="pkcs7--cms" class="headerLink">
    <a href="#pkcs7--cms" class="header-mark"></a>PKCS#7 / CMS</h4><blockquote>
<p>头疼&hellip;为什么这么多五花八门的格式&hellip;</p>
</blockquote>
<p><a href="https://datatracker.ietf.org/doc/html/rfc5652" target="_blank" rel="noopener noreferrer">PKCS#7/CMS</a>，是一个多用途的证书描述格式。
它包含一个数据填充规则，这个填充规则常被用在需要数据填充的分组加密、数字签名等算法中。</p>
<p>另外据说 PKCS#7 也可以被用来描述证书，并以 DER/PEM 格式保存，后缀通常使用 <code>.p7b</code> 或者 <code>.p7c</code>,
这个暂时存疑吧，有需要再研究了。</p>
<h4 id="pkcs8" class="headerLink">
    <a href="#pkcs8" class="header-mark"></a>PKCS#8</h4><p><a href="https://datatracker.ietf.org/doc/html/rfc5958" target="_blank" rel="noopener noreferrer">PKCS#8</a> 是一个专门用于编码私钥的标准，可用于编码 DSA/RSA/ECC 私钥。它通常被编码成 PEM 格式存储。</p>
<p>前面介绍了专门用于编码 RSA 的 PKCS#1 标准比较陈旧，而且<a href="https://web.archive.org/web/20081117042916/http://www.gemplus.com/smart/rd/publications/pdf/CJNP00pk.pdf" target="_blank" rel="noopener noreferrer">曾经出过漏洞</a>。因此通常建议使用更安全的 PKCS#8 来取代 PKCS#1.</p>
<p>C# Java 等编程语言通常要求使用此格式的私钥，而 Python 的 <a href="https://github.com/pyca/cryptography" target="_blank" rel="noopener noreferrer">pyca/cryptography</a> 则支持多种编码格式。</p>
<p>一个非加密 ECC 私钥的 PKCS#8 格式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-----BEGIN PRIVATE KEY-----
</span></span><span class="line"><span class="cl">MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQglQanBRiYVPX7F2Rd
</span></span><span class="line"><span class="cl">4CqyjEN0K4qfHw4tM/yMIh21wamhRANCAARsxaI4jT1b8zbDlFziuLngPcExbYzz
</span></span><span class="line"><span class="cl">ePAHUmgWL/ZCeqlODF/l/XvimkjaWC2huu1OSWB9EKuG+mKFY2Y5k+vF
</span></span><span class="line"><span class="cl">-----END PRIVATE KEY-----
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个加密 PKCS#8 私钥的 PEM 格式私钥如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-----BEGIN ENCRYPTED PRIVATE KEY-----
</span></span><span class="line"><span class="cl">Base64 编码内容
</span></span><span class="line"><span class="cl">-----END ENCRYPTED PRIVATE KEY-----
</span></span></code></pre></td></tr></table>
</div>
</div><p>可使用如下 openssl 命令将 RSA/ECC 私钥转换为 PKCS#8 格式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># RSA
</span></span><span class="line"><span class="cl">openssl pkcs8 -topk8 -inform PEM -in rsa-private-key.pem -outform PEM -nocrypt -out rsa-private-key-pkcs8.pem
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># ECC 的转换命令与 RSA 完全一致
</span></span><span class="line"><span class="cl">openssl pkcs8 -topk8 -inform PEM -in ecc-private-key.pem -outform PEM -nocrypt -out ecc-private-key-pkcs8.pem
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="pkcs12" class="headerLink">
    <a href="#pkcs12" class="header-mark"></a>PKCS#12</h4><p><a href="https://zh.wikipedia.org/wiki/PKCS_12" target="_blank" rel="noopener noreferrer">PKCS#12</a> 是一个归档文件格式，用于实现存储多个私钥及相关的 X.509 证书。</p>
<p>因为保存了私钥，为了安全性它通常是加密的，需要使用 passphrase 解密后才能使用。</p>
<p>PKCS#12 的常用拓展名为 <code>.p12</code> <code>.pfx</code>.</p>
<p>PKCS#12 的主要使用场景是安全地保存、传输私钥及相关的 X.509 证书，比如：</p>
<ul>
<li>微信/支付宝等支付相关的数字证书，通常使用 PKCS#12 格式存储，使用商户号做加密密码，然后编码为 base64 再提供给用户</li>
<li>安卓的 APK 签名证书通常使用 PKCS#12 格式存储，拓展名为 <code>.keystore</code> 或者 <code>.jks</code>.</li>
</ul>
<p>PEM 格式转 PKCS#12（公钥和私钥都放里面）:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># </span>
</span></span><span class="line"><span class="cl">openssl pkcs12 -export -in client.crt -inkey client.key -out client.p12
</span></span><span class="line"><span class="cl"><span class="c1"># 按提示输入保护密码</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从 PKCS#12 中分别提取出 PEM 格式的公钥与私钥:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">openssl pkcs12 -in xxx.p12 -out xxx.crt -clcerts -nokeys
</span></span><span class="line"><span class="cl">openssl pkcs12 -in xxx.p12 -out xxx.key -nocerts -nodes
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="4-证书支持保护的域名类型" class="headerLink">
    <a href="#4-%e8%af%81%e4%b9%a6%e6%94%af%e6%8c%81%e4%bf%9d%e6%8a%a4%e7%9a%84%e5%9f%9f%e5%90%8d%e7%b1%bb%e5%9e%8b" class="header-mark"></a>4. 证书支持保护的域名类型</h3><p>TLS 证书支持配置多个域名，并且支持所谓的通配符（泛）域名。
但是通配符域名证书的匹配规则，<strong>和 DNS 解析中的匹配规则并不一致</strong>！</p>
<p>根据<a href="https://help.aliyun.com/document_detail/28542.html" target="_blank" rel="noopener noreferrer">证书选型和购买 - 阿里云文档</a> 的解释，<strong>通配符证书只支持同级匹配</strong>，详细说明如下:</p>
<ol>
<li><strong>一级通配符域名</strong>: 可保护该通配符域名（主域名）自身和该域名所有的一级子域名。
<ul>
<li>例如: 一级通配符域名 <code>*.aliyun.com</code> 可以用于保护 <code>aliyun.com</code>、<code>www.aliyun.com</code> 以及其他所有一级子域名。
但是不能用于保护任何二级子域名，如 <code>xx.aa.aliyun.com</code></li>
</ul>
</li>
<li><strong>二级或二级以上通配符域名</strong>: 只能保护该域名同级的所有通配域名，不支持保护该通配符域名本身。
<ul>
<li>例如: <code>*.a.aliyun.com</code> 只支持保护它的所有同级域名，不能用于保护三级子域名。</li>
</ul>
</li>
</ol>
<p>要想保护多个二三级子域，只能在生成 TLS 证书时，添加多个通配符域名。
因此设计域名规则时，要考虑到这点，尽量不要使用层级太深的域名！有些信息可以通过 <code>-</code> 来拼接以减少域名层级，比如阿里云的 oss 域名:</p>
<ol>
<li>公网: <code>oss-cn-shenzhen.aliyuncs.com</code></li>
<li>内网: <code>oss-cn-shenzhen-internal.aliyuncs.com</code></li>
</ol>
<p>此外也可直接为 IP 地址签发证书，IP 地址可以记录在证书的 SAN 属性中。
在自己生成的证书链中可以为局域网 IP 或局域网域名生成本地签名证书。
此外在因特网中也有一些权威认证机构提供为公网 IP 签发证书的服务，一个例子是 Cloudflare 的 <a href="https://1.1.1.1" target="_blank" rel="noopener noreferrer">https://1.1.1.1</a>, 使用 Firefox 查看其证书，可以看到是一个由 DigiCert 签发的 ECC 证书，使用了 P-256 曲线：</p>
<figure><img src="/images/about-tls-cert/1.1.1.1-cert.webp"/><figcaption>
            <h4> Cloudflare 的 IP 证书</h4>
        </figcaption>
</figure>

<h3 id="5-生成自己的证书链" class="headerLink">
    <a href="#5-%e7%94%9f%e6%88%90%e8%87%aa%e5%b7%b1%e7%9a%84%e8%af%81%e4%b9%a6%e9%93%be" class="header-mark"></a>5. 生成自己的证书链</h3><blockquote>
<p><a href="https://github.com/openssl/openssl" target="_blank" rel="noopener noreferrer">OpenSSL</a> 是目前使用最广泛的网络加密算法库，这里以它为例介绍证书的生成。
另外也可以考虑使用 CloudFalre 开源的 PKI 工具 <a href="https://github.com/cloudflare/cfssl" target="_blank" rel="noopener noreferrer">cfssl</a>.</p>
</blockquote>
<p>前面介绍了，在局域网通信中通常使用本地证书链（<strong>私有 PKI</strong>）来保障通信安全，这通常有如下几个原因。</p>
<ol>
<li>在内网环境下，管理员将本地 CA 证书安装到所有局域网设备上，因此并无必要向权威 CA 机构申请证书</li>
<li>内网环境使用的可能是非公网域名（<code>xxx.local</code>/<code>xxx.lan</code>/<code>xxx.srv</code> 等），甚至可能直接使用局域网 IP 通信，权威 CA 机构不签发这种类型的证书</li>
<li>本地证书链完全受自己控制，可以自己设置安全强度、证书年限等等，而且不受权威 CA 机构影响。</li>
<li>权威 CA 机构不签发客户端证书，因为客户端不一定有固定的 IP 地址或者域名。客户端证书需要自己签发。</li>
</ol>
<p>下面介绍下如何使用 OpenSSL 生成一个本地 CA 证书链，并签发用于安全通信的服务端证书，可用于 HTTPS/QUIC 等协议。</p>
<h4 id="1-生成-rsa-证书链" class="headerLink">
    <a href="#1-%e7%94%9f%e6%88%90-rsa-%e8%af%81%e4%b9%a6%e9%93%be" class="header-mark"></a>1. 生成 RSA 证书链</h4><p>到目前为止 RSA 仍然是应用最广泛的非对称加密方案，几乎所有的根证书都是使用的 2048 位或者 4096 位的 RSA 密钥对。</p>
<p>对于 RSA 算法而言，越长的密钥能提供越高的安全性，当前使用最多的 RSA 密钥长度仍然是 2048 位，但是 2048 位已被一些人认为不够安全了，密码学家更建议使用 3072 位或者 4096 位的密钥。</p>
<p>生成一个 2048 位的 RSA 证书链的流程如下:</p>
<blockquote>
<p>OpenSSL 的 CSR 配置文件官方文档: <a href="https://www.openssl.org/docs/manmaster/man1/openssl-req.html" target="_blank" rel="noopener noreferrer">https://www.openssl.org/docs/manmaster/man1/openssl-req.html</a></p>
</blockquote>
<ol>
<li>编写证书签名请求的配置文件 <code>csr.conf</code>:
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[ req ]
</span></span><span class="line"><span class="cl">prompt = no
</span></span><span class="line"><span class="cl">default_md = sha256  # 在签名算法中使用 SHA-256 计算哈希值
</span></span><span class="line"><span class="cl">req_extensions = req_ext
</span></span><span class="line"><span class="cl">distinguished_name = dn
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[ dn ]
</span></span><span class="line"><span class="cl">C = CN  # Contountry
</span></span><span class="line"><span class="cl">ST = Guangdong
</span></span><span class="line"><span class="cl">L = Shenzhen
</span></span><span class="line"><span class="cl">O = Xxx
</span></span><span class="line"><span class="cl">OU = Xxx-SRE
</span></span><span class="line"><span class="cl">CN = *.svc.local  # 泛域名，这个字段已经被 chrome/apple 弃用了。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[ alt_names ]  # 备用名称，chrome/apple 目前只信任这里面的域名。
</span></span><span class="line"><span class="cl">DNS.1 = *.svc.local  # 一级泛域名
</span></span><span class="line"><span class="cl">DNS.2 = *.aaa.svc.local  # 二级泛域名
</span></span><span class="line"><span class="cl">DNS.3 = *.bbb.svc.local  # 二级泛域名
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[ req_ext ]
</span></span><span class="line"><span class="cl">subjectAltName = @alt_names
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[ v3_ext ]
</span></span><span class="line"><span class="cl">subjectAltName=@alt_names  # Chrome 要求必须要有 subjectAltName(SAN)
</span></span><span class="line"><span class="cl">authorityKeyIdentifier=keyid,issuer:always
</span></span><span class="line"><span class="cl">basicConstraints=CA:FALSE
</span></span><span class="line"><span class="cl">keyUsage=keyEncipherment,dataEncipherment,digitalSignature
</span></span><span class="line"><span class="cl">extendedKeyUsage=serverAuth,clientAuth
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>此文件的详细文档</strong>: <a href="https://www.openssl.org/docs/man1.1.1/man5/" target="_blank" rel="noopener noreferrer">OpenSSL file formats and conventions</a></li>
</ul>
</li>
<li>生成证书链与服务端证书:
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 1. 生成本地 CA 根证书的私钥</span>
</span></span><span class="line"><span class="cl">openssl genrsa -out ca.key <span class="m">2048</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 2. 使用私钥签发出 CA 根证书</span>
</span></span><span class="line"><span class="cl"><span class="c1">## CA 根证书的有效期尽量设长一点，因为不方便更新换代，这里设了 100 年</span>
</span></span><span class="line"><span class="cl">openssl req -x509 -new -nodes -key ca.key -subj <span class="s2">&#34;/CN=MyLocalRootCA&#34;</span> -days <span class="m">36500</span> -out ca.crt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 3. 生成服务端证书的 RSA 私钥（2048 位）</span>
</span></span><span class="line"><span class="cl">openssl genrsa -out server.key <span class="m">2048</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 4. 通过第一步编写的配置文件，生成证书签名请求（公钥+申请者信息）</span>
</span></span><span class="line"><span class="cl">openssl req -new -key server.key -out server.csr -config csr.conf
</span></span><span class="line"><span class="cl"><span class="c1"># 5. 使用 CA 根证书直接签发服务端证书，这里指定服务端证书的有效期为 3650 天</span>
</span></span><span class="line"><span class="cl">openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  -CAcreateserial -out server.crt -days <span class="m">3650</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  -extensions v3_ext -extfile csr.conf
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>简单起见这里没有生成中间证书，直接使用根证书签发了用于安全通信的服务端证书。</p>
<h4 id="2-生成-ecc-证书链" class="headerLink">
    <a href="#2-%e7%94%9f%e6%88%90-ecc-%e8%af%81%e4%b9%a6%e9%93%be" class="header-mark"></a>2. 生成 ECC 证书链</h4><p>在上一篇文章中我们已经介绍过了，ECC 加密方案是新一代非对称加密算法，是 RSA 的继任者，在安全性相同的情况下，ECC 拥有比 RSA 更快的计算速度、更少的内存以及更短的密钥长度。</p>
<p>对于 ECC 加密方案而言，不同的椭圆曲线生成的密钥对提供了不同程度的安全性。
各个组织（ANSI X9.62、NIST、SECG）命名了多种曲线，可通过如下命名查看 openssl 支持的所有椭圆曲线名称:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">openssl ecparam -list_curves
</span></span></code></pre></td></tr></table>
</div>
</div><p>目前在 TLS 协议以及 JWT 签名算法中，目前应该最广泛的椭圆曲线仍然是 NIST 系列：</p>
<ul>
<li><code>P-256</code>: 到目前为止 P-256 应该仍然是应用最为广泛的椭圆曲线
<ul>
<li>在 openssl 中对应的名称为 <code>prime256v1</code></li>
</ul>
</li>
<li><code>P-384</code>
<ul>
<li>在 openssl 中对应的名称为 <code>secp384r1</code></li>
</ul>
</li>
<li><code>P-521</code>
<ul>
<li>在 openssl 中对应的名称为 <code>secp521r1</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>此外还有新兴的 x25519 系列，这里不多介绍了，有兴趣可自行了解。</p>
</blockquote>
<p>生成一个使用 <code>P-384</code> 曲线的 ECC 证书的示例如下:</p>
<ol>
<li>编写证书签名请求的配置文件 <code>ecc-csr.conf</code>:
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[ req ]
</span></span><span class="line"><span class="cl">prompt = no
</span></span><span class="line"><span class="cl">default_md = sha256 # 在签名算法中使用 SHA-256 计算哈希值
</span></span><span class="line"><span class="cl">req_extensions = req_ext
</span></span><span class="line"><span class="cl">distinguished_name = dn
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[ dn ]
</span></span><span class="line"><span class="cl">C = CN  # Contountry
</span></span><span class="line"><span class="cl">ST = Guangdong
</span></span><span class="line"><span class="cl">L = Shenzhen
</span></span><span class="line"><span class="cl">O = Xxx
</span></span><span class="line"><span class="cl">OU = Xxx-SRE
</span></span><span class="line"><span class="cl">CN = *.svc.local  # 泛域名，这个字段已经被 chrome/apple 弃用了。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[ alt_names ]  # 备用名称，chrome/apple 目前只信任这里面的域名。
</span></span><span class="line"><span class="cl">DNS.1 = *.svc.local  # 一级泛域名
</span></span><span class="line"><span class="cl">DNS.2 = *.aaa.svc.local  # 二级泛域名
</span></span><span class="line"><span class="cl">DNS.3 = *.bbb.svc.local  # 二级泛域名
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[ req_ext ]
</span></span><span class="line"><span class="cl">subjectAltName = @alt_names
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[ v3_ext ]
</span></span><span class="line"><span class="cl">subjectAltName=@alt_names  # Chrome 要求必须要有 subjectAltName(SAN)
</span></span><span class="line"><span class="cl">authorityKeyIdentifier=keyid,issuer:always
</span></span><span class="line"><span class="cl">basicConstraints=CA:FALSE
</span></span><span class="line"><span class="cl">keyUsage=keyEncipherment,dataEncipherment,digitalSignature
</span></span><span class="line"><span class="cl">extendedKeyUsage=serverAuth,clientAuth
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>此文件的详细文档</strong>: <a href="https://www.openssl.org/docs/man1.1.1/man5/" target="_blank" rel="noopener noreferrer">OpenSSL file formats and conventions</a></li>
</ul>
</li>
<li>生成证书链与服务端证书:
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 1. 生成本地 CA 根证书的私钥，使用 P-384 曲线，密钥长度 384 位</span>
</span></span><span class="line"><span class="cl">openssl ecparam -genkey -name secp384r1 -out ecc-ca.key
</span></span><span class="line"><span class="cl"><span class="c1"># 2. 使用私钥签发出 CA 根证书</span>
</span></span><span class="line"><span class="cl"><span class="c1">## CA 根证书的有效期尽量设长一点，因为不方便更新换代，这里设了 100 年</span>
</span></span><span class="line"><span class="cl">openssl req -x509 -new -nodes -key ecc-ca.key -subj <span class="s2">&#34;/CN=MyLocalRootCA&#34;</span> -days <span class="m">36500</span> -out ecc-ca.crt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 3. 生成服务端证书的 EC 私钥，使用 P-384 曲线，密钥长度 384 位</span>
</span></span><span class="line"><span class="cl">openssl ecparam -genkey -name secp384r1 -out ecc-server.key
</span></span><span class="line"><span class="cl"><span class="c1"># 4. 通过第一步编写的配置文件，生成证书签名请求（公钥+申请者信息）</span>
</span></span><span class="line"><span class="cl">openssl req -new -key ecc-server.key -out ecc-server.csr -config ecc-csr.conf
</span></span><span class="line"><span class="cl"><span class="c1"># 5. 使用 CA 根证书直接签发 ECC 服务端证书，这里指定服务端证书的有效期为 3650 天</span>
</span></span><span class="line"><span class="cl">openssl x509 -req -in ecc-server.csr -CA ecc-ca.crt -CAkey ecc-ca.key <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  -CAcreateserial -out ecc-server.crt -days <span class="m">3650</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  -extensions v3_ext -extfile ecc-csr.conf
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>简单起见这里没有生成中间证书，直接使用根证书签发了用于安全通信的服务端证书，而且根证书跟服务端证书都使用了 ECC 证书。
现实中由于根证书更新缓慢，几乎所有的根证书都还是 RSA 证书，而中间证书与终端实体证书的迭代要快得多，目前已经有不少网站在使用 ECC 证书了。</p>
<h3 id="6-证书的类型" class="headerLink">
    <a href="#6-%e8%af%81%e4%b9%a6%e7%9a%84%e7%b1%bb%e5%9e%8b" class="header-mark"></a>6. 证书的类型</h3><p>按照数字证书的生成方式进行分类，证书有三种类型:</p>
<ol>
<li><strong>公网受信任证书</strong> 或者叫 <strong>Web PKI 证书</strong>: 即由权威证书认证机构签名的的证书。
<ul>
<li>几乎所有终端都预装了其的根证书，因此这类证书会被浏览器、小程序等第三方应用/服务商验证并信任。</li>
<li>申请证书时需要验证你对域名/IP 的所有权，也就使证书无法伪造</li>
<li>如果你的 API 需要提供给第三方应用/服务商/用户访问，那就需要向权威 CA 机构申请此类证书</li>
</ul>
</li>
<li><strong>本地签名证书</strong>: 即由本地 CA 证书签名的 TLS 证书
<ul>
<li>本地 CA 证书，就是自己使用 <code>openssl</code> 等工具生成的 CA 证书</li>
<li>这类证书的缺点是无法与第三方应用/服务商建立安全的连接</li>
<li>如果客户端是完全可控的（比如是自家的 APP，或者是接入了域控的企业局域网设备），完全可以在所有客户端都安装上自己生成的 CA 证书。这种场景下使用此类证书是安全可靠的，可以不向权威 CA 机构申请证书</li>
</ul>
</li>
<li><strong>自签名证书</strong>: 前面介绍了根证书是一个自签名证书，它使用根证书的私钥为根证书签名
<ul>
<li>这里的「自签名证书」是指<strong>直接使用根证书进行网络通讯</strong>，缺点是证书的更新迭代会很麻烦，而且安全性低。</li>
</ul>
</li>
</ol>
<p>总的来说，权威 CA 机构颁发的「公网受信任证书」，可以被第三方应用信任，但是自己生成的不行。
而越贵的权威证书，安全性与可信度就越高，或者可以保护更多的域名。</p>
<p>在客户端可控的情况下，可以考虑自己生成证书链并签发「本地签名证书」，将本地 CA 证书预先安装在客户端中用于验证。</p>
<p>而「自签名证书」主要是方便，能不用还是尽量不要使用。</p>
<h3 id="7-向权威-ca-机构申请公网受信任证书" class="headerLink">
    <a href="#7-%e5%90%91%e6%9d%83%e5%a8%81-ca-%e6%9c%ba%e6%9e%84%e7%94%b3%e8%af%b7%e5%85%ac%e7%bd%91%e5%8f%97%e4%bf%a1%e4%bb%bb%e8%af%81%e4%b9%a6" class="header-mark"></a>7. 向权威 CA 机构申请「公网受信任证书」</h3><p>向权威机构申请的公网受信任证书，可以直接应用在边界网关上，用于给公网用户提供 TLS 加密访问服务，比如各种 HTTPS 站点、API。这是需求最广的一类数字证书服务。</p>
<p>而证书的申请与管理方式又分为两种：</p>
<ol>
<li>通过 <a href="https://en.wikipedia.org/wiki/Automatic_Certificate_Management_Environment" target="_blank" rel="noopener noreferrer">ACMEv2（Automated Certificate Management Environment (ACME) </a> 协议进行证书的自动化申请与管理。支持使用此开放协议申请证书的权威机构有：</li>
</ol>
<ul>
<li>免费服务
<ul>
<li>Let&rsquo;s Encrypt: 众所周知，它提供三个月有效期的免费证书。</li>
<li><a href="https://zerossl.com/documentation/acme/" target="_blank" rel="noopener noreferrer">ZeroSSL</a>:  貌似也是一个比较有名的 SSL 证书服务
<ul>
<li>通过 ACME 协议支持不限数量的 90 天证书，也支持多域名证书与泛域名证书。</li>
<li>它相比 Let&rsquo;s Encrypt 的优势是，它提供一个证书控制台，可以查看与管理用户当前的所有证书，了解其状态。</li>
</ul>
</li>
</ul>
</li>
<li>付费服务
<ul>
<li>DigiCert: 这个非常有名（但也是相当贵），官方文档 <a href="https://docs.digicert.com/certificate-tools/Certificate-lifecycle-automation-index/acme-user-guide/" target="_blank" rel="noopener noreferrer">Digicert - Third-party ACME client automation</a></li>
<li>Google Trust Services: Google 推出的公网证书服务，也是三个月有效期，其根证书交叉验证了 GlobalSign。官方文档 <a href="https://cloud.google.com/blog/products/identity-security/automate-public-certificate-lifecycle-management-via--acme-client-api" target="_blank" rel="noopener noreferrer">Automate Public Certificates Lifecycle Management via RFC 8555 (ACME)</a></li>
<li>Entrust: 官方文档 <a href="https://www.entrust.com/knowledgebase/ssl/how-to-use-acme-to-install-ssl-tls-certificates-in-entrust-certificate-services-apache#step1" target="_blank" rel="noopener noreferrer">Entrust&rsquo;s ACME implementation</a></li>
<li>GlobalSign: 官方文档 <a href="https://www.globalsign.com/en/acme-automated-certificate-management" target="_blank" rel="noopener noreferrer">GlobalSign ACME Service</a></li>
</ul>
</li>
<li>相关的自动化工具
<ul>
<li>很多代理工具都有提供基于 ACMEv2 协议的证书申请与自动更新，比如:
<ul>
<li><a href="/network-proxy&#43;web-server/traefik/README.md" rel="">Traefik</a></li>
<li><a href="https://github.com/caddyserver/caddy" target="_blank" rel="noopener noreferrer">Caddy</a></li>
<li><a href="https://github.com/nginx-proxy/docker-letsencrypt-nginx-proxy-companion" target="_blank" rel="noopener noreferrer">docker-letsencrypt-nginx-proxy-companion</a></li>
</ul>
</li>
<li><strong>网上也有一些 <a href="https://github.com/certbot/certbot" target="_blank" rel="noopener noreferrer">certbot</a> 插件，可以通过 DNS 提供商的 API 进行 ACMEv2 证书的申请与自动更新，比如</strong>:
<ul>
<li><a href="https://github.com/tengattack/certbot-dns-aliyun" target="_blank" rel="noopener noreferrer">certbot-dns-aliyun</a></li>
</ul>
</li>
<li><strong>terraform 也有相关 provider</strong>: <a href="https://github.com/vancluever/terraform-provider-acme" target="_blank" rel="noopener noreferrer">terraform-provider-acme</a></li>
<li><a href="https://github.com/cert-manager/cert-manager" target="_blank" rel="noopener noreferrer">cert-manager</a>: kubernetes 中的证书管理工具，支持 ACMEv2，也支持创建与管理私有证书。</li>
</ul>
</li>
</ul>
<ol>
<li>通过一些权威 CA 机构或代理商提供的 Web 网站，手动填写信息来申请与更新证书。</li>
</ol>
<ul>
<li>这个流程相对会比较繁琐。</li>
</ul>
<p>这些权威机构提供的证书服务，提供的证书又有不同的分级，这里详细介绍下三种不同的证书级别，以及该如何选用：</p>
<ul>
<li>Domain Validated（DV）证书
<ul>
<li>应用最广泛的证书类型，我接触最多的就是这种。各云厂商提供的免费 SSL 证书也都是这种类型。</li>
<li><strong>仅验证域名所有权</strong>，验证步骤最少，价格最低，仅需要数分钟即可签发。</li>
<li>优点就是易于签发，很适合做自动化。</li>
<li>各云厂商（AWS/GCP/Cloudflare，以及 Vercel/Github 的站点服务）给自家服务提供的免费证书都是 DV 证书，Let&rsquo;s Encrypt 的证书也是这个类型。
<ul>
<li>很明显这些证书的签发都非常方便，而且仅验证域名所有权。</li>
<li>但是 AWS/GCP/Cloudflare/Vercel/Github 提供的 DV 证书都仅能在它们的云服务上使用，不提供私钥导出功能！</li>
</ul>
</li>
</ul>
</li>
<li>Organization Validated (OV) 证书
<ul>
<li>（貌似我也接触地比较少，不做评价）</li>
<li>据说是企业 SSL 证书的首选，通过企业认证确保企业 SSL 证书的真实性。</li>
<li>除域名所有权外，CA 机构还会审核组织及企业的真实性，包括注册状况、联系方式、恶意软件等内容。</li>
<li>如果要做合规化，可能至少也得用 OV 这个级别的证书。</li>
</ul>
</li>
<li>Extended Validation（EV）证书
<ul>
<li>（我基本没接触过）</li>
<li>最严格的认证方式，CA 机构会深度审核组织及企业各方面的信息。</li>
<li>被认为适合用于大型企业、金融机构等组织或企业。</li>
<li>而且仅支持签发单域名、多域名证书，不支持签发泛域名证书，安全性杠杠的。</li>
</ul>
</li>
</ul>
<p>完整的证书申请流程如下:</p>
<p><figure><a class="lightgallery" href="/images/about-tls-cert/ca-sign-sechdule.webp" title="/images/about-tls-cert/ca-sign-sechdule.webp" data-thumbnail="/images/about-tls-cert/ca-sign-sechdule.webp" data-sub-html="<h2>证书申请流程</h2>">
        <img
            class="lazyload"
            data-src="/images/about-tls-cert/ca-sign-sechdule.webp"
            data-srcset="/images/about-tls-cert/ca-sign-sechdule.webp, /images/about-tls-cert/ca-sign-sechdule.webp 1.5x, /images/about-tls-cert/ca-sign-sechdule.webp 2x"
            data-sizes="auto"
            alt="/images/about-tls-cert/ca-sign-sechdule.webp">
    </a><figcaption class="image-caption">证书申请流程</figcaption>
    </figure></p>
<p>为了方便用户，图中的申请人（Applicant）自行处理的部分，目前很多证书申请网站也可以自动处理，用户只需要提供相关信息即可。</p>
<h3 id="8-证书的寿命" class="headerLink">
    <a href="#8-%e8%af%81%e4%b9%a6%e7%9a%84%e5%af%bf%e5%91%bd" class="header-mark"></a>8. 证书的寿命</h3><p>对于公开服务，服务端证书的有效期不要超过 825 天（27 个月）！
另外从 2020 年 11 月起，新申请的服务端证书有效期已经缩短到了 398 天（13 个月）。
目前 Apple/Mozilla/Chrome 都发表了相应声明，证书有效期超过上述限制的，将被浏览器/Apple设备禁止使用。</p>
<p>而对于其他用途的证书，如果更换起来很麻烦，可以考虑放宽条件。
比如 kubernetes 集群的加密证书，可以考虑有效期设长一些，比如 10 年。</p>
<p>据<a href="https://mp.weixin.qq.com/s?__biz=MzA4MTQ2MjI5OA==&amp;mid=2664079008&amp;idx=1&amp;sn=dede1114d5705880ea757f8d9ae4c92d" target="_blank" rel="noopener noreferrer">云原生安全破局｜如何管理周期越来越短的数字证书？</a>所述，大量知名企业如特斯拉/微软/领英/爱立信都曾因未及时更换 TLS 证书导致服务暂时不可用。</p>
<p>因此 TLS 证书最好是设置自动轮转！人工维护不可靠！</p>
<p>目前很多 Web 服务器/代理，都支持自动轮转 Let&rsquo;s Encrypt 证书。
另外 Vault 等安全工具，也支持自动轮转私有证书。</p>
<h3 id="9-使用-openssl-验证证书查看证书信息" class="headerLink">
    <a href="#9-%e4%bd%bf%e7%94%a8-openssl-%e9%aa%8c%e8%af%81%e8%af%81%e4%b9%a6%e6%9f%a5%e7%9c%8b%e8%af%81%e4%b9%a6%e4%bf%a1%e6%81%af" class="header-mark"></a>9. 使用 OpenSSL 验证证书、查看证书信息</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 查看证书(crt)信息</span>
</span></span><span class="line"><span class="cl">openssl x509 -noout -text -in server.crt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 查看证书请求(csr)信息</span>
</span></span><span class="line"><span class="cl">openssl req -noout -text -in server.csr
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 查看 RSA 私钥(key)信息</span>
</span></span><span class="line"><span class="cl">openssl rsa -noout -text -in server.key
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 验证证书是否可信</span>
</span></span><span class="line"><span class="cl"><span class="c1">## 1. 使用系统的证书链进行验证</span>
</span></span><span class="line"><span class="cl">openssl verify server.crt
</span></span><span class="line"><span class="cl"><span class="c1">## 2. 使用指定的 CA 证书进行验证</span>
</span></span><span class="line"><span class="cl">openssl verify -CAfile ca.crt server.crt
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="二tls-协议" class="headerLink">
    <a href="#%e4%ba%8ctls-%e5%8d%8f%e8%ae%ae" class="header-mark"></a>二、TLS 协议</h2><p>TLS 协议，中文名为「传输层安全协议」，是一个安全通信协议，被用于在网络上进行安全通信。</p>
<p>TLS 协议通常与 HTTP / FTP / SMTP 等协议一起使用以实现加密通讯，这种组合协议通常被缩写为 HTTPS / SFTP / SMTPS.</p>
<p>在讲 <a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener noreferrer">TLS 协议</a>前，还是先复习下「对称密码算法」与「非对称密码算法」两个密码体系的特点。</p>
<ul>
<li><strong>对称密码算法（如 AES/ChaCha20）</strong>: 计算速度快、安全强度高，但是缺乏安全交换密钥的手段、密钥的保存和管理也很困难</li>
<li><strong>非对称密码算法（如 RSA/ECC）</strong>: 解决了上述对称密码算法的两个缺陷——通过数字证书 + PKI 公钥基础架构实现了身份认证，再通过 DHE/ECDHE 实现了安全的对称密钥交换。</li>
</ul>
<p>但是非对称密码算法要比对称密码算法更复杂，计算速度也慢得多。
因此实际使用上通常结合使用这两种密码算法，各取其长，以实现高速且安全的网络通讯。
我们通常称结合使用对称密码算法以及非对称密码算法的加密方案为「混合加密方案」。</p>
<p>TLS 协议就是一个「混合加密方案」，它借助数字证书与 PKI 公钥基础架构、DHE/ECDHE 密钥交换协议以及对称加密方案这三者，实现了安全的加密通讯。</p>
<p>基于经典 DHKE 协议的 TLS 握手流程如下：</p>
<p><figure><a class="lightgallery" href="/images/about-tls-cert/tls-handshake.webp" title="/images/about-tls-cert/tls-handshake.webp" data-thumbnail="/images/about-tls-cert/tls-handshake.webp" data-sub-html="<h2>基于经典 DHKE 协议的 TLS 握手</h2>">
        <img
            class="lazyload"
            data-src="/images/about-tls-cert/tls-handshake.webp"
            data-srcset="/images/about-tls-cert/tls-handshake.webp, /images/about-tls-cert/tls-handshake.webp 1.5x, /images/about-tls-cert/tls-handshake.webp 2x"
            data-sizes="auto"
            alt="/images/about-tls-cert/tls-handshake.webp">
    </a><figcaption class="image-caption">基于经典 DHKE 协议的 TLS 握手</figcaption>
    </figure></p>
<p>而在支持「完美前向保密（Perfect Forward Secrecy）」的 TLS1.2 或 TLS1.3 协议中，经典 DH 协议被 ECDHE 协议取代。
变化之一是进行最初的握手协议从经典 DHKE 换成了基于 ECC 的 ECDH 协议，
变化之二是在每次通讯过程中也在不断地进行密钥交换，生成新的对称密钥供下次通讯使用，其细节参见 <a href="/posts/practical-cryptography-basics-5-key-exchange/" rel="">写给开发人员的实用密码学（五）—— 密钥交换 DHKE 与完美前向保密 PFS</a>。</p>
<p>TLS 协议通过应用 ECDHE 密钥交换协议，提供了「完美前向保密（Perfect Forward Secrecy）」特性，也就是说它能够保护过去进行的通讯不受密钥在未来暴露的威胁。
即使攻击者破解出了一个「对称密钥」，也只能获取到一次事务中的数据，其他事务的数据安全性完全不受影响。</p>
<p>另外注意一点是，CA 证书和服务端证书都只在 TLS 协议握手的前三个步骤中有用到，之后的通信就与它们无关了。</p>
<h3 id="1-密码套件与-tls-历史版本" class="headerLink">
    <a href="#1-%e5%af%86%e7%a0%81%e5%a5%97%e4%bb%b6%e4%b8%8e-tls-%e5%8e%86%e5%8f%b2%e7%89%88%e6%9c%ac" class="header-mark"></a>1. 密码套件与 TLS 历史版本</h3><p><a href="https://en.wikipedia.org/wiki/Cipher_suite" target="_blank" rel="noopener noreferrer">密码套件（Cipher_suite）</a>是 TLS 协议中一组用于实现安全通讯的密码学算法，类似于我们前面学习过的加密方案。
不同密码学算法的组合形成不同的密码套件，算法组合的差异使这些密码套件具有不同的性能与安全性，另外 TLS 协议的更新迭代也导致各密码套件拥有不同的兼容性。
通常越新推出的密码套件的安全性越高，但是兼容性就越差（旧设备不支持）。</p>
<p>密码套件的名称由它使用的各种密码学算法名称组成，而且有固定的格式，以 <code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code> 为例介绍下：</p>
<ul>
<li><code>TLS</code>: 定义了此套件适用的协议，通常固定为 <code>TLS</code></li>
<li><code>ECDHE</code>: 密钥交换算法</li>
<li><code>RSA</code>: 数字证书认证算法</li>
<li><code>AES_128_GCM</code>: 使用的对称加密方案，这是一个基于 AES 与 GCM 模式的对称认证加密方案，使用 128 位密钥</li>
<li><code>SHA256</code>: 哈希函数，用于 HMAC 算法实现消息认证
<ul>
<li>TLS 固定使用 HMAC 算法进行消息认证</li>
</ul>
</li>
</ul>
<p>TLS 协议的前身是 SSL 协议，TLS/SSL 的发展历程展示如下：</p>
<figure><img src="/images/about-tls-cert/history-of-ssl-tls.webp"/><figcaption>
            <h4>SSL/TLS 的历史版本</h4>
        </figcaption>
</figure>

<p>SSL 协议早在 2015 年就被各大主流浏览器废除了，TLS1.0 感觉也基本没站点在用了，这俩就直接跳过了。</p>
<p>下面分别介绍下 TLS1.1 TLS1.2 与 TLS1.3.</p>
<h4 id="tls-11" class="headerLink">
    <a href="#tls-11" class="header-mark"></a>TLS 1.1</h4><p>TLS 1.1 在 RFC4346 中定义，于 2006 年 4 月发布。</p>
<p>TLS 1.1 是 TLS 1.0 的一个补丁，主要更新包括：</p>
<ul>
<li>添加对CBC攻击的保护
<ul>
<li>隐式初始向量 IV 被替换成一个显式的 IV</li>
<li>修复分组密码模式中填充算法的 bug</li>
</ul>
</li>
<li>支持 IANA 登记的参数</li>
</ul>
<p><strong>TLS 1.1</strong>及其之前的算法曾经被广泛应用，它目前已知的缺陷如下：</p>
<ul>
<li>不支持 PFS 完全前向保密</li>
<li>不支持 AEAD 认证加密算法</li>
<li>为了兼容性，保留了很多不安全的算法</li>
</ul>
<p>TLS 1.1 已经不够安全了，不过一些陈年老站点或许还在使用它。</p>
<p>各操作系统（Android/IOS/MacOS/Windows）与浏览器基本都在很早的版本中就已经支持 TLS1.2+ 了，站在 2022 年这个时间节点看，我们已经可以完全废止 TLS1.1 协议。
实际上各大云厂商也是这么干的，比如 AWS 自身的 API 对 TLS1.1 的支持就已确定将在 2023 年 6 月废止，2022 年就开始频繁扫描并提醒各位仍然在使用低版本 TLS 协议的客户升级。</p>
<h4 id="tls-12" class="headerLink">
    <a href="#tls-12" class="header-mark"></a>TLS 1.2</h4><p>TLS 1.2 在 RFC5246 中定义，于 2008 年 8 月发发布。</p>
<ul>
<li>可选支持 PFS 完全前向保密</li>
<li>移除对 MD5 与 SHA-1 签名算法的支持</li>
<li>添加对 HMAC-SHA-256 及 HMAC-SHA-384 消息认证算法的支持</li>
<li>添加对 AEAD 加密认证方案的支持</li>
<li>去除 forback 回到 SSL 协议的能力，提升安全性</li>
<li>为了兼容性，保留了很多不安全的算法</li>
</ul>
<p>如果你使用 TLS 1.2，需要小心地选择密码套件，避开不安全的套件，就能实现足够高的安全性。</p>
<h4 id="tls-13" class="headerLink">
    <a href="#tls-13" class="header-mark"></a>TLS 1.3</h4><p><a href="https://blog.cloudflare.com/rfc-8446-aka-tls-1-3/" target="_blank" rel="noopener noreferrer">TLS 1.3</a> 做了一次大刀阔斧的更新，是一个里程碑式的版本，其更新总结如下：</p>
<ul>
<li>移除对如下算法的支持
<ul>
<li>哈希函数 SHA1/MD5</li>
<li>所有非 AEAD 加密认证的密码方案（CBC 模式）</li>
<li>移除对 RC4 与 3DES 加密算法的支持</li>
<li>移除了静态 RSA 与 DH 密钥交换算法</li>
</ul>
</li>
<li>支持高性能的 Ed25519/Ed448 签名认证算法、X25519 密钥协商算法</li>
<li>支持高性能的 ChaCha20-Poly1305 对称认证加密方案</li>
<li>将密钥交换算法与公钥认证算法从密码套件中分离出来
<ul>
<li>比如原来的 <code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code> 密码套件将被拆分为 <code>ECDHE</code> 算法、<code>RSA</code> 身份认证算法、以及 <code>TLS_AES_128_GCM_SHA256</code> 密码套件</li>
<li>这样密码套件就只包含一个 AEAD 认证加密方案，以及一个哈希函数了</li>
</ul>
</li>
<li>仅支持前向安全的密钥交换算法 DHE 或 ECDHE</li>
<li>支持最短 0-RTT 的 TLS 握手（会话恢复）</li>
</ul>
<p>TLS 1.3 从协议中删除了所有不安全的算法或协议，可以说只要你的通讯用了 TLS 1.3，那你的数据就安全了（当然前提是你的私钥没泄漏）。</p>
<h4 id="如何设置-tls-协议的版本密码套件参数" class="headerLink">
    <a href="#%e5%a6%82%e4%bd%95%e8%ae%be%e7%bd%ae-tls-%e5%8d%8f%e8%ae%ae%e7%9a%84%e7%89%88%e6%9c%ac%e5%af%86%e7%a0%81%e5%a5%97%e4%bb%b6%e5%8f%82%e6%95%b0" class="header-mark"></a>如何设置 TLS 协议的版本、密码套件参数</h4><p>我们前面已经学习了对称加密、非对称加密、密钥交换三部分知识，对照 TLS 套件的名称，应该能很容易判断出哪些是安全的、哪些不够安全，哪些支持前向保密、哪些不支持。</p>
<p>一个非常好用的「站点 HTTPS 安全检测」网站是 <a href="https://myssl.com/" target="_blank" rel="noopener noreferrer">https://myssl.com/</a>，使用它测试知乎网的检测结果如下：</p>
<figure><img src="/images/about-tls-cert/tls-cipher.webp"/><figcaption>
            <h4>SSL/TLS 的历史版本</h4>
        </figcaption>
</figure>

<p>能看到知乎为了兼容性，目前仍然支持 TLS1.0 与 TLS1.1，另外目前还不支持 TLS1.3.</p>
<p>此外，知乎仍然支持很多已经不安全的加密套件，myssl.com 专门使用黄色标识出了这些不安全的加密套件，我们总结下主要特征：</p>
<ul>
<li>部分密码套件使用了不安全的对称加密算法 <code>3DES</code></li>
<li>其他被标识为黄色的套件虽然使用了安全的对称加密算法，但是不支持 PFS 前向保密</li>
</ul>
<p>此外 myssl.com 还列出了许多站点更详细的信息，包括 TLS1.3 的会话恢复，以及后面将会介绍的公钥固定、HTTP严格传输安全等信息：</p>
<figure><img src="/images/about-tls-cert/other-https-info.webp"/><figcaption>
            <h4>SSL/TLS 的历史版本</h4>
        </figcaption>
</figure>

<h5 id="nginx-的-tls-协议配置" class="headerLink">
    <a href="#nginx-%e7%9a%84-tls-%e5%8d%8f%e8%ae%ae%e9%85%8d%e7%bd%ae" class="header-mark"></a>Nginx 的 TLS 协议配置</h5><p>以前为 Nginx 等程序配置 HTTPS 协议时，我最头疼的就是其中密码套件参数 <code>ssl_ciphers</code>，为了安全性，需要配置超长的一大堆选用的密码套件名称，我可以说一个都看不懂，但是为了把网站搞好还是得硬着头皮搜索复制粘贴，实际上也不清楚安全性到底如何。</p>
<p>为了解决这个问题，Mozilla/DigitalOcean 都搞过流行 Web 服务器的 TLS 配置生成工具，比如 <strong><a href="https://ssl-config.mozilla.org/#server=nginx" target="_blank" rel="noopener noreferrer">ssl-config - mozilla</a>，这个网站提供三个安全等级的配置</strong>:</p>
<ol>
<li>「Intermediate」: 查看生成出的 <code>ssl-cipher</code> 属性，发现它只支持 <code>ECDHE</code>/<code>DHE</code> 开头的算法。因此它保证前向保密。
<ul>
<li>对于需要通过浏览器访问的 API，推荐选择这个等级。</li>
</ul>
</li>
<li>「Mordern」: 只支持 <code>TLSv1.3</code>，该协议废弃掉了过往所有不安全的算法，保证前向保密，安全性极高，性能也更好。
<ul>
<li>对于不需要通过浏览器等旧终端访问的 API，请直接选择这个等级。</li>
</ul>
</li>
<li>「Old」: 除非你的用户使用非常老的终端进行访问，否则请不要考虑这个选项！</li>
</ol>
<p>可以点进去查看详细的 TLS 套件配置。</p>
<h4 id="ocsp-证书验证协议" class="headerLink">
    <a href="#ocsp-%e8%af%81%e4%b9%a6%e9%aa%8c%e8%af%81%e5%8d%8f%e8%ae%ae" class="header-mark"></a>OCSP 证书验证协议</h4><blockquote>
<p><a href="https://www.ssl.com/blogs/how-do-browsers-handle-revoked-ssl-tls-certificates/" target="_blank" rel="noopener noreferrer">https://www.ssl.com/blogs/how-do-browsers-handle-revoked-ssl-tls-certificates/</a></p>
</blockquote>
<blockquote>
<p><a href="https://imququ.com/post/why-can-not-turn-on-ocsp-stapling.html" target="_blank" rel="noopener noreferrer">https://imququ.com/post/why-can-not-turn-on-ocsp-stapling.html</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.digicert.com/help/" target="_blank" rel="noopener noreferrer">https://www.digicert.com/help/</a></p>
</blockquote>
<p>前面提到除了数字证书自带的有效期外，为了在私钥泄漏的情况下，能够吊销对应的证书，PKI 公钥基础设施还提供了 OCSP（Online Certificate Status Protocol）证书状态查询协议。</p>
<p>可以使用如下命令测试，确认站点是否启用了 ocsp stapling:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ openssl s_client -connect www.digicert.com:443 -servername www.digicert.com -status -tlsextdebug &lt; /dev/null 2&gt;&amp;1 | grep -i &#34;OCSP response&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果输出包含 <code>OCSP Response Status: successful</code> 就说明站点支持 ocsp stapling，
如果输出内容为 <code>OCSP response: no response sent</code> 则说明站点不支持ocsp stapling。</p>
<blockquote>
<p>实际上 Google/AWS 等大多数站点都不会启用也不需要启用 ocsp stapling，一是因为它们自己就是证书颁发机构，OCSP 服务器也归它们自己管，不存在隐私的问题。二是它们的 OCSP 服务器遍布全球，也不存在性能问题。
这种情况下开个 OCSP Stapling 反而是浪费流量，因为每次 TLS 握手都得发送一个 OCSP 状态信息。</p>
</blockquote>
<blockquote>
<p>我测试发现只有 <a href="https://www.digicert.com/www.douban.com" target="_blank" rel="noopener noreferrer">www.digicert.com/www.douban.com</a> 等少数站点启用了 ocsp stapling，www.baidu.com/www.google.com/www.zhihu.com 都未启用 ocsp stapling.</p>
</blockquote>
<p>这导致了一些问题：</p>
<ul>
<li>Chrome/Firefox 等浏览器都会定期通过 OCSP 协议去请求 CA 机构的 OCSP 服务器验证证书状态，这可能会拖慢 HTTPS 协议的响应速度。
<ul>
<li>所谓的定期是指超过上一个 OCSP 响应的 <code>nextUpdate</code> 时间（一般为 7 天），或者如果该值为空的话，Firefox 默认 24h 后会重新查询 OCSP 状态。</li>
</ul>
</li>
<li>因为客户端直接去请求 CA 机构的 OCSP 地址获取证书状态，这就导致 CA 机构可以获取到一些对应站点的用户信息（IP 地址、网络状态等）。</li>
<li>如果因为某些原因导致客户端无法访问 OCSP 服务器，会导致站点的初次访问时间用时变得很长。因为浏览器会每隔一阵时间就重新尝试去访问 OCSP 服务器！
<ul>
<li>一个典型的例子就是 <a href="https://www.hawu.me/operation/2129" target="_blank" rel="noopener noreferrer">提高https载入速度，记一次nginx升级优化</a>，因为 Let&rsquo;s Encrypt 的 OCSP 服务器被 GFW 屏蔽，导致国内使用该证书的站点首次访问速度非常慢。</li>
</ul>
</li>
</ul>
<p>为了解决这两个问题，<a href="https://www.rfc-editor.org/rfc/rfc6066" target="_blank" rel="noopener noreferrer">rfc6066</a> 定义了 OCSP stapling 功能，它使服务器可以提前访问 OCSP 获取证书状态信息并缓存到本地。</p>
<p>在客户端使用 TLS 协议访问 HTTPS 服务时，服务端会直接在握手阶段将缓存的 OCSP 信息发送给客户端。
因为 OCSP 信息会带有 CA 证书的签名及有效期，客户端可以直接通过签名验证 OCSP 信息的真实性与有效性，这样就避免了客户端访问 OCSP 服务器带来的开销。</p>
<p>对于 Let&rsquo;s Encrypt 的 OCSP 服务器被 GFW 屏蔽这样的场景，开不开 OCSP Stapling 对站点访问速度的影响就会变得非常地大！</p>
<h4 id="alpn-应用层协议协商" class="headerLink">
    <a href="#alpn-%e5%ba%94%e7%94%a8%e5%b1%82%e5%8d%8f%e8%ae%ae%e5%8d%8f%e5%95%86" class="header-mark"></a>ALPN 应用层协议协商</h4><blockquote>
<p><a href="https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation</a></p>
</blockquote>
<blockquote>
<p><a href="https://imququ.com/post/enable-alpn-asap.html" target="_blank" rel="noopener noreferrer">https://imququ.com/post/enable-alpn-asap.html</a></p>
</blockquote>
<p>TODO</p>
<h3 id="2-mtls-双向认证" class="headerLink">
    <a href="#2-mtls-%e5%8f%8c%e5%90%91%e8%ae%a4%e8%af%81" class="header-mark"></a>2. mTLS 双向认证</h3><p>TLS 协议（tls1.0+，RFC: <a href="https://tools.ietf.org/html/rfc5246#section-7.4.4" target="_blank" rel="noopener noreferrer">TLS1.2 - RFC5246</a>）也定义了可选的服务端请求验证客户端证书的方法。这
个方法是可选的。如果使用上这个方法，那客户端和服务端就会在 TLS 协议的握手阶段进行互相认证。这种验证方式被称为双向 TLS 认证(mTLS, mutual TLS)。</p>
<p>传统的「TLS 单向认证」技术，只在客户端去验证服务端是否可信。
而「TLS 双向认证（mTLS）」，则添加了服务端验证客户端是否可信的步骤（第三步）:</p>
<ol>
<li>客户端发起请求</li>
<li>「验证服务端是否可信」: 服务端将自己的 TLS 证书发送给客户端，客户端通过自己的 CA 证书链验证这个服务端证书。</li>
<li>「验证客户端是否可信」: 客户端将自己的 TLS 证书发送给服务端，服务端使用它的 CA 证书链验证该客户端证书。</li>
<li>协商对称加密算法及密钥</li>
<li>使用对称加密进行后续通信。</li>
</ol>
<p>因为相比传统的 TLS，mTLS 只是添加了「验证客户端」这样一个步骤，所以这项技术也被称为「Client Authetication」.</p>
<p>mTLS 需要用到两套 TLS 证书:</p>
<ol>
<li>服务端证书: 这个证书的内容以及申请流程，前面介绍过了。</li>
<li>客户端证书: 客户端证书貌似对证书信息（如 CN/SAN 域名）没有任何要求，只要证书能通过服务端的 CA 签名验证就行。</li>
</ol>
<p>使用 openssl 生成 TLS 客户端证书（ca 和 csr.conf 可以直接使用前面生成服务端证书用到的，也可以另外生成）:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 1. 生成 2048 位 的 RSA 密钥</span>
</span></span><span class="line"><span class="cl">openssl genrsa -out client.key <span class="m">2048</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 2. 通过第一步编写的配置文件，生成证书签名请求</span>
</span></span><span class="line"><span class="cl">openssl req -new -key client.key -out client.csr -config csr.conf
</span></span><span class="line"><span class="cl"><span class="c1"># 3. 生成最终的证书，这里指定证书有效期 3650 天</span>
</span></span><span class="line"><span class="cl"><span class="c1">### 使用前面生成的 ca 证书对客户端证书进行签名（客户端和服务端共用 ca 证书）</span>
</span></span><span class="line"><span class="cl">openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>   -CAcreateserial -out client.crt -days <span class="m">3650</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>   -extensions v3_ext -extfile csr.conf
</span></span></code></pre></td></tr></table>
</div>
</div><p>mTLS 的应用场景主要在「零信任网络架构」，或者叫「无边界网络」中。
比如微服务之间的互相访问，就可以使用 mTLS。
这样就能保证每个 RPC 调用的客户端，都是其他微服务（或者别的可信方），防止黑客入侵后为所欲为。</p>
<p>目前查到如下几个Web服务器/代理支持 mTLS:</p>
<ol>
<li>Traefik: <a href="https://docs.traefik.io/v2.0/https/tls/#client-authentication-mtls" target="_blank" rel="noopener noreferrer">Docs - Client Authentication (mTLS)</a></li>
<li>Nginx: <a href="https://community.openhab.org/t/using-nginx-reverse-proxy-for-client-certificate-authentication-start-discussion/43064" target="_blank" rel="noopener noreferrer">Using NGINX Reverse Proxy for client certificate authentication</a>
<ol>
<li>主要参数是两个: <code>ssl_client_certificate /etc/nginx/client-ca.pem</code> 和 <code>ssl_verify_client on</code></li>
</ol>
</li>
</ol>
<h4 id="mtls-的安全性" class="headerLink">
    <a href="#mtls-%e7%9a%84%e5%ae%89%e5%85%a8%e6%80%a7" class="header-mark"></a>mTLS 的安全性</h4><p>如果将 mTLS 用在 App 安全上，存在的风险是:</p>
<ol>
<li>客户端中隐藏的证书是否可以被提取出来，或者黑客能否 Hook 进 App 中，直接使用证书发送信息。</li>
<li>如果客户端私钥设置了「密码（passphrase）」，那这个密码是否能很容易被逆向出来？</li>
</ol>
<p>mTLS 和「公钥锁定/证书锁定」对比:</p>
<ol>
<li>公钥锁定/证书锁定: 只在客户端进行验证。
<ol>
<li>但是在服务端没有进行验证。这样就无法鉴别并拒绝第三方应用（爬虫）的请求。</li>
<li>加强安全的方法，是通过某种算法生成动态的签名。爬虫生成不出来这个签名，请求就被拒绝。</li>
</ol>
</li>
<li>mTLS: 服务端和客户端都要验证对方。
<ol>
<li>保证双边可信，在客户端证书不被破解的情况下，就能 Ban 掉所有的爬虫或代理技术。</li>
</ol>
</li>
</ol>
<h3 id="3-其他加密通讯协议" class="headerLink">
    <a href="#3-%e5%85%b6%e4%bb%96%e5%8a%a0%e5%af%86%e9%80%9a%e8%ae%af%e5%8d%8f%e8%ae%ae" class="header-mark"></a>3. 其他加密通讯协议</h3><h4 id="ssh-协议" class="headerLink">
    <a href="#ssh-%e5%8d%8f%e8%ae%ae" class="header-mark"></a>SSH 协议</h4><p>首先最容易想到的应该就是是 SSH 协议（Secure SHell protocol）。SSH 与 TLS 一样都能提供加密通讯，是 PKI 公钥基础设施的早期先驱者之一。</p>
<p>SSH 协议应用最广泛的实现是 OpenSSH，它使用 SSH Key 而非数字证书进行身份认证，这主要是因为 OpenSSH 仅用于用户与主机之间的安全通信，不需要记录 X.509 这么繁多的信息。</p>
<p>我们来手动生成个 OpenSSH ed25519 密钥对试试（RSA 的生成命令完全类似）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">❯ ssh-keygen -t ed25519
</span></span><span class="line"><span class="cl">Generating public/private ed25519 key pair.
</span></span><span class="line"><span class="cl">Enter file in which to save the key <span class="o">(</span>/Users/admin/.ssh/id_ed25519<span class="o">)</span>: ed25519-key
</span></span><span class="line"><span class="cl">Enter passphrase <span class="o">(</span>empty <span class="k">for</span> no passphrase<span class="o">)</span>: 
</span></span><span class="line"><span class="cl">Enter same passphrase again: 
</span></span><span class="line"><span class="cl">Your identification has been saved in ed25519-key.
</span></span><span class="line"><span class="cl">Your public key has been saved in ed25519-key.pub.
</span></span><span class="line"><span class="cl">The key fingerprint is:
</span></span><span class="line"><span class="cl">SHA256:jgeuWVflhNXXrDDzUtW6ZV1lpBWNAj0Rstizh9Lbyg0 admin@ryan-MacBook-Pro.local
</span></span><span class="line"><span class="cl">The key<span class="err">&#39;</span>s randomart image is:
</span></span><span class="line"><span class="cl">+--<span class="o">[</span>ED25519 256<span class="o">]</span>--+
</span></span><span class="line"><span class="cl"><span class="p">|</span>          oo++ *%<span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span>         <span class="nv">o</span> <span class="o">=</span>B ++B<span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span>        . <span class="o">=</span> oO.+o<span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span>         . B. + +<span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span>      . <span class="nv">S</span> <span class="o">=</span> o. + <span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span>     . + o +  .  <span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span>      + + E .    <span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span>     + o . +     <span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span>    o     o .    <span class="p">|</span>
</span></span><span class="line"><span class="cl">+----<span class="o">[</span>SHA256<span class="o">]</span>-----+
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">❯ cat ed25519-key    
</span></span><span class="line"><span class="cl">-----BEGIN OPENSSH PRIVATE KEY-----
</span></span><span class="line"><span class="cl">b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW
</span></span><span class="line"><span class="cl">QyNTUxOQAAACDux4KnrKXVs4iR9mPZnSpur5207ceyMiZP+CDnXdooMQAAAKDnHOSY5xzk
</span></span><span class="line"><span class="cl">mAAAAAtzc2gtZWQyNTUxOQAAACDux4KnrKXVs4iR9mPZnSpur5207ceyMiZP+CDnXdooMQ
</span></span><span class="line"><span class="cl">AAAEADkVL1gZHAvBx4M5+UjVVL7ltVOC4r9tdR23CoI9iV1O7HgqespdWziJH2Y9mdKm6v
</span></span><span class="line"><span class="cl">nbTtx7IyJk/4IOdd2igxAAAAHGFkbWluQHJ5YW4tTWFjQm9vay1Qcm8ubG9jYWwB
</span></span><span class="line"><span class="cl">-----END OPENSSH PRIVATE KEY-----
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">❯ cat ed25519-key.pub 
</span></span><span class="line"><span class="cl">ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIO7HgqespdWziJH2Y9mdKm6vnbTtx7IyJk/4IOdd2igx admin@ryan-MacBook-Pro.local
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到 SSH Key 的结构非常简单，仅包含如下三个部分：</p>
<ul>
<li>密钥对类型: 最常见的是 <code>ssh-rsa</code>，另外由于安全性目前更推荐使用 <code>ssh-ed25519</code></li>
<li>公钥的 Base64 字符串</li>
<li>一个 Comment，通常包含这个 Key 的用途，或者 Key 所有者的邮箱地址</li>
</ul>
<p>通过我们前面学的非对称密码学知识可以知道，公钥能直接从私钥生成，假设你的 ssh 公钥丢失，可以通过如下命令重新生成出公钥：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ssh-keygen -y -f xxx_rsa &gt; xxx_rsa.pub
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="http3-与-quic-协议" class="headerLink">
    <a href="#http3-%e4%b8%8e-quic-%e5%8d%8f%e8%ae%ae" class="header-mark"></a>HTTP/3 与 QUIC 协议</h4><p><a href="https://github.com/quicwg" target="_blank" rel="noopener noreferrer">QUIC 协议</a>，是 Google 研发并推动标准化的 TCP 协议的替代品， QUIC 是基于 UDP 协议实现的。基于 QUIC 提出的 HTTP over QUIC 协议已被标准化为 <a href="https://www.rfc-editor.org/rfc/rfc9114.html" target="_blank" rel="noopener noreferrer">RFC 9114 - HTTP/3</a>，它做了很多大刀阔斧的改革：</p>
<ul>
<li>传输层协议从 TCP 改成了 UDP，QUIC 自己实现的数据的可靠传输、按序到达、拥塞控制
<ul>
<li>也就是说 QUIC 绕过了陈旧的内核 TCP 协议实现，直接在用户空间实现了这些功能</li>
<li>通过另起炉灶，它解决了一些 TCP 协议的痛点：队头阻塞、握手延迟高、特性迭代慢、拥塞控制算法不佳等问题</li>
</ul>
</li>
<li>在 TLS1.3 出现之前，QUIC 实现了自己的加密方案 <a href="https://docs.google.com/document/d/1g5nIXAIkN_Y-7XJW5K45IblHd_L2f5LTaDUDwvZ5L6g/edit" target="_blank" rel="noopener noreferrer">QUIC Crypto</a> 以取代陈旧的 TLS 协议，同时兼容现有的数字证书体系
<ul>
<li>QUIC Crypto 的特点是它直接在应用层进行加密通讯的握手，并且恢复通信时可以通过缓存实现 0RTT 握手</li>
<li>也就说 QUIC 通过另起炉灶，解决了 TLS 的安全问题，以及握手延迟高的问题</li>
</ul>
</li>
</ul>
<p>总结一下就是，旧的实验性 HTTP-over-QUIC 协议，重新实现了 HTTP+TLS+TCP 三种协议并将它们整合到一起，这带来了极佳的性能，但也使它变得非常复杂。</p>
<p>QUIC 的 0RTT 握手是一个非常妙的想法，可以显著降低握手时延，TLS1.3 的设计者们将它纳入了 TLS1.3 标准中。</p>
<p>由于 TLS1.3 的良好特性，在 TLS1.3 协议发布后，新的 QUIC 标准 <a href="https://datatracker.ietf.org/doc/html/rfc9001" target="_blank" rel="noopener noreferrer">RFC 9001</a> 已经使用 TLS1.3 取代了实验阶段使用的 QUIC Crypto 加密方案，目前只有 Chromium/Chrome 仍然支持 QUIC Crypto，其他 QUIC 实现基本都只支持 TLS1.3, 详见 <a href="https://github.com/quicwg/base-drafts/wiki/Implementations" target="_blank" rel="noopener noreferrer">QUIC Implementations</a>.</p>
<h3 id="4-tls-协议攻防战" class="headerLink">
    <a href="#4-tls-%e5%8d%8f%e8%ae%ae%e6%94%bb%e9%98%b2%e6%88%98" class="header-mark"></a>4. TLS 协议攻防战</h3><h4 id="1-证书锁定certifacte-pining技术" class="headerLink">
    <a href="#1-%e8%af%81%e4%b9%a6%e9%94%81%e5%ae%9acertifacte-pining%e6%8a%80%e6%9c%af" class="header-mark"></a>1. 证书锁定（Certifacte Pining）技术</h4><p>即使使用了 TLS 协议对流量进行加密，并且保证了前向保密，也无法保证流量不被代理！</p>
<p>这是因为客户端大多是直接依靠了操作系统内置的 CA 证书库进行证书验证，而 Fiddler 等代理工具可以将自己的 CA 证书添加到该证书库中。</p>
<p>为了防止流量被 Fiddler 等工具使用上述方式监听流量，出现了「证书锁定（Certifacte Pining, 或者 SSL Pinning）」技术。
方法是在客户端中硬编码证书的指纹（Hash值，或者直接保存整个证书的内容也行），在建立 TLS 连接前，先计算使用的证书的指纹是否匹配，否则就中断连接。</p>
<p>这种锁定方式需要以下几个前提才能确保流量不被监听:</p>
<ol>
<li>客户端中硬编码的证书指纹不会被篡改。</li>
<li>指纹验证不能被绕过。
<ol>
<li>目前有公开技术（XPosed+JustTrustMe）能破解 Android 上常见的 HTTPS 请求库，直接绕过证书检查。</li>
<li>针对上述问题，可以考虑加大绕过的难度。或者 App 检测自己是否运行在 Xposed 等虚拟环境下。</li>
</ol>
</li>
<li>用于 TLS 协议的证书不会频繁更换。（如果更换了，指纹就对不上了。）</li>
</ol>
<p>而对于第三方的 API，因为我们不知道它们会不会更换 TLS 证书，就不能直接将证书指纹硬编码在客户端中。
这时可以考虑从服务端获取这些 API 的证书指纹（附带私钥签名用于防伪造）。</p>
<p>为了实现证书的轮转(rotation)，可以在新版本的客户端中包含多个证书指纹，这样能保证同时有多个可信证书，达成证书的轮转。（类比 JWT 的公钥轮转机制）</p>
<blockquote>
<p>证书锁定技术几乎等同于 SSH 协议的 <code>StrictHostKeyChecking</code> 选项，客户端会验证服务端的公钥指纹（key fingerprint），验证不通过则断开连接。</p>
</blockquote>
<h4 id="2-公钥锁定public-key-pining技术" class="headerLink">
    <a href="#2-%e5%85%ac%e9%92%a5%e9%94%81%e5%ae%9apublic-key-pining%e6%8a%80%e6%9c%af" class="header-mark"></a>2. 公钥锁定（Public Key Pining）技术</h4><p>前面介绍过证书的结构，它其实包含了公钥、有效期与一系列的其他信息。
使用了证书锁定技术，会导致证书的有效期也被锁定，APK 内的证书指纹就必须随着证书一起更新。</p>
<p>更好的做法是仅锁定证书中的公钥，即「公钥锁定」技术。
「公钥锁定」比「证书锁定」更灵活，这样证书本身其实就可以直接轮转了（证书有过期时间），而不需要一个旧证书和新证书共存的中间时期。</p>
<p><strong>「公钥锁定」是更推荐的锁定技术</strong>。</p>
<h4 id="3-https-严格传输安全---hsts" class="headerLink">
    <a href="#3-https-%e4%b8%a5%e6%a0%bc%e4%bc%a0%e8%be%93%e5%ae%89%e5%85%a8---hsts" class="header-mark"></a>3. HTTPS 严格传输安全 - HSTS</h4><p>HSTS，即 HTTP Strict Transport Security，是一项安全技术，它允许服务端在返回 HTTPS 响应时，通过 Headers 明确要求客户端，在之后的一段时间内必须使用安全的 HTTPS 协议访问服务端。</p>
<p>举个例子，假设站点 <code>https://example.com/</code> 的响应头中有 <code>Strict-Transport-Security: max-age=31536000; includeSubDomains</code>，这表示服务端要求客户端（比如浏览器）：</p>
<ul>
<li>在接下来的 31536000 秒（即一年）中，客户端向 example.com 或<strong>其子域名</strong>发送 HTTP 请求时，必须采用HTTPS来发起连接。
<ul>
<li>比如用户在浏览器地址栏输入 <code>http://example.com/</code> 时，浏览器应自动将 http 改写为 https 再发起请求</li>
</ul>
</li>
<li>在接下来的 31536000 秒（即一年）中，如果 example.com 服务器提供的证书无效，用户不能忽略浏览器的证书警告继续访问网站。
<ul>
<li>也就是说一旦证书失效，站点将完全无法访问，直至服务端修复证书问题。</li>
<li>一旦证书失效，HTTPS 其实就不是严格安全的了，可能会遭遇中间人攻击。也就是说 HSTS 通过牺牲站点的可访问性来避免中间人攻击。</li>
</ul>
</li>
</ul>
<h4 id="4-tls-协议的逆向手段" class="headerLink">
    <a href="#4-tls-%e5%8d%8f%e8%ae%ae%e7%9a%84%e9%80%86%e5%90%91%e6%89%8b%e6%ae%b5" class="header-mark"></a>4. TLS 协议的逆向手段</h4><p>要获取一个应用的 HTTPS 数据，有两个方向:</p>
<ol>
<li>服务端入侵: 现代应用的服务端突破难度通常都比较客户端高，注入等漏洞底层框架就有处理。
<ol>
<li>不过如果你获得了服务器 root 权限，可以在 openssl 上做文章，比如篡改 openssl？</li>
</ol>
</li>
<li>客户端逆向+爬虫: 客户端是离用户最近的地方，也是最容易被突破的地方。
<ol>
<li>mTLS 常见的破解手段，是找到老版本的安装包，发现很容易就能提取出客户端证书。。</li>
</ol>
</li>
</ol>
<blockquote>
<p>wiki 列出了一些 TLS 协议的安全问题：https://en.wikipedia.org/wiki/Transport_Layer_Security#Security</p>
</blockquote>
<p>TO BE DONE&hellip;</p>
<h3 id="5-在边缘侧卸载-tls" class="headerLink">
    <a href="#5-%e5%9c%a8%e8%be%b9%e7%bc%98%e4%be%a7%e5%8d%b8%e8%bd%bd-tls" class="header-mark"></a>5. 在边缘侧卸载 TLS</h3><p>TLS 加密是一个安全协议，工程上虽然有 Google 等公司力推所谓「零信任加密」方案，在所有通信场景下都应用 mTLS 等加密技术。
但是为了成本与性能考量，绝大部分公司都选择仅在公网使用 HTTPS，在可信内网场景下使用纯 HTTP。其做法就是在边缘网关层卸载 TLS 协议，再将内部的 HTTP 请求负载均衡到后端服务上。</p>
<p>所谓卸载 TLS 协议，就是指它对外提供 TLS 协议端口，但是使用 HTTP 等裸协议与上游服务通信。</p>
<p>在边缘侧卸载 HTTPS 的好处主要有：</p>
<ul>
<li>内网环境都使用了纯 HTTP，性能更好，延迟更低，成本更低。</li>
<li>参见 <a href="https://0xffff.one/d/968-yi-pian-jiang-tls-de-hao-wen-fen" target="_blank" rel="noopener noreferrer">一篇讲 TLS 的好文分享</a>，如果通过 CDN 在边缘节点卸载 TLS，然后使用纯 HTTP 回源，能显著降低请求延迟。
<ul>
<li>我本人就于 2022 年，在 AWS 上通过这个手段优化了一波广告业务 API 的延迟，广告收益有明显上涨。</li>
</ul>
</li>
</ul>
<h2 id="三参考" class="headerLink">
    <a href="#%e4%b8%89%e5%8f%82%e8%80%83" class="header-mark"></a>三、参考</h2><ul>
<li>
<p><a href="https://halfrost.com/https_tls1-2_handshake/" target="_blank" rel="noopener noreferrer">HTTPS 温故知新（三） —— 直观感受 TLS 握手流程(上)</a></p>
</li>
<li>
<p><a href="https://halfrost.com/https-key-cipher/" target="_blank" rel="noopener noreferrer">HTTPS 温故知新（五） —— TLS 中的密钥计算</a></p>
</li>
<li>
<p><a href="https://dev.to/techschoolguru/a-complete-overview-of-ssl-tls-and-its-cryptographic-system-36pd" target="_blank" rel="noopener noreferrer">A complete overview of SSL/TLS and its cryptographic system</a></p>
</li>
<li>
<p><a href="https://kubernetes.io/docs/concepts/cluster-administration/certificates/" target="_blank" rel="noopener noreferrer">Certificates - Kubernetes Docs</a></p>
</li>
<li>
<p><a href="https://help.aliyun.com/document_detail/28542.html" target="_blank" rel="noopener noreferrer">证书选型和购买 - 阿里云文档</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4MTQ2MjI5OA==&amp;mid=2664079008&amp;idx=1&amp;sn=dede1114d5705880ea757f8d9ae4c92d" target="_blank" rel="noopener noreferrer">云原生安全破局｜如何管理周期越来越短的数字证书？</a></p>
</li>
</ul>
<p>另外两个关于 CN(Common Name) 和 SAN(Subject Altnative Name) 的问答:</p>
<ul>
<li><a href="https://serverfault.com/questions/880804/can-not-get-rid-of-neterr-cert-common-name-invalid-error-in-chrome-with-self" target="_blank" rel="noopener noreferrer">Can not get rid of <code>net::ERR_CERT_COMMON_NAME_INVALID</code> error in chrome with self-signed certificates</a></li>
<li><a href="https://stackoverflow.com/questions/5935369/ssl-how-do-common-names-cn-and-subject-alternative-names-san-work-together" target="_blank" rel="noopener noreferrer">SSL - How do Common Names (CN) and Subject Alternative Names (SAN) work together?</a></li>
</ul>
<p>关于证书锁定/公钥锁定技术:</p>
<ul>
<li><a href="https://owasp.org/www-community/controls/Certificate_and_Public_Key_Pinning" target="_blank" rel="noopener noreferrer">Certificate and Public Key Pinning - OWASP</a></li>
<li><a href="https://security.stackexchange.com/questions/85209/difference-between-certificate-pinning-and-public-key-pinning" target="_blank" rel="noopener noreferrer">Difference between certificate pinning and public key pinning</a></li>
</ul>
<p>其他推荐读物:</p>
<ul>
<li><a href="https://book.douban.com/subject/26822106/" target="_blank" rel="noopener noreferrer">图解密码技术 - [日]结城浩</a></li>
<li><a href="https://mp.weixin.qq.com/s/li3ZjfNgX5nh7AKjyyzt5A" target="_blank" rel="noopener noreferrer">给工程师：关于证书（certificate）和公钥基础设施（PKI）的一切</a></li>
</ul>
]]></content></entry><entry><title type="html">写给开发人员的实用密码学（七）—— 非对称密钥加密算法 RSA/ECC</title><link href="https://thiscute.world/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/"/><id>https://thiscute.world/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/</id><author><name>ryan4yin</name></author><published>2022-03-09T20:50:00+08:00</published><updated>2022-03-13T15:26:00+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/symmetric-vs-asymmetric.webp" height="909" width="287"><figcaption></figcaption>
        </figure><blockquote>
<p>本文部分内容翻译自 <a href="https://github.com/nakov/Practical-Cryptography-for-Developers-Book" target="_blank" rel="noopener noreferrer">Practical-Cryptography-for-Developers-Book</a>，笔者补充了密码学历史以及 openssl 命令示例，并重写了 RSA/ECC 算法原理、代码示例等内容。</p>
</blockquote>
<blockquote>
<p>这篇文章中会涉及到一些数论知识，本文不会详细介绍这些数学知识，可以在有疑惑的时候自行查找相关知识，或者选择跳过相关内容。</p>
</blockquote>
<p>《写给开发人员的实用密码学》系列文章目录：</p>
<ul>
<li><a href="/posts/practical-cryptography-basics-1/" rel="">写给开发人员的实用密码学（一）—— 概览</a></li>
<li><a href="/posts/practical-cryptography-basics-2-hash/" rel="">写给开发人员的实用密码学（二）—— 哈希函数</a></li>
<li><a href="/posts/practical-cryptography-basics-3-key-derivation-function/" rel="">写给开发人员的实用密码学（三）—— MAC 与密钥派生函数 KDF</a></li>
<li><a href="/posts/practical-cryptography-basics-4-secure-random-generators/" rel="">写给开发人员的实用密码学（四）—— 安全随机数生成器 CSPRNG</a></li>
<li><a href="/posts/practical-cryptography-basics-5-key-exchange/" rel="">写给开发人员的实用密码学（五）—— 密钥交换 DHKE 与完美前向保密 PFS</a></li>
<li><a href="/posts/practical-cryptography-basics-6-symmetric-key-ciphers/" rel="">写给开发人员的实用密码学（六）—— 对称密钥加密算法</a></li>
<li><a href="/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/" rel="">写给开发人员的实用密码学（七）—— 非对称密钥加密算法 RSA/ECC</a></li>
<li><a href="/posts/about-tls-cert" rel="">写给开发人员的实用密码学（八）—— 数字证书与 TLS 协议</a></li>
<li>待续</li>
</ul>
<h2 id="一公钥密码学--非对称密码学" class="headerLink">
    <a href="#%e4%b8%80%e5%85%ac%e9%92%a5%e5%af%86%e7%a0%81%e5%ad%a6--%e9%9d%9e%e5%af%b9%e7%a7%b0%e5%af%86%e7%a0%81%e5%ad%a6" class="header-mark"></a>一、公钥密码学 / 非对称密码学</h2><p>在介绍非对称密钥加密方案和算法之前，我们首先要了解公钥密码学的概念。</p>
<h3 id="密码学的历史" class="headerLink">
    <a href="#%e5%af%86%e7%a0%81%e5%ad%a6%e7%9a%84%e5%8e%86%e5%8f%b2" class="header-mark"></a>密码学的历史</h3><p>从第一次世界大战、第二次世界大战到 1976 年这段时期密码的发展阶段，被称为「近代密码阶段」。
在近代密码阶段，所有的密码系统都使用对称密码算法——使用相同的密钥进行加解密。
当时使用的密码算法在拥有海量计算资源的现代人看来都是非常简单的，我们经常看到各种讲述一二战的谍战片，基本都包含破译电报的片段。</p>
<p>第一二次世界大战期间，无线电被广泛应用于军事通讯，围绕无线电通讯的加密破解攻防战极大地影响了战局。</p>
<p>公元20世纪初，第一次世界大战进行到关键时刻，英国破译密码的专门机构「40号房间」利用缴获的德国密码本破译了著名的「齐默尔曼电报」，其内容显示德国打算联合墨西哥对抗可能会参战的美国，这促使美国放弃中立对德宣战，从而彻底改变了一战的走势。</p>
<p>1943 年，美国从破译的日本电报中得知山本五十六将于 4 月 18 日乘中型轰炸机，由 6 架战斗机护航，到中途岛视察。美国总统罗斯福亲自做出决定截击山本，山本乘坐的飞机在去往中途岛的路上被美军击毁，战争天才山本五十六机毁人亡，日本海军从此一蹶不振。</p>
<p>此外，在二次世界大战中，美军将印第安纳瓦霍土著语言作为密码使用，并特别征募使用印第安纳瓦霍通信兵。在二次世界大战日美的太平洋战场上，美国海军军部让北墨西哥和亚历桑那印第安纳瓦霍族人使用纳瓦霍语进行情报传递。纳瓦霍语的语法、音调及词汇都极为独特，不为世人所知道，当时纳瓦霍族以外的美国人中，能听懂这种语言的也就一二十人。这是<strong>密码学</strong>和<strong>语言学</strong>的成功结合，纳瓦霍语密码成为历史上从未被破译的密码。</p>
<p>在 1976 年 Malcolm J. Williamson 公开发表了现在被称为「Diffie–Hellman 密钥交换，DHKE」的算法，并提出了「公钥密码学」的概念，这是密码学领域一项划时代的发明，它宣告了「近代密码阶段」的终结，是「现代密码学」的起点。</p>
<p>言归正传，对称密码算法的问题有两点：</p>
<ul>
<li>「<strong>需要安全的通道进行密钥交换</strong>」，早期最常见的是面对面交换密钥</li>
<li>每个点对点通信都需要使用不同的密钥，<strong>密钥的管理会变得很困难</strong>
<ul>
<li>如果你需要跟 100 个朋友安全通信，你就要维护 100 个不同的对称密钥，而且还得确保它们不泄漏。</li>
</ul>
</li>
</ul>
<p>这会导致巨大的「密钥交换」跟「密钥保存与管理」的成本。「公钥密码学」最大的优势就是，它解决了这两个问题：</p>
<ul>
<li>「公钥密码学」可以在<strong>不安全的信道</strong>上安全地进行密钥交换，第三方即使监听到通信过程，但是（几乎）无法破解出密钥。</li>
<li>每个人只需要公开自己的公钥，就可以跟其他任何人安全地通信。
<ul>
<li>如果你需要跟 100 个朋友安全通信，你们只需要公开自己的公钥。发送消息时使用对方的公钥加密，接收消息时使用自己的私钥解密即可。</li>
<li>只有你自己的私钥需要保密，所有的公钥都可以公开，这就显著降低了密钥的维护成本。</li>
</ul>
</li>
</ul>
<p>因此公钥密码学成为了现代密码学的基石，而「公钥密码学」的诞生时间 1976 年被认为是现代密码学的开端。</p>
<h3 id="公钥密码学的概念" class="headerLink">
    <a href="#%e5%85%ac%e9%92%a5%e5%af%86%e7%a0%81%e5%ad%a6%e7%9a%84%e6%a6%82%e5%bf%b5" class="header-mark"></a>公钥密码学的概念</h3><p>公钥密码系统的密钥始终以公钥 + 私钥对的形式出现，公钥密码系统提供数学框架和算法来生成公钥+私钥对。
公钥通常与所有人共享，而私钥则保密。
公钥密码系统在设计时就确保了在预期的算力下，几乎不可能从其公开的公钥逆向演算出对应的私钥。</p>
<p>公钥密码系统主要有三大用途：<strong>加密与解密、签名与验证、密钥交换</strong>。
每种算法都需要使用到公钥和私钥，比如由公钥加密的消息只能由私钥解密，由私钥签名的消息需要用公钥验证。</p>
<p>由于加密解密、签名验证均需要两个不同的密钥，故「公钥密码学」也被称为「<strong>非对称密码学</strong>」。</p>
<p>比较著名的公钥密码系统有：RSA、ECC（椭圆曲线密码学）、ElGamal、Diffie-Hellman、ECDH、ECDSA 和 EdDSA。许多密码算法都是以这些密码系统为基础实现的，例如 RSA 签名、RSA 加密/解密、ECDH 密钥交换以及 ECDSA 和 EdDSA 签名。</p>
<h3 id="量子安全性" class="headerLink">
    <a href="#%e9%87%8f%e5%ad%90%e5%ae%89%e5%85%a8%e6%80%a7" class="header-mark"></a>量子安全性</h3><blockquote>
<p>参考文档：https://en.wikipedia.org/wiki/Post-quantum_cryptography</p>
</blockquote>
<p>目前流行的公钥密码系统基本都依赖于 IFP（整数分解问题）、DLP（离散对数问题）或者 ECDLP（椭圆曲线离散对数问题），这导致这些算法都是<strong>量子不安全</strong>（quantum-unsafe）的。</p>
<p>如果人类进入量子时代，IFP / DLP / ECDLP 的难度将大大降低，目前流行的 RSA、ECC、ElGamal、Diffie-Hellman、ECDH、ECDSA 和 EdDSA 等公钥密码算法都将被淘汰。</p>
<p>目前已经有一些量子安全的公钥密码系统问世，但是因为它们需要更长的密钥、更长的签名等原因，目前还未被广泛使用。</p>
<p>一些量子安全的公钥密码算法举例：NewHope、NTRU、GLYPH、BLISS、XMSS、<a href="https://github.com/Microsoft/Picnic" target="_blank" rel="noopener noreferrer">Picnic</a> 等，有兴趣的可以自行搜索相关文档。</p>
<h2 id="二非对称加密方案简介" class="headerLink">
    <a href="#%e4%ba%8c%e9%9d%9e%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e6%96%b9%e6%a1%88%e7%ae%80%e4%bb%8b" class="header-mark"></a>二、非对称加密方案简介</h2><p>非对称加密要比对称加密复杂，有如下几个原因：</p>
<ul>
<li>使用密钥对进行加解密，导致其算法更为复杂</li>
<li>只能加密/解密很短的消息
<ul>
<li>在 RSA 系统中，输入消息需要被转换为大整数（例如使用 OAEP 填充），然后才能被加密为密文。（密文实质上就是另一个大整数）</li>
</ul>
</li>
<li>一些非对称密码系统（如 ECC）不直接提供加密能力，需要结合使用更复杂的方案才能实现加解密</li>
</ul>
<p>此外，非对称密码比对称密码慢非常多。比如 RSA 加密比 AES 慢 1000 倍，跟 ChaCha20 就更没法比了。</p>
<p>为了解决上面提到的这些困难并支持加密任意长度的消息，现代密码学使用「<strong>非对称加密方案</strong>」来实现消息加解密。
又因为「对称加密方案」具有速度快、支持加密任意长度消息等特性，「非对称加密方案」通常直接直接组合使用<strong>对称加密算法</strong>与<strong>非对称加密算法</strong>。比如「密钥封装机制 KEM（key encapsulation mechanisms)）」与「集成加密方案 IES（Integrated Encryption Scheme）」</p>
<h3 id="1-密钥封装机制-kem" class="headerLink">
    <a href="#1-%e5%af%86%e9%92%a5%e5%b0%81%e8%a3%85%e6%9c%ba%e5%88%b6-kem" class="header-mark"></a>1. 密钥封装机制 KEM</h3><p>顾名思义，KEM 就是仅使用非对称加密算法加密另一个密钥，实际数据的加解密由该密钥完成。</p>
<p>密钥封装机制 KEM 的加密流程（使用公钥加密传输对称密钥）：</p>
<figure><img src="/images/practical-cryptography-basics-7-asymmetric-key-ciphers/hybrid-encryption.webp"/>
</figure>

<p>密钥封装机制 KEM 的解密流程（使用私钥解密出对称密钥，然后再使用这个对称密钥解密数据）：</p>
<figure><img src="/images/practical-cryptography-basics-7-asymmetric-key-ciphers/hybrid-decryption.webp"/>
</figure>

<p>RSA-OAEP, RSA-KEM, ECIES-KEM 和 PSEC-KEM. 都是 KEM 加密方案。</p>
<h4 id="密钥封装key-encapsulation与密钥包裹key-wrapping" class="headerLink">
    <a href="#%e5%af%86%e9%92%a5%e5%b0%81%e8%a3%85key-encapsulation%e4%b8%8e%e5%af%86%e9%92%a5%e5%8c%85%e8%a3%b9key-wrapping" class="header-mark"></a>密钥封装（Key encapsulation）与密钥包裹（Key wrapping）</h4><p>主要区别在于使用的是对称加密算法、还是非对称加密算法：</p>
<ul>
<li>密钥封装（Key encapsulation）指使用非对称密码算法的公钥加密另一个密钥。</li>
<li>密钥包裹（Key wrapping）指使用对称密码算法加密另一个密钥。</li>
</ul>
<h3 id="2-集成加密方案-ies" class="headerLink">
    <a href="#2-%e9%9b%86%e6%88%90%e5%8a%a0%e5%af%86%e6%96%b9%e6%a1%88-ies" class="header-mark"></a>2. 集成加密方案 IES</h3><p>集成加密方案 (IES) 在密钥封装机制（KEM）的基础上，添加了密钥派生算法 KDF、消息认证算法 MAC 等其他密码学算法以达成更高的安全性。</p>
<p>在 IES 方案中，非对称算法（如 RSA 或 ECC）跟 KEM 一样，都是用于加密或封装对称密钥，然后通过对称密钥（如 AES 或 Chacha20）来加密输入消息。</p>
<p>DLIES（离散对数集成加密方案）和 ECIES（椭圆曲线集成加密方案）都是 IES 方案。</p>
<h2 id="三rsa-密码系统" class="headerLink">
    <a href="#%e4%b8%89rsa-%e5%af%86%e7%a0%81%e7%b3%bb%e7%bb%9f" class="header-mark"></a>三、RSA 密码系统</h2><p>RSA 密码系统是最早的公钥密码系统之一，它基于 <a href="https://en.wikipedia.org/wiki/RSA_problem" target="_blank" rel="noopener noreferrer">RSA 问题</a>和<a href="https://en.wikipedia.org/wiki/Integer_factorization" target="_blank" rel="noopener noreferrer">整数分解问题 （IFP）</a>的计算难度。
RSA 算法以其作者（Rivest–Shamir–Adleman）的首字母命名。</p>
<p>RSA 算法在计算机密码学的早期被广泛使用，至今仍然是数字世界应用最广泛的密码算法。
但是随着 ECC 密码学的发展，ECC 正在非对称密码系统中慢慢占据主导地位，因为它比 RSA 具有更高的安全性和更短的密钥长度。</p>
<p>RSA 算法提供如下几种功能：</p>
<ul>
<li>密钥对生成：生成随机私钥（通常大小为 1024-4096 位）和相应的公钥。</li>
<li>加密解密：使用公钥加密消息（消息要先转换为 [0&hellip;key_length] 范围内的整数），然后使用密钥解密。</li>
<li>数字签名：签署消息（使用私钥）和验证消息签名（使用公钥）。
<ul>
<li>数字签名实际上是通过 Hash 算法 + 加密解密功能实现的。后面会介绍到，它与一般加解密流程的区别，在于数字签名使用私钥加密，再使用公钥解密。</li>
</ul>
</li>
<li>密钥交换：安全地传输密钥，用于以后的加密通信。</li>
</ul>
<p>RSA 可以使用不同长度的密钥：1024、2048、3072、4096、8129、16384 甚至更多位。目前 <strong>3072</strong> 位及以上的密钥长度被认为是安全的，曾经大量使用的 <strong>2048</strong> 位 RSA 现在被破解的风险在不断提升，已经不推荐使用了。</p>
<p>更长的密钥提供更高的安全性，但会消耗更多的计算时间，同时签名也会变得更长，因此需要在安全性和速度之间进行权衡。
非常长的 RSA 密钥（例如 50000 位或 65536 位）对于实际使用可能太慢，例如密钥生成可能需要几分钟到几个小时。</p>
<h3 id="rsa-密钥对生成" class="headerLink">
    <a href="#rsa-%e5%af%86%e9%92%a5%e5%af%b9%e7%94%9f%e6%88%90" class="header-mark"></a>RSA 密钥对生成</h3><p>RSA 密钥对的生成跟我们在本系列文章的第 5 篇介绍的「DHKE 密钥交换算法」会有些类似，但是要更复杂一点。</p>
<p>首先看下我们怎么使用 openssl 生成一个 1024 位的 RSA 密钥对（<strong>仅用做演示，实际应用中建议 3072 位</strong>）：</p>
<blockquote>
<p><a href="https://github.com/openssl/openssl" target="_blank" rel="noopener noreferrer">OpenSSL</a> 是目前使用最广泛的网络加密算法库，支持非常多流行的现代密码学算法，几乎所有操作系统都会内置 openssl.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 生成 1024 位的 RSA 私钥
</span></span><span class="line"><span class="cl">❯ openssl genrsa -out rsa-private-key.pem 1024
</span></span><span class="line"><span class="cl">Generating RSA private key, 1024 bit long modulus
</span></span><span class="line"><span class="cl">.................+++
</span></span><span class="line"><span class="cl">.....+++
</span></span><span class="line"><span class="cl">e is 65537 (0x10001)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 使用私钥生成对应的公钥文件
</span></span><span class="line"><span class="cl">❯ openssl rsa -in rsa-private-key.pem -pubout -out rsa-public-key.pem
</span></span><span class="line"><span class="cl">writing RSA key
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 查看私钥内容
</span></span><span class="line"><span class="cl">❯ cat rsa-private-key.pem
</span></span><span class="line"><span class="cl">-----BEGIN RSA PRIVATE KEY-----
</span></span><span class="line"><span class="cl">MIICXAIBAAKBgQDNE8QZLJZXREOeWZ2ilAzGC4Kjq/PfsFzrXGj8g3IaS4/J3JrB
</span></span><span class="line"><span class="cl">o3qEq/k9XoRzOmNPyvWCj2FAY7A099d7qX4ztthBpUM2ePDIYDvhL0EpfQqbhe+Q
</span></span><span class="line"><span class="cl">aagcFpuKTshGR2wBjH0Cl1/WxJkfIUMmWYU+m4iKLw9KfLX6BjmSgWB6HQIDAQAB
</span></span><span class="line"><span class="cl">AoGADb5NXgKG8MI6ZdpLniGd2Yfb8WwMo+kF0SAYSRPmCa0WrciC9ocmJs3/ngU/
</span></span><span class="line"><span class="cl">ixlWnnpTibRiKBaGMIaLglYRhvbvibUo8PH4woIidTho2e6swF2aqILk6YFJDpxX
</span></span><span class="line"><span class="cl">FCFdbXM4Cm2MqbD4VtmhCYqbvuiyEUci83YrRP0jJGNt0GECQQDyZgdi8JlFQFH8
</span></span><span class="line"><span class="cl">1QRHjLN57v5bHQamv7Qb77hlbdbg1wTYO+H8tsOB181TEHA7uN8hxkzyYZy+goRx
</span></span><span class="line"><span class="cl">n0hvJcQXAkEA2JWhCb7oG1eal1aUdgofxhlWnkoFeWHay2zgDWSqmGKyDt0Cb1jq
</span></span><span class="line"><span class="cl">XTdN9dchnqfptWN2/QPLDgM+/9g39/zv6wJATC1sXNeoE29nVMHNGn9JWCSXoyK4
</span></span><span class="line"><span class="cl">GGdevvjTRm0Cfp6UUzBekQEO6Btd16Du5JXw6bhcLkAm9mgmH18jcGq5+QJBALnr
</span></span><span class="line"><span class="cl">aDv3d0PRZdE372WMt03UfniOzjgueiVaJtMYcSEyx+reabKvvy+ZxACfVirdtU+S
</span></span><span class="line"><span class="cl">PJhhYzN6MeBp+VGV/VUCQBXz0LyM08roWi6DiaRwJIbYx+WCKEOGXQ9QsZND+sGr
</span></span><span class="line"><span class="cl">pOpugr3mcUge5dcZGKtsOUx2xRVmg88nSWMQVkTlsjQ=
</span></span><span class="line"><span class="cl">-----END RSA PRIVATE KEY-----
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 查看私钥的详细参数
</span></span><span class="line"><span class="cl">❯ openssl rsa -noout -text -in rsa-private-key.pem
</span></span><span class="line"><span class="cl">Private-Key: (1024 bit)
</span></span><span class="line"><span class="cl">modulus:
</span></span><span class="line"><span class="cl">    00💿13:c4:19:2c:96:57:44:43:9e:59:9d:a2:94:
</span></span><span class="line"><span class="cl">    0c:c6:0b:82:a3🆎f3:df:b0:5c:eb:5c:68:fc:83:
</span></span><span class="line"><span class="cl">    72:1a:4b:8f:c9:dc:9a:c1:a3:7a:84🆎f9:3d:5e:
</span></span><span class="line"><span class="cl">    84:73:3a:63:4f:ca:f5:82:8f:61:40:63:b0:34:f7:
</span></span><span class="line"><span class="cl">    d7:7b:a9:7e:33:b6:d8:41:a5:43:36:78:f0:c8:60:
</span></span><span class="line"><span class="cl">    3b:e1:2f:41:29:7d:0a:9b:85:ef:90:69:a8:1c:16:
</span></span><span class="line"><span class="cl">    9b:8a:4e:c8:46:47:6c:01:8c:7d:02:97:5f:d6:c4:
</span></span><span class="line"><span class="cl">    99:1f:21:43:26:59:85:3e:9b:88:8a:2f:0f:4a:7c:
</span></span><span class="line"><span class="cl">    b5:fa:06:39:92:81:60:7a:1d
</span></span><span class="line"><span class="cl">publicExponent: 65537 (0x10001)
</span></span><span class="line"><span class="cl">privateExponent:
</span></span><span class="line"><span class="cl">    0d:be:4d:5e:02:86:f0:c2:3a:65:da:4b:9e:21:9d:
</span></span><span class="line"><span class="cl">    d9:87:db:f1:6c:0c:a3:e9:05:d1:20:18:49:13:e6:
</span></span><span class="line"><span class="cl">    09:ad:16:ad:c8:82:f6:87:26:26:cd:ff:9e:05:3f:
</span></span><span class="line"><span class="cl">    8b:19:56:9e:7a:53:89:b4:62:28:16:86:30:86:8b:
</span></span><span class="line"><span class="cl">    82:56:11:86:f6:ef:89:b5:28:f0:f1:f8:c2:82:22:
</span></span><span class="line"><span class="cl">    75:38:68:d9:ee:ac:c0:5d:9a:a8:82:e4:e9:81:49:
</span></span><span class="line"><span class="cl">    0e:9c:57:14:21:5d:6d:73:38:0a:6d:8c:a9:b0:f8:
</span></span><span class="line"><span class="cl">    56:d9:a1:09:8a:9b:be:e8:b2:11:47:22:f3:76:2b:
</span></span><span class="line"><span class="cl">    44:fd:23:24:63:6d:d0:61
</span></span><span class="line"><span class="cl">prime1:
</span></span><span class="line"><span class="cl">    00:f2:66:07:62:f0:99:45:40:51:fc:d5:04:47:8c:
</span></span><span class="line"><span class="cl">    b3:79:ee:fe:5b:1d:06:a6:bf:b4:1b:ef:b8:65:6d:
</span></span><span class="line"><span class="cl">    d6:e0:d7:04:d8:3b:e1:fc:b6:c3:81:d7:cd:53:10:
</span></span><span class="line"><span class="cl">    70:3b:b8:df:21:c6:4c:f2:61:9c:be:82:84:71:9f:
</span></span><span class="line"><span class="cl">    48:6f:25:c4:17
</span></span><span class="line"><span class="cl">prime2:
</span></span><span class="line"><span class="cl">    00:d8:95:a1:09:be:e8:1b:57:9a:97:56:94:76:0a:
</span></span><span class="line"><span class="cl">    1f:c6:19:56:9e:4a:05:79:61:da:cb:6c:e0:0d:64:
</span></span><span class="line"><span class="cl">    aa:98:62:b2:0e:dd:02:6f:58:ea:5d:37:4d:f5:d7:
</span></span><span class="line"><span class="cl">    21:9e:a7:e9:b5:63:76:fd:03:cb:0e:03:3e:ff:d8:
</span></span><span class="line"><span class="cl">    37:f7:fc:ef:eb
</span></span><span class="line"><span class="cl">exponent1:
</span></span><span class="line"><span class="cl">    4c:2d:6c:5c:d7:a8:13:6f:67:54:c1💿1a:7f:49:
</span></span><span class="line"><span class="cl">    58:24:97:a3:22:b8:18:67:5e:be:f8:d3:46:6d:02:
</span></span><span class="line"><span class="cl">    7e:9e:94:53:30:5e:91:01:0e:e8:1b:5d:d7:a0:ee:
</span></span><span class="line"><span class="cl">    e4:95:f0:e9:b8:5c:2e:40:26:f6:68:26:1f:5f:23:
</span></span><span class="line"><span class="cl">    70:6a:b9:f9
</span></span><span class="line"><span class="cl">exponent2:
</span></span><span class="line"><span class="cl">    00:b9:eb:68:3b:f7:77:43:d1:65:d1:37:ef:65:8c:
</span></span><span class="line"><span class="cl">    b7:4d:d4:7e:78:8e:ce:38:2e:7a:25:5a:26:d3:18:
</span></span><span class="line"><span class="cl">    71:21:32:c7:ea🇩🇪69:b2:af:bf:2f:99:c4:00:9f:
</span></span><span class="line"><span class="cl">    56:2a:dd:b5:4f:92:3c:98:61:63:33:7a:31:e0:69:
</span></span><span class="line"><span class="cl">    f9:51:95:fd:55
</span></span><span class="line"><span class="cl">coefficient:
</span></span><span class="line"><span class="cl">    15:f3:d0:bc:8c:d3:ca:e8:5a:2e:83:89:a4:70:24:
</span></span><span class="line"><span class="cl">    86:d8:c7:e5:82:28:43:86:5d:0f:50:b1:93:43:fa:
</span></span><span class="line"><span class="cl">    c1🆎a4:ea:6e:82:bd:e6:71:48:1e:e5:d7:19:18:
</span></span><span class="line"><span class="cl">    ab:6c:39:4c:76:c5:15:66:83:cf:27:49:63:10:56:
</span></span><span class="line"><span class="cl">    44:e5:b2:34
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 查看私钥内容
</span></span><span class="line"><span class="cl">❯ cat rsa-public-key.pem 
</span></span><span class="line"><span class="cl">-----BEGIN PUBLIC KEY-----
</span></span><span class="line"><span class="cl">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDNE8QZLJZXREOeWZ2ilAzGC4Kj
</span></span><span class="line"><span class="cl">q/PfsFzrXGj8g3IaS4/J3JrBo3qEq/k9XoRzOmNPyvWCj2FAY7A099d7qX4ztthB
</span></span><span class="line"><span class="cl">pUM2ePDIYDvhL0EpfQqbhe+QaagcFpuKTshGR2wBjH0Cl1/WxJkfIUMmWYU+m4iK
</span></span><span class="line"><span class="cl">Lw9KfLX6BjmSgWB6HQIDAQAB
</span></span><span class="line"><span class="cl">-----END PUBLIC KEY-----
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 查看公钥的参数
</span></span><span class="line"><span class="cl">❯ openssl rsa -noout -text -pubin -in rsa-public-key.pem
</span></span><span class="line"><span class="cl">Public-Key: (1024 bit)
</span></span><span class="line"><span class="cl">Modulus:
</span></span><span class="line"><span class="cl">    00💿13:c4:19:2c:96:57:44:43:9e:59:9d:a2:94:
</span></span><span class="line"><span class="cl">    0c:c6:0b:82:a3🆎f3:df:b0:5c:eb:5c:68:fc:83:
</span></span><span class="line"><span class="cl">    72:1a:4b:8f:c9:dc:9a:c1:a3:7a:84🆎f9:3d:5e:
</span></span><span class="line"><span class="cl">    84:73:3a:63:4f:ca:f5:82:8f:61:40:63:b0:34:f7:
</span></span><span class="line"><span class="cl">    d7:7b:a9:7e:33:b6:d8:41:a5:43:36:78:f0:c8:60:
</span></span><span class="line"><span class="cl">    3b:e1:2f:41:29:7d:0a:9b:85:ef:90:69:a8:1c:16:
</span></span><span class="line"><span class="cl">    9b:8a:4e:c8:46:47:6c:01:8c:7d:02:97:5f:d6:c4:
</span></span><span class="line"><span class="cl">    99:1f:21:43:26:59:85:3e:9b:88:8a:2f:0f:4a:7c:
</span></span><span class="line"><span class="cl">    b5:fa:06:39:92:81:60:7a:1d
</span></span><span class="line"><span class="cl">Exponent: 65537 (0x10001)
</span></span></code></pre></td></tr></table>
</div>
</div><p>RSA 描述的私钥的结构如下（其中除 $n, d$ 之外的都是冗余信息）：</p>
<ul>
<li><code>modulus</code>: 模数 $n$</li>
<li><code>publicExponent</code>: 公指数 $e$，固定为 65537 (0x10001)</li>
<li><code>privateExponent</code>: 私钥指数 $d$</li>
<li><code>prime1</code>: 质数 p，用于计算 $n$</li>
<li><code>prime2</code>: 质数 q，用于计算 $n$</li>
<li><code>exponent1</code>: 用于加速 RSA 运算的中国剩余定理指数一，$d \mod (p-1)$</li>
<li><code>exponent2</code>: 用于加速 RSA 运算的中国剩余定理指数二，$d \mod (q-1)$</li>
<li><code>coefficient</code>: 用于加速 RSA 运算的中国剩余定理系数，$q^{-1} \mod p$</li>
</ul>
<p>再看下 RSA 公钥的结构：</p>
<ul>
<li><code>modulus</code>: 模数 $n$</li>
<li><code>exponent</code>: 公指数 $e$，固定为 65537 (0x10001)</li>
</ul>
<p>可以看到私钥文件中就已经包含了公钥的所有参数，实际上我们也是使用 <code>openssl rsa -in rsa-private-key.pem -pubout -out rsa-public-key.pem</code> 命令通过私钥生成出的对应的公钥文件。</p>
<p>下面就介绍下具体的密钥对生成流程，搞清楚 openssl 生成出的这个私钥，各项参数分别是什么含义：</p>
<blockquote>
<p>这里不会详细介绍其中的各种数学证明，具体的请参考维基百科。
相关数学知识包括取模运算的性质、欧拉函数、模倒数（拓展欧几里得算法）</p>
</blockquote>
<ul>
<li>随机选择两个不相等的质数 $p$ 与 $q$
<ul>
<li>p 跟 q 应该非常大，但是长度相差几个整数，这样会使得破解更加困难</li>
</ul>
</li>
<li>计算出模数 $n = pq$</li>
<li>计算欧拉函数的值 $\phi(n) = \phi(pq) = (p-1)(q-1)$</li>
<li>选择公指数 $e$，要求 $1 &lt; e &lt; \lambda (n)$，且 $e$ 与 $\phi(n)$ 互质，即 $\gcd(e, \phi(n)) = 1$。
<ul>
<li>目前 openssl 固定使用 65537 (0x10001) 作为 e 的值</li>
<li>曾经也有使用过 3 作为 e 的值，但是目前 3 已被证明不够安全</li>
</ul>
</li>
<li>计算出使等式 $ed \equiv 1 \bmod \phi(n)$ 成立的值 $d$，它就是我们的私钥指数
<ul>
<li>上述等式的含义：$ed$ 被 $\phi(n)$ 的余数为 $1$</li>
<li>等式可转换为 $ed = 1 + \phi(n) \cdot k$，其中 $k$ 为整数。</li>
<li>移项得 $e d + \phi(n) \cdot y = 1 = \gcd(e, \phi(n))$，其中 $y=-k$</li>
<li>上面的等式可使用<a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95" target="_blank" rel="noopener noreferrer">拓展欧几里得算法</a>求解，wiki 有给出此算法的 Python 实现，非常简洁。</li>
</ul>
</li>
<li>使用 $(n, e)$ 组成公钥，使用 $(n, d)$ 组成私钥。其他参数可以保存在私钥中，也可丢弃。
<ul>
<li>$p, q, \phi(n), d$ 四个参数都必须保密，绝不能泄漏！</li>
</ul>
</li>
<li>在现有算力下，想要通过公钥的 $(n, e)$ 推算出 $d$ 是非常困难的，这保证了 RSA 算法的安全性。</li>
</ul>
<p>下面我们使用 Python 来通过 $p,q,e$ 计算出 $n, d$ 来，跟 openssl 打印的对比下，看看是否一致。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># pip install cryptography==36.0.1</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">cryptography.hazmat.primitives</span> <span class="kn">import</span> <span class="n">serialization</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">key_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&#34;./rsa-private-key.pem&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">private_key</span> <span class="o">=</span> <span class="n">serialization</span><span class="o">.</span><span class="n">load_pem_private_key</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">key_path</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="n">password</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span> <span class="o">=</span> <span class="n">private_key</span><span class="o">.</span><span class="n">private_numbers</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span> <span class="o">=</span> <span class="n">private_key</span><span class="o">.</span><span class="n">public_key</span><span class="p">()</span><span class="o">.</span><span class="n">public_numbers</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">p</span> <span class="o">=</span> <span class="n">private</span><span class="o">.</span><span class="n">p</span>
</span></span><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">private</span><span class="o">.</span><span class="n">q</span>
</span></span><span class="line"><span class="cl"><span class="n">e</span> <span class="o">=</span> <span class="n">public</span><span class="o">.</span><span class="n">e</span>
</span></span><span class="line"><span class="cl"><span class="n">phi_n</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">extended_euclidean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">      拓展欧几里得算法，能在计算出 a 与 b 的最大公约数的同时，给出 ax + by = gcd(a, b) 中的 x 与 y 的值
</span></span></span><span class="line"><span class="cl"><span class="s2">      代码来自 wiki: https://zh.wikipedia.org/wiki/</span><span class="si">%E</span><span class="s2">6</span><span class="si">%89%</span><span class="s2">A9</span><span class="si">%E</span><span class="s2">5%B1</span><span class="si">%95%</span><span class="s2">E6%AC%A7</span><span class="si">%E</span><span class="s2">5</span><span class="si">%87%</span><span class="s2">A0</span><span class="si">%E</span><span class="s2">9</span><span class="si">%87%</span><span class="s2">8C</span><span class="si">%E</span><span class="s2">5%BE</span><span class="si">%97%</span><span class="s2">E7%AE</span><span class="si">%97%</span><span class="s2">E6%B3%95
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">old_s</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="n">old_t</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="n">old_r</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">r</span><span class="o">!=</span><span class="mi">0</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">q</span> <span class="o">=</span> <span class="n">old_r</span> <span class="o">//</span> <span class="n">r</span>
</span></span><span class="line"><span class="cl">            <span class="n">old_r</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">,</span> <span class="n">old_r</span><span class="o">-</span><span class="n">q</span><span class="o">*</span><span class="n">r</span>
</span></span><span class="line"><span class="cl">            <span class="n">old_s</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">,</span> <span class="n">old_s</span><span class="o">-</span><span class="n">q</span><span class="o">*</span><span class="n">s</span>
</span></span><span class="line"><span class="cl">            <span class="n">old_t</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span> <span class="n">old_t</span><span class="o">-</span><span class="n">q</span><span class="o">*</span><span class="n">t</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">old_s</span><span class="p">,</span> <span class="n">old_t</span><span class="p">,</span> <span class="n">old_r</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 我们只需要 d，y 可忽略，而余数 remainder 肯定为 1，也可忽略</span>
</span></span><span class="line"><span class="cl"><span class="n">d</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">extended_euclidean</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">phi_n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">n</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">q</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">=}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># =&gt; hex(n)=&#39;0xcd13c4192c965744439e599da2940cc60b82a3abf3dfb05ceb5c68fc83721a4b8fc9dc9ac1a37a84abf93d5e84733a634fcaf5828f614063b034f7d77ba97e33b6d841a5433678f0c8603be12f41297d0a9b85ef9069a81c169b8a4ec846476c018c7d02975fd6c4991f21432659853e9b888a2f0f4a7cb5fa06399281607a1d&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">=}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># =&gt; hex(d)=&#39;0xdbe4d5e0286f0c23a65da4b9e219dd987dbf16c0ca3e905d120184913e609ad16adc882f6872626cdff9e053f8b19569e7a5389b46228168630868b82561186f6ef89b528f0f1f8c28222753868d9eeacc05d9aa882e4e981490e9c5714215d6d73380a6d8ca9b0f856d9a1098a9bbee8b2114722f3762b44fd2324636dd061&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对比 RSA 的输出，可以发现去掉冒号后，<code>d</code> 跟 <code>n</code> 的值是完全相同的。</p>
<h3 id="rsa-加密与解密" class="headerLink">
    <a href="#rsa-%e5%8a%a0%e5%af%86%e4%b8%8e%e8%a7%a3%e5%af%86" class="header-mark"></a>RSA 加密与解密</h3><p>RSA 加密算法，一次只能加密一个小于 $n$ 的非负整数，假设明文为整数 $msg$，加密算法如下：</p>
<p>$$
\text{encryptedMsg} = msg^e \mod n
$$</p>
<p>通常的手段是，先使用 <a href="https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding" target="_blank" rel="noopener noreferrer">EAOP</a>  将被加密消息编码成一个个符合条件的整数，再使用上述公式一个个加密。</p>
<p>解密的方法，就是对被每一段加密的数据 $encryptedMsg$，进行如下运算：</p>
<p>$$
\text{decryptedMsg} = \text{encryptedMsg}^d \mod n
$$</p>
<h4 id="rsa-解密运算的证明" class="headerLink">
    <a href="#rsa-%e8%a7%a3%e5%af%86%e8%bf%90%e7%ae%97%e7%9a%84%e8%af%81%e6%98%8e" class="header-mark"></a>RSA 解密运算的证明</h4><blockquote>
<p>这里的证明需要用到一些数论知识，觉得不容易理解的话，建议自行查找相关资料。</p>
</blockquote>
<p>证明流程如下：</p>
<p>$$
\begin{alignedat}{2}
\text{decryptedMsg} &amp;= &amp;\text{encryptedMsg}^d &amp;\mod n \\
&amp;= &amp;{(msg^e \mod n)}^d &amp;\mod n \\
&amp;= &amp;{msg^{ed}} &amp;\mod n \\
&amp;= &amp;{msg^{ed}} &amp;\mod {pq}
\end{alignedat}
$$</p>
<p>接下来将下面两个等式代入上述计算中：</p>
<ul>
<li>我们在前面的「密钥对生成」一节中有给出等式：$ed = 1 + (p-1)(q-1) \cdot k$</li>
<li>因为 $0 \le msg \lt n$ 以及 $n = pq$，有 $msg \mod pq = msg$</li>
</ul>
<p>这样就得到：</p>
<p>$$
\begin{alignedat}{2}
\text{decryptedMsg} &amp;= &amp;{msg^{ed}} &amp;\mod {pq} \\
&amp;= &amp;{(msg \mod pq) \cdot (msg^{ed-1} \mod pq)} &amp;\mod {pq} \\
&amp;= &amp;{msg \cdot (msg^{(p-1)(q-1) \cdot k} \mod pq)} &amp;\mod {pq}
\end{alignedat}
$$</p>
<p>又有<a href="https://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86" target="_blank" rel="noopener noreferrer">费马小定理</a>指出，在 $a$ 为整数，$p$ 为质数的情况下，有同余等式</p>
<p>$$a^{p-1} \equiv 1 {\pmod  p}$$</p>
<p>因为我们的模数 $n=pq$ 并不是质数，不能直接利用费马小定理给出的同余公式。
但是 $p$, $q$ 两数都为质数，我们可以分别计算方程  对 $p$ 以及 $q$ 取模的结果，然后再根据<a href="https://zhuanlan.zhihu.com/p/44591114" target="_blank" rel="noopener noreferrer">中国剩余定理</a>得出通解，也就得到我们需要的结果。</p>
<p>对于模 $p$ 的情况，计算方法如下：</p>
<ul>
<li>当 $msg = 0 \mod p$ 时，${msg^{ed}} \mod p = 0 \equiv msg \pmod  p$</li>
<li>当 $msg \ne 0 \mod p$ 时，利用费马小定理，有
$$
\begin{alignedat}{2}
msg^{ed} &amp;= &amp;{msg \cdot (msg^{(p-1)(q-1) \cdot k} \mod p)} &amp;\pmod {p}  \\
&amp;= &amp;msg \cdot (msg^{(p-1)} \mod p)^{(q-1) \cdot k} &amp;\pmod p \\
&amp;= &amp;msg \cdot 1^{(q-1) \cdot k} &amp;\pmod p \\
&amp;\equiv &amp;msg \pmod  p
\end{alignedat}
$$</li>
</ul>
<p>同理，对模 $q$ 的情况，也能得到等式</p>
<p>$$msg^{ed} \equiv msg \pmod  q$$</p>
<p>有了上面两个结果，根据中国剩余定理，就能得到</p>
<p>$$msg^{ed} \equiv msg \pmod  {pq}$$</p>
<p>现在再接续前面的计算：</p>
<p>$$
\begin{alignedat}{2}
\text{decryptedMsg} &amp;= &amp;{msg^{ed}} &amp;\pmod {pq} \\
&amp;= &amp;msg &amp;\pmod  {pq} \\
&amp;= &amp;msg
\end{alignedat}
$$</p>
<p>这样就证明了，解密操作得到的就是原始信息。</p>
<p>因为非对称加解密非常慢，对于较大的文件，通常会分成两步加密来提升性能：首先用使用对称加密算法来加密数据，再使用 RSA 等非对称加密算法加密上一步用到的「对称密钥」。</p>
<p>下面我们用 Python 来验证下 RSA 算法的加解密流程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># pip install cryptography==36.0.1</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">cryptography.hazmat.primitives</span> <span class="kn">import</span> <span class="n">serialization</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 私钥</span>
</span></span><span class="line"><span class="cl"><span class="n">key_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&#34;./rsa-private-key.pem&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">private_key</span> <span class="o">=</span> <span class="n">serialization</span><span class="o">.</span><span class="n">load_pem_private_key</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">key_path</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="n">password</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span> <span class="o">=</span> <span class="n">private_key</span><span class="o">.</span><span class="n">private_numbers</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span> <span class="o">=</span> <span class="n">private_key</span><span class="o">.</span><span class="n">public_key</span><span class="p">()</span><span class="o">.</span><span class="n">public_numbers</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">d</span> <span class="o">=</span> <span class="n">private</span><span class="o">.</span><span class="n">d</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 公钥</span>
</span></span><span class="line"><span class="cl"><span class="n">n</span> <span class="o">=</span> <span class="n">public</span><span class="o">.</span><span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="n">e</span> <span class="o">=</span> <span class="n">public</span><span class="o">.</span><span class="n">e</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">int_to_bytes</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;big&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">int_from_bytes</span><span class="p">(</span><span class="n">xbytes</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">xbytes</span><span class="p">,</span> <span class="s1">&#39;big&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">fast_power_modular</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    快速模幂运算：b^p % m
</span></span></span><span class="line"><span class="cl"><span class="s2">    复杂度： O(log p)
</span></span></span><span class="line"><span class="cl"><span class="s2">    因为 RSA 的底数跟指数都非常大，如果先进行幂运算，最后再取模，计算结果会越来越大，导致速度非常非常慢
</span></span></span><span class="line"><span class="cl"><span class="s2">    根据模幂运算的性质  b^(ab) % m = (b^a % m)^b % m, 可以通过边进行幂运算边取模，极大地提升计算速度
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">p</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">p</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">:</span> <span class="n">res</span> <span class="o">*=</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">%</span> <span class="n">m</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">res</span> <span class="o">%</span> <span class="n">m</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 明文</span>
</span></span><span class="line"><span class="cl"><span class="n">original_msg</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&#34;an example&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;</span><span class="si">{</span><span class="n">original_msg</span><span class="si">=}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 加密</span>
</span></span><span class="line"><span class="cl"><span class="n">msg_int</span> <span class="o">=</span> <span class="n">int_from_bytes</span><span class="p">(</span><span class="n">original_msg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">encrypt_int</span> <span class="o">=</span> <span class="n">msg_int</span> <span class="o">**</span> <span class="n">e</span> <span class="o">%</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="n">encrypt_msg</span> <span class="o">=</span> <span class="n">int_to_bytes</span><span class="p">(</span><span class="n">encrypt_int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;</span><span class="si">{</span><span class="n">encrypt_msg</span><span class="si">=}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 解密</span>
</span></span><span class="line"><span class="cl"><span class="c1"># decrypt_int = encrypt_int ** d % n # 因为 d 非常大，直接使用公式计算会非常非常慢，所以不能这么算</span>
</span></span><span class="line"><span class="cl"><span class="n">decrypt_int</span> <span class="o">=</span> <span class="n">fast_power_modular</span><span class="p">(</span><span class="n">encrypt_int</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">decrypt_msg</span> <span class="o">=</span> <span class="n">int_to_bytes</span><span class="p">(</span><span class="n">decrypt_int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;</span><span class="si">{</span><span class="n">decrypt_msg</span><span class="si">=}</span><span class="s2">&#34;</span><span class="p">)</span>  <span class="c1"># 应该与原信息完全一致</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="rsa-数字签名" class="headerLink">
    <a href="#rsa-%e6%95%b0%e5%ad%97%e7%ad%be%e5%90%8d" class="header-mark"></a>RSA 数字签名</h3><p>前面证明了可以使用公钥加密，再使用私钥解密。</p>
<p>实际上从上面的证明也可以看出来，顺序是完全可逆的，先使用私钥加密，再使用公钥解密也完全是可行的。这种运算被我们用在数字签名算法中。</p>
<p>数字签名的方法为：</p>
<ul>
<li>首先计算原始数据的 Hash 值，比如 SHA256</li>
<li>使用私钥对计算出的 Hash 值进行加密，得到数字签名</li>
<li>其他人使用公开的公钥进行解密出 Hash 值，再对原始数据计算 Hash 值对比，如果一致，就说明数据未被篡改</li>
</ul>
<p>Python 演示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># pip install cryptography==36.0.1</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">sha512</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">cryptography.hazmat.primitives</span> <span class="kn">import</span> <span class="n">serialization</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">key_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&#34;./rsa-private-key.pem&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">private_key</span> <span class="o">=</span> <span class="n">serialization</span><span class="o">.</span><span class="n">load_pem_private_key</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">key_path</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="n">password</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span> <span class="o">=</span> <span class="n">private_key</span><span class="o">.</span><span class="n">private_numbers</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span> <span class="o">=</span> <span class="n">private_key</span><span class="o">.</span><span class="n">public_key</span><span class="p">()</span><span class="o">.</span><span class="n">public_numbers</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">d</span> <span class="o">=</span> <span class="n">private</span><span class="o">.</span><span class="n">d</span>
</span></span><span class="line"><span class="cl"><span class="n">n</span> <span class="o">=</span> <span class="n">public</span><span class="o">.</span><span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="n">e</span> <span class="o">=</span> <span class="n">public</span><span class="o">.</span><span class="n">e</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># RSA sign the message</span>
</span></span><span class="line"><span class="cl"><span class="n">msg</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;A message for signing&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nb">hash</span> <span class="o">=</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">sha512</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="o">.</span><span class="n">digest</span><span class="p">(),</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">signature</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Signature:&#34;</span><span class="p">,</span> <span class="nb">hex</span><span class="p">(</span><span class="n">signature</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># RSA verify signature</span>
</span></span><span class="line"><span class="cl"><span class="n">msg</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;A message for signing&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nb">hash</span> <span class="o">=</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">sha512</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="o">.</span><span class="n">digest</span><span class="p">(),</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">hashFromSignature</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Signature valid:&#34;</span><span class="p">,</span> <span class="nb">hash</span> <span class="o">==</span> <span class="n">hashFromSignature</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="四ecc-密码系统" class="headerLink">
    <a href="#%e5%9b%9becc-%e5%af%86%e7%a0%81%e7%b3%bb%e7%bb%9f" class="header-mark"></a>四、ECC 密码系统</h2><figure><img src="/images/practical-cryptography-basics-7-asymmetric-key-ciphers/ecc.webp"/>
</figure>

<p>ECC 椭圆曲线密码学，于 1985 年被首次提出，并于 2004 年开始被广泛应用。
ECC 被认为是 RSA 的继任者，新一代的非对称加密算法。</p>
<p>其最大的特点在于相同密码强度下，ECC 的密钥和签名的大小都要显著低于 RSA. 256bits 的 ECC 密钥，安全性与 3072bits 的 RSA 密钥安全性相当。</p>
<p>其次 ECC 的密钥对生成、密钥交换与签名算法的速度都要比 RSA 快。</p>
<h3 id="椭圆曲线的数学原理简介" class="headerLink">
    <a href="#%e6%a4%ad%e5%9c%86%e6%9b%b2%e7%ba%bf%e7%9a%84%e6%95%b0%e5%ad%a6%e5%8e%9f%e7%90%86%e7%ae%80%e4%bb%8b" class="header-mark"></a>椭圆曲线的数学原理简介</h3><p>在数学中，椭圆曲线（Elliptic Curves）是一种平面曲线，由如下方程定义的点的集合组成（$A-J$ 均为常数）：</p>
<p>$$
Ax^3 + Bx^2y + Cxy^2 + Dy^3 + Ex^2 + Fxy + Gy^2 + Hx + Iy + J = 0
$$</p>
<p>而 ECC 只使用了其中很简单的一个子集（$a, b$ 均为常数）：</p>
<p>$$
y^2 = x^3 + ax + b
$$</p>
<p>比如著名的 NIST 曲线 secp256k1 就是基于如下椭圆曲线方程：</p>
<p>$$
y^2 = x^3 + 7
$$</p>
<p>椭圆曲线大概长这么个形状：</p>
<blockquote>
<p>椭圆曲线跟椭圆的关系，就犹如雷锋跟雷峰塔、Java 跟 JavaScript&hellip;</p>
</blockquote>
<figure><img src="/images/practical-cryptography-basics-7-asymmetric-key-ciphers/elliptic-curve.webp"/>
</figure>

<p>你可以通过如下网站手动调整 $a$ 与 $b$ 的值，拖动曲线的交点查看图形的变化情况：
<a href="https://www.desmos.com/calculator/ialhd71we3?lang=zh-CN" target="_blank" rel="noopener noreferrer">https://www.desmos.com/calculator/ialhd71we3?lang=zh-CN</a></p>
<h4 id="椭圆曲线上的运算" class="headerLink">
    <a href="#%e6%a4%ad%e5%9c%86%e6%9b%b2%e7%ba%bf%e4%b8%8a%e7%9a%84%e8%bf%90%e7%ae%97" class="header-mark"></a>椭圆曲线上的运算</h4><p>数学家在椭圆曲线上定义了一些运算规则，ECC 就依赖于这些规则，下面简单介绍下我们用得到的部分。</p>
<blockquote>
<p>椭圆曲线上的运算跟我们所熟知的实数域运算不太一样，它在现实生活中并无实际意义，但是它的一些性质使其很适合被应用在密码学中。</p>
</blockquote>
<h5 id="1-加法与负元" class="headerLink">
    <a href="#1-%e5%8a%a0%e6%b3%95%e4%b8%8e%e8%b4%9f%e5%85%83" class="header-mark"></a>1. 加法与负元</h5><p>对于曲线上的任意两点 $A$ 与 $B$，我们定义过 $A, B$ 的直线与曲线的交点为 $-(A+B)$，而 $-(A+B)$ 相对于 x 轴的对称点即为 $A+B$:</p>
<figure><img src="/images/practical-cryptography-basics-7-asymmetric-key-ciphers/ecc-add-operation.webp"/>
</figure>

<p>上述描述一是定义了椭圆曲线的加法规则，二是定义了椭圆曲线上的负元运算。</p>
<h5 id="2-二倍运算" class="headerLink">
    <a href="#2-%e4%ba%8c%e5%80%8d%e8%bf%90%e7%ae%97" class="header-mark"></a>2. 二倍运算</h5><p>在加法规则中，如果 $A=B$，我们定义曲线在 $A$ 点的切线与曲线的交点为 $-2A$，于是得到二倍运算的规则：</p>
<figure><img src="/images/practical-cryptography-basics-7-asymmetric-key-ciphers/ecc-2-times.webp"/>
</figure>

<h5 id="3-无穷远点" class="headerLink">
    <a href="#3-%e6%97%a0%e7%a9%b7%e8%bf%9c%e7%82%b9" class="header-mark"></a>3. 无穷远点</h5><p>对于 $(-A) + A$ 这种一个值与其负元本身相加的情况，我们会发现过这两点的直线与椭圆曲线没有第三个交点，前面定义的加法规则在这种情况下失效了。
为了解决这个问题，我们假设这条直线与椭圆曲线相交于无穷远点 $O_{\infty}$.</p>
<figure><img src="/images/practical-cryptography-basics-7-asymmetric-key-ciphers/ecc-ifinite-point.webp"/>
</figure>

<h5 id="4-k-倍运算" class="headerLink">
    <a href="#4-k-%e5%80%8d%e8%bf%90%e7%ae%97" class="header-mark"></a>4. k 倍运算</h5><p>我们在前面已经定义了椭圆曲线上的<strong>加法运算</strong>、<strong>二倍运算</strong>以及<strong>无穷远点</strong>，有了这三个概念，我们就能定义<strong>k 倍运算</strong> 了。</p>
<p>K 倍运算最简单的计算方法，就是不断地进行加法运算，但是也有许多更高效的算法。
其中最简单的算法是「double-and-add」，它要求首先 $k$ 拆分成如下形式</p>
<p>$$
k = k_{0}+2k_{1}+2^{2}k_{2}+\cdots +2^{m}k_{m} \\
\text{其中} k_{0}~..~k_{m}\in {0,1},m=\lfloor \log _{2}{k}\rfloor
$$</p>
<p>然后再迭代计算其中各项的值，它的运算复杂度为 $log_{2}(k)$.</p>
<p>因 Double 和 Add 的执行时间不同，根据执行时间就可以知道是执行 Double 还是 Add，间接可以推算出 $k$. 因此这个算法会有计时攻击的风险。
基于「double-and-add」修改的蒙哥马利阶梯（Montgomery Ladder）是可以避免计时分析的作法，这里就不详细介绍了。</p>
<h4 id="5-有限域上的椭圆曲线" class="headerLink">
    <a href="#5-%e6%9c%89%e9%99%90%e5%9f%9f%e4%b8%8a%e7%9a%84%e6%a4%ad%e5%9c%86%e6%9b%b2%e7%ba%bf" class="header-mark"></a>5. 有限域上的椭圆曲线</h4><p>椭圆曲线是连续且无限的，而计算机却更擅长处理离散的、存在上限的整数，因此 ECC 使用「有限域上的椭圆曲线」进行计算。</p>
<p>「有限域（也被称作 Galois Filed, 缩写为 GF）」顾名思义，就是指只有有限个数值的域。</p>
<p>有限域上的椭圆曲线方程，通过取模的方式将曲线上的所有值都映射到同一个有限域内。
有限域 $\mathbb {F} _{p}$ 上的 EC 椭圆曲线方程为：</p>
<p>$$
y^2 = x^3 + ax + b (\mod p), 0 \le x \le p
$$</p>
<p>目前主要有两种有限域在 ECC 中被广泛应用：</p>
<ul>
<li>以素数为模的整数域: $\mathbb {F} _{p}$
<ul>
<li>在通用处理器上计算很快</li>
</ul>
</li>
<li>以 2 的幂为模的整数域: $\mathbb {F} _{2^{m}}$
<ul>
<li>当使用专用硬件时，计算速度很快</li>
</ul>
</li>
</ul>
<p>通过限制 x 为整数，并使用取模进行了映射后，椭圆曲线的形状已经面目全非了，它的加减法也不再具有几何意义。
但是它的一些特性仍然跟椭圆曲线很类似，各种公式基本加个 $\mod p$ 就变成了它的有限域版本：</p>
<ul>
<li>无穷远点 $O_{\infty}$ 是零元，$O_{\infty} + O_{\infty} = O_{\infty}$，$O_{\infty} + P = P$</li>
<li>$P_{x, y}$ 的负元为 $P_{x, -y}$,，并且有 $P + (-P) = O_{\infty}$</li>
<li>$P * 0 = O_{\infty}$</li>
<li>如果 $P_{x1, y1} + Q_{x2, y2} = R_{x3, y3}$，则其坐标有如下关系
<ul>
<li>$x3 = (k^2 - x1 - x2) \mod p$</li>
<li>$y3 = (k(x1 - x3) - y1) \mod p$</li>
<li>斜率 $k$ 的计算
<ul>
<li>如果 $P=Q$，则 $k=\dfrac {3x^{2}+a} {2y_{1}}$</li>
<li>否则 $k=\dfrac {y_{2}-y_{1}} {x_{2}-x_{1}} $</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="ecdlp-椭圆曲线离散对数问题" class="headerLink">
    <a href="#ecdlp-%e6%a4%ad%e5%9c%86%e6%9b%b2%e7%ba%bf%e7%a6%bb%e6%95%a3%e5%af%b9%e6%95%b0%e9%97%ae%e9%a2%98" class="header-mark"></a>ECDLP 椭圆曲线离散对数问题</h4><p>前面已经介绍了椭圆曲线上的 <strong>k 倍运算</strong> 及相关的高效算法，但是我们还没有涉及到除法。</p>
<p>椭圆曲线上的除法是一个尚未被解决的难题——「ECDLP 椭圆曲线离散对数问题」：</p>
<blockquote>
<p>已知 $kG$ 与基点 $G$，求整数 $k$ 的值。</p>
</blockquote>
<p>目前并没有有效的手段可以快速计算出 $k$ 的值。
比较直观的方法应该是从基点 $G$ 开始不断进行加法运算，直到结果与 $kG$ 相等。</p>
<p>目前已知的 ECDLP 最快的解法所需步骤为 $\sqrt{k}$，而 <strong>k 倍运算</strong>高效算法前面已经介绍过了，所需步骤为 $log_2(k)$。
在 $k$ 非常大的情况下，它们的计算用时将会有指数级的差距。</p>
<blockquote>
<p>椭圆曲线上的 <strong>k 倍运算</strong>与素数上的幂运算很类似，因此 ECC 底层的数学难题 ECDLP 与 RSA 的离散对数问题 DLP 也有很大相似性。</p>
</blockquote>
<h3 id="ecc-密钥对生成" class="headerLink">
    <a href="#ecc-%e5%af%86%e9%92%a5%e5%af%b9%e7%94%9f%e6%88%90" class="header-mark"></a>ECC 密钥对生成</h3><p>首先，跟 RSA 一样，让我们先看下怎么使用 openssl 生成一个使用 prime256v1 曲线的 ECC 密钥对：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 列出 openssl 支持的所有曲线名称</span>
</span></span><span class="line"><span class="cl">openssl ecparam -list_curves
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 生成 ec 算法的私钥，使用 prime256v1 算法，密钥长度 256 位。（强度大于 2048 位的 RSA 密钥）</span>
</span></span><span class="line"><span class="cl">openssl ecparam -genkey -name prime256v1 -out ecc-private-key.pem
</span></span><span class="line"><span class="cl"><span class="c1"># 通过密钥生成公钥</span>
</span></span><span class="line"><span class="cl">openssl ec -in ecc-private-key.pem -pubout -out ecc-public-key.pem
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 查看私钥内容</span>
</span></span><span class="line"><span class="cl">❯ cat ecc-private-key.pem
</span></span><span class="line"><span class="cl">-----BEGIN EC PARAMETERS-----
</span></span><span class="line"><span class="cl"><span class="nv">BggqhkjOPQMBBw</span><span class="o">==</span>
</span></span><span class="line"><span class="cl">-----END EC PARAMETERS-----
</span></span><span class="line"><span class="cl">-----BEGIN EC PRIVATE KEY-----
</span></span><span class="line"><span class="cl">MHcCAQEEIGm3wT/m4gDaoJGKfAHDXV2BVtdyb/aPTITJR5B6KVEtoAoGCCqGSM49
</span></span><span class="line"><span class="cl">AwEHoUQDQgAE5IEIorw0WU5+om/UgfyYSKosiGO6Hpe8hxkqL5GUVPyu4LJkfw/e
</span></span><span class="line"><span class="cl">99zhNJatliZ1Az/yCKww5KrXC8bQ9wGQvw<span class="o">==</span>
</span></span><span class="line"><span class="cl">-----END EC PRIVATE KEY-----
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 查看私钥的详细参数</span>
</span></span><span class="line"><span class="cl">❯ openssl ec -noout -text -in ecc-private-key.pem
</span></span><span class="line"><span class="cl"><span class="nb">read</span> EC key
</span></span><span class="line"><span class="cl">Private-Key: <span class="o">(</span><span class="m">256</span> bit<span class="o">)</span>
</span></span><span class="line"><span class="cl">priv:
</span></span><span class="line"><span class="cl">    69:b7:c1:3f:e6:e2:00:da:a0:91:8a:7c:01:c3:5d:
</span></span><span class="line"><span class="cl">    5d:81:56:d7:72:6f:f6:8f:4c:84:c9:47:90:7a:29:
</span></span><span class="line"><span class="cl">    51:2d
</span></span><span class="line"><span class="cl">pub: 
</span></span><span class="line"><span class="cl">    04:e4:81:08:a2:bc:34:59:4e:7e:a2:6f:d4:81:fc:
</span></span><span class="line"><span class="cl">    98:48:aa:2c:88:63:ba:1e:97:bc:87:19:2a:2f:91:
</span></span><span class="line"><span class="cl">    94:54:fc:ae:e0:b2:64:7f:0f🇩🇪f7:dc:e1:34:96:
</span></span><span class="line"><span class="cl">    ad:96:26:75:03:3f:f2:08:ac:30:e4:aa:d7:0b:c6:
</span></span><span class="line"><span class="cl">    d0:f7:01:90:bf
</span></span><span class="line"><span class="cl">ASN1 OID: prime256v1
</span></span><span class="line"><span class="cl">NIST CURVE: P-256
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 查看公钥内容</span>
</span></span><span class="line"><span class="cl">❯ cat ecc-public-key.pem 
</span></span><span class="line"><span class="cl">-----BEGIN PUBLIC KEY-----
</span></span><span class="line"><span class="cl">MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE5IEIorw0WU5+om/UgfyYSKosiGO6
</span></span><span class="line"><span class="cl">Hpe8hxkqL5GUVPyu4LJkfw/e99zhNJatliZ1Az/yCKww5KrXC8bQ9wGQvw<span class="o">==</span>
</span></span><span class="line"><span class="cl">-----END PUBLIC KEY-----
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 查看公钥的参数</span>
</span></span><span class="line"><span class="cl">❯ openssl ec -noout -text -pubin -in ecc-public-key.pem
</span></span><span class="line"><span class="cl"><span class="nb">read</span> EC key
</span></span><span class="line"><span class="cl">Private-Key: <span class="o">(</span><span class="m">256</span> bit<span class="o">)</span>
</span></span><span class="line"><span class="cl">pub: 
</span></span><span class="line"><span class="cl">    04:e4:81:08:a2:bc:34:59:4e:7e:a2:6f:d4:81:fc:
</span></span><span class="line"><span class="cl">    98:48:aa:2c:88:63:ba:1e:97:bc:87:19:2a:2f:91:
</span></span><span class="line"><span class="cl">    94:54:fc:ae:e0:b2:64:7f:0f🇩🇪f7:dc:e1:34:96:
</span></span><span class="line"><span class="cl">    ad:96:26:75:03:3f:f2:08:ac:30:e4:aa:d7:0b:c6:
</span></span><span class="line"><span class="cl">    d0:f7:01:90:bf
</span></span><span class="line"><span class="cl">ASN1 OID: prime256v1
</span></span><span class="line"><span class="cl">NIST CURVE: P-256
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到 ECC 算法的公钥私钥都比 RSA 小了非常多，数据量小，却能带来同等的安全强度，这是 ECC 相比 RSA 最大的优势。</p>
<p>私钥的参数：</p>
<ul>
<li><code>priv</code>: 私钥，一个 256bits 的大整数，对应我们前面介绍的 $k 倍运算$中的 $k$</li>
<li><code>pub</code>: 公钥，是一个椭圆曲线（EC）上的坐标 ${x, y}$，也就是我们 well-known 的基点 $G$</li>
<li><code>ASN1 OID</code>: prime256v1, 椭圆曲线的名称</li>
<li><code>NIST CURVE</code>: P-256</li>
</ul>
<p>使用安全随机数生成器即可直接生成出 ECC 的私钥 <code>priv</code>，因此 ECC 的密钥对生成速度非常快。</p>
<h3 id="ecdh-密钥交换" class="headerLink">
    <a href="#ecdh-%e5%af%86%e9%92%a5%e4%ba%a4%e6%8d%a2" class="header-mark"></a>ECDH 密钥交换</h3><p>这个在前面<a href="/posts/practical-cryptography-basics-5-key-exchange/" rel="">写给开发人员的实用密码学（五）—— 密钥交换 DHKE 与完美前向保密 PFS</a>已经介绍过了，不过这里再复述一遍：</p>
<ul>
<li>Alice 跟 Bob 协商好椭圆曲线的各项参数，以及基点 G，这些参数都是公开的。</li>
<li>Alice 生成一个随机的 ECC 密钥对（公钥：$alicePrivate * G$, 私钥: $alicePrivate$）</li>
<li>Bob 生成一个随机的 ECC 密钥对（公钥：$bobPrivate * G$, 私钥: $bobPrivate$）</li>
<li>两人通过不安全的信道交换公钥</li>
<li>Alice 将 Bob 的公钥乘上自己的私钥，得到共享密钥 $sharedKey = (bobPrivate * G) * alicePrivate$</li>
<li>Bob 将 Alice 的公钥乘上自己的私钥，得到共享密钥 $sharedKey = (alicePrivate * G) * bobPrivate$</li>
<li>因为 $(a * G) * b = (b * G) * a$，Alice 与 Bob 计算出的共享密钥应该是相等的</li>
</ul>
<p>这样两方就通过 ECDH 完成了密钥交换。
而 ECDH 的安全性，则由 ECDLP 问题提供保证。</p>
<h3 id="ecc-加密与解密" class="headerLink">
    <a href="#ecc-%e5%8a%a0%e5%af%86%e4%b8%8e%e8%a7%a3%e5%af%86" class="header-mark"></a>ECC 加密与解密</h3><p>ECC 本身并没有提供加密与解密的功能，但是我们可以借助 ECDH 迂回实现加解密。流程如下：</p>
<ol>
<li>Bob 想要将消息 <code>M</code> 安全地发送给 Alice，他手上已经拥有了 Alice 的 ECC 公钥 <code>alicePubKey</code></li>
<li>Bob 首先使用如下算法生成出「共享密钥」+「密文公钥」
<ol>
<li>随机生成一个临时用的密文 ECC 密钥对
<ul>
<li>密文私钥 <code>ciphertextPrivKey</code>：生成一个安全随机数作为私钥即可</li>
<li>密文公钥 <code>ciphertextPubKey</code>：使用此公式从私钥生成 <code>ciphertextPubKey =ciphertextPrivKey * G</code></li>
</ul>
</li>
<li>使用 ECDH 算法计算出「共享密钥」：<code>sharedECCKey = alicePubKey * ciphertextPrivKey</code></li>
<li>为了确保安全性，每份密文都应该使用不同的「<strong>临时 ECC 密钥对</strong>」作为「密文密钥对」，不应该直接使用「Bob 的密钥对」！「Bob 的密钥对」只在 Alice 回复密文消息给 Bob 时才应该被用到。</li>
</ol>
</li>
<li>Bob 使用「共享密钥」与对称加密算法加密消息，得到密文 <code>C</code>
<ul>
<li>比如使用 AES-256-GCM 或者 ChaCha20-Poly1305 进行对称加密</li>
</ul>
</li>
<li>Bob 将 <code>C</code> 与「密文公钥 <code>ciphertextPubKey</code>」打包传输给 Alice</li>
<li>Alice 使用「密文公钥」与自己的私钥计算出「共享密钥」<code>sharedECCKey = ciphertextPubKey * alicePrivKey</code>
<ol>
<li>根据 ECDH 算法可知，这里计算出的共享密钥 <code>sharedECCKey</code>，跟 Bob 加密数据使用的共享密钥是完全一致的</li>
</ol>
</li>
<li>Alice 使用计算出的共享密钥解密 <code>C</code> 得到消息 <code>M</code></li>
</ol>
<p>实际上就是消息的发送方先生成一个临时的 ECC 密钥对，然后借助 ECDH 协议计算出共享密钥用于加密。
消息的接收方同样通过 ECDH 协议计算出共享密钥再解密数据。</p>
<p>使用 Python 演示如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># pip install tinyec  # &lt;= ECC 曲线库</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">tinyec</span> <span class="kn">import</span> <span class="n">registry</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">secrets</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用这条曲线进行演示</span>
</span></span><span class="line"><span class="cl"><span class="n">curve</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="n">get_curve</span><span class="p">(</span><span class="s1">&#39;brainpoolP256r1&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">compress_point</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">hex</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">y</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">ecc_calc_encryption_keys</span><span class="p">(</span><span class="n">pubKey</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    安全地生成一个随机 ECC 密钥对，然后按 ECDH 流程计算出共享密钥 sharedECCKey
</span></span></span><span class="line"><span class="cl"><span class="s2">    最后返回（共享密钥, 临时 ECC 公钥 ciphertextPubKey）
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ciphertextPrivKey</span> <span class="o">=</span> <span class="n">secrets</span><span class="o">.</span><span class="n">randbelow</span><span class="p">(</span><span class="n">curve</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">ciphertextPubKey</span> <span class="o">=</span> <span class="n">ciphertextPrivKey</span> <span class="o">*</span> <span class="n">curve</span><span class="o">.</span><span class="n">g</span>
</span></span><span class="line"><span class="cl">    <span class="n">sharedECCKey</span> <span class="o">=</span> <span class="n">pubKey</span> <span class="o">*</span> <span class="n">ciphertextPrivKey</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">sharedECCKey</span><span class="p">,</span> <span class="n">ciphertextPubKey</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">ecc_calc_decryption_key</span><span class="p">(</span><span class="n">privKey</span><span class="p">,</span> <span class="n">ciphertextPubKey</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">sharedECCKey</span> <span class="o">=</span> <span class="n">ciphertextPubKey</span> <span class="o">*</span> <span class="n">privKey</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sharedECCKey</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 1. 首先生成出 Alice 的 ECC 密钥对</span>
</span></span><span class="line"><span class="cl"><span class="n">privKey</span> <span class="o">=</span> <span class="n">secrets</span><span class="o">.</span><span class="n">randbelow</span><span class="p">(</span><span class="n">curve</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pubKey</span> <span class="o">=</span> <span class="n">privKey</span> <span class="o">*</span> <span class="n">curve</span><span class="o">.</span><span class="n">g</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;private key:&#34;</span><span class="p">,</span> <span class="nb">hex</span><span class="p">(</span><span class="n">privKey</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;public key:&#34;</span><span class="p">,</span> <span class="n">compress_point</span><span class="p">(</span><span class="n">pubKey</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 2. Alice 将公钥发送给 Bob</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 3. Bob 使用 Alice 的公钥生成出（共享密钥, 临时 ECC 公钥 ciphertextPubKey）</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">encryptKey</span><span class="p">,</span> <span class="n">ciphertextPubKey</span><span class="p">)</span> <span class="o">=</span> <span class="n">ecc_calc_encryption_keys</span><span class="p">(</span><span class="n">pubKey</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;ciphertext pubKey:&#34;</span><span class="p">,</span> <span class="n">compress_point</span><span class="p">(</span><span class="n">ciphertextPubKey</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;encryption key:&#34;</span><span class="p">,</span> <span class="n">compress_point</span><span class="p">(</span><span class="n">encryptKey</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 4. Bob 使用共享密钥 encryptKey 加密数据，然后将密文与 ciphertextPubKey 一起发送给 Alice</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 5. Alice 使用自己的私钥 + ciphertextPubKey 计算出共享密钥 decryptKey</span>
</span></span><span class="line"><span class="cl"><span class="n">decryptKey</span> <span class="o">=</span> <span class="n">ecc_calc_decryption_key</span><span class="p">(</span><span class="n">privKey</span><span class="p">,</span> <span class="n">ciphertextPubKey</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;decryption key:&#34;</span><span class="p">,</span> <span class="n">compress_point</span><span class="p">(</span><span class="n">decryptKey</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 6. Alice 使用 decryptKey 解密密文得到原始消息</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="ecc-数字签名" class="headerLink">
    <a href="#ecc-%e6%95%b0%e5%ad%97%e7%ad%be%e5%90%8d" class="header-mark"></a>ECC 数字签名</h3><p>前面已经介绍了 RSA 签名，这里介绍下基于 ECC 的签名算法。</p>
<p>基于 ECC 的签名算法主要有两种：ECDSA 与 EdDSA，以及 EdDSA 的变体。
其中 ECDSA 算法稍微有点复杂，而安全强度跟它基本一致的 EdDSA 的算法更简洁更易于理解，在使用特定曲线的情况下 EdDSA 还要比 ECDSA 更快一点，因此现在通常更推荐使用 <strong>EdDSA</strong> 算法。</p>
<h4 id="eddsa-与-ed25519-签名算法" class="headerLink">
    <a href="#eddsa-%e4%b8%8e-ed25519-%e7%ad%be%e5%90%8d%e7%ae%97%e6%b3%95" class="header-mark"></a>EdDSA 与 Ed25519 签名算法</h4><p>EdDSA（Edwards-curve Digital Signature Algorithm）是一种现代的安全数字签名算法，它使用专为性能优化的椭圆曲线，如 255bits 曲线 edwards25519 和 448bits 曲线 edwards448.</p>
<p>EdDSA 签名算法及其变体 Ed25519 和 Ed448 在技术上在 <a href="https://tools.ietf.org/html/rfc8032" target="_blank" rel="noopener noreferrer">RFC8032</a> 中进行了描述。</p>
<p>首先，用户需要基于 edwards25519 或者 edwards448 曲线，生成一个 ECC 密钥对。
生成私钥的时候，算法首先生成一个随机数，然后会对随机数做一些变换以确保安全性，防范计时攻击等攻击手段。
对于 edwards25519 公私钥都是 32 字节，而对于 edwards448 公私钥都是 57 字节。</p>
<p>对于 edwards25519 输出的签名长度为 64 字节，而对于 Ed448 输出为 114 字节。</p>
<p>具体的算法虽然比 ECDSA 简单，但还是有点难度的，这里就直接略过了。</p>
<p>下面给出个 ed25519 的计算示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># pip install cryptography==36.0.1</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">cryptography.hazmat.primitives.asymmetric.ed25519</span> <span class="kn">import</span> <span class="n">Ed25519PrivateKey</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 也可用 openssl 生成，都没啥毛病</span>
</span></span><span class="line"><span class="cl"><span class="n">private_key</span> <span class="o">=</span> <span class="n">Ed25519PrivateKey</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 签名</span>
</span></span><span class="line"><span class="cl"><span class="n">signature</span> <span class="o">=</span> <span class="n">private_key</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;my authenticated message&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 显然 ECC 的公钥 kG 也能直接从私钥 k 生成</span>
</span></span><span class="line"><span class="cl"><span class="n">public_key</span> <span class="o">=</span> <span class="n">private_key</span><span class="o">.</span><span class="n">public_key</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 验证</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Raises InvalidSignature if verification fails</span>
</span></span><span class="line"><span class="cl"><span class="n">public_key</span><span class="o">.</span><span class="n">verify</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;my authenticated message&#34;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>ed448 的代码也完全类似：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># pip install cryptography==36.0.1</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">cryptography.hazmat.primitives.asymmetric.ed448</span> <span class="kn">import</span> <span class="n">Ed448PrivateKey</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">private_key</span> <span class="o">=</span> <span class="n">Ed448PrivateKey</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">signature</span> <span class="o">=</span> <span class="n">private_key</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;my authenticated message&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">public_key</span> <span class="o">=</span> <span class="n">private_key</span><span class="o">.</span><span class="n">public_key</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Raises InvalidSignature if verification fails</span>
</span></span><span class="line"><span class="cl"><span class="n">public_key</span><span class="o">.</span><span class="n">verify</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;my authenticated message&#34;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="密码学常用椭圆曲线介绍" class="headerLink">
    <a href="#%e5%af%86%e7%a0%81%e5%ad%a6%e5%b8%b8%e7%94%a8%e6%a4%ad%e5%9c%86%e6%9b%b2%e7%ba%bf%e4%bb%8b%e7%bb%8d" class="header-mark"></a>密码学常用椭圆曲线介绍</h3><p>在介绍密码学中的常用椭圆曲线前，需要先介绍一下椭圆曲线的<strong>阶</strong>（order）以及<strong>辅助因子</strong>（cofactor）这两个概念。</p>
<p>首先还得介绍下数学中「循环群」的概念，它是指能由单个元素所生成的群，在 ECC 中这就是预先定义好的基点 $G$.</p>
<p>一个有限域上的椭圆曲线可以形成一个有限「循环代数群」，它由曲线上的所有点组成。椭圆曲线的<strong>阶</strong>被定义为该曲线上所有点的个数（包括无穷远点）。</p>
<p>有些曲线加上 G 点可以形成一个单一循环群，这一个群包含了曲线上的所有点。而其他的曲线加上 G 点则形成多个不相交的循环子群，每个子群包含了曲线的一个子集。
对于上述第二种情况，假设曲线上的点被拆分到了 <strong>h</strong> 个循环子群中，每个子群的<strong>阶</strong>都是 <strong>r</strong>，那这时整个群的阶就是 $n = h * r$，其中子群的个数 <strong>h</strong> 被称为<strong>辅助因子</strong>。</p>
<figure><img src="/images/practical-cryptography-basics-7-asymmetric-key-ciphers/elliptic-curve-subgroups.webp"/>
</figure>

<p>有限域上的椭圆曲线的阶都是有限的，也就是说对于曲线上任意一点 $G$，我们计算它的数乘 $kG$，随着整数 $k$ 的增大，一定会存在某个 $k$ 使 $kG = O_{\infty}$ 成立，然后 $k$ 继续增大时，因为 $O_{\infty} * P = O_{\infty}$，$kG$ 的值就固定为 $O_{\infty}$ 了，更大的 $k$ 值已经失去了意义。</p>
<p>因此 ECC 中要求 $kG$ 中的私钥 $k$ 符合条件 $0 \le k \le r$，也就是说总的私钥数量是受 $r$ 限制的。</p>
<p>辅助因子通过用如下公式表示：</p>
<p>$$
h = n / r
$$</p>
<p>其中 $n$ 是曲线的阶，$r$ 是每个子群的阶，$h$ 是辅助因子。
如果曲线形成了一个单一循环群，那显然 $h = 1$，否则 $h &gt; 1$</p>
<p>举例如下：</p>
<ul>
<li><code>secp256k1</code> 的辅助因子为 1</li>
<li><code>Curve25519</code> 的辅助因子为 8</li>
<li><code>Curve448</code> 的辅助因子为 4</li>
</ul>
<h4 id="生成点-g" class="headerLink">
    <a href="#%e7%94%9f%e6%88%90%e7%82%b9-g" class="header-mark"></a>生成点 G</h4><p>生成点 G 的选择是很有讲究的，虽然每个循环子群都包含有很多个生成点，但是 ECC 只会谨慎的选择其中一个。
首先 G 点必须要能生成出整个循环子群，其次还需要有尽可能高的计算性能。</p>
<p>数学上已知某些椭圆曲线上，不同的生成点生成出的循环子群，阶也是不同的。如果 G 点选得不好，可能会导致生成出的子群的阶较小。
前面我们已经提过子群的阶 $r$ 会限制总的私钥数量，导致算法强度变弱！因此不恰当的 $G$ 点可能会导致我们遭受「<a href="https://datatracker.ietf.org/doc/html/rfc2785" target="_blank" rel="noopener noreferrer">小子群攻击</a>」。
为了避免这种风险，建议尽量使用被广泛使用的加密库，而不是自己撸一个。</p>
<h4 id="椭圆曲线的域参数" class="headerLink">
    <a href="#%e6%a4%ad%e5%9c%86%e6%9b%b2%e7%ba%bf%e7%9a%84%e5%9f%9f%e5%8f%82%e6%95%b0" class="header-mark"></a>椭圆曲线的域参数</h4><p>ECC椭圆曲线由一组椭圆曲线域参数描述，如曲线方程参数、场参数和生成点坐标。这些参数在各种密码学标准中指定，你可以网上搜到相应的 RFC 或 NIST 文档。</p>
<p>这些标准定义了一组命名曲线的参数，例如 secp256k1、P-521、brainpoolP512t1 和 SM2. 这些加密标准中描述的有限域上的椭圆曲线得到了密码学家的充分研究和分析，并被认为具有一定的安全强度。</p>
<p>也有一些密码学家（如 Daniel Bernstein）认为，官方密码标准中描述的大多数曲线都是「不安全的」，并定义了他们自己的密码标准，这些标准在更广泛的层面上考虑了 ECC 安全性。</p>
<p>开发人员应该仅使用各项标准文档给出的、经过密码学家充分研究的命名曲线。</p>
<h5 id="secp256k1" class="headerLink">
    <a href="#secp256k1" class="header-mark"></a>secp256k1</h5><p>此曲线被应用在比特币中，它的域参数如下：</p>
<ul>
<li><em><strong>p</strong></em> (modulus) = <code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F</code></li>
<li><em><strong>n</strong></em> (order; size; the count of all possible EC points) = <code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</code></li>
<li><em><strong>a</strong></em> (方程 $y^2 ≡ x^3 + a*x + b (\mod p)$ 中的常数) = <code>0x0000000000000000000000000000000000000000000000000000000000000000</code></li>
<li><em><strong>b</strong></em> (方程 $y^2 ≡ x^3 + a*x + b (\mod p)$ 中的常数)= <code>0x0000000000000000000000000000000000000000000000000000000000000007</code></li>
<li><em><strong>g</strong></em> (the curve generator point G {x, y}) = (<code>0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798</code>, <code>0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8</code>)</li>
<li><em><strong>h</strong></em> (cofactor, typically 1) = 01</li>
</ul>
<h5 id="edwards-曲线" class="headerLink">
    <a href="#edwards-%e6%9b%b2%e7%ba%bf" class="header-mark"></a>Edwards 曲线</h5><p>椭圆曲线方程除了我们前面使用的 Weierstrass 形式 $$y^2 = (x^3 + ax + b) \mod p$$ 外，还可以被写成其他多种形式，这些不同的形式是<a href="https://zh.wikipedia.org/zh-hans/%E6%9C%89%E7%90%86%E6%98%A0%E5%B0%84" target="_blank" rel="noopener noreferrer">双有理等价</a>的（别问，我也不懂什么叫「双有理等价」&hellip;）。
不同的方程形式在计算机的数值计算上可能会存在区别。</p>
<p>为了性能考虑，ECC 在部分场景下会考虑使用 Edwards 曲线形式进行计算，该方程形式如下：</p>
<p>$$
x^{2}+y^{2}=1+dx^{2}y^{2}
$$</p>
<p>画个图长这样：</p>
<p><a class="lightgallery" href="/images/practical-cryptography-basics-7-asymmetric-key-ciphers/edwards-curve.webp" title="/images/practical-cryptography-basics-7-asymmetric-key-ciphers/edwards-curve.webp" data-thumbnail="/images/practical-cryptography-basics-7-asymmetric-key-ciphers/edwards-curve.webp">
        <img
            class="lazyload"
            data-src="/images/practical-cryptography-basics-7-asymmetric-key-ciphers/edwards-curve.webp"
            data-srcset="/images/practical-cryptography-basics-7-asymmetric-key-ciphers/edwards-curve.webp, /images/practical-cryptography-basics-7-asymmetric-key-ciphers/edwards-curve.webp 1.5x, /images/practical-cryptography-basics-7-asymmetric-key-ciphers/edwards-curve.webp 2x"
            data-sizes="auto"
            alt="/images/practical-cryptography-basics-7-asymmetric-key-ciphers/edwards-curve.webp">
    </a></p>
<p>知名的 Edwards 曲线有：</p>
<ul>
<li>Curve1174 (251-bit)</li>
<li>Curve25519 (255-bit)</li>
<li>Curve383187 (383-bit)</li>
<li>Curve41417 (414-bit)</li>
<li>Curve448 (448-bit)</li>
<li>E-521 (521-bit)</li>
<li>&hellip;</li>
</ul>
<h5 id="curve25519-x25519-和-ed25519" class="headerLink">
    <a href="#curve25519-x25519-%e5%92%8c-ed25519" class="header-mark"></a>Curve25519, X25519 和 Ed25519</h5><blockquote>
<p><a href="https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ed25519/" target="_blank" rel="noopener noreferrer">https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ed25519/</a></p>
</blockquote>
<p>只要域参数选得好，Edwards 就可以以非常高的性能实现 ECC 密钥交换、数字签名、混合加密方案。</p>
<p>一个例子就是 <a href="https://en.wikipedia.org/wiki/Curve25519" target="_blank" rel="noopener noreferrer">Curve25519</a>，它是 Edwards 曲线，其 Montgomery 形式的定义如下：</p>
<p>$$
y^{2}=x^{3}+486662x^{2}+x
$$</p>
<p>其被定义在有限域 $\mathbb {F} _{p}$ 上，$p = 2255 - 19$, 其他域参数如下：</p>
<ul>
<li>阶 <code>n = 2252 + 0x14def9dea2f79cd65812631a5cf5d3ed</code></li>
<li>辅因子 <code>h = 8</code></li>
</ul>
<p>虽然此曲线并未以 Edwards 形式定义，但是它已被证明与如下扭曲 Edwards 曲线（<code>edwards25519</code>）双有理等价：</p>
<p>$$
-x^2 + y^2 = 1 + 37095705934669439343138083508754565189542113879843219016388785533085940283555 x^2 y^2
$$</p>
<p>上面给出的这种 Edwards 形式与前文给出的 Weierstrass 形式完全等价，是专为计算速度优化而设计成这样的。</p>
<p>Curve25519 由 Daniel Bernstein 领导的密码学家团队精心设计，在多个设计和实现层面上达成了非常高的性能，同时不影响安全性。</p>
<p>Curve25519 的构造使其避免了许多潜在的实现缺陷。根据设计，它不受定时攻击的影响，并且它接受任何 32 字节的字符串作为有效的公钥，并且不需要验证。
它能提供 125.8bits 的安全强度（有时称为 ~ 128bits 安全性）</p>
<p>Curve25519 的私钥为 251 位，通常编码为 256 位整数（32 个字节，64 个十六进制数字）。
公钥通常也编码为 256 位整数（255 位 y 坐标 + 1 位 x 坐标），这对开发人员来说非常方便。</p>
<p>基于 Curve25519 派生出了名为 <a href="https://en.wikipedia.org/wiki/Curve25519" target="_blank" rel="noopener noreferrer">X25519</a> 的 ECDH 算法，以及基于 EdDSA 的高速数字签名算法 <a href="https://en.wikipedia.org/wiki/EdDSA#Ed25519" target="_blank" rel="noopener noreferrer">Ed25519</a>.</p>
<h5 id="curve448-x448-和-ed448" class="headerLink">
    <a href="#curve448-x448-%e5%92%8c-ed448" class="header-mark"></a>Curve448, X448 和 Ed448</h5><blockquote>
<p><a href="https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ed448/" target="_blank" rel="noopener noreferrer">https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ed448/</a></p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Curve448" target="_blank" rel="noopener noreferrer">Curve448</a>（Curve448-Goldilocks）是一种非扭曲 Edwards 曲线，它的方程定义如下：</p>
<p>$$
x^2 + y^2 = 1 - 39081 x^2 y^2
$$</p>
<p>其被定义在有限域 $\mathbb {F} _{p}$ 上，$p = 2448 - 2224 - 1$，其他域参数：</p>
<ul>
<li>阶 <code>n = 2446 - 0x8335dc163bb124b65129c96fde933d8d723a70aadc873d6d54a7bb0d</code></li>
<li>辅助因子 <code>h = 4</code></li>
</ul>
<p>与 Curve25519 一样，Curve448 也等价于前面给出的 Weierstrass 形式，选择 Edwards 形式主要是因为它能显著提升性能。</p>
<p>Curve448 提供 222.8 位的安全强度。
Curve448 的私钥为 446 位，通常编码为 448 位整数（56 个字节，112 个十六进制数字）。
公钥也被编码为 448 位整数。</p>
<p>基于 Curve448 派生出了名为 <a href="https://tools.ietf.org/html/rfc7748#section-5" target="_blank" rel="noopener noreferrer">X448</a> 的 ECDH 算法，以及基于 EdDSA 的高速数字签名算法 <a href="https://tools.ietf.org/html/rfc8032#section-5.2" target="_blank" rel="noopener noreferrer">Ed448</a>.</p>
<h5 id="该选择哪种椭圆曲线" class="headerLink">
    <a href="#%e8%af%a5%e9%80%89%e6%8b%a9%e5%93%aa%e7%a7%8d%e6%a4%ad%e5%9c%86%e6%9b%b2%e7%ba%bf" class="header-mark"></a>该选择哪种椭圆曲线</h5><p>首先，Bernstein 的 SafeCurves 标准列出了符合一组 ECC 安全要求的安全曲线，可访问 <a href="https://safecurves.cr.yp.to" target="_blank" rel="noopener noreferrer">https://safecurves.cr.yp.to</a> 了解此标准。</p>
<p>此外对于我们前面介绍的 Curve448 与 Curve25519，可以从性能跟安全性方面考量：</p>
<ul>
<li>要更好的性能，可以接受弱一点的安全性：选择 Curve25519</li>
<li>要更好的安全性，可以接受比 Curve25519 慢 3 倍的计算速度：选择 Curve448</li>
</ul>
<p>如果你的应用场景中暂时还很难用上 Curve448/Curve25519，你可以考虑一些应用更广泛的其他曲线，但是一定要遵守如下安全规范：</p>
<ul>
<li>模数 p 应该至少有 256 位
<ul>
<li>比如 <code>secp224k1</code> <code>secp192k1</code> 啥的就可以扫进历史尘埃里了</li>
</ul>
</li>
<li>暂时没有想补充的，可以参考 <a href="https://safecurves.cr.yp.to" target="_blank" rel="noopener noreferrer">https://safecurves.cr.yp.to</a></li>
</ul>
<p>目前在 TLS 协议以及 JWT 签名算法中，目前应该最广泛的椭圆曲线仍然是 NIST 系列：</p>
<ul>
<li><code>P-256</code>: 到目前为止 P-256 应该仍然是应用最为广泛的椭圆曲线
<ul>
<li>在 openssl 中对应的名称为 <code>prime256v1</code></li>
</ul>
</li>
<li><code>P-384</code>
<ul>
<li>在 openssl 中对应的名称为 <code>secp384r1</code></li>
</ul>
</li>
<li><code>P-521</code>
<ul>
<li>在 openssl 中对应的名称为 <code>secp521r1</code></li>
</ul>
</li>
</ul>
<p>但是我们也看到 Curve25519 正在越来越流行，因为美国政府有前科，NIST 标准被怀疑可能有后门，目前很多人都在推动使用 Curve25519 等社区方案取代掉 NIST 标准曲线。</p>
<p>对于 openssl，如下命令会列出 openssl 支持的所有曲线：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">openssl ecparam -list_curves
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="ecies---集成加密方案" class="headerLink">
    <a href="#ecies---%e9%9b%86%e6%88%90%e5%8a%a0%e5%af%86%e6%96%b9%e6%a1%88" class="header-mark"></a>ECIES - 集成加密方案</h3><p>在文章开头我们已经介绍了集成加密方案 (IES)，它在密钥封装机制（KEM）的基础上，添加了密钥派生算法 KDF、消息认证算法 MAC 等其他密码学算法以达成我们对消息的安全性、真实性、完全性的需求。</p>
<p>而 ECIES 也完全类似，是在 ECC + 对称加密算法的基础上，添加了许多其他的密码学算法实现的。</p>
<p>ECIES 是一个加密框架，而不是某种固定的算法。它可以通过插拔不同的算法，形成不同的实现。
比如「secp256k1 + Scrypt + AES-GCM + HMAC-SHA512」。</p>
<p>大概就介绍到这里吧，后续就请在需要用到时自行探索相关的细节咯。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://github.com/nakov/Practical-Cryptography-for-Developers-Book" target="_blank" rel="noopener noreferrer">Practical-Cryptography-for-Developers-Book</a></li>
<li><a href="https://dev.to/techschoolguru/a-complete-overview-of-ssl-tls-and-its-cryptographic-system-36pd" target="_blank" rel="noopener noreferrer">A complete overview of SSL/TLS and its cryptographic system</a></li>
<li><a href="https://www.oscca.gov.cn/sca/zxfw/2017-04/24/content_1011711.shtml" target="_blank" rel="noopener noreferrer">密码发展史之近现代密码 - 中国国家密码管理局</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc6090" target="_blank" rel="noopener noreferrer">RFC6090 - Fundamental Elliptic Curve Cryptography Algorithms</a></li>
<li><a href="https://security.stackexchange.com/questions/78621/which-elliptic-curve-should-i-use" target="_blank" rel="noopener noreferrer">Which elliptic curve should I use?</a></li>
</ul>
]]></content></entry><entry><title type="html">写给开发人员的实用密码学（六）—— 对称密钥加密算法</title><link href="https://thiscute.world/posts/practical-cryptography-basics-6-symmetric-key-ciphers/"/><id>https://thiscute.world/posts/practical-cryptography-basics-6-symmetric-key-ciphers/</id><author><name>ryan4yin</name></author><published>2022-03-06T18:44:00+08:00</published><updated>2022-03-06T18:44:00+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/practical-cryptography-basics-6-symmetric-key-ciphers/symmetric-vs-asymmetric.webp" height="909" width="287"><figcaption></figcaption>
        </figure><blockquote>
<p>本文主要翻译自 <a href="https://github.com/nakov/Practical-Cryptography-for-Developers-Book" target="_blank" rel="noopener noreferrer">Practical-Cryptography-for-Developers-Book</a>，笔者补充了部分代码示例。</p>
</blockquote>
<p>《写给开发人员的实用密码学》系列文章目录：</p>
<ul>
<li><a href="/posts/practical-cryptography-basics-1/" rel="">写给开发人员的实用密码学（一）—— 概览</a></li>
<li><a href="/posts/practical-cryptography-basics-2-hash/" rel="">写给开发人员的实用密码学（二）—— 哈希函数</a></li>
<li><a href="/posts/practical-cryptography-basics-3-key-derivation-function/" rel="">写给开发人员的实用密码学（三）—— MAC 与密钥派生函数 KDF</a></li>
<li><a href="/posts/practical-cryptography-basics-4-secure-random-generators/" rel="">写给开发人员的实用密码学（四）—— 安全随机数生成器 CSPRNG</a></li>
<li><a href="/posts/practical-cryptography-basics-5-key-exchange/" rel="">写给开发人员的实用密码学（五）—— 密钥交换 DHKE 与完美前向保密 PFS</a></li>
<li><a href="/posts/practical-cryptography-basics-6-symmetric-key-ciphers/" rel="">写给开发人员的实用密码学（六）—— 对称密钥加密算法</a></li>
<li><a href="/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/" rel="">写给开发人员的实用密码学（七）—— 非对称密钥加密算法 RSA/ECC</a></li>
<li><a href="/posts/about-tls-cert" rel="">写给开发人员的实用密码学（八）—— 数字证书与 TLS 协议</a></li>
<li>待续</li>
</ul>
<h2 id="零术语介绍" class="headerLink">
    <a href="#%e9%9b%b6%e6%9c%af%e8%af%ad%e4%bb%8b%e7%bb%8d" class="header-mark"></a>零、术语介绍</h2><p>两个常用动词：</p>
<ul>
<li>加密：cipher 或者 encrypt</li>
<li>解密：decipher 或者 decrypt</li>
</ul>
<p>另外有几个名词有必要解释：</p>
<ul>
<li>cipher: 指用于加解密的「密码算法」，有时也被直接翻译成「密码」</li>
<li>cryptographic algorithm: 密码学算法，泛指密码学相关的各类算法</li>
<li>ciphertext: 密文，即加密后的信息。对应的词是明文 plaintext</li>
<li>password: 这个应该不需要解释，就是我们日常用的各种字符或者数字密码，也可称作口令。</li>
<li><a href="https://en.wikipedia.org/wiki/Passphrase" target="_blank" rel="noopener noreferrer">passphrase</a>: 翻译成「密码词组」或者「密碼片語」，通常指用于保护密钥或者其他敏感数据的一个 password
<ul>
<li>如果你用 ssh/gpg/openssl 等工具生成或使用过密钥，应该对它不陌生。</li>
</ul>
</li>
</ul>
<p>在密码学里面，最容易搞混的词估计就是「密码」了，cipher/password/passphrase 都可以被翻译成「密码」，需要注意下其中区别。</p>
<h2 id="一什么是对称加密" class="headerLink">
    <a href="#%e4%b8%80%e4%bb%80%e4%b9%88%e6%98%af%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86" class="header-mark"></a>一、什么是对称加密</h2><p>在密码学中，有两种加密方案被广泛使用：「对称加密」与「非对称加密」。</p>
<p>对称加密是指，使用相同的密钥进行消息的加密与解密。因为这个特性，我们也称这个密钥为「共享密钥（Shared Secret Key）」，示意图如下：</p>
<figure><img src="/images/practical-cryptography-basics-6-symmetric-key-ciphers/symmetric-cryptography.webp"/>
</figure>

<p>现代密码学中广泛使用的对称加密算法（ciphers）有：AES（AES-128、AES-192、AES-256）、ChaCha20、Twofish、IDEA、Serpent、Camelia、RC6、CAST 等。
其中绝大多数都是「<strong>块密码算法</strong>（Block Cipher）」或者叫「<strong>分组密码算法</strong>」，这种算法一次只能加密固定大小的块（例如 128 位）；
少部分是「<strong>流密码算法</strong>（Stream Cipher）」，流密码算法将数据逐字节地加密为密文流。</p>
<p>通过使用称为「分组密码工作模式」的技术，可以将「分组密码算法」转换为「流密码算法」。</p>
<h3 id="量子安全性" class="headerLink">
    <a href="#%e9%87%8f%e5%ad%90%e5%ae%89%e5%85%a8%e6%80%a7" class="header-mark"></a>量子安全性</h3><p>即使计算机进入量子时代，仍然可以沿用当前的对称密码算法。因为大多数现代对称密钥密码算法都是<strong>抗量子的</strong>（<strong>quantum-resistant</strong>），这意味当使用长度足够的密钥时，强大的量子计算机无法破坏其安全性。
目前来看 256 位的 AES/Twofish 在很长一段时间内都将是 <strong>量子安全</strong> 的。</p>
<h2 id="二对称加密方案的结构" class="headerLink">
    <a href="#%e4%ba%8c%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e6%96%b9%e6%a1%88%e7%9a%84%e7%bb%93%e6%9e%84" class="header-mark"></a>二、对称加密方案的结构</h2><p>我们在第一章「概览」里介绍过，单纯使用数据加密算法只能保证数据的<strong>安全性</strong>，并不能满足我们对消息<strong>真实性、完整性与不可否认性</strong>的需求，因此通常我们会将对称加密算法跟其他算法组合成一个「<strong>对称加密方案</strong>」来使用，这种多个密码学算法组成的「加密方案」能同时保证数据的安全性、真实性、完整性与不可否认性。</p>
<p>一个<strong>分组加密方案</strong>通常会包含如下几种算法：</p>
<ul>
<li>将密码转换为密钥的<strong>密钥派生算法 KDF</strong>（如 Scrypt 或 Argon2）：通过使用 KDF，加密方案可以允许用户使用字符密码作为「Shared Secret Key」，并使密码的破解变得困难和缓慢</li>
<li><strong>分组密码工作模式</strong>（用于将分组密码转换为流密码，如 CBC 或 CTR）+ <strong>消息填充算法</strong>（如 PKCS7）：分组密码算法（如 AES）需要借助这两种算法，才能加密任意大小的数据</li>
<li><strong>分组密码算法</strong>（如 AES）：使用密钥安全地加密固定长度的数据块
<ul>
<li>大多数流行的对称加密算法，都是分组密码算法</li>
</ul>
</li>
<li><strong>消息认证算法</strong>（如HMAC）：用于验证消息的真实性、完整性、不可否认性</li>
</ul>
<p>而一个<strong>流密码加密方案</strong>本身就能加密任意长度的数据，因此不需要「分组密码模式」与「消息填充算法」。</p>
<p>如 AES-256-CTR-HMAC-SHA256 就表示一个使用 AES-256 与 Counter 分组模式进行加密，使用 HMAC-SHA256 进行消息认证的加密方案。
其他流行的对称加密方案还有 ChaCha20-Poly1305 和 AES-128-GCM 等，其中 ChaCha20-Poly130 是一个流密码加密方案。我们会在后面单独介绍这两种加密方案。</p>
<h2 id="三分组密码工作模式" class="headerLink">
    <a href="#%e4%b8%89%e5%88%86%e7%bb%84%e5%af%86%e7%a0%81%e5%b7%a5%e4%bd%9c%e6%a8%a1%e5%bc%8f" class="header-mark"></a>三、分组密码工作模式</h2><p>前面简单介绍了「<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation" target="_blank" rel="noopener noreferrer"><strong>分组密码工作模式</strong></a>」可以将「分组密码算法」转换为「流密码算法」，从而实现加密任意长度的数据，这里主要就具体介绍下这个分组密码工作模式（下文简称为「<strong>分组模式</strong>」或者「<strong>XXX 模式</strong>」）。</p>
<p>加密方案的名称中就带有具体的「分组模式」名称，如：</p>
<ul>
<li><strong>AES-256-GCM</strong> - 具有 256 位加密密钥和 GCM 分组模式的 AES 密码</li>
<li><strong>AES-128-CTR</strong> - 具有 128 位加密密钥和 CTR 分组模式的 AES 密码</li>
<li><strong>Serpent-128-CBC</strong> - 具有 128 位加密密钥和 CBC 分组模式的 Serpent 密码</li>
</ul>
<p>「分组密码工作模式」背后的主要思想是把明文分成多个长度固定的组，再在这些分组上重复应用分组密码算法进行加密/解密，以实现安全地加密/解密任意长度的数据。</p>
<p>某些分组模式（如 CBC）要求将输入拆分为分组，并使用填充算法（例如添加特殊填充字符）将最末尾的分组填充到块大小。
也有些分组模式（如 CTR、CFB、OFB、CCM、EAX 和 GCM）根本不需要填充，因为它们在每个步骤中，都直接在明文部分和内部密码状态之间执行异或（XOR）运算.</p>
<p>使用「分组模式」加密大量数据的流程基本如下：</p>
<ul>
<li>初始化加密算法状态（使用加密密钥 + 初始向量 IV）</li>
<li>加密数据的第一个分组</li>
<li>使用加密密钥和其他参数转换加密算法的当前状态</li>
<li>加密下一个分组</li>
<li>再次转换加密状态</li>
<li>再加密下一分组</li>
<li>依此类推，直到处理完所有输入数据</li>
</ul>
<p>解密的流程跟加密完全类似：先初始化算法，然后依次解密所有分组，中间可能会涉及到加密状态的转换。</p>
<p>下面我们来具体介绍下 CTR 与 GCM 两个常见的分组模式。</p>
<h3 id="0-初始向量-iv" class="headerLink">
    <a href="#0-%e5%88%9d%e5%a7%8b%e5%90%91%e9%87%8f-iv" class="header-mark"></a>0. 初始向量 IV</h3><p>介绍具体的分组模式前，需要先了解下<strong>初始向量 IV</strong>（Initialization Vector）这个概念，它有时也被称作 Salt 或者 Nonce。
初始向量 IV 通常是一个随机数，主要作用是往密文中添加随机性，使同样的明文被多次加密也会产生不同的密文，从而确保密文的不可预测性。</p>
<p>IV 的大小应与密码块大小相同，例如 AES、Serpent 和 Camellia 都只支持 128 位密码块，那么它们需要的 IV 也必须也 128 位。</p>
<p>IV 通常无需保密，但是应当足够随机（无法预测），而且不允许重用，应该对每条加密消息使用随机且不可预测的 IV。</p>
<p>一个常见错误是使用相同的对称密钥和<strong>相同的 IV</strong> 加密多条消息，这使得针对大多数分组模式的各种加密攻击成为可能。</p>
<h3 id="counter_mode" class="headerLink">
    <a href="#counter_mode" class="header-mark"></a>1. CTR (Counter) 分组模式</h3><blockquote>
<p>参考文档: <a href="https://csrc.nist.gov/publications/detail/sp/800-38a/final" target="_blank" rel="noopener noreferrer">https://csrc.nist.gov/publications/detail/sp/800-38a/final</a></p>
</blockquote>
<p>下图说明了「CTR 分组工作模式」的加密解密流程，基本上就是将明文/密文拆分成一个个长度固定的分组，然后使用一定的算法进行加密与解密：</p>
<figure><img src="/images/practical-cryptography-basics-6-symmetric-key-ciphers/CTR_encryption.svg"/>
</figure>

<figure><img src="/images/practical-cryptography-basics-6-symmetric-key-ciphers/CTR_decryption.svg"/>
</figure>

<p>可以看到两图中左边的第一个步骤，涉及到三个参数：</p>
<ul>
<li><code>Nonce</code>，初始向量 IV 的别名，前面已经介绍过了。</li>
<li><code>Counter</code>: 一个计数器，最常用的 Counter 实现是「从 0 开始，每次计算都自增 1」</li>
<li><code>Key</code>: 对称加密的密钥</li>
<li><code>Plaintext</code>: 明文的一个分组。除了最后一个分组外，其他分组的长度应该跟 <code>Key</code> 相同</li>
</ul>
<p>CTR 模式加解密的算法使用公式来表示如下：</p>
<p>$$
\begin{alignedat}{2}
C_i &amp;= P_i \oplus O_i, \ &amp;\text{for } i &amp;= 1, 2 &hellip; n-1 \\
P_i &amp;= C_i \oplus O_i, \ &amp;\text{for } i &amp;= 1, 2 &hellip; n-1 \\
O_i &amp;= \text{CIPH}_{key}(\text{Nonce} + I_i), \ &amp;\text{for } i &amp;= 1, 2 &hellip; n-1
\end{alignedat}
$$</p>
<p>公式的符号说明如下</p>
<ul>
<li>$C_i$ 表示密文的第 $i$ 个分组</li>
<li>$P_i$ 表示明文的第 $i$ 个 分组</li>
<li>$O_i$ 是一个中间量，第三个公式是它的计算方法</li>
<li>$I_i$ 表示计数器返回的第 $i$ 个值，其长度应与分组的长度相同</li>
<li>$\text{CIPH}_{key}$ 表示使用密钥 $key$ 的对称加密算法</li>
</ul>
<p>上面的公式只描述了 $ 0 \ge i \le n-1$ 的场景，最后一个分组  $i = n$ 要特殊一些——它的长度可能比 <code>Key</code> 要短。
CTR 模式加解密这最后这个分组时，会直接忽略掉 $O_n$ 末尾多余的 bytes.
这种处理方式使得 CTR 模式不需要使用填充算法对最后一个分组进行填充，而且还使密文跟明文的长度完全一致。
我们假设最后一个分组的长度为 $u$，它的加解密算法描述如下（$MSB_u(O_n)$ 表示取 $O_n$ 的 u 个最高有效位）：</p>
<p>$$
\begin{alignedat}{2}
C_{n} &amp;= P_{n} \oplus {MSB_u}(O_n) \\
P_{n} &amp;= C_{n} \oplus {MSB_u}(O_n)\\
O_n &amp;= \text{CIPH}_{key}(\text{Nonce} + I_n)
\end{alignedat}
$$</p>
<p>可以看到，因为异或 XOR 的对称性，加密跟解密的算法是完全相同的，直接 XOR $O_i$ 即可。</p>
<p>Python 中最流行的密码学库是 <a href="https://github.com/pyca/cryptography" target="_blank" rel="noopener noreferrer">cryptography</a>，<code>requests</code> 的底层曾经就使用了它（新版本已经换成使用标准库 ssl 了），下面我们使用这个库来演示下 AES-256-CTR 算法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># pip install cryptography==36.0.1</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">cryptography.hazmat.primitives.ciphers</span> <span class="kn">import</span> <span class="n">Cipher</span><span class="p">,</span> <span class="n">algorithms</span><span class="p">,</span> <span class="n">modes</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">plaintext</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&#34;this is a test message, hahahahahaha~&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 32bytes 的 key，即使用算法 AES-256-CTR</span>
</span></span><span class="line"><span class="cl"><span class="n">key</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># key =&gt; b&#39;\x96\xec.\xc7\xd5\x1b/5\xa1\x10s\x9d\xd5\x10z\xdc\x90\xb5\x1cm&#34;&gt;x\xfd \xd5\xc5\xaf\x19\xd1Z\xbb&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># AES 算法的 block 大小是固定的 128bits，即 16 bytes, IV 长度需要与 block 一致</span>
</span></span><span class="line"><span class="cl"><span class="n">iv</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># iv =&gt; b&#39;\x88[\xc9\n`\xe4\xc2^\xaf\xdc\x1e\xfd.c&gt;=&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 1. 发送方加密数据</span>
</span></span><span class="line"><span class="cl"><span class="c1">## 构建 AES-256-CTR 的 cipher，然后加密数据，得到密文</span>
</span></span><span class="line"><span class="cl"><span class="n">cipher</span> <span class="o">=</span> <span class="n">Cipher</span><span class="p">(</span><span class="n">algorithms</span><span class="o">.</span><span class="n">AES</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">modes</span><span class="o">.</span><span class="n">CTR</span><span class="p">(</span><span class="n">iv</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">encryptor</span> <span class="o">=</span> <span class="n">cipher</span><span class="o">.</span><span class="n">encryptor</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">ciphertext</span> <span class="o">=</span> <span class="n">encryptor</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">plaintext</span><span class="p">)</span> <span class="o">+</span> <span class="n">encryptor</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># ciphertext =&gt; b&#39;\x9b6(\x1d\xfd\xde\x96S\x8b\x8f\x90\xc5}ou\x9e\xb1\xbd\x9af\xb8\xdc\xec\xbf\xa3&#34;\x18^\xac\x14\xc8s2*\x1a\xcf\x1d&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 2. 发送方将 iv + ciphertext 发送给接收方</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 3. 接收方解密数据</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 接收方使用自己的 key + 接收到的 iv，构建 cipher，然后解密出原始数据</span>
</span></span><span class="line"><span class="cl"><span class="n">cipher</span> <span class="o">=</span> <span class="n">Cipher</span><span class="p">(</span><span class="n">algorithms</span><span class="o">.</span><span class="n">AES</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">modes</span><span class="o">.</span><span class="n">CTR</span><span class="p">(</span><span class="n">iv</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">decryptor</span> <span class="o">=</span> <span class="n">cipher</span><span class="o">.</span><span class="n">decryptor</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">decryptor</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">)</span> <span class="o">+</span> <span class="n">decryptor</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从上面的算法描述能感觉到，CTR 算法还蛮简单的。下面我使用 Python 写一个能够 work 的 CTR 实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">xor_bytes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;Returns a new byte array with the elements xor&#39;ed.
</span></span></span><span class="line"><span class="cl"><span class="s2">       if len(a) != len(b), extra parts are discard.
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">i</span><span class="o">^</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">inc_bytes</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34; Returns a new byte array with the value increment by 1 &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">out</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">))):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">split_blocks</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">require_padding</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    Split `message` with fixed length `block_size`
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">message</span><span class="p">)</span> <span class="o">%</span> <span class="n">block_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">require_padding</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">[</span><span class="n">message</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">16</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">message</span><span class="p">),</span> <span class="n">block_size</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">encrypt_ctr</span><span class="p">(</span><span class="n">block_cipher</span><span class="p">,</span> <span class="n">plaintext</span><span class="p">,</span> <span class="n">iv</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    Encrypts `plaintext` using CTR mode with the given nounce/IV.
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">16</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">blocks</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">nonce</span> <span class="o">=</span> <span class="n">iv</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">plaintext_block</span> <span class="ow">in</span> <span class="n">split_blocks</span><span class="p">(</span><span class="n">plaintext</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">require_padding</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># CTR mode encrypt: plaintext_block XOR encrypt(nonce)</span>
</span></span><span class="line"><span class="cl">        <span class="n">o</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">block_cipher</span><span class="o">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">nonce</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="n">block</span> <span class="o">=</span> <span class="n">xor_bytes</span><span class="p">(</span><span class="n">plaintext_block</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>  <span class="c1"># extra parts of `o` are discard in this step</span>
</span></span><span class="line"><span class="cl">        <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">nonce</span> <span class="o">=</span> <span class="n">inc_bytes</span><span class="p">(</span><span class="n">nonce</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 加密与解密的算法完全一致</span>
</span></span><span class="line"><span class="cl"><span class="n">decrypt_ctr</span> <span class="o">=</span> <span class="n">encrypt_ctr</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来验证下算法的正确性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Python 官方库未提供 AES 实现，因此需要先装下这个库：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># pip install pyaes==1.6.1</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pyaes</span> <span class="kn">import</span> <span class="n">AES</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># AES-256-CTR - plaintext key 都与前面的测试代码完全一致</span>
</span></span><span class="line"><span class="cl"><span class="n">plaintext</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&#34;this is a test message, hahahahahaha~&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">key</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x96\xec</span><span class="s1">.</span><span class="se">\xc7\xd5\x1b</span><span class="s1">/5</span><span class="se">\xa1\x10</span><span class="s1">s</span><span class="se">\x9d\xd5\x10</span><span class="s1">z</span><span class="se">\xdc\x90\xb5\x1c</span><span class="s1">m&#34;&gt;x</span><span class="se">\xfd</span><span class="s1"> </span><span class="se">\xd5\xc5\xaf\x19\xd1</span><span class="s1">Z</span><span class="se">\xbb</span><span class="s1">&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 1. 发送方加密数据</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 首先生成一个随机 IV，为了对比，这里使用前面生成好的数据</span>
</span></span><span class="line"><span class="cl"><span class="n">iv</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x88</span><span class="s1">[</span><span class="se">\xc9\n</span><span class="s1">`</span><span class="se">\xe4\xc2</span><span class="s1">^</span><span class="se">\xaf\xdc\x1e\xfd</span><span class="s1">.c&gt;=&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">aes_cipher</span> <span class="o">=</span> <span class="n">AES</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ciphertext</span> <span class="o">=</span> <span class="n">encrypt_ctr</span><span class="p">(</span><span class="n">aes_cipher</span><span class="p">,</span> <span class="n">plaintext</span><span class="p">,</span> <span class="n">iv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;ciphertext =&gt;&#34;</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">))</span> <span class="c1"># 输出应该与前面用 cryptography 计算出来的完全一致</span>
</span></span><span class="line"><span class="cl"><span class="c1"># ciphertext =&gt; b&#39;\x9b6(\x1d\xfd\xde\x96S\x8b\x8f\x90\xc5}ou\x9e\xb1\xbd\x9af\xb8\xdc\xec\xbf\xa3&#34;\x18^\xac\x14\xc8s2*\x1a\xcf\x1d&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 2. 发送方将 ciphertext + iv 发送给接收方</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 3. 接收方使用自己的 key 解密数据</span>
</span></span><span class="line"><span class="cl"><span class="n">aes_cipher</span> <span class="o">=</span> <span class="n">AES</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">decrypted_bytes</span> <span class="o">=</span> <span class="n">decrypt_ctr</span><span class="p">(</span><span class="n">aes_cipher</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">,</span> <span class="n">iv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;decrypted_bytes =&gt;&#34;</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">decrypted_bytes</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1"># decrypted_bytes =&gt; b&#34;this is a test message, hahahahahaha~&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="2-gcm-galoiscounter-分组模式" class="headerLink">
    <a href="#2-gcm-galoiscounter-%e5%88%86%e7%bb%84%e6%a8%a1%e5%bc%8f" class="header-mark"></a>2. GCM (Galois/Counter) 分组模式</h3><p>GCM (Galois/Counter) 模式在 CTR 模式的基础上，添加了消息认证的功能，而且同时还具有与 CTR 模式相同的并行计算能力。因此相比 CTR 模式，GCM 不仅速度一样快，还能额外提供对消息完整性、真实性的验证能力。</p>
<p>下图直观地解释了 GCM 块模式（Galois/Counter 模式）的工作原理：</p>
<figure><img src="/images/practical-cryptography-basics-6-symmetric-key-ciphers/gcm-galois_counter_mode.webp"/>
</figure>

<p>GCM 模式新增的 Auth Tag，计算起来会有些复杂，我们就直接略过了，对原理感兴趣的可以看下 <a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode" target="_blank" rel="noopener noreferrer">Galois/Counter_Mode_wiki</a>.</p>
<h3 id="3-如何选用块模式" class="headerLink">
    <a href="#3-%e5%a6%82%e4%bd%95%e9%80%89%e7%94%a8%e5%9d%97%e6%a8%a1%e5%bc%8f" class="header-mark"></a>3. 如何选用块模式</h3><p>一些 Tips:</p>
<ul>
<li>常用的安全块模式是 CBC（密码块链接）、CTR（计数器）和 GCM（伽罗瓦/计数器模式），它们需要一个随机（不可预测的）初始化向量 (IV)，也称为 <code>nonce</code> 或 <code>salt</code></li>
<li>「<strong>CTR</strong>（Counter）」块模式在大多数情况下是一个不错的选择，因为它具有很强的安全性和并行处理能力，允许任意输入数据长度（无填充）。但它不提供身份验证和完整性，只提供加密</li>
<li><strong>GCM</strong>（Galois/Counter Mode）块模式继承了 CTR 模式的所有优点，并增加了加密消息认证能力。GCM 是在对称密码中实现认证加密的快速有效的方法，<strong>强烈推荐</strong></li>
<li>CBC 模式在固定大小的分组上工作。因此，在将输入数据拆分为分组后，应使用填充算法使最后一个分组的长度一致。大多数应用程序使用 <strong>PKCS7</strong> 填充方案或 ANSI X.923. 在某些情况下，CBC 阻塞模式可能容易受到「padding oracle」攻击，因此<strong>最好避免使用 CBC 模式</strong></li>
<li>众所周知的不安全块模式是 <strong>ECB</strong>（电子密码本），它将相等的输入块加密为相等的输出块（无加密扩散能力）。<strong>不要使用 ECB 块模式</strong>！它可能会危及整个加密方案。</li>
<li>CBC、CTR 和 GCM 模式等大多数块都支持「随机访问」解密。比如在视频播放器中的任意时间偏移处寻找，播放加密的视频流</li>
</ul>
<p>总之，建议使用 CTR (Counter) 或 GCM (Galois/Counter) 分组模式。
其他的分组在某些情况下可能会有所帮助，但很可能有安全隐患，因此除非你很清楚自己在做什么，否则不要使用其他分组模式！</p>
<p>CTR 和 GCM 加密模式有很多优点：它们是安全的（目前没有已知的重大缺陷），可以加密任意长度的数据而无需填充，可以并行加密和解密分组（在多核 CPU 中）并可以直接解密任意一个密文分组。
因此它们适用于加密加密钱包、文档和流视频（用户可以按时间查找）。
GCM 还提供消息认证，是一般情况下密码块模式的推荐选择。</p>
<p>请注意，GCM、CTR 和其他分组模式会泄漏原始消息的长度，因为它们生成的密文长度与明文消息的长度相同。
如果您想避免泄露原始明文长度，可以在加密前向明文添加一些随机字节（额外的填充数据），并在解密后将其删除。</p>
<h2 id="四对称加密算法与对称加密方案" class="headerLink">
    <a href="#%e5%9b%9b%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95%e4%b8%8e%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e6%96%b9%e6%a1%88" class="header-mark"></a>四、对称加密算法与对称加密方案</h2><p>前面啰嗦了这么多，下面进入正题：对称加密算法</p>
<h3 id="1-安全的对称加密算法" class="headerLink">
    <a href="#1-%e5%ae%89%e5%85%a8%e7%9a%84%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95" class="header-mark"></a>1. 安全的对称加密算法</h3><p>目前应用最广泛的对称加密算法，是 AES 跟 Salsa20 / ChaCha20 这两个系列。</p>
<h4 id="1-aes-rijndael" class="headerLink">
    <a href="#1-aes-rijndael" class="header-mark"></a>1. AES (Rijndael)</h4><blockquote>
<p>wiki: <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Advanced_Encryption_Standard</a></p>
</blockquote>
<p>AES（高级加密标准，也称为 Rijndael）是现代 IT 行业中最流行和广泛使用的对称加密算法。AES 被证明是高度安全、快速且标准化的，到目前为止没有发现任何明显的弱点或攻击手段，而且几乎在所有平台上都得到了很好的支持。 AES 是 128 位分组密码，使用 128、192 或 256 位密钥。它通常与分组模式组合成分组加密方案（如 AES-CTR 或 AES-GCM）以处理流数据。
在大多数分组模式中，AES 还需要一个随机的 128 位初始向量 IV。</p>
<p>Rijndael (AES) 算法可免费用于任何用途，而且非常流行。很多站点都选择 AES 作为 TLS 协议的一部分，以实现安全通信。
现代 CPU 硬件基本都在微处理器级别实现了 AES 指令以加速 AES 加密解密操作。</p>
<p>这里有一个纯 Python 的 AES 实现可供参考: <a href="https://github.com/boppreh/aes/blob/master/aes.py" target="_blank" rel="noopener noreferrer">AES encryption in pure Python - boppreh</a></p>
<p>我们在前面的 <a href="#counter_mode" rel="">CTR 分组模式</a>中已经使用 Python 实践了 AES-256-CTR 加密方案。
而实际上更常用的是支持集成身份验证加密（AEAD）的 AES-256-GCM 加密方案，它的优势我们前面已经介绍过了，这里我们使用 Python 演示下如何使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># pip install cryptography==36.0.1</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">cryptography.hazmat.primitives.ciphers</span> <span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">Cipher</span><span class="p">,</span> <span class="n">algorithms</span><span class="p">,</span> <span class="n">modes</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">plaintext</span><span class="p">,</span> <span class="n">associated_data</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Generate a random 96-bit IV.</span>
</span></span><span class="line"><span class="cl">    <span class="n">iv</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Construct an AES-GCM Cipher object with the given key and a</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># randomly generated IV.</span>
</span></span><span class="line"><span class="cl">    <span class="n">encryptor</span> <span class="o">=</span> <span class="n">Cipher</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">algorithms</span><span class="o">.</span><span class="n">AES</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">modes</span><span class="o">.</span><span class="n">GCM</span><span class="p">(</span><span class="n">iv</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="o">.</span><span class="n">encryptor</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># associated_data will be authenticated but not encrypted,</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># it must also be passed in on decryption.</span>
</span></span><span class="line"><span class="cl">    <span class="n">encryptor</span><span class="o">.</span><span class="n">authenticate_additional_data</span><span class="p">(</span><span class="n">associated_data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Encrypt the plaintext and get the associated ciphertext.</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># GCM does not require padding.</span>
</span></span><span class="line"><span class="cl">    <span class="n">ciphertext</span> <span class="o">=</span> <span class="n">encryptor</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">plaintext</span><span class="p">)</span> <span class="o">+</span> <span class="n">encryptor</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">,</span> <span class="n">encryptor</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">associated_data</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Construct a Cipher object, with the key, iv, and additionally the</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># GCM tag used for authenticating the message.</span>
</span></span><span class="line"><span class="cl">    <span class="n">decryptor</span> <span class="o">=</span> <span class="n">Cipher</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">algorithms</span><span class="o">.</span><span class="n">AES</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">modes</span><span class="o">.</span><span class="n">GCM</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">tag</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="o">.</span><span class="n">decryptor</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># We put associated_data back in or the tag will fail to verify</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># when we finalize the decryptor.</span>
</span></span><span class="line"><span class="cl">    <span class="n">decryptor</span><span class="o">.</span><span class="n">authenticate_additional_data</span><span class="p">(</span><span class="n">associated_data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Decryption gets us the authenticated plaintext.</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># If the tag does not match an InvalidTag exception will be raised.</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">decryptor</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">)</span> <span class="o">+</span> <span class="n">decryptor</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 接下来进行算法验证</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">plaintext</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&#34;this is a paintext, hahahahahaha~&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">key</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x96\xec</span><span class="s1">.</span><span class="se">\xc7\xd5\x1b</span><span class="s1">/5</span><span class="se">\xa1\x10</span><span class="s1">s</span><span class="se">\x9d\xd5\x10</span><span class="s1">z</span><span class="se">\xdc\x90\xb5\x1c</span><span class="s1">m&#34;&gt;x</span><span class="se">\xfd</span><span class="s1"> </span><span class="se">\xd5\xc5\xaf\x19\xd1</span><span class="s1">Z</span><span class="se">\xbb</span><span class="s1">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">associated_data</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&#34;authenticated but not encrypted payload&#34;</span>  <span class="c1"># 被用于消息认证的关联数据</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 1. 发送方加密消息</span>
</span></span><span class="line"><span class="cl"><span class="n">iv</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">,</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">plaintext</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">associated_data</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 2. 发送方将 associated_data iv ciphertext tag 打包发送给接收方</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 3. 接收方使用自己的 key 验证并解密数据</span>
</span></span><span class="line"><span class="cl"><span class="n">descrypt_text</span> <span class="o">=</span> <span class="n">decrypt</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">associated_data</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">iv</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">ciphertext</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">tag</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="2-salsa20--chacha20" class="headerLink">
    <a href="#2-salsa20--chacha20" class="header-mark"></a>2. Salsa20 / ChaCha20</h4><blockquote>
<p>wiki: <a href="https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant</a></p>
</blockquote>
<p>Salsa20 及其改进的变体 ChaCha（ChaCha8、ChaCha12、ChaCha20）和 XSalsa20 是由密码学家 Daniel Bernstein 设计的现代、快速的对称流密码家族。 Salsa20 密码是对称流密码设计竞赛 eSTREAM（2004-2008）的决赛选手之一，它随后与相关的 BLAKE 哈希函数一起被广泛采用。 Salsa20 及其变体是免版税的，没有专利。</p>
<p>Salsa20 密码将 128 位或 256 位对称密钥 + 随机生成的 64 位随机数（初始向量）和无限长度的数据流作为输入，并生成长度相同的加密数据流作为输出输入流。</p>
<h5 id="chacha20-poly1305" class="headerLink">
    <a href="#chacha20-poly1305" class="header-mark"></a>ChaCha20-Poly1305</h5><p>Salsa20 应用最为广泛的是认证加密方案：<a href="https://en.wikipedia.org/wiki/ChaCha20-Poly1305" target="_blank" rel="noopener noreferrer">ChaCha20-Poly1305</a>，即组合使用 ChaCha20 与消息认证算法 Poly1305，它们都由密码学家 Bernstein 设计。</p>
<p>ChaCha20-Poly1305 已被证明足够安全，不过跟 GCM 一样它的安全性也依赖于足够随机的初始向量 IV，另外 ChaCha20-Poly1305 也不容易遭受计时攻击。</p>
<p>在没有硬件加速的情况下，ChaCha20 通常比 AES 要快得多（比如在旧的没有硬件加速的移动设备上），这是它最大的优势。</p>
<p>以下是一个 ChaCha20 的 Python 示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># pip install cryptography==36.0.1</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">cryptography.hazmat.primitives.ciphers</span> <span class="kn">import</span> <span class="n">Cipher</span><span class="p">,</span> <span class="n">algorithms</span><span class="p">,</span> <span class="n">modes</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">plaintext</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&#34;this is a paintext, hahahahahaha~&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">key</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x96\xec</span><span class="s1">.</span><span class="se">\xc7\xd5\x1b</span><span class="s1">/5</span><span class="se">\xa1\x10</span><span class="s1">s</span><span class="se">\x9d\xd5\x10</span><span class="s1">z</span><span class="se">\xdc\x90\xb5\x1c</span><span class="s1">m&#34;&gt;x</span><span class="se">\xfd</span><span class="s1"> </span><span class="se">\xd5\xc5\xaf\x19\xd1</span><span class="s1">Z</span><span class="se">\xbb</span><span class="s1">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">nonce</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">algorithm</span> <span class="o">=</span> <span class="n">algorithms</span><span class="o">.</span><span class="n">ChaCha20</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">nonce</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># ChaCha20 是一个流密码，mode 必须为 None</span>
</span></span><span class="line"><span class="cl"><span class="n">cipher</span> <span class="o">=</span> <span class="n">Cipher</span><span class="p">(</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 1. 加密</span>
</span></span><span class="line"><span class="cl"><span class="n">encryptor</span> <span class="o">=</span> <span class="n">cipher</span><span class="o">.</span><span class="n">encryptor</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">ct</span> <span class="o">=</span> <span class="n">encryptor</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">plaintext</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 2. 解密</span>
</span></span><span class="line"><span class="cl"><span class="n">decryptor</span> <span class="o">=</span> <span class="n">cipher</span><span class="o">.</span><span class="n">decryptor</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">decryptor</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="3-其他流行的对称加密算法" class="headerLink">
    <a href="#3-%e5%85%b6%e4%bb%96%e6%b5%81%e8%a1%8c%e7%9a%84%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95" class="header-mark"></a>3. 其他流行的对称加密算法</h4><p>还有一些其他的现代安全对称密码，它们的应用不如 AES 和 ChaCha20 这么广泛，但在程序员和信息安全社区中仍然很流行：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Serpent_%28cipher%29" target="_blank" rel="noopener noreferrer">Serpent</a> - 安全对称密钥分组密码（密钥大小：128、192 或 256 位），公众所有（Public Domain），完全免费</li>
<li><a href="https://en.wikipedia.org/wiki/Twofish" target="_blank" rel="noopener noreferrer">Twofish</a> - 安全对称密钥分组密码（密钥大小：128、192 或 256 位），公众所有（Public Domain），完全免费</li>
<li><a href="https://en.wikipedia.org/wiki/Camellia_%28cipher%29" target="_blank" rel="noopener noreferrer">Camellia</a> - 安全对称密钥分组密码（分组大小：128 位；密钥大小：128、192 和 256 位），专利算法，但完全免费
<ul>
<li>该算法由三菱和日本电信电话（NTT）在 2000 年共同发明</li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/RC5" target="_blank" rel="noopener noreferrer">RC5</a> - 安全对称密钥分组密码（密钥大小：128 到 2040 位；分组大小：32、64 或 128 位；轮数：1 &hellip; 255），短密钥不安全（56 位密钥已被暴力破解） , 专利在 2015 年到期，现在完全免费</li>
<li><a href="https://en.wikipedia.org/wiki/RC6" target="_blank" rel="noopener noreferrer">RC6</a> - 安全对称密钥分组密码，类似于 RC5，但更复杂（密钥大小：128 到 2040 位；分组大小：32、64 或 128 位；轮数：1 &hellip; 255），专利在 2017 年到期，现在完全免费</li>
<li><a href="https://en.wikipedia.org/wiki/International_Data_Encryption_Algorithm" target="_blank" rel="noopener noreferrer">IDEA</a> - 安全对称密钥分组密码（密钥大小：128 位），所有专利在均 2012 年前过期，完全免费</li>
<li><a href="https://en.wikipedia.org/wiki/CAST-256" target="_blank" rel="noopener noreferrer">CAST (CAST-128 / CAST5, CAST-256 / CAST6)</a> - 安全对称密钥分组密码系列（密钥大小：40 &hellip; 256 位），免版税</li>
<li><a href="https://en.wikipedia.org/wiki/ARIA_%28cipher%29" target="_blank" rel="noopener noreferrer">ARIA</a> - 安全对称密钥分组密码，类似于 AES（密钥大小：128、192 或 256 位），韩国官方标准，免费供公众使用</li>
<li><a href="https://en.wikipedia.org/wiki/SM4_%28cipher%29" target="_blank" rel="noopener noreferrer">SM4</a> - 安全对称密钥分组密码，类似于 AES（密钥大小：128 位），中国官方标准，免费供公众使用
<ul>
<li>由中国国家密码管理局于 2012 年 3 月 21 日发布</li>
</ul>
</li>
</ul>
<p>具体的算法内容这里就不介绍了，有兴趣或者用得到的时候，可以再去仔细了解。</p>
<h3 id="2-不安全的对称加密算法" class="headerLink">
    <a href="#2-%e4%b8%8d%e5%ae%89%e5%85%a8%e7%9a%84%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95" class="header-mark"></a>2. 不安全的对称加密算法</h3><p>如下这些对称加密算法曾经很流行，但现在被认为是不安全的或有争议的安全性，<strong>不建议再使用</strong>：</p>
<ul>
<li>DES - 56 位密钥大小，可以被暴力破解</li>
<li>3DES（三重 DES, TDES）- 64 位密码，被认为不安全，已在 2017 年被 NIST 弃用.</li>
<li>RC2 - 64 位密码，被认为不安全</li>
<li>RC4 - 流密码，已被破解，网上存在大量它的破解资料</li>
<li>Blowfish - 旧的 64 位密码，已被破坏
<ul>
<li><a href="https://web.archive.org/web/20161009174028/https://sweet32.info/" target="_blank" rel="noopener noreferrer">Sweet32: Birthday attacks on 64-bit block ciphers in TLS and OpenVPN</a></li>
</ul>
</li>
<li>GOST - 俄罗斯 64 位分组密码，有争议的安全性，被认为有风险</li>
</ul>
<h3 id="对称认证加密算法-ae--aead" class="headerLink">
    <a href="#%e5%af%b9%e7%a7%b0%e8%ae%a4%e8%af%81%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95-ae--aead" class="header-mark"></a>对称认证加密算法 AE / AEAD</h3><p>我们在前面第三篇文章「MAC 与密钥派生函数 KDF」中介绍过 AE 认证加密及其变体 AEAD.</p>
<p>一些对称加密方案提供集成身份验证加密（AEAD），比如使用了 GCM 分组模式的加密方案 AES-GCM，而其他加密方案（如 AES-CBC 和 AES-CTR）自身不提供身份验证能力，需要额外添加。</p>
<p>最流行的认证加密（AEAD）方案有如下几个，我们在之前已经简单介绍过它们：</p>
<ul>
<li>ChaCha20-Poly1305
<ul>
<li>具有集成 Poly1305 身份验证器的 ChaCha20 流密码（集成身份验证 AEAD 加密）</li>
<li>使用 256 位密钥和 96 位随机数（初始向量）</li>
<li>极高的性能</li>
<li>在硬件不支持 AES 加速指令时（如路由器、旧手机等硬件上），推荐使用此算法</li>
</ul>
</li>
<li>AES-256-GCM
<ul>
<li>我们在前面的 GCM 模式一节，使用 Python 实现并验证了这个 AES-256-GCM 加密方案</li>
<li>使用 256 位密钥和 128 位随机数（初始向量）</li>
<li>较高的性能</li>
<li>在硬件支持 AES 加速时（如桌面、服务器等场景），更推荐使用此算法</li>
</ul>
</li>
<li>AES-128-GCM
<ul>
<li>跟 AES-256-GCM 一样，区别在于它使用 128 位密钥，安全性弱于 ChaCha20-Poly1305 与 AES-256-GCM.</li>
<li>目前被广泛应用在 HTTPS 等多种加密场景下，但是正在慢慢被前面两种方案取代</li>
</ul>
</li>
</ul>
<p>今天的大多数应用程序应该优先选用上面这些加密方案进行对称加密，而不是自己造轮子。
上述方案是高度安全的、经过验证的、经过良好测试的，并且大多数加密库都已经提供了高效的实现，可以说是开箱即用。</p>
<p>目前应用最广泛的对称加密方案应该是 AES-128-GCM，
而 ChaCha20-Poly1305 因为其极高的性能，也越来越多地被应用在 TLS1.2、TLS1.3、QUIC/HTTP3、Wireguard、SSH 等协议中。</p>
<h2 id="五aes-算法案例以太坊钱包加密" class="headerLink">
    <a href="#%e4%ba%94aes-%e7%ae%97%e6%b3%95%e6%a1%88%e4%be%8b%e4%bb%a5%e5%a4%aa%e5%9d%8a%e9%92%b1%e5%8c%85%e5%8a%a0%e5%af%86" class="header-mark"></a>五、AES 算法案例：以太坊钱包加密</h2><p>在这一小节我们研究一个现实中的 AES 应用场景：以太坊区块链的标准加密钱包文件格式。
我们将看到 AES-128-CTR 密码方案如何与 Scrypt 和 MAC 相结合，通过字符密码安全地实现经过身份验证的对称密钥加密。</p>
<h4 id="以太坊-utc--json-钱包" class="headerLink">
    <a href="#%e4%bb%a5%e5%a4%aa%e5%9d%8a-utc--json-%e9%92%b1%e5%8c%85" class="header-mark"></a>以太坊 UTC / JSON 钱包</h4><p>在比特币和以太坊等区块链网络中，区块链资产持有者的私钥存储在称为<strong>加密钱包</strong>的特殊密钥库中。
通常，这些加密钱包是本地硬盘上的文件，并使用字符密码加密。</p>
<p>在以太坊区块链中，<strong>加密钱包</strong>以一种特殊的加密格式在内部存储，称为「UTC / JSON 钱包（密钥库文件）」或「Web3 秘密存储定义」。
这是一种加密钱包的文件格式，被广泛应用在 geth 和 Parity（以太坊的主要协议实现）、MyEtherWallet（流行的在线客户端以太坊钱包）、MetaMask（广泛使用的浏览器内以太坊钱包）、ethers.js 和 Nethereum 库以及许多其他与以太坊相关的技术和工具中。</p>
<p>以太坊 UTC/JSON 密钥库将加密的私钥、加密数据、加密算法及其参数保存为 JSON 文本文档。</p>
<p>UTC / JSON 钱包的一个示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl">{<span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">&#34;version&#34;: </span><span class="m">3</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">&#34;id&#34;: </span><span class="s2">&#34;07a9f767-93c5-4842-9afd-b3b083659f04&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">&#34;address&#34;: </span><span class="s2">&#34;aef8cad64d29fcc4ed07629b9e896ebc3160a8d0&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">&#34;Crypto&#34;: </span>{<span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">&#34;ciphertext&#34;: </span><span class="s2">&#34;99d0e66c67941a08690e48222a58843ef2481e110969325db7ff5284cd3d3093&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">&#34;cipherparams&#34;: { &#34;iv&#34;: </span><span class="s2">&#34;7d7fabf8dee2e77f0d7e3ff3b965fc23&#34;</span><span class="w"> </span>}<span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">&#34;cipher&#34;: </span><span class="s2">&#34;aes-128-ctr&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">&#34;kdf&#34;: </span><span class="s2">&#34;scrypt&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">&#34;kdfparams&#34;: </span>{<span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">&#34;dklen&#34;: </span><span class="m">32</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">&#34;salt&#34;: </span><span class="s2">&#34;85ad073989d461c72358ccaea3551f7ecb8e672503cb05c2ee80cfb6b922f4d4&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">&#34;n&#34;: </span><span class="m">8192</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">&#34;r&#34;: </span><span class="m">8</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">&#34;p&#34;: </span><span class="m">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>}<span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">&#34;mac&#34;: </span><span class="s2">&#34;06dcf1cc4bffe1616fafe94a2a7087fd79df444756bb17c93af588c3ab02a913&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>}<span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>}<span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述 json 内容也是认证对称加密的一个典型示例，可以很容易分析出它的一些组成成分：</p>
<ul>
<li><code>kdf</code>: 用于从字符密码派生出密钥的 KDF 算法名称，这里用的是 <code>scrypt</code>
<ul>
<li><code>kdfparams</code>: KDF 算法的参数，如迭代参数、盐等&hellip;</li>
</ul>
</li>
<li><code>ciphertext</code>: 钱包内容的密文，通常这就是一个被加密的 256 位私钥</li>
<li><code>cipher</code> + <code>cipherparams</code>: 对称加密算法的名称及参数，这里使用了 AES-128-CTR，并给出了初始向量 IV</li>
<li><code>mac</code>: 由 MAC 算法生成的消息认证码，被用于验证解密密码的正确性
<ul>
<li>以太坊使用截取派生密钥的一部分，拼接上完整密文，然后进行 keccak-256 哈希运算得到 MAC 值</li>
</ul>
</li>
<li>其他钱包相关的信息</li>
</ul>
<p>默认情况下，密钥派生函数是 scrypt 并使用的是弱 scrypt 参数（n=8192 成本因子，r=8 块大小，p=1 并行化），因此建议使用长而复杂的密码以避免钱包被暴力解密。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://github.com/nakov/Practical-Cryptography-for-Developers-Book" target="_blank" rel="noopener noreferrer">Practical-Cryptography-for-Developers-Book</a></li>
<li><a href="https://dev.to/techschoolguru/a-complete-overview-of-ssl-tls-and-its-cryptographic-system-36pd" target="_blank" rel="noopener noreferrer">A complete overview of SSL/TLS and its cryptographic system</a></li>
<li><a href="https://github.com/boppreh/aes/blob/master/aes.py" target="_blank" rel="noopener noreferrer">AES encryption in pure Python - boppreh</a></li>
<li><a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation" target="_blank" rel="noopener noreferrer">Block_cipher_mode_of_operation_wiki</a></li>
<li><a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode" target="_blank" rel="noopener noreferrer">Galois/Counter_Mode_wiki</a></li>
</ul>
]]></content></entry><entry><title type="html">「转」且看有思想的年轻人</title><link href="https://thiscute.world/posts/the-thoughtful-youth/"/><id>https://thiscute.world/posts/the-thoughtful-youth/</id><author><name>ryan4yin</name></author><published>2022-03-04T22:58:00+08:00</published><updated>2022-03-04T22:58:00+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/the-thoughtful-youth/%E9%AD%91%E9%AD%85%E9%AD%8D%E9%AD%89.webp" height="1728" width="1080"><figcaption></figcaption>
        </figure><blockquote>
<p>原文：<a href="https://www.zhihu.com/question/447184915/answer/1768006207" target="_blank" rel="noopener noreferrer">哪一刻你发现年轻人正在悄悄改变社会？ - 赦己</a></p>
</blockquote>
<blockquote>
<p>我的读后感：他的眼里有光！</p>
</blockquote>
<p>之前见过一个特别厉害的面试者，让我觉得，老一辈真的是老一辈了，他放弃了一个月薪一万三，十三薪的工作，他的演讲让我记忆非常深刻，也使得面试官面面相觑。</p>
<p>这个岗位算是万人过独木桥，不仅海内的很多大学生在竞争，海外的很多大学生也在努力，整个过程是这样的：简历筛选-线上一面-线上hr二面-线下主管面试-总裁轮面试（压力轮）。</p>
<p>我们都到了最后的一轮面试,本来就是压力轮面试，但是那天不知道为什么总裁的脾气很暴躁，对他冷嘲热讽，说了一些比较难听的话，大概的意思就是“你还小，以后需要认真学，你们太嫩了”，其实总裁的意思非常明确了，会招他，但是他太嫩需要学很多东西，但是就是他这样大人看小屁孩的感觉惹怒了他，后面他的演讲就是十分高能了，我尽量原文复述。</p>
<p>「你坐在我前面会不会有点点害怕呢？你看看你身边有什么人可以给你参考吗？你没有，你只能战战兢兢如履薄冰，走错一步都是深渊。你知道你在我眼里是什么吗？你只是一个猎物，一个我追逐的、猎杀的的目标，其实你哪里来的自信呢？就凭你是这个公司的总裁吗？来自职级和制度的压力我一概不屑，反而觉得是黔驴技穷，小人做法，我不会服气，只是照做而已。</p>
<p>其实我也很享受被统治的感觉，上一个能统治我的人已经很久了，你知道那种纯粹的实力压服吗？我可以毫无保留地顺从他的任何意见，我从来不怀疑他的任何决定，哪怕行动后面失败了我也觉得他是对的。但是你呢？只是来自制度的威力，你的每一个决定都会遭到我的质疑。</p>
<p><strong>我最讨厌的就是别人和我说，我想让你去做点什么但是你能力还不够，简直瞎扯淡，其实是你能力不够，作为一个管理者，你甚至不知道怎么用我，我如何为你卖命啊</strong>？</p>
<p>我渴望的是在一个稳定的环境默默耕耘，把坏的变成好的，但是前提是我们够团队，你呢？凭你作为一个过来人的经验吗？这些东西经过时间大家都会有的，你还有其他的吗？你真的有能力把我变成你的三头六臂吗？你真的控制得住我吗？」</p>
<p>复述其实没那么精彩了，他支着手目光瞪着总裁的眼睛的时候超级精彩，后面他去了一个对手小公司，相当于这边的市值来了，相差了十倍之多，但是七个月之后再见面已是兵刃交接，他成了六个人团队的小主管，耀武扬威地围着我们总部办公地盘下了一圈广告。</p>
]]></content></entry><entry><title type="html">写给开发人员的实用密码学（五）—— 密钥交换 DHKE 与完美前向保密 PFS</title><link href="https://thiscute.world/posts/practical-cryptography-basics-5-key-exchange/"/><id>https://thiscute.world/posts/practical-cryptography-basics-5-key-exchange/</id><author><name>ryan4yin</name></author><published>2022-03-01T17:15:05+08:00</published><updated>2022-03-13T15:26:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">写给开发人员的实用密码学（四）—— 安全随机数生成器 CSPRNG</title><link href="https://thiscute.world/posts/practical-cryptography-basics-4-secure-random-generators/"/><id>https://thiscute.world/posts/practical-cryptography-basics-4-secure-random-generators/</id><author><name>ryan4yin</name></author><published>2022-03-01T17:15:04+08:00</published><updated>2022-03-01T17:15:04+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">写给开发人员的实用密码学（三）—— MAC 与密钥派生函数 KDF</title><link href="https://thiscute.world/posts/practical-cryptography-basics-3-key-derivation-function/"/><id>https://thiscute.world/posts/practical-cryptography-basics-3-key-derivation-function/</id><author><name>ryan4yin</name></author><published>2022-03-01T17:15:03+08:00</published><updated>2022-03-01T17:15:03+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">写给开发人员的实用密码学（二）—— 哈希函数</title><link href="https://thiscute.world/posts/practical-cryptography-basics-2-hash/"/><id>https://thiscute.world/posts/practical-cryptography-basics-2-hash/</id><author><name>ryan4yin</name></author><published>2022-03-01T17:15:01+08:00</published><updated>2022-03-01T17:15:01+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">写给开发人员的实用密码学（一）—— 概览</title><link href="https://thiscute.world/posts/practical-cryptography-basics-1/"/><id>https://thiscute.world/posts/practical-cryptography-basics-1/</id><author><name>ryan4yin</name></author><published>2022-03-01T17:15:00+08:00</published><updated>2022-03-01T17:15:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">「转」仙马赛记——我又 PB 了</title><link href="https://thiscute.world/posts/likenttt-2021-04-11-xianlin-half-marathon-1_33_12/"/><id>https://thiscute.world/posts/likenttt-2021-04-11-xianlin-half-marathon-1_33_12/</id><author><name>ryan4yin</name></author><published>2022-02-26T17:44:00+08:00</published><updated>2022-02-26T17:44:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">「转」MIRT出征广马——首次摸到330的边儿</title><link href="https://thiscute.world/posts/likenttt-2020-12-13-guangzhou-marathon-3_30_15/"/><id>https://thiscute.world/posts/likenttt-2020-12-13-guangzhou-marathon-3_30_15/</id><author><name>ryan4yin</name></author><published>2022-02-26T16:59:00+08:00</published><updated>2022-02-26T16:59:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">Linux/Windows/MacOSX 系统常用命令集锦</title><link href="https://thiscute.world/posts/common-commands-for-various-operating-systems/"/><id>https://thiscute.world/posts/common-commands-for-various-operating-systems/</id><author><name>ryan4yin</name></author><published>2022-02-13T16:09:00+08:00</published><updated>2022-02-13T16:09:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">Python 实用技巧与常见错误集锦</title><link href="https://thiscute.world/posts/python-tips-and-tricks/"/><id>https://thiscute.world/posts/python-tips-and-tricks/</id><author><name>ryan4yin</name></author><published>2022-02-13T01:17:00+08:00</published><updated>2022-02-13T01:17:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">部署一个 Kubernetes 集群</title><link href="https://thiscute.world/posts/kubernetes-deployment-using-kubeadm/"/><id>https://thiscute.world/posts/kubernetes-deployment-using-kubeadm/</id><author><name>ryan4yin</name></author><published>2022-01-25T01:37:00+08:00</published><updated>2022-01-25T01:37:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">Kubernetes 微服务最佳实践</title><link href="https://thiscute.world/posts/kubernetes-best-practices/"/><id>https://thiscute.world/posts/kubernetes-best-practices/</id><author><name>ryan4yin</name></author><published>2022-01-25T00:13:00+08:00</published><updated>2022-01-25T00:13:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">2021 年年终总结</title><link href="https://thiscute.world/posts/2021-summary/"/><id>https://thiscute.world/posts/2021-summary/</id><author><name>ryan4yin</name></author><published>2022-01-03T14:50:00+08:00</published><updated>2022-01-03T14:50:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">月宫</title><link href="https://thiscute.world/posts/moon-palace/"/><id>https://thiscute.world/posts/moon-palace/</id><author><name>ryan4yin</name></author><published>2021-12-27T17:23:00+08:00</published><updated>2021-12-27T17:23:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">浮生若梦，为欢几何？</title><link href="https://thiscute.world/posts/life-is-just-like-a-dream/"/><id>https://thiscute.world/posts/life-is-just-like-a-dream/</id><author><name>ryan4yin</name></author><published>2021-11-16T02:07:39+08:00</published><updated>2021-11-16T02:14:37+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">此岸弃草，彼岸繁花</title><link href="https://thiscute.world/posts/weeds-on-this-side-flowers-on-the-other/"/><id>https://thiscute.world/posts/weeds-on-this-side-flowers-on-the-other/</id><author><name>ryan4yin</name></author><published>2021-08-28T12:24:20+08:00</published><updated>2021-08-28T12:24:20+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">iptables 及 docker 容器网络分析</title><link href="https://thiscute.world/posts/iptables-and-container-networks/"/><id>https://thiscute.world/posts/iptables-and-container-networks/</id><author><name>ryan4yin</name></author><published>2021-08-15T19:11:29+08:00</published><updated>2021-08-15T19:11:29+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">Linux 中的虚拟网络接口</title><link href="https://thiscute.world/posts/linux-virtual-network-interfaces/"/><id>https://thiscute.world/posts/linux-virtual-network-interfaces/</id><author><name>ryan4yin</name></author><published>2021-08-14T11:13:03+08:00</published><updated>2021-08-14T11:13:03+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">Linux 网络工具中的瑞士军刀 - socat &amp;amp; netcat</title><link href="https://thiscute.world/posts/socat-netcat/"/><id>https://thiscute.world/posts/socat-netcat/</id><author><name>ryan4yin</name></author><published>2021-04-11T16:38:13+08:00</published><updated>2021-04-11T16:38:13+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">脚踏实地，仰望星空</title><link href="https://thiscute.world/posts/no-more-dreams/"/><id>https://thiscute.world/posts/no-more-dreams/</id><author><name>ryan4yin</name></author><published>2021-02-13T10:32:56+08:00</published><updated>2021-02-13T10:32:56+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">我在创业公司做技术一年多的一点体会</title><link href="https://thiscute.world/posts/end-of-the-first-round/"/><id>https://thiscute.world/posts/end-of-the-first-round/</id><author><name>ryan4yin</name></author><published>2021-02-06T08:46:46+08:00</published><updated>2021-02-06T08:46:46+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">云原生流水线 Argo Workflows 的安装、使用以及个人体验</title><link href="https://thiscute.world/posts/experience-of-argo-workflows/"/><id>https://thiscute.world/posts/experience-of-argo-workflows/</id><author><name>ryan4yin</name></author><published>2021-01-27T15:37:27+08:00</published><updated>2021-01-27T15:37:27+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">secrets 管理工具 Vault 的介绍、安装及使用</title><link href="https://thiscute.world/posts/experience-of-vault/"/><id>https://thiscute.world/posts/experience-of-vault/</id><author><name>ryan4yin</name></author><published>2021-01-24T09:31:41+08:00</published><updated>2021-01-24T09:31:41+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">QEMU/KVM 虚拟化环境的搭建与使用</title><link href="https://thiscute.world/posts/qemu-kvm-usage/"/><id>https://thiscute.world/posts/qemu-kvm-usage/</id><author><name>ryan4yin</name></author><published>2021-01-17T21:34:04+08:00</published><updated>2021-01-17T21:34:04+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">Pulumi 使用体验 - 基础设施代码化</title><link href="https://thiscute.world/posts/experience-of-pulumi/"/><id>https://thiscute.world/posts/experience-of-pulumi/</id><author><name>ryan4yin</name></author><published>2021-01-08T18:51:30+08:00</published><updated>2021-01-08T18:51:30+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">openSUSE 使用指南</title><link href="https://thiscute.world/posts/opensuse-instruction/"/><id>https://thiscute.world/posts/opensuse-instruction/</id><author><name>ryan4yin</name></author><published>2021-01-04T08:42:21+08:00</published><updated>2021-01-04T08:42:21+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">2020 年年终总结</title><link href="https://thiscute.world/posts/2020-summary/"/><id>https://thiscute.world/posts/2020-summary/</id><author><name>ryan4yin</name></author><published>2020-12-12T23:45:00+08:00</published><updated>2020-12-12T23:45:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">「小歌行」-景德镇文艺复兴-2020巡演-深圳</title><link href="https://thiscute.world/posts/jingdezhen-renaissance-band-2020-shenzhen/"/><id>https://thiscute.world/posts/jingdezhen-renaissance-band-2020-shenzhen/</id><author><name>ryan4yin</name></author><published>2020-11-28T11:49:00+08:00</published><updated>2020-11-28T11:49:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">Base64 编码并不唯一</title><link href="https://thiscute.world/posts/base64-encoding-is-not-unique/"/><id>https://thiscute.world/posts/base64-encoding-is-not-unique/</id><author><name>ryan4yin</name></author><published>2020-05-31T00:13:00+08:00</published><updated>2020-05-31T00:13:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">使用 tcpdump 和 Wireshark 进行远程实时抓包分析</title><link href="https://thiscute.world/posts/tcpdump-and-wireshark/"/><id>https://thiscute.world/posts/tcpdump-and-wireshark/</id><author><name>ryan4yin</name></author><published>2020-05-28T16:20:26+08:00</published><updated>2020-05-28T16:20:26+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">使用 Istio 进行 JWT 身份验证（充当 API 网关）</title><link href="https://thiscute.world/posts/use-istio-for-jwt-auth/"/><id>https://thiscute.world/posts/use-istio-for-jwt-auth/</id><author><name>ryan4yin</name></author><published>2020-04-06T21:48:26+08:00</published><updated>2020-04-06T21:48:26+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">Linux网络学习笔记（二）：域名解析(DNS)——以 CoreDNS 为例</title><link href="https://thiscute.world/posts/about-dns-protocol/"/><id>https://thiscute.world/posts/about-dns-protocol/</id><author><name>ryan4yin</name></author><published>2020-03-29T15:49:23+08:00</published><updated>2020-03-29T15:49:23+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">JWT 签名算法 HS256、RS256 及 ES256 及密钥生成</title><link href="https://thiscute.world/posts/jwt-algorithm-key-generation/"/><id>https://thiscute.world/posts/jwt-algorithm-key-generation/</id><author><name>ryan4yin</name></author><published>2020-03-03T14:09:46+08:00</published><updated>2020-03-03T14:09:46+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">2019 年年终总结</title><link href="https://thiscute.world/posts/2019-summary/"/><id>https://thiscute.world/posts/2019-summary/</id><author><name>ryan4yin</name></author><published>2020-01-31T19:19:00+08:00</published><updated>2020-01-31T19:19:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">Kubernetes 常见错误、原因及处理方法</title><link href="https://thiscute.world/posts/kubernetes-common-errors-and-solutions/"/><id>https://thiscute.world/posts/kubernetes-common-errors-and-solutions/</id><author><name>ryan4yin</name></author><published>2019-11-24T19:26:54+08:00</published><updated>2019-11-24T19:26:54+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">Manjaro 使用指南</title><link href="https://thiscute.world/posts/manjaro-instruction/"/><id>https://thiscute.world/posts/manjaro-instruction/</id><author><name>ryan4yin</name></author><published>2019-07-13T20:38:24+08:00</published><updated>2019-07-13T20:38:24+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry></feed>