<feed xmlns="http://www.w3.org/2005/Atom"><title>This Cute World</title><link href="https://thiscute.world/index.xml" rel="self"/><link href="https://thiscute.world/"/><updated>2023-08-01T11:40:57+08:00</updated><id>https://thiscute.world/</id><author><name>ryan4yin</name></author><generator>Hugo -- gohugo.io</generator><entry><title type="html">为什么我折腾这些小众技术？</title><link href="https://thiscute.world/posts/why-i-choose-niche-products/"/><id>https://thiscute.world/posts/why-i-choose-niche-products/</id><author><name>ryan4yin</name></author><published>2023-08-01T11:40:57+08:00</published><updated>2023-08-01T11:40:57+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/why-i-choose-niche-products/anime-girls-seagulls.webp" height="2428" width="1134"><figcaption></figcaption>
        </figure><p>我折腾过许多的小众技术，而今年新折腾的主要有 NixOS、窗口管理器 i3 / hyprland、以及 Neovim，其中 NixOS 我甚至折腾到了一个新境界——出了一本帮助新手入门的中英双语开源书籍 <a href="https://github.com/ryan4yin/nixos-and-flakes-book" target="_blank" rel="noopener noreferrer">nixos-and-flakes-book</a>，还搞了好几个 NixOS 相关的开源项目（比如 <a href="https://github.com/ryan4yin/nix-darwin-kickstarter" target="_blank" rel="noopener noreferrer">nix-darwin-kickstarter</a> 跟 <a href="https://github.com/ryan4yin/nix-config" target="_blank" rel="noopener noreferrer">ryan4yin/nix-config</a>），都收到了许多好评。</p>
<p>结合我自己折腾这些小众技术的经历，以及我经常被问到的问题（为什么你选择用 <a href="nixos.org/" rel="">NixOS</a> / <a href="https://github.com/Neovim/Neovim" target="_blank" rel="noopener noreferrer">Neovim</a> / <a href="https://flypy.com/" target="_blank" rel="noopener noreferrer">小鹤音形中文输入法</a>？它有什么好处？它真的能提升效率吗？等等），我想在这里简单谈谈我对它们的看法。</p>
<h2 id="什么是小众技术" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%b0%8f%e4%bc%97%e6%8a%80%e6%9c%af" class="header-mark"></a>什么是小众技术？</h2><p>小众，是相对于大众而言的。小众技术，指在该领域中用户占比较相对较小的技术。</p>
<p>基于这样的定义，我可以列举出我接触过的不同领域的一些小众技术：</p>
<table>
<thead>
<tr>
<th>领域</th>
<th>小众技术</th>
<th>大众技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>编辑器</td>
<td>Neovim、Emacs</td>
<td>VSCode、Pycharm、IDEA</td>
</tr>
<tr>
<td>中文输入方案</td>
<td>双拼、小鹤音形、五笔、二笔、郑码、灵形速影</td>
<td>智能拼音</td>
</tr>
<tr>
<td>Linux 操作系统</td>
<td>NixOS、Gentoo、Arch Linux</td>
<td>Ubuntu、Fedora</td>
</tr>
<tr>
<td>窗口管理器</td>
<td>i3、hyprland</td>
<td>KDE、GNOME</td>
</tr>
</tbody>
</table>
<p>大多数人在使用这些领域的技术时，都会选择大众技术，因为它们的入门门槛低，使用起来也比较方便。
我曾经也是这大多数人之一，但是我渐渐发现，这些小众技术也有它们的优势，所以我开始尝试使用它们，并逐渐过渡到了它们。</p>
<h2 id="这些小众技术有什么特点" class="headerLink">
    <a href="#%e8%bf%99%e4%ba%9b%e5%b0%8f%e4%bc%97%e6%8a%80%e6%9c%af%e6%9c%89%e4%bb%80%e4%b9%88%e7%89%b9%e7%82%b9" class="header-mark"></a>这些小众技术有什么特点？</h2><p>小众技术显然得拥有一些优势，才能吸引到一部分用户，让这些用户选择它们而不是大众技术。</p>
<p>从我个人的使用经验来看，我用过的这些小众技术，具有一些比较明显的共同特征。</p>
<p>首先是它们共同的劣势：<strong>入门门槛更高，入门阶段需要花费更多的时间去学习、熟悉</strong>。</p>
<p>这就过滤掉了大部分用户，只有那些喜欢折腾、喜欢挑战的人才会去尝试这些小众技术。</p>
<p>比如说五笔输入法，它们的入门门槛很高，需要花费大量的时间去记忆它的键位编排、去练习，前期的输入体验会跌到谷底。
要想达到你曾经智能拼音的输入速度，感觉至少得每天练习 1 个小时，持续一个月（这很可能还不够）。</p>
<p>其他形码输入法也是一样，我用的小鹤音形算是一个折衷的选择，它的入门门槛比五笔低一些，学会后也能获得类似五笔的输入体验。</p>
<p>再说说它们共同的优势：</p>
<ol>
<li><strong>定制程度高</strong>：用户可以根据自己的需求，自由地定制各种功能。</li>
<li><strong>强烈的掌控感、绝佳的使用体验</strong>：高度的自定义，让用户感觉到自己在使用这些技术的过程中，能够完全掌控一切，从而带来绝佳的使用体验。</li>
<li><strong>用户黏性高、社区活跃</strong>：用户在使用这些技术的过程中，会不断地去探索、去学习、去定制，这会让用户对它们产生强烈的归属感。</li>
</ol>
<p>也因为上面这些原因，用户一旦成功入门某项小众技术（比如说形码输入法、Neovim/Emacs 编辑器），就很难再退回到曾经的大众方案——他们会发现曾经的大众方案用起来，各种不顺手、不爽快。</p>
<h2 id="我为什么折腾这些小众技术" class="headerLink">
    <a href="#%e6%88%91%e4%b8%ba%e4%bb%80%e4%b9%88%e6%8a%98%e8%85%be%e8%bf%99%e4%ba%9b%e5%b0%8f%e4%bc%97%e6%8a%80%e6%9c%af" class="header-mark"></a>我为什么折腾这些小众技术？</h2><p>我折腾过许多小众技术，而原因中最大的一部分，应该是好奇心。
但好奇心只能让我去尝试，让我留下来的，是它们优秀的使用体验。</p>
<p>比如说最近折腾的 Neovim 编辑器、Hyprland 窗口管理器，让我留下来继续使用它们的原因，一是 Neovim 跟 Hyprland 配置好了之后，真的很漂亮！而且 Neovim 速度真的超快、太快了！
这种快对没体验过的 VSCode / IDEA 用户来说可能觉得不过如此，但是一旦你体验过，就会发现这种快真的很爽，就像三体中图恒宇的感叹一样（550W 太快了!这速度太快了！）
二是实际入门后，发现它们用起来很爽快，基于键盘的交互，能带给我形码输入法的那种掌控感、流畅感（优雅，太优雅了 hhh）。</p>
<p><figure><img src="./hyprland_2023-07-29_1.webp" width="85%"/><figcaption>
            <h4>我的 NixOS &#43; Hyprland 桌面</h4>
        </figcaption>
</figure>

<figure><img src="./hyprland_2023-07-29_2.webp" width="85%"/><figcaption>
            <h4>我的 Neovim 编辑器</h4>
        </figcaption>
</figure>
</p>
<p>而我折腾并且爱上 NixOS，也是基于类似的原因。
拥有声明式、可复现（一致的运行环境）、OS as Code 等这些特点的 NixOS，对于本运维狗而言，真就是理想中的样子，这让我迫不及待地想要使用它，即使发现了问题也希望能尽快完善它，使它能够适用于更多的场景。</p>
<blockquote>
<p>前两天在 4chan 上看到某外国网友的这么一段评论（虽然言词有点偏激，但我还真有点认同&hellip;）：
Completely and utterly unacceptable. Imagine having a tool that can&rsquo;t even properly undo an operation and then relying on it to manage an operating system.
<code>apt</code>, <code>pip</code>, <code>pm</code>, <code>rpm</code>, <code>pacman</code>, whatever are all a mad fucking joke.</p>
</blockquote>
<h2 id="小众工具或技术能提升效率吗" class="headerLink">
    <a href="#%e5%b0%8f%e4%bc%97%e5%b7%a5%e5%85%b7%e6%88%96%e6%8a%80%e6%9c%af%e8%83%bd%e6%8f%90%e5%8d%87%e6%95%88%e7%8e%87%e5%90%97" class="header-mark"></a>小众工具或技术能提升效率吗？</h2><p>有许多人说，Neovim 编辑器、i3 窗口管理器、形码输入法等这些小众工具或技术，能提升效率，我觉得这是一个误区。
相反，其中许多工具或技术，实际上是一个时间销金窟，你会被自己的兴趣驱使着去不断探索它们的边界、调整它的配置使其更契合自己的需求。
这导致至少前面较长一段上升期，这些投入的时间会比你效率提升所省下的时间多得多。</p>
<p>所以说到底，想用这些技术来提升效率啥的还是不用想了。
它能提升你的效率，但是比较有限，除非你写代码/文档的效率是受限于你的手速 emmm</p>
<blockquote>
<p>当然也有些特殊场景，比如说有的人需要经常输入些生僻字，这时候智能拼音就比较鸡肋了，五笔等形码输入法就确实能大大提升输入效率。</p>
</blockquote>
<p>或者有人会说，完全熟悉后，vim/emacs 能使你更容易进入心流状态？这个也很难说吧。</p>
<h2 id="那折腾这些东西到底有什么好处" class="headerLink">
    <a href="#%e9%82%a3%e6%8a%98%e8%85%be%e8%bf%99%e4%ba%9b%e4%b8%9c%e8%a5%bf%e5%88%b0%e5%ba%95%e6%9c%89%e4%bb%80%e4%b9%88%e5%a5%bd%e5%a4%84" class="header-mark"></a>那折腾这些东西，到底有什么好处？</h2><p>如果从很功利的角度看的话，确实就没啥好处，就跟打游戏一样，单纯在消遣时光而已。</p>
<figure><img src="./useless-work.jpg" width="35%"/>
</figure>

<p>要说跟做些无聊的事消遣时光有啥区别的话，大概就是还确实能获得点有用的东西。
比如我，遇到 AstroNvim 的 bug ，会提 PR 给上游仓库。发现 NixOS 的文档很糟糕，我直接自己写文档并分享出来。
发现 NixOS 缺少对我手头某块开发板的支持，我会自己尝试移植。
啥时候发现某工具缺少自己想要的功能，我也可能直接自己写一个。</p>
<p>这些折腾过程中获得的经验、创建的开源项目、在上游仓库中留下的 PR 、在社区中收获的感谢，感觉都是有价值的。
它不一定有啥业务价值，但是它好玩啊，还能交到朋友，帮到别人，在开源社区留下自己的痕迹，这不是很有意思么？</p>
<p>Linus 最开始写 Linux，也<a href="https://book.douban.com/subject/1451172/" target="_blank" rel="noopener noreferrer">只是为了好玩（Just For Fun）</a>.</p>]]></content></entry><entry><title type="html">MacOS 窗口管理器 yabai 玩耍笔记</title><link href="https://thiscute.world/posts/macos-window-manager-yabai-usage/"/><id>https://thiscute.world/posts/macos-window-manager-yabai-usage/</id><author><name>ryan4yin</name></author><published>2023-05-22T12:24:57+08:00</published><updated>2023-05-22T12:24:57+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/macos-window-manager-yabai-usage/yabai.png" height="1280" width="640"><figcaption></figcaption>
        </figure><p>在 Linux 上用了一段时间 i3wm 后，我就有点忍受不了工作电脑的桌面环境了，公司给配的是 Macbook Pro 2020，一番查找发现 yabai 比较符合我的需求，于是开始了折腾之旅。</p>
<h2 id="使用体验总结" class="headerLink">
    <a href="#%e4%bd%bf%e7%94%a8%e4%bd%93%e9%aa%8c%e6%80%bb%e7%bb%93" class="header-mark"></a>使用体验总结</h2><p>我的电脑配置为 Macbook Pro 2020，i5 + 16G RAM + 512G Disk，性能尚可。
我从 2023-04-25 开始在这台机器上使用 yabai，到现在（2023-05-18）有三周了，刚刚把 yabai 卸载掉，这里总结下使用体验。</p>
<p>一句话总结：体验还不错，但是还不太成熟，Bug 比较多，而且有点吃性能，安装 yabai 后偶尔就会卡顿一下。</p>
<p>自动分屏 + 快捷键自动调整窗口的体验还是很舒服的，劝退我的主要是如下这些问题：</p>
<ol>
<li>对有些软件，比如企业微信、微信、QQ，自动分屏功能不太行，会出现窗口错位。</li>
<li>如下两个问题逼着我一会儿进入全屏模式，一会儿又要退出全屏，简直离谱。
<ol>
<li>全屏下 Chrome 搜索框下方的提示栏被会 Chrome 本身遮挡，必须退出全屏功能才能看到。</li>
<li>非全屏下，Chrome 页面中的输入框「自动填充」功能会被 Chrome 遮挡，必须进入全屏模式才能看到&hellip;</li>
</ol>
</li>
<li>在右键修改 Firefox Bookmark 中标签时，弹出的修改菜单会被 Bookmark 收藏夹本身的弹窗遮挡，导致有些选项无法点击到。</li>
<li>开始使用 yabai 后，系统经常性地卡顿，或者风扇狂转，说明这玩意儿有点吃性能。</li>
</ol>
<h2 id="安装流程" class="headerLink">
    <a href="#%e5%ae%89%e8%a3%85%e6%b5%81%e7%a8%8b" class="header-mark"></a>安装流程</h2><p>首先参考这篇官方 Wiki <a href="https://github.com/koekeishiya/yabai/wiki/Disabling-System-Integrity-Protection" target="_blank" rel="noopener noreferrer">Disabling System Integrity Protection</a> 关闭 SIP，然后参照如下流程安装 yabai 与 skhd。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 安装yabai</span>
</span></span><span class="line"><span class="cl">brew install koekeishiya/formulae/yabai
</span></span><span class="line"><span class="cl">sudo yabai --install-sa
</span></span><span class="line"><span class="cl"><span class="c1"># 启动yabai 这时候需要授权辅助功能</span>
</span></span><span class="line"><span class="cl">brew services start yabai
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 安装skhd</span>
</span></span><span class="line"><span class="cl">brew install koekeishiya/formulae/skhd
</span></span><span class="line"><span class="cl"><span class="c1"># 启动skhd 这时候需要授权辅助功能</span>
</span></span><span class="line"><span class="cl">brew services start skhd
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">########### 为 yabai 添加 sudo 权限 ###########</span>
</span></span><span class="line"><span class="cl">sudo yabai --load-sa
</span></span><span class="line"><span class="cl">sudo visudo -f /private/etc/sudoers.d/yabai
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 然后输入以下内容 其中 &lt;user&gt; 修改为当前 mac 的用户名</span>
</span></span><span class="line"><span class="cl"><span class="c1"># input the line below into the file you are editing.</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  replace &lt;yabai&gt; with the path to the yabai binary (output of: which yabai).</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  replace &lt;user&gt; with your username (output of: whoami).</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  replace &lt;hash&gt; with the sha256 hash of the yabai binary (output of: shasum -a 256 $(which yabai)).</span>
</span></span><span class="line"><span class="cl"><span class="c1">#   this hash must be updated manually after running brew upgrade.</span>
</span></span><span class="line"><span class="cl">&lt;user&gt; <span class="nv">ALL</span><span class="o">=(</span>root<span class="o">)</span> NOPASSWD: sha256:&lt;hash&gt; &lt;yabai&gt; --load-sa
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面就完成了安装流程，但是到这里还不能使用，还需要为 skhd 与 yabai 添加配置文件，并添加自定义配置。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 创建yabai配置文件</span>
</span></span><span class="line"><span class="cl">touch ~/.yabairc
</span></span><span class="line"><span class="cl">chmod +x ~/.yabairc
</span></span><span class="line"><span class="cl"><span class="c1"># 创建skhd配置文件</span>
</span></span><span class="line"><span class="cl">touch ~/.skhdrc
</span></span><span class="line"><span class="cl">chmod +x ~/.skhdrc
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 之后在 ~/.yabairc 中添加以下命令</span>
</span></span><span class="line"><span class="cl">cat <span class="s">&lt;&lt;EOF &gt; ~/.yabairc
</span></span></span><span class="line"><span class="cl"><span class="s">#!/usr/bin/env sh
</span></span></span><span class="line"><span class="cl"><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s"># wiki 要求在配置最前面加这个，看起来是跟 sudo 权限相关的东西
</span></span></span><span class="line"><span class="cl"><span class="s">sudo yabai --load-sa
</span></span></span><span class="line"><span class="cl"><span class="s">yabai -m signal --add event=dock_did_restart action=&#34;sudo yabai --load-sa&#34;
</span></span></span><span class="line"><span class="cl"><span class="s">EOF</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="自定义-skhd-与-yabai-配置" class="headerLink">
    <a href="#%e8%87%aa%e5%ae%9a%e4%b9%89-skhd-%e4%b8%8e-yabai-%e9%85%8d%e7%bd%ae" class="header-mark"></a>自定义 skhd 与 yabai 配置</h2><p>这里配置的目标是，尽量与 i3wm 的默认快捷键保持一致，因为我在家用的是 Linux，只有办公电脑是 Mac.</p>
<p>我目前的 <code>~/.yabairc</code>，它用于配置 yabai 的各种行为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="cp">#!/usr/bin/env sh
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1"># wiki 要求在配置最前面加这个，看起来是跟 sudo 权限相关的东西</span>
</span></span><span class="line"><span class="cl">sudo yabai --load-sa
</span></span><span class="line"><span class="cl">yabai -m signal --add <span class="nv">event</span><span class="o">=</span>dock_did_restart <span class="nv">action</span><span class="o">=</span><span class="s2">&#34;sudo yabai --load-sa&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">## 输出 debug 日志，出问题时方便排查</span>
</span></span><span class="line"><span class="cl">yabai -m config debug_output on
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 窗口平铺</span>
</span></span><span class="line"><span class="cl">yabai -m space --layout bsp
</span></span><span class="line"><span class="cl"><span class="c1"># 默认拆分规则 first_child second_child</span>
</span></span><span class="line"><span class="cl">yabai -m config window_placement             second_child
</span></span><span class="line"><span class="cl"><span class="c1"># 窗口间距设置</span>
</span></span><span class="line"><span class="cl">yabai -m config top_padding                  <span class="m">10</span>
</span></span><span class="line"><span class="cl">yabai -m config bottom_padding               <span class="m">10</span>
</span></span><span class="line"><span class="cl">yabai -m config left_padding                 <span class="m">10</span>
</span></span><span class="line"><span class="cl">yabai -m config right_padding                <span class="m">10</span>
</span></span><span class="line"><span class="cl">yabai -m config window_gap                   <span class="m">10</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 自动平衡所有窗口始终占据相同的空间</span>
</span></span><span class="line"><span class="cl">yabai -m config auto_balance                 off
</span></span><span class="line"><span class="cl"><span class="c1"># 如果禁用自动平衡，此项属性定义的是新窗口占用的空间量。0.5意为旧窗口占用50%</span>
</span></span><span class="line"><span class="cl">yabai -m config split_ratio                 0.50
</span></span><span class="line"><span class="cl"><span class="c1"># 鼠标修饰键 意思就是按着这个键就可以使用鼠标单独修改窗口大小了</span>
</span></span><span class="line"><span class="cl">yabai -m config mouse_modifier ctrl
</span></span><span class="line"><span class="cl"><span class="c1"># ctrl + 鼠标左键 移动窗口</span>
</span></span><span class="line"><span class="cl">yabai -m config mouse_action1 move
</span></span><span class="line"><span class="cl"><span class="c1"># ctrl + 鼠标右键 调整窗口大小</span>
</span></span><span class="line"><span class="cl">yabai -m config mouse_action2 resize
</span></span><span class="line"><span class="cl"><span class="c1"># 焦点跟随鼠标 默认off: 关闭  autoraise:自动提升 autofocus: 自动对焦</span>
</span></span><span class="line"><span class="cl">yabai -m config focus_follows_mouse          autofocus
</span></span><span class="line"><span class="cl"><span class="c1"># 设置鼠标是否跟随当前活动窗口 默认 off: 关闭 on: 开启</span>
</span></span><span class="line"><span class="cl">yabai -m config mouse_follows_focus          on
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 浮动窗口问题在顶部</span>
</span></span><span class="line"><span class="cl">yabai -m config window_topmost               on
</span></span><span class="line"><span class="cl"><span class="c1"># 修改窗口阴影 on: 打开 off: 关闭 float: 只显示浮动窗口的阴影</span>
</span></span><span class="line"><span class="cl">yabai -m config window_shadow                float
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 窗口透明度设置</span>
</span></span><span class="line"><span class="cl">yabai -m config window_opacity               on
</span></span><span class="line"><span class="cl"><span class="c1"># 配置活动窗口不透明度</span>
</span></span><span class="line"><span class="cl">yabai -m config active_window_opacity        0.98
</span></span><span class="line"><span class="cl">yabai -m config normal_window_opacity        0.9
</span></span><span class="line"><span class="cl">yabai -m config window_opacity_duration      0.0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 在所有显示器上的每个空间顶部添加 0 填充 底部添加 0 填充</span>
</span></span><span class="line"><span class="cl">yabai -m config external_bar all:0:0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ================================ 规则 ================================</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 打开系统偏好设置，不使用平铺模式</span>
</span></span><span class="line"><span class="cl">yabai -m rule --add <span class="nv">app</span><span class="o">=</span><span class="s2">&#34;^系统偏好设置</span>$<span class="s2">&#34;</span> <span class="nv">manage</span><span class="o">=</span>off
</span></span><span class="line"><span class="cl">yabai -m rule --add <span class="nv">app</span><span class="o">=</span><span class="s2">&#34;^提醒事项</span>$<span class="s2">&#34;</span> <span class="nv">manage</span><span class="o">=</span>off
</span></span><span class="line"><span class="cl">yabai -m rule --add <span class="nv">app</span><span class="o">=</span><span class="s2">&#34;^关于本机</span>$<span class="s2">&#34;</span> <span class="nv">manage</span><span class="o">=</span>off
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;yabai configuration loaded..&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>再就是 <code>~/.skhdrc</code>，它负责配置各种快捷键，如下是我的配置:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 配置语法 : &lt;modifier&gt; - &lt;key&gt; : &lt;command&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># modifier 可以是单个键比如 cmd, alt, ctrl, 也可以是组合键比如  ctrl + shift, ctrl + alt</span>
</span></span><span class="line"><span class="cl"><span class="c1"># ================================ 打开终端 ================================</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 启动终端</span>
</span></span><span class="line"><span class="cl">cmd - <span class="k">return</span> : open -a iTerm
</span></span><span class="line"><span class="cl"><span class="c1"># 关闭当前窗口，这个不需要加，macOS 默认是 cmd + q，我 Linux 也这么设置的</span>
</span></span><span class="line"><span class="cl"><span class="c1"># ================================ 窗口设置 ================================</span>
</span></span><span class="line"><span class="cl"><span class="c1"># =============== 为了避免快捷键冲突改用了 ctrl 作为 modifier =================</span>
</span></span><span class="line"><span class="cl"><span class="c1"># ctrl + e 切换为平铺模式</span>
</span></span><span class="line"><span class="cl">ctrl - e : yabai -m space --layout bsp
</span></span><span class="line"><span class="cl"><span class="c1"># ctrl + s 切换为堆叠模式</span>
</span></span><span class="line"><span class="cl">ctrl - s : yabai -m space --layout stack
</span></span><span class="line"><span class="cl"><span class="c1"># 浮动/不浮动窗口 float</span>
</span></span><span class="line"><span class="cl">ctrl - f : yabai -m window --toggle float
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ================================ 多桌面配置  ================================</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 创建一个新桌面，并把当前活动的窗口发送到新桌面，并且自动跳转到新桌面. 需要 jq 支持 brew install jq</span>
</span></span><span class="line"><span class="cl"><span class="nb">shift</span> + cmd - n : yabai -m space --create <span class="o">&amp;&amp;</span> <span class="nv">index</span><span class="o">=</span><span class="s2">&#34;</span><span class="k">$(</span>yabai -m query --spaces --display <span class="p">|</span> jq <span class="s1">&#39;.| length&#39;</span><span class="k">)</span><span class="s2">&#34;</span> <span class="o">&amp;&amp;</span> yabai -m window --space <span class="s2">&#34;</span><span class="si">${</span><span class="nv">index</span><span class="si">}</span><span class="s2">&#34;</span> <span class="o">&amp;&amp;</span> yabai -m space --focus <span class="s2">&#34;</span><span class="si">${</span><span class="nv">index</span><span class="si">}</span><span class="s2">&#34;</span> <span class="o">&amp;&amp;</span> yabai -m space --layout bsp
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 在 stack 模式下通过方向键切换窗口</span>
</span></span><span class="line"><span class="cl">ctrl - down : yabai -m window --focus stack.next <span class="o">||</span> yabai -m window --focus south
</span></span><span class="line"><span class="cl">ctrl - up : yabai -m window --focus stack.prev <span class="o">||</span> yabai -m window --focus north
</span></span><span class="line"><span class="cl"><span class="c1"># 在 bsp 模式下通过方向键切换窗口</span>
</span></span><span class="line"><span class="cl">cmd - left : yabai -m window --focus west
</span></span><span class="line"><span class="cl">cmd - right : yabai -m window --focus east
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 在 9 个桌面之间切换</span>
</span></span><span class="line"><span class="cl">ctrl - <span class="m">1</span> : yabai -m space --focus <span class="m">1</span>
</span></span><span class="line"><span class="cl">ctrl - <span class="m">2</span> : yabai -m space --focus <span class="m">2</span>
</span></span><span class="line"><span class="cl">ctrl - <span class="m">3</span> : yabai -m space --focus <span class="m">3</span>
</span></span><span class="line"><span class="cl">ctrl - <span class="m">4</span> : yabai -m space --focus <span class="m">4</span>
</span></span><span class="line"><span class="cl">ctrl - <span class="m">5</span> : yabai -m space --focus <span class="m">5</span>
</span></span><span class="line"><span class="cl">ctrl - <span class="m">6</span> : yabai -m space --focus <span class="m">6</span>
</span></span><span class="line"><span class="cl">ctrl - <span class="m">7</span> : yabai -m space --focus <span class="m">7</span>
</span></span><span class="line"><span class="cl">ctrl - <span class="m">8</span> : yabai -m space --focus <span class="m">8</span>
</span></span><span class="line"><span class="cl">ctrl - <span class="m">9</span> : yabai -m space --focus <span class="m">9</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 将窗口发送到某个其他桌面</span>
</span></span><span class="line"><span class="cl">ctrl + <span class="nb">shift</span> - <span class="m">1</span> : yabai -m window --space <span class="m">1</span>
</span></span><span class="line"><span class="cl">ctrl + <span class="nb">shift</span> - <span class="m">2</span> : yabai -m window --space <span class="m">2</span>
</span></span><span class="line"><span class="cl">ctrl + <span class="nb">shift</span> - <span class="m">3</span> : yabai -m window --space <span class="m">3</span>
</span></span><span class="line"><span class="cl">ctrl + <span class="nb">shift</span> - <span class="m">4</span> : yabai -m window --space <span class="m">4</span>
</span></span><span class="line"><span class="cl">ctrl + <span class="nb">shift</span> - <span class="m">5</span> : yabai -m window --space <span class="m">5</span>
</span></span><span class="line"><span class="cl">ctrl + <span class="nb">shift</span> - <span class="m">6</span> : yabai -m window --space <span class="m">6</span>
</span></span><span class="line"><span class="cl">ctrl + <span class="nb">shift</span> - <span class="m">7</span> : yabai -m window --space <span class="m">7</span>
</span></span><span class="line"><span class="cl">ctrl + <span class="nb">shift</span> - <span class="m">8</span> : yabai -m window --space <span class="m">8</span>
</span></span><span class="line"><span class="cl">ctrl + <span class="nb">shift</span> - <span class="m">9</span> : yabai -m window --space <span class="m">9</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>配置加好后重启 yabai 与 skhd:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">brew services restart yabai
</span></span><span class="line"><span class="cl">brew services restart skhd
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在就可以随便打开几个程序试试，正常情况下 yabai 会自动帮你分屏。
再尝试下添加好的这些快捷键，看看是否生效。</p>
<h2 id="问题排查" class="headerLink">
    <a href="#%e9%97%ae%e9%a2%98%e6%8e%92%e6%9f%a5" class="header-mark"></a>问题排查</h2><h3 id="1-yabai" class="headerLink">
    <a href="#1-yabai" class="header-mark"></a>1. yabai</h3><p>如果 yabai 配置没有生效，有可能是权限问题，可以试下这个命令重启 yabai:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo yabai --uninstall-sa<span class="p">;</span> sudo yabai --load-sa<span class="p">;</span> brew services restart yabai
</span></span></code></pre></td></tr></table>
</div>
</div><p>其他问题可查看 yabai 的日志解决：</p>
<ul>
<li>错误日志路径: /usr/local/var/log/yabai/yabai.err.log</li>
<li>普通日志路径: /usr/local/var/log/yabai/yabai.out.log</li>
</ul>
<h3 id="2-skhd" class="headerLink">
    <a href="#2-skhd" class="header-mark"></a>2. skhd</h3><p>如果 skhd 配置没有生效，首先可以查看 skhd 的日志:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cat /usr/local/var/log/skhd/*.log
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果日志文件不存在，可以停止 skhd 服务并手动启动它，看看是否有输出报错：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">brew services stop skhd
</span></span><span class="line"><span class="cl">skhd -c ~/.skhdrc
</span></span></code></pre></td></tr></table>
</div>
</div><p>比如我之前改错了配置，执行上述命令就会报错：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#27:7 expected modifier
</span></span></code></pre></td></tr></table>
</div>
</div><p>提示我配置的第 27 行配置有问题，我就去看了下，发现是我把 <code>cmd - return</code> 写成了 <code>cmd + return</code>，改正后再 <code>brew services start skhd</code> 重启 skhd 就好了。</p>
<h2 id="堆叠模式下的可视化" class="headerLink">
    <a href="#%e5%a0%86%e5%8f%a0%e6%a8%a1%e5%bc%8f%e4%b8%8b%e7%9a%84%e5%8f%af%e8%a7%86%e5%8c%96" class="header-mark"></a>堆叠模式下的可视化</h2><p>yabai 在堆叠模式下的可视化效果不是很好，可以使用 <a href="https://github.com/AdamWagner/stackline" target="_blank" rel="noopener noreferrer">stackline</a> 来改善一下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># stackline 依赖 hammerspoon，这是一个 macOS 桌面自动化工具</span>
</span></span><span class="line"><span class="cl">brew install hammerspoon --cask
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 现在将 stackline 安装到 hammerspoon 的配置目录中</span>
</span></span><span class="line"><span class="cl">git clone https://github.com/AdamWagner/stackline.git ~/.hammerspoon/stackline
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Make stackline run when hammerspoon launches</span>
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> ~/.hammerspoon
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s1">&#39;stackline = require &#34;stackline&#34;&#39;</span> &gt;&gt; init.lua
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s1">&#39;stackline:init()&#39;</span> &gt;&gt; init.lua
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在还需要安装下 hammerspoon 的命令行工具 hs，它用于在脚本中执行 stackline 操作，安装方法如下：</p>
<ol>
<li>首先搜索打开 Hamerspoon 程序，或者使用命令 <code>open -a &quot;Hammerspoon&quot;</code>
<ol>
<li>这里启动时会申请权限，需要手动打开下</li>
<li>同时注意勾选登录时自动启动</li>
</ol>
</li>
<li>在下方的命令输出栏中键入 <code>hs.ipc.cliInstall()</code> 再回车，即可完成安装</li>
</ol>
<p>现在确认下 hs 命令已经可用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">which hs
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="使用时的常见问题与解决方法" class="headerLink">
    <a href="#%e4%bd%bf%e7%94%a8%e6%97%b6%e7%9a%84%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e4%b8%8e%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95" class="header-mark"></a>使用时的常见问题与解决方法</h2><ol>
<li>Chrome/WeChat 等程序的弹窗无法显示: 尝试下进入全屏或者退出全屏，总有一种场景下可以显示弹窗&hellip;</li>
<li>&hellip;</li>
</ol>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://vccv.cc/article/mac-tiling-yabai.html" target="_blank" rel="noopener noreferrer">mac 下的平铺桌面 yabai 使用 - 月青悠</a></li>
<li><a href="https://gist.github.com/Krever/74d43fa38c57c42c355df55faa0a00ee" target="_blank" rel="noopener noreferrer">Yabai setup for i3wm users - Krever</a></li>
</ul>
]]></content></entry><entry><title type="html">NixOS 与 Nix Flakes 新手入门</title><link href="https://thiscute.world/posts/nixos-and-flake-basics/"/><id>https://thiscute.world/posts/nixos-and-flake-basics/</id><author><name>ryan4yin</name></author><published>2023-05-04T15:19:28+08:00</published><updated>2023-06-21T16:16:00+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/nixos-and-flake-basics/nixos-and-flakes-book.webp" height="2219" width="800"><figcaption></figcaption>
        </figure><p>随着文章的更新，文章内容逐渐增多，为了方便阅读，文章内容已经迁移到单独的站点:</p>
<ul>
<li>文档站: <a href="https://nixos-and-flakes.thiscute.world/zh/" target="_blank" rel="noopener noreferrer">https://nixos-and-flakes.thiscute.world/zh/</a></li>
<li>GitHub: <a href="https://github.com/ryan4yin/nixos-and-flakes-book" target="_blank" rel="noopener noreferrer">https://github.com/ryan4yin/nixos-and-flakes-book</a></li>
</ul>
<p>非常感谢 <a href="https://www.reddit.com/r/NixOS/comments/14fvz1q/comment/jp4xhj3/?context=3" target="_blank" rel="noopener noreferrer">Reddit</a>、文章评论区、<a href="https://www.v2ex.com/t/951190#reply9" target="_blank" rel="noopener noreferrer">V2EX</a> 以及 <a href="https://0xffff.one/d/1521-nixos-yu-nix-flakes-xin-shou-ru-men/4" target="_blank" rel="noopener noreferrer">0xffff.one</a> 等平台上各位朋友的反馈、批评与建议 ❤️</p>
]]></content></entry><entry><title type="html">Linux 上的 WireGuard 网络分析（一）</title><link href="https://thiscute.world/posts/wireguard-on-linux/"/><id>https://thiscute.world/posts/wireguard-on-linux/</id><author><name>ryan4yin</name></author><published>2023-03-28T22:19:25+08:00</published><updated>2023-03-28T22:19:25+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/wireguard-on-linux/wireguard.png" height="1280" width="500"><figcaption></figcaption>
        </figure><blockquote>
<p>阅读此文章需要前置知识：Linux 网络基础知识、iptables、conntrack</p>
</blockquote>
<blockquote>
<p>本文内容部分采用了 Copilot 提示内容，也有部分内容用了 ChatGPT 免费版进行分析，确实都比较有帮助。</p>
</blockquote>
<p>最近因为工作需要研究了一波 WireGuard 协议，在这篇文章中简单记录下心得。</p>
<h2 id="wireguard-是什么" class="headerLink">
    <a href="#wireguard-%e6%98%af%e4%bb%80%e4%b9%88" class="header-mark"></a>WireGuard 是什么</h2><p>WireGuard 是极简主义思想下的 VPN 实现，解决了很多现存 VPN 协议存在的问题。
它于 2015 年由 Jason A. Donenfeld 设计实现，因其代码实现简洁易懂、配置简单、性能高、安全强度高而受到广泛关注。</p>
<p>WireGuard 在 2020 年初进入 Linux 主线分支，随后成为 Linux 5.6 的一个内核模块，这之后很快就涌现出许多基于 WireGuard 的开源项目与相关企业，各大老牌 VPN 服务商也逐渐开始支持 WireGuard 协议，很多企业也使用它来组建企业 VPN 网络。</p>
<p>基于 WireGuard 的明星开源项目举例：</p>
<ul>
<li><a href="https://github.com/tailscale/tailscale" target="_blank" rel="noopener noreferrer">tailscale</a>: 一套简单易用的 WireGuard VPN 私有网络解决方案，强烈推荐！</li>
<li><a href="https://github.com/juanfont/headscale" target="_blank" rel="noopener noreferrer">headscale</a>: tailscale 控制服务器的开源实现，使你可以自建 tailscale 服务。</li>
<li><a href="https://github.com/squat/kilo" target="_blank" rel="noopener noreferrer">kilo</a>: 基于 WireGuard 的 Kubernetes 多云网络解决方案。</li>
<li>&hellip;</li>
<li>除了上面这些，还有很多其他 WireGuard 项目，有兴趣可以去 <a href="https://github.com/cedrickchee/awesome-wireguard" target="_blank" rel="noopener noreferrer">awesome-wireguard</a> 仓库看看。</li>
</ul>
<p>WireGuard 本身只是一个点对点隧道协议，只提供点对点通信的能力（这也是其极简主义思想的体现）。而其他网络路由、NAT 穿越、DNS 解析、防火墙策略等功能都是基于 Linux 系统的现有工具来实现的。</p>
<p>在这篇文章里，我将搭建一个简单的单服务器 + 单客户端 WireGuard 网络，然后分析它如何使用 Linux 系统现有的工具，在 WireGuard 隧道上搭建出一个安全可靠的虚拟网络。</p>
<p>文章测试用到的服务器与客户端均为虚拟机，使用 Ubuntu 20.04 系统，内核版本为 5.15，也就是说都包含了 wireguard 内核模块。</p>
<h2 id="wireguard-服务端网络分析" class="headerLink">
    <a href="#wireguard-%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%bd%91%e7%bb%9c%e5%88%86%e6%9e%90" class="header-mark"></a>WireGuard 服务端网络分析</h2><p>简单起见，这里使用 docker-compose 启动一个 WireGuard 服务端，使用的镜像是 <a href="https://github.com/linuxserver/docker-wireguard" target="_blank" rel="noopener noreferrer">linuxserver/docker-wireguard</a>。</p>
<p>配置文件如下，内容完全参考自此镜像的官方 README：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;2.1&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">wireguard</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">lscr.io/linuxserver/wireguard:latest</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">wireguard</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">cap_add</span><span class="p">:</span><span class="w">           
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">NET_ADMIN</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">SYS_MODULE</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">PUID=1000</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">PGID=1000</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">TZ=Etc/UTC</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">SERVERURL=auto  </span><span class="w"> </span><span class="c"># 自动确定服务器的外部 IP 地址，在生成客户端配置时会用到</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">SERVERPORT=51820</span><span class="w"> </span><span class="c"># 服务端监听的端口号</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">PEERS=1         </span><span class="w"> </span><span class="c"># 自动生成 1 个客户端配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">PEERDNS=auto    </span><span class="w"> </span><span class="c"># 自动确定客户端的 DNS 服务器地址，同样是在生成客户端配置时会用到</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">INTERNAL_SUBNET=10.13.13.0   </span><span class="w"> </span><span class="c"># WireGuard 虚拟网络的网段</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">ALLOWEDIPS=0.0.0.0/0         </span><span class="w"> </span><span class="c"># 这条规则表示允许虚拟网络内的所有客户端将流量发送到此节点</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># 众所周知，NAT 网络需要定期发送心跳包来保持 NAT 表内容不过期，俗称连接保活。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c"># 这里设置为 all 表示所有客户端都开启连接保活。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">PERSISTENTKEEPALIVE_PEERS=all </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">LOG_CONFS=true</span><span class="w"> </span><span class="c"># 开启日志</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">./config:/config</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">/lib/modules:/lib/modules</span><span class="w"> </span><span class="c"># 将宿主机的内核模块挂载到容器内，用于加载 WireGuard 内核模块</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="m">51820</span><span class="p">:</span><span class="m">51820</span><span class="l">/udp</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">sysctls</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">net.ipv4.conf.all.src_valid_mark=1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">unless-stopped</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>将上面的配置文件保存为 <code>docker-compose.yml</code>，然后通过如下命令后台启动 WireGuard 服务端：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">docker-compose up -d
</span></span></code></pre></td></tr></table>
</div>
</div><p>WireGuard 服务端启动好了，现在查看下服务端容器的日志（我加了详细注释说明）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ docker logs wireguard
</span></span><span class="line"><span class="cl"><span class="c1"># ...省略若干内容</span>
</span></span><span class="line"><span class="cl">.:53                          <span class="c1"># 这几行日志是启动 CoreDNS，为虚拟网络提供默认的 DNS 服务</span>
</span></span><span class="line"><span class="cl">CoreDNS-1.10.1                <span class="c1"># 实际上 CoreDNS 不是必须的，客户端可以改用其他 DNS 服务器</span>
</span></span><span class="line"><span class="cl">linux/amd64, go1.20, 055b2c3
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] ip link add wg0 type wireguard   # 创建一个 wireguard 设备</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] wg setconf wg0 /dev/fd/63        # 设置 wireguard 设备的配置</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] ip -4 address add 10.13.13.1 dev wg0   # 为 wireguard 设备添加一个 ip 地址</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] ip link set mtu 1420 up dev wg0        # 设置 wireguard 设备的 mtu</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] ip -4 route add 10.13.13.2/32 dev wg0  # 为 wireguard peer1 添加路由，其地址来自 wireguard 配置的 `allowedIPs` 参数</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 下面这几条 iptables 命令为 wireguard 设备添加 NAT 规则，使其成为 WireGuard 虚拟网络的默认网关</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 并使虚拟网络内的其他 peers 能通过此默认网关访问外部网络。</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] iptables -A FORWARD -i wg0 -j ACCEPT; iptables -A FORWARD -o wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth+ -j MASQUERADE</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>ls.io-init<span class="o">]</span> <span class="k">done</span>.
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过日志能看到，程序首先创建了 WireGuard 设备 wg0 并绑定了地址 <code>10.13.13.1</code>。作为 WireGuard 网络中的服务端，它所创建的这个 wg0 的任务是成为整个 WireGuard 虚拟网络的默认网关，处理来自虚拟网络内的其他 peers 的流量，构成一个星型网络。</p>
<p>然后服务端为它所生成的 peer1 添加了一个路由，使得 peer1 的流量能够被正确路由到 wg0 设备上。</p>
<p>最后为了让 WireGuard 虚拟网络内的其他 peers 的流量能够通过 wg0 设备访问外部网络或者互相访问，服务端为 wg0 设备添加了如下的 iptables 规则：</p>
<ul>
<li><code>iptables -A FORWARD -i wg0 -j ACCEPT; iptables -A FORWARD -o wg0 -j ACCEPT;</code>：允许进出 wg0 设备的数据包通过 netfilter 的 FORWARD 链（默认规则是 DROP，即默认是不允许通过的）</li>
<li><code>iptables -t nat -A POSTROUTING -o eth+ -j MASQUERADE</code>：在 eth+ 网卡上添加 MASQUERADE 规则，即将数据包的源地址伪装成 eth+ 网卡的地址，目的是为了允许 wireguard 的数据包通过 NAT 访问外部网络。
<ul>
<li>而回来的流量会被 NAT 的 conntrack 链接追踪规则自动允许通过，不过 conntrack 表有自动清理机制，长时间没流量的话会被从 conntrack 表中移除。这就是前面 <code>docker-compose.yml</code> 中的 <code>PERSISTENTKEEPALIVE_PEERS=all</code> 参数解决的问题通过定期发送心跳包来保持 conntrack 表中的连接信息。</li>
<li>这里还涉及到了 NAT 穿越相关内容，就不多展开了，感兴趣的可以自行了解。</li>
</ul>
</li>
</ul>
<p>WireGuard 的实现中还有一个比较重要的概念叫做 <code>AllowedIPs</code>，它是一个 IP 地址列表，表示允许哪些 IP 地址的流量通过 WireGuard 虚拟网络。
为了详细说明这一点，我们先看下服务端配置文件夹中 wg0 的配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ cat wg0.conf
</span></span><span class="line"><span class="cl"><span class="o">[</span>Interface<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nv">Address</span> <span class="o">=</span> 10.13.13.1
</span></span><span class="line"><span class="cl"><span class="nv">ListenPort</span> <span class="o">=</span> <span class="m">51820</span>
</span></span><span class="line"><span class="cl"><span class="nv">PrivateKey</span> <span class="o">=</span> kGZzt/CU2MVgq19ffXB2YMDSr6WIhlkdlL1MOeGH700<span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="c1"># wg0 隧道启动后添加 iptables 规则</span>
</span></span><span class="line"><span class="cl"><span class="nv">PostUp</span> <span class="o">=</span> iptables -A FORWARD -i %i -j ACCEPT<span class="p">;</span> iptables -A FORWARD -o %i -j ACCEPT<span class="p">;</span> iptables -t nat -A POSTROUTING -o eth+ -j MASQUERADE
</span></span><span class="line"><span class="cl"><span class="c1"># wg0 隧道停止后删除前面添加的 iptables 规则</span>
</span></span><span class="line"><span class="cl"><span class="nv">PostDown</span> <span class="o">=</span> iptables -D FORWARD -i %i -j ACCEPT<span class="p">;</span> iptables -D FORWARD -o %i -j ACCEPT<span class="p">;</span> iptables -t nat -D POSTROUTING -o eth+ -j MASQUERADE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>Peer<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># peer1</span>
</span></span><span class="line"><span class="cl"><span class="nv">PublicKey</span> <span class="o">=</span> HR8Kp3xWIt2rNdS3aaCk+Ss7yQqC9cn6h3WS6UK3WE0<span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="nv">PresharedKey</span> <span class="o">=</span> 7mCNCZdMKeRz1Zrpl9bFS08jJAdv6/USazRVq7tjznY<span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="c1"># AllowedIPs 设置为 peer1 的虚拟 IP 地址，表示允许 peer1 的流量通过 WireGuard 虚拟网络</span>
</span></span><span class="line"><span class="cl"><span class="nv">AllowedIPs</span> <span class="o">=</span> 10.13.13.2/32
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>AllowedIPs</code> 实际就是每个 peer 在服务端路由表中的 ip 地址，它既可以是 ip 也可以是网段，而且能设置多个，这使所有 peer 都可以负责一个甚至多个 ip 段的转发，也就是充当局域网的路由器——VPN 子路由。</p>
<p>WireGuard 本身只是一个点对点隧道协议，它非常通用。通过 <code>AllowedIPs</code> 参数，我们就能在每个 peer 上添加各 peers 的配置与不同的路由规则，构建出各种复杂的网络拓扑，比如星型、环型、树型等等。</p>
<h2 id="wireguard-客户端网络分析" class="headerLink">
    <a href="#wireguard-%e5%ae%a2%e6%88%b7%e7%ab%af%e7%bd%91%e7%bb%9c%e5%88%86%e6%9e%90" class="header-mark"></a>WireGuard 客户端网络分析</h2><p>现在换台虚拟机跑 WireGuard 客户端，首先需要安装 wireguard 命令行工具：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo apt install wireguard resolvconf
</span></span></code></pre></td></tr></table>
</div>
</div><p>第二步是从服务端的配置文件夹中找到 <code>peer1/peer1.conf</code>，它是服务端容器根据参数 <code>PEERS=1</code> 自动生成的客户端配置文件，先确认下它的内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ <span class="nb">cd</span> ./config/peer1
</span></span><span class="line"><span class="cl">$ cat peer1.conf
</span></span><span class="line"><span class="cl"><span class="o">[</span>Interface<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nv">Address</span> <span class="o">=</span> 10.13.13.2
</span></span><span class="line"><span class="cl"><span class="nv">PrivateKey</span> <span class="o">=</span> +GLDb5QQOHQ2QKWvuFS/4FiWpnivaxzwlm0QmFJIHV8<span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="nv">ListenPort</span> <span class="o">=</span> <span class="m">51820</span>
</span></span><span class="line"><span class="cl"><span class="nv">DNS</span> <span class="o">=</span> 10.13.13.1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>Peer<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nv">PublicKey</span> <span class="o">=</span> <span class="nv">t95vF4b11RLCId3ArVVIJoC5Ih9CNbI0VTNuDuEzZyw</span><span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="nv">PresharedKey</span> <span class="o">=</span> 7mCNCZdMKeRz1Zrpl9bFS08jJAdv6/USazRVq7tjznY<span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 需要注意的是这个 Peer Endpoint 的 IP 是否正确</span>
</span></span><span class="line"><span class="cl"><span class="nv">Endpoint</span> <span class="o">=</span> 192.168.5.198:51820
</span></span><span class="line"><span class="cl"><span class="nv">AllowedIPs</span> <span class="o">=</span> 0.0.0.0/0
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>插入下，这个 Endpoint 的地址也很值得一说，能看到服务端 wg0.conf 的配置中，peer1 并未被设置任何 Endpoint，这实质是表示这个 peer1 的 Endpoint 是动态的，也就是说每次 peer1 发送数据到服务端 wg0 时，服务端通过认证加密技术认证了数据后，就会以数据包的来源 IP 地址作为 peer1 的 Endpoint，这样 peer1 就可以随意更换自己的 IP 地址（Roaming），而 WireGuard 隧道仍然能正常工作（IP 频繁更换的一个典型场景就是手机的网络漫游与 WiFi 切换）。这使 WireGuard 具备了比较明显的无连接特性，也就是说 WireGuard 隧道不需要保持一个什么连接，切换网络也不需要重连，只要数据包能够到达服务端，就能够正常工作。</p>
</blockquote>
<p>因为我这里是内网环境测试，配置文件中的 <code>Peer</code> - <code>Endpoint</code> 的 IP 地址直接用服务端的内网 IP 地址就行，也就是 <code>192.168.5.198</code>。</p>
<blockquote>
<p>如果你的服务端有公网 IP 地址（比如是云服务器，或者通过端口映射用家庭宽带的动态公网 IP），这个 Endpoint 地址也可以使用该公网 IP 地址，效果是一样的。</p>
</blockquote>
<p>配置文件确认无误后，将该配置文件保存到客户端的 <code>/etc/wireguard/peer1.conf</code> 这个路径下，然后使用如下命令启动 WireGuard 客户端：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo wg-quick up peer1
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述命令会自动在 <code>/etc/wireguard/</code> 目录下找到名为 <code>peer1.conf</code> 的配置文件，然后根据其内容启动一个名为 <code>peer1</code> 的 WireGuard 设备并完成对应配置。</p>
<p>我启动时的日志如下，wg-quick 打印出了它执行的所有网络相关指令（我添加了详细的注释）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ sudo wg-quick up peer1
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] ip link add peer1 type wireguard        # 创建一个名为 peer1 的 WireGuard 设备</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] wg setconf peer1 /dev/fd/63             # 设置 peer1 设备的配置</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] ip -4 address add 10.13.13.2 dev peer1  # 设置 peer1 设备的 IP 地址</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] ip link set mtu 1420 up dev peer1       # 设置 peer1 设备的 MTU</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] resolvconf -a tun.peer1 -m 0 -x  # 设置 peer1 设备的 DNS，确保 DNS 能够正常工作</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] wg set peer1 fwmark 51820        # 将 peer1 设备的防火墙标记设为 51820，用于标记 WireGuard 出站流量</span>
</span></span><span class="line"><span class="cl">                                     <span class="c1"># 在后面的路由策略中会使用该标记使 WireGuard 出站流量走默认路由表</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] ip -4 route add 0.0.0.0/0 dev peer1 table 51820     # 创建单独的路由表 51820，默认将所有流量转发到 peer1 接口</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] ip -4 rule add not fwmark 51820 table 51820         # 所有不带 51820 标记的流量（普通流量），都转发到前面新建的路由表 51820</span>
</span></span><span class="line"><span class="cl">                                                        <span class="c1"># 也就是所有普通流量都转发到 peer1 接口</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] ip -4 rule add table main suppress_prefixlength 0   # 流量全都走 main 路由表（即默认路由表），但是排除掉前缀长度（掩码） &lt;= 0 的流量</span>
</span></span><span class="line"><span class="cl">                                                        <span class="c1"># 掩码 &lt;= 0 的只有 0.0.0.0/0，即默认路由。所以意思是所有非默认路由策略的流量都走 main 路由表</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] sysctl -q net.ipv4.conf.all.src_valid_mark=1        # 启用源地址有效性检查，用于防止伪造源地址</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] nft -f /dev/fd/63                                   # 配置 nftables 规则，用于确保 WireGuard 流量能正确路由，并防止恶意数据包进入网络</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>跑完后我们现在确认下状态，应该是能正常走 WireGuard 访问相关网络了，可以 WireShark 抓个包确认下。</p>
<blockquote>
<p>如果网络不通，那肯定是中间哪一步配置有问题，可以根据上面的日志一步步排查网络接口、路由表、路由策略、iptables/nftables 的配置，必要时可以通过 WireShark 抓包定位。</p>
</blockquote>
<p>现在再检查下系统的网络状态，首先检查下路由表，会发现路由表没任何变化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ ip route ls
</span></span><span class="line"><span class="cl">default via 192.168.5.201 dev eth0 proto static 
</span></span><span class="line"><span class="cl">192.168.5.0/24 dev eth0 proto kernel scope link src 192.168.5.197 
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是我们的 WireGuard 隧道已经生效了，这就说明现在我们的流量已经不是直接走上面这个默认路由表了，还有其他配置在起作用。
往回看看前面的客户端启动日志，其中显示 wg-quick 创建了一个名为 51820 的路由表，我们来检查下这个表：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ryan@ubuntu-2004-builder:~$ ip route ls table <span class="m">51820</span>
</span></span><span class="line"><span class="cl">default dev peer1 scope link
</span></span></code></pre></td></tr></table>
</div>
</div><p>能看到这个表确实是将所有流量都转发到了 WireGuard 的 peer1 接口，基本能确认现在流量都走了这个路由表。
那么问题来了，系统的流量是如何被转发到这个路由表的呢？为什么默认的路由表现在不生效了？</p>
<p>要理清这个问题，需要补充点知识——Linux 从 2.2 开始支持了多路由表，并通过路由策略数据库来为每个数据包选择正确的路由表，这个路由策略数据库可以通过 <code>ip rule</code> 命令来查看、修改。</p>
<p>前置知识补充完毕，现在来看下系统当前的路由策略，同样我已经补充好了注释：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ ip rule show
</span></span><span class="line"><span class="cl">0:      from all lookup <span class="nb">local</span>   <span class="c1"># 0 是最高优先级，`all` 表示所有流量，`lookup local` 表示查找 local 路由表。</span>
</span></span><span class="line"><span class="cl">                                <span class="c1"># local 是一个特殊路由表，包含对本地和广播地址的优先级控制路由。</span>
</span></span><span class="line"><span class="cl">32764:  from all lookup main suppress_prefixlength <span class="m">0</span>  <span class="c1"># 32764 目前是第二优先级，将所有流量路由到 main 路由表，但是排除掉默认路由（前缀/掩码 &lt;= 0）</span>
</span></span><span class="line"><span class="cl">                                                      <span class="c1"># 功能是让所有非默认路由的流量都走 main 路由表</span>
</span></span><span class="line"><span class="cl">                                                      <span class="c1"># 这条规则前面实际解释过了，它是 wg-quick 在启动隧道时添加的规则。</span>
</span></span><span class="line"><span class="cl">32765:  not from all fwmark 0xca6c lookup <span class="m">51820</span> <span class="c1"># 所有不带 0xca6c 标记（51820 的 16 进制格式）的流量（普通流量），都走 51820 路由表</span>
</span></span><span class="line"><span class="cl">                                                <span class="c1"># 也就是都转发到 WireGuard peer1 接口。</span>
</span></span><span class="line"><span class="cl">                                                <span class="c1"># 这条规则是前面的 `ip -4 rule add not fwmark 51820 table 51820` 命令添加的。</span>
</span></span><span class="line"><span class="cl">                                                <span class="c1"># 而它所匹配的防火墙标记则是由前面的 `wg set peer1 fwmark 51820` 命令设置的。</span>
</span></span><span class="line"><span class="cl">32766:  from all lookup main    <span class="c1"># 所有流量都走 main 路由表，当前是不生效状态，因为前面的规则优先级更高。</span>
</span></span><span class="line"><span class="cl">                                <span class="c1"># main 是系统的默认路由表，通常我们使用 ip route 命令都是在这个表上操作。</span>
</span></span><span class="line"><span class="cl">32767:  from all lookup default <span class="c1"># 所有流量都走 default 路由表，当前同样是不生效状态。</span>
</span></span><span class="line"><span class="cl">                                <span class="c1"># default 是一个系统生成的兜底路由表，默认不包含任何路由规则，可用于自定义路由策略，也可删除。</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>结合注释看完上面的路由策略，现在你应该理清楚 WireGuard 的路由规则了，它加了条比默认路由策略 <code>32766</code> 优先级更高的路由策略 <code>32765</code>，将所有普通流量都通过它的自定义路由表路由到 peer1 接口。
另一方面 peer1 接口在前面已经被打了 fwmark 标记 <code>51820</code> 也就是 16 进制的 0xca6c，所以 peer1 出站到服务端的流量不会被 <code>32765</code> 匹配到，所以会走优先级更低的 <code>32766</code> 策略，也就是走了 main 路由表。</p>
<p>另外 <code>32764</code> 这条路由策略有点特殊，这里也简单解释下，此策略在前面注释中已经做了解释——是让所有非默认路由的流量都走 main 路由表，而 main 路由表中的非默认路由一般都是其他程序自动管理添加的，或者是我们手动添加的，所以这条规则其实就是确保这些路由策略仍然有效，避免 WireGuard 策略把它们覆盖掉而导致问题。</p>
<p>前面都分析完了，现在还剩下 wg-quick 日志的最后一行 <code>nft -f /dev/fd/63</code>，它到底做了什么呢？
nft 是 nftables 的命令行工具名称，所以它实际是设置了一些 nftables 规则，我们查看下它的规则内容：</p>
<blockquote>
<p>注意：nftables 的这些 chain 名称是完全自定义的，没啥特殊意义</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ sudo nft list ruleset
</span></span><span class="line"><span class="cl">table ip wg-quick-peer1 <span class="o">{</span>
</span></span><span class="line"><span class="cl">        chain preraw <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="nb">type</span> filter hook prerouting priority raw<span class="p">;</span> policy accept<span class="p">;</span>
</span></span><span class="line"><span class="cl">                iifname !<span class="o">=</span> <span class="s2">&#34;peer1&#34;</span> ip daddr 10.13.13.2 fib saddr <span class="nb">type</span> !<span class="o">=</span> <span class="nb">local</span> drop
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        chain premangle <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="nb">type</span> filter hook prerouting priority mangle<span class="p">;</span> policy accept<span class="p">;</span>
</span></span><span class="line"><span class="cl">                meta l4proto udp meta mark <span class="nb">set</span> ct mark
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        chain postmangle <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="nb">type</span> filter hook postrouting priority mangle<span class="p">;</span> policy accept<span class="p">;</span>
</span></span><span class="line"><span class="cl">                meta l4proto udp meta mark 0x0000ca6c ct mark <span class="nb">set</span> meta mark
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到这里是创建了一个 <code>wg-quick-peer1</code> 表，通过该表在 netfilter 上设置了如下规则：</p>
<ol>
<li><code>preraw</code> 链：此链用于防止恶意数据包进入网络。
<ol>
<li>type 开头的一行是规则的类型，这里是 <code>filter</code>，仅匹配了 <code>raw</code> 链的 <code>prerouting</code> 表。</li>
<li>它丢弃掉所有来源接口不是 peer1、目的地址是 10.13.13.2、且源地址不是本地地址的数据包。</li>
<li>总结下就是只允许本地地址或者 peer1 直接访问 10.13.13.2 这个地址。</li>
</ol>
</li>
<li><code>premangle</code> 链：此链用于确保所有 UDP 数据包都能被正确从 WireGuard 接口入站。
<ol>
<li>它将所有 UDP 数据包的标记设置为连接跟踪标记（没搞懂这个标记是如何生效的&hellip;.）。</li>
</ol>
</li>
<li><code>postmangle</code> 链：此链用于确保所有 UDP 数据包都能被正确从 WireGuard 接口出站。
<ol>
<li>它将所有 UDP 数据包的标记设置为 0xca6c（51820 的 16 进制格式）（同样没理解这个标记是如何生效的&hellip;）。</li>
</ol>
</li>
</ol>
<p>最后看下 WireGuard 的状态，它是前面 <code>wg setconf peer1 /dev/fd/63</code> 设置的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ryan@ubuntu-2004-builder:~$ sudo wg show 
</span></span><span class="line"><span class="cl">interface: peer1
</span></span><span class="line"><span class="cl">  public key: HR8Kp3xWIt2rNdS3aaCk+Ss7yQqC9cn6h3WS6UK3WE0<span class="o">=</span>
</span></span><span class="line"><span class="cl">  private key: <span class="o">(</span>hidden<span class="o">)</span>
</span></span><span class="line"><span class="cl">  listening port: <span class="m">51820</span>
</span></span><span class="line"><span class="cl">  fwmark: 0xca6c
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">peer: <span class="nv">t95vF4b11RLCId3ArVVIJoC5Ih9CNbI0VTNuDuEzZyw</span><span class="o">=</span>
</span></span><span class="line"><span class="cl">  preshared key: <span class="o">(</span>hidden<span class="o">)</span>
</span></span><span class="line"><span class="cl">  endpoint: 192.168.5.198:51820
</span></span><span class="line"><span class="cl">  allowed ips: 0.0.0.0/0
</span></span><span class="line"><span class="cl">  latest handshake: <span class="m">18</span> minutes, <span class="m">59</span> seconds ago
</span></span><span class="line"><span class="cl">  transfer: <span class="m">124</span> B received, <span class="m">324</span> B sent
</span></span></code></pre></td></tr></table>
</div>
</div><p>分析完毕，现在关闭掉 WireGuard 客户端，将客户端主机的网络恢复到正常状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ sudo wg-quick down peer1
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] ip -4 rule delete table 51820</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] ip -4 rule delete table main suppress_prefixlength 0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] ip link delete dev peer1</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] resolvconf -d tun.peer1 -f</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="c1">#] nft -f /dev/fd/63</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="结语" class="headerLink">
    <a href="#%e7%bb%93%e8%af%ad" class="header-mark"></a>结语</h2><p>一通分析，你是否感觉到了 wg-quick 的实现十分巧妙，通过简单几行 iptables/nftables 与 iproute2 命令就在 WireGuard 隧道上实现了一个 VPN 网络，更妙的是只要把新增的这些 iptables/nftables 与 iproute2 规则删除，就能恢复到 WireGuard 未启动的状态，相当于整个工作是完全可逆的（显然前面的 <code>sudo wg-quick down peer1</code> 就是这么干的）。</p>
<p>总之这篇文章简单分析了 wireguard 虚拟网络在 Linux 上的实现，希望对你有所帮助。</p>
<p>下一篇文章（如果有的话&hellip;），我会带来更多的 WireGuard 实现细节，敬请期待。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://www.wireguard.com/protocol/" target="_blank" rel="noopener noreferrer">wireguard protocol</a>： 官方文档还有官方的白皮书，都写得很清晰易懂。</li>
<li><a href="https://zhuanlan.zhihu.com/p/404402933" target="_blank" rel="noopener noreferrer">WireGuard到底好在哪？</a>: 比较深入浅出的随想，值得一读。</li>
<li><a href="https://ro-che.info/articles/2021-02-27-linux-routing" target="_blank" rel="noopener noreferrer">Understanding modern Linux routing (and wg-quick)</a>: 对 WireGuard 客户端用到的多路由表与路由策略技术做了详细的介绍。
<ul>
<li>它的中文翻译：<a href="https://icloudnative.io/posts/linux-routing-of-wireguard/" target="_blank" rel="noopener noreferrer">WireGuard 基础教程：wg-quick 路由策略解读 - 米开朗基扬</a></li>
</ul>
</li>
</ul>
]]></content></entry><entry><title type="html">EE 入门（二） - 使用 ESP32 与 SPI 显示屏绘图、显示图片、跑贪吃蛇</title><link href="https://thiscute.world/posts/ee-basics-2-esp32-display/"/><id>https://thiscute.world/posts/ee-basics-2-esp32-display/</id><author><name>ryan4yin</name></author><published>2023-03-05T21:57:01+08:00</published><updated>2023-03-05T21:57:01+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/ee-basics-2-esp32-display/tft_esp32_show_image-2.webp" height="1333" width="1000"><figcaption></figcaption>
        </figure><h2 id="零硬件准备与依赖库调研" class="headerLink">
    <a href="#%e9%9b%b6%e7%a1%ac%e4%bb%b6%e5%87%86%e5%a4%87%e4%b8%8e%e4%be%9d%e8%b5%96%e5%ba%93%e8%b0%83%e7%a0%94" class="header-mark"></a>零、硬件准备与依赖库调研</h2><p>之前淘货买了挺多显示屏的，本文使用的是这一块：</p>
<ul>
<li><a href="http://www.lcdwiki.com/3.5inch_SPI_Module_ILI9488_SKU:MSP3520" target="_blank" rel="noopener noreferrer">3.5 寸电阻触摸屏，480 * 320，SPI 协议，显示屏驱动 IC 为 ILI9488</a></li>
</ul>
<p>开发板是 ESP-WROOM-32 模组开发板。
其他需要的东西：杜邦线、面包板、四个 10 K$\Omega$ 电阻、四个按键。</p>
<p>至于需要的依赖库，我找到如下几个 stars 数较高的支持 ILI9488 + ESP32 的显示屏驱动库：</p>
<ul>
<li><a href="https://github.com/Bodmer/TFT_eSPI" target="_blank" rel="noopener noreferrer">Bodmer/TFT_eSPI</a>: 一个基于 Arudino 框架的 tft 显示屏驱动，支持 STM32/ESP32 等多种芯片。</li>
<li><a href="https://github.com/lvgl/lv_port_esp32" target="_blank" rel="noopener noreferrer">lv_port_esp32</a>: lvgl 官方提供的 esp32 port，但是几百年不更新了，目前仅支持到 esp-idf v4，试用了一波被坑了，不建议使用。</li>
<li><a href="https://github.com/espressif/esp-idf/tree/master/examples/peripherals/lcd" target="_blank" rel="noopener noreferrer">esp-idf/peripherals/lcd</a>: ESP 官方的 lcd 示例，不过仅支持部分常见显示屏驱动，比如我这里用的 ili9488 官方就没有。</li>
</ul>
<p>总之强烈推荐 TFT_eSPI 这个库，很好用，而且驱动支持很齐全。</p>
<h2 id="一开发环境搭建电路搭建与测试" class="headerLink">
    <a href="#%e4%b8%80%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83%e6%90%ad%e5%bb%ba%e7%94%b5%e8%b7%af%e6%90%ad%e5%bb%ba%e4%b8%8e%e6%b5%8b%e8%af%95" class="header-mark"></a>一、开发环境搭建、电路搭建与测试</h2><h3 id="1-创建项目并配置好环境" class="headerLink">
    <a href="#1-%e5%88%9b%e5%bb%ba%e9%a1%b9%e7%9b%ae%e5%b9%b6%e9%85%8d%e7%bd%ae%e5%a5%bd%e7%8e%af%e5%a2%83" class="header-mark"></a>1. 创建项目并配置好环境</h3><p>ESP32 开发有好几种方式：</p>
<ol>
<li>vscode 的 esp-idf 插件 + 官方的 esp-idf 工具</li>
<li>vscode 的 platformio 插件 + arudino 框架</li>
</ol>
<p><a href="https://github.com/Bodmer/TFT_eSPI" target="_blank" rel="noopener noreferrer">Bodmer/TFT_eSPI</a> 这个依赖库两种方式都支持，不过看了下官方文档，仓库作者表示 ESP-IDF 的支持是其他人提供的，他不保证能用，所以稳妥起见我选择了 PlatformIO + Arduino 框架作为开发环境。</p>
<p>首先当然是创建一个空项目，点击 VSCode 侧栏的 PlatformIO 图标，再点击列表中的 <code>PlatformIO Core CLI</code> 选项进入 shell 执行如下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">pio project init --ide<span class="o">=</span>vscode -d tft_esp32_arduino
</span></span></code></pre></td></tr></table>
</div>
</div><p>这条命令会创建一个空项目，并配置好 vscode 插件相关配置，这样就算完成了一个空的项目框架。</p>
<h3 id="1-显示屏接线与项目参数配置" class="headerLink">
    <a href="#1-%e6%98%be%e7%a4%ba%e5%b1%8f%e6%8e%a5%e7%ba%bf%e4%b8%8e%e9%a1%b9%e7%9b%ae%e5%8f%82%e6%95%b0%e9%85%8d%e7%bd%ae" class="header-mark"></a>1. 显示屏接线与项目参数配置</h3><p>网上简单搜了下 ESP32 pinout，找到这张图，引脚定义与我的 ESP32 开发板完全一致，用做接线参考：</p>
<figure><img src="/images/ee-basics-2-esp32-display/ESP32-DOIT-DEVKIT-V1-Board-Pinout-36-GPIOs-updated.webp" width="70%"/>
</figure>

<p>可以看到这块 ESP32 开发板有两个 SPI 端口：HSPI 跟 VSPI，这里我们使用 HSPI，那么 MOSI/MISO/SCK 三个引脚的接线必须与上图的定义完全一致。
而其他引脚随便找个普通 GPIO 口接上就行。</p>
<p>此外背光灯的线我试了下接 GPIO 口不好使，建议直接接在 3V3 引脚上（缺点就是没法通过程序关闭背光，问题不大）。</p>
<p>我的接线如下：</p>
<p><figure><img src="/images/ee-basics-2-esp32-display/esp32-spi-display-wiring.webp" width="70%"/><figcaption>
            <h4>使用 wokwi.com 制作的示意图</h4>
        </figcaption>
</figure>

<figure><img src="/images/ee-basics-2-esp32-display/esp32-spi-display-wiring-real.webp" width="70%"/><figcaption>
            <h4>接线实操</h4>
        </figcaption>
</figure>
</p>
<p>线接好后需要更新下 PlatformIO 项目根目录 <code>platformio.ini</code> 的配置，使其显示屏引脚相关的参数与我们的接线完全对应起来，这样才能正常驱动这个显示屏。</p>
<p>这里我以驱动库官方提供的模板 <a href="https://github.com/Bodmer/TFT_eSPI/tree/master/docs/PlatformIO" target="_blank" rel="noopener noreferrer">Bodmer/TFT_eSPI/docs/PlatformIO</a> 为基础，更新了其构建参数对应的引脚，加了点注释，得到的内容如下（如果你的接线与我一致，直接抄就行）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ini" data-lang="ini"><span class="line"><span class="cl"><span class="k">[env:esp32dev]</span>
</span></span><span class="line"><span class="cl"><span class="na">platform</span> <span class="o">=</span> <span class="s">espressif32</span>
</span></span><span class="line"><span class="cl"><span class="na">board</span> <span class="o">=</span> <span class="s">esp32dev</span>
</span></span><span class="line"><span class="cl"><span class="na">framework</span> <span class="o">=</span> <span class="s">arduino</span>
</span></span><span class="line"><span class="cl"><span class="na">lib_deps</span> <span class="o">=</span><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s">  bodmer/TFT_eSPI@^2.5.0
</span></span></span><span class="line"><span class="cl"><span class="s">  Bodmer/TFT_eWidget@^0.0.5</span>
</span></span><span class="line"><span class="cl"><span class="na">monitor_speed</span> <span class="o">=</span> <span class="s">115200</span>
</span></span><span class="line"><span class="cl"><span class="na">build_flags</span> <span class="o">=</span><span class="s">
</span></span></span><span class="line"><span class="cl"><span class="s">  -Os
</span></span></span><span class="line"><span class="cl"><span class="s">  -DCORE_DEBUG_LEVEL=ARDUHAL_LOG_LEVEL_DEBUG
</span></span></span><span class="line"><span class="cl"><span class="s">  -DUSER_SETUP_LOADED=1
</span></span></span><span class="line"><span class="cl"><span class="s">  
</span></span></span><span class="line"><span class="cl"><span class="s">  ; Define the TFT driver, pins etc here:
</span></span></span><span class="line"><span class="cl"><span class="s">  ; 显示屏驱动要对得上
</span></span></span><span class="line"><span class="cl"><span class="s">  -DILI9488_DRIVER=1
</span></span></span><span class="line"><span class="cl"><span class="s">  # 宽度与高度
</span></span></span><span class="line"><span class="cl"><span class="s">  -DTFT_WIDTH=480
</span></span></span><span class="line"><span class="cl"><span class="s">  -DTFT_HEIGHT=320
</span></span></span><span class="line"><span class="cl"><span class="s">  # SPI 引脚的接线方式，
</span></span></span><span class="line"><span class="cl"><span class="s">  -DTFT_MISO=12
</span></span></span><span class="line"><span class="cl"><span class="s">  -DTFT_MOSI=13
</span></span></span><span class="line"><span class="cl"><span class="s">  # SCLK 在显示屏上对应的引脚可能叫 SCK，是同一个东西
</span></span></span><span class="line"><span class="cl"><span class="s">  -DTFT_SCLK=14
</span></span></span><span class="line"><span class="cl"><span class="s">  -DTFT_CS=15
</span></span></span><span class="line"><span class="cl"><span class="s">  # DC 在显示屏上对应的引脚可能叫 RS 或者 DC/RS，是同一个东西
</span></span></span><span class="line"><span class="cl"><span class="s">  -DTFT_DC=4
</span></span></span><span class="line"><span class="cl"><span class="s">  -DTFT_RST=2
</span></span></span><span class="line"><span class="cl"><span class="s">  # 背光暂时直接接在 3V3 上
</span></span></span><span class="line"><span class="cl"><span class="s">  ; -DTFT_BL=27
</span></span></span><span class="line"><span class="cl"><span class="s">  # 触摸，暂时不用
</span></span></span><span class="line"><span class="cl"><span class="s">  ;-DTOUCH_CS=22
</span></span></span><span class="line"><span class="cl"><span class="s">  -DLOAD_GLCD=1
</span></span></span><span class="line"><span class="cl"><span class="s">  # 其他配置，保持默认即可
</span></span></span><span class="line"><span class="cl"><span class="s">  -DLOAD_FONT2=1
</span></span></span><span class="line"><span class="cl"><span class="s">  -DLOAD_FONT4=1
</span></span></span><span class="line"><span class="cl"><span class="s">  -DLOAD_FONT6=1
</span></span></span><span class="line"><span class="cl"><span class="s">  -DLOAD_FONT7=1
</span></span></span><span class="line"><span class="cl"><span class="s">  -DLOAD_FONT8=1
</span></span></span><span class="line"><span class="cl"><span class="s">  -DLOAD_GFXFF=1
</span></span></span><span class="line"><span class="cl"><span class="s">  -DSMOOTH_FONT=1
</span></span></span><span class="line"><span class="cl"><span class="s">  -DSPI_FREQUENCY=27000000</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>修好后保存修改，platformio 将会自动检测到配置文件变更，并根据配置文件下载 Arduino/ESP32 工具链，更新构建配置、拉取依赖库（建议开个全局代理，不然下载会贼慢）。</p>
<h3 id="3-测试验证" class="headerLink">
    <a href="#3-%e6%b5%8b%e8%af%95%e9%aa%8c%e8%af%81" class="header-mark"></a>3. 测试验证</h3><p>现在找几个 demo 跑跑看，新建文件 <code>src/main.ino</code>，从如下文件夹中随便找个 demo copy 进去然后编译上传，看看效果：</p>
<ul>
<li><a href="https://github.com/Bodmer/TFT_eSPI/blob/master/examples/480%20x%20320" target="_blank" rel="noopener noreferrer">Bodmer/TFT_eSPI - examples/480x320</a></li>
</ul>
<blockquote>
<p>可以直接从 libdeps 中 copy exmaples 代码过来测试：<code>cp .pio/libdeps/esp32dev/TFT_eSPI/examples/480\ x\ 320/TFT_Meters/TFT_Meters.ino src/main.ino</code></p>
</blockquote>
<p>我跑出来的效果：</p>
<p><figure><img src="/images/ee-basics-2-esp32-display/tft_esp32_meters_demo_2.webp" width="60%"/>
</figure>

<figure><img src="/images/ee-basics-2-esp32-display/tft_esp32_sin_cosin_chart_2.webp" width="60%"/>
</figure>
</p>
<h2 id="二显示图片文字" class="headerLink">
    <a href="#%e4%ba%8c%e6%98%be%e7%a4%ba%e5%9b%be%e7%89%87%e6%96%87%e5%ad%97" class="header-mark"></a>二、显示图片、文字</h2><p>这需要首先将图片/文字转换成 bitmap 格式的 C 代码，可使用在线工具 <a href="https://github.com/javl/image2cpp" target="_blank" rel="noopener noreferrer">javl/image2cpp</a> 进行转换，简单演示下：</p>
<figure><img src="/images/ee-basics-2-esp32-display/how-to-use-image2cpp.webp" width="50%"/>
</figure>

<p>注意高度与宽度调整为与屏幕大小一致，设置放缩模式，然后色彩改为 RGB565，最后上传图片、生成代码。</p>
<p>将生成好的代码贴到 <code>src/test_img.h</code> 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// We need this header file to use FLASH as storage with PROGMEM directive:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Icon width and height
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">imgWidth</span> <span class="o">=</span> <span class="mi">480</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">imgHeight</span> <span class="o">=</span> <span class="mi">320</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// &#39;evt_source&#39;, 480x320px
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">epd_bitmap_evt_source</span> <span class="p">[]</span> <span class="n">PROGMEM</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 这里省略掉图片内容......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后写个主程序 <code>src/main.ino</code> 显示图像：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;TFT_eSPI.h&gt;       // Hardware-specific library</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">TFT_eSPI</span> <span class="n">tft</span> <span class="o">=</span> <span class="nf">TFT_eSPI</span><span class="p">();</span>  <span class="c1">// Invoke custom library
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Include the header files that contain the icons
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;test_img.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Serial</span><span class="p">.</span><span class="nf">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">tft</span><span class="p">.</span><span class="nf">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">tft</span><span class="p">.</span><span class="nf">setRotation</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>	<span class="c1">// landscape
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">tft</span><span class="p">.</span><span class="nf">fillScreen</span><span class="p">(</span><span class="n">TFT_BLACK</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Swap the colour byte order when rendering
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">tft</span><span class="p">.</span><span class="nf">setSwapBytes</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 显示图片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">tft</span><span class="p">.</span><span class="nf">pushImage</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">imgWidth</span><span class="p">,</span> <span class="n">imgHeight</span><span class="p">,</span> <span class="n">epd_bitmap_evt_source</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">delay</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译上传，效果如下：</p>
<figure><img src="/images/ee-basics-2-esp32-display/tft_esp32_show_image-2.webp" width="60%"/>
</figure>

<h2 id="三写个极简贪吃蛇游戏" class="headerLink">
    <a href="#%e4%b8%89%e5%86%99%e4%b8%aa%e6%9e%81%e7%ae%80%e8%b4%aa%e5%90%83%e8%9b%87%e6%b8%b8%e6%88%8f" class="header-mark"></a>三、写个极简贪吃蛇游戏</h2><p>N 年前我写的第一篇博客文章，是用 C 语言写一个贪吃蛇，这里把它移植过来玩玩看~</p>
<p>我的旧文章地址为：<a href="https://www.cnblogs.com/kirito-c/p/5596160.html" target="_blank" rel="noopener noreferrer">贪吃蛇—C—基于easyx图形库(下):从画图程序到贪吃蛇【自带穿墙术】 </a>，里面详细介绍了程序的思路。</p>
<p>那么现在开始代码移植，TFT 屏幕前面已经接好了不需要动，要改的只有软件部分，还有就是添加上下左右四个按键的电路。</p>
<p>首先清空 <code>src</code> 文件夹，新建文件 <code>src/main.ino</code>，内容如下，其中主要逻辑均移植自我前面贴的文章：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;TFT_eSPI.h&gt; // Hardware-specific library</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define WIDTH 480
</span></span></span><span class="line"><span class="cl"><span class="cp">#define HEIGHT 320
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 四个方向键对应的 GPIO 引脚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define BUTTON_UP_PIN     5
</span></span></span><span class="line"><span class="cl"><span class="cp">#define BUTTON_LEFT_PIN   18
</span></span></span><span class="line"><span class="cl"><span class="cp">#define BUTTON_DOWN_PIN   19
</span></span></span><span class="line"><span class="cl"><span class="cp">#define BUTTON_RIGHT_PIN  21
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">TFT_eSPI</span> <span class="n">tft</span> <span class="o">=</span> <span class="nf">TFT_eSPI</span><span class="p">();</span> <span class="c1">// Invoke custom library
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Position</span> <span class="c1">// 坐标结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">Pos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Pos</span> <span class="n">SNAKE</span><span class="p">[</span><span class="mi">3000</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Pos</span> <span class="n">DIRECTION</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Pos</span> <span class="n">EGG</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">long</span> <span class="n">SNAKE_LEN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Serial</span><span class="p">.</span><span class="nf">begin</span><span class="p">(</span><span class="mi">115200</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">tft</span><span class="p">.</span><span class="nf">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">tft</span><span class="p">.</span><span class="nf">setRotation</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// landscape
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">tft</span><span class="p">.</span><span class="nf">fillScreen</span><span class="p">(</span><span class="n">TFT_BLACK</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Swap the colour byte order when rendering
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">tft</span><span class="p">.</span><span class="nf">setSwapBytes</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// initialize the pushbutton pin as an input: the default state is LOW
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">pinMode</span><span class="p">(</span><span class="n">BUTTON_UP_PIN</span><span class="p">,</span> <span class="n">INPUT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">pinMode</span><span class="p">(</span><span class="n">BUTTON_LEFT_PIN</span><span class="p">,</span> <span class="n">INPUT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">pinMode</span><span class="p">(</span><span class="n">BUTTON_DOWN_PIN</span><span class="p">,</span> <span class="n">INPUT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">pinMode</span><span class="p">(</span><span class="n">BUTTON_RIGHT_PIN</span><span class="p">,</span> <span class="n">INPUT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">init_game</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">command</span><span class="p">();</span> <span class="c1">// 获取按键消息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">move</span><span class="p">();</span>    <span class="c1">// 修改头节点坐标-蛇的移动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">eat_egg</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nf">draw</span><span class="p">();</span> <span class="c1">// 作图
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">eat_self</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nf">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init_game</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 初始化小蛇
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">SNAKE_LEN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">SNAKE</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span>  <span class="nf">random</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="n">WIDTH</span> <span class="o">-</span> <span class="mi">50</span><span class="p">);</span> <span class="c1">// 头节点位置随机化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">SNAKE</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span>  <span class="nf">random</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="n">HEIGHT</span> <span class="o">-</span> <span class="mi">50</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">DIRECTION</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="nf">pow</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nf">random</span><span class="p">());</span> <span class="c1">// 初始化方向向量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">DIRECTION</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">creat_egg</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Serial</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s">&#34;GAM STARTED, Having Fun~&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">creat_egg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">EGG</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="nf">random</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="n">WIDTH</span> <span class="o">-</span> <span class="mi">50</span><span class="p">);</span> <span class="c1">// 头节点位置随机化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">EGG</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="nf">random</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="n">HEIGHT</span> <span class="o">-</span> <span class="mi">50</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SNAKE_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">SNAKE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">SNAKE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nf">fabs</span><span class="p">(</span><span class="n">SNAKE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">EGG</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="nf">fabs</span><span class="p">(</span><span class="n">SNAKE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">EGG</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">ok</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ok</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">command</span><span class="p">()</span> <span class="c1">// 获取按键命令命令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">digitalRead</span><span class="p">(</span><span class="n">BUTTON_LEFT_PIN</span><span class="p">)</span> <span class="o">==</span> <span class="n">HIGH</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">DIRECTION</span><span class="p">.</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">DIRECTION</span><span class="p">.</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span> <span class="c1">// 如果不是反方向，按键才有效
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Serial</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s">&#34;Trun Left!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">DIRECTION</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">DIRECTION</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nf">digitalRead</span><span class="p">(</span><span class="n">BUTTON_RIGHT_PIN</span><span class="p">)</span> <span class="o">==</span> <span class="n">HIGH</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">DIRECTION</span><span class="p">.</span><span class="n">x</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">DIRECTION</span><span class="p">.</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Serial</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s">&#34;Trun Right!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">DIRECTION</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">DIRECTION</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nf">digitalRead</span><span class="p">(</span><span class="n">BUTTON_UP_PIN</span><span class="p">)</span> <span class="o">==</span> <span class="n">HIGH</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">DIRECTION</span><span class="p">.</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">DIRECTION</span><span class="p">.</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>  <span class="c1">// 注意 Y 轴，向上是负轴，因为屏幕左上角是原点 (0,0)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Serial</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s">&#34;Trun Up!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">DIRECTION</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">DIRECTION</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nf">digitalRead</span><span class="p">(</span><span class="n">BUTTON_DOWN_PIN</span><span class="p">)</span> <span class="o">==</span> <span class="n">HIGH</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">DIRECTION</span><span class="p">.</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">DIRECTION</span><span class="p">.</span><span class="n">y</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Serial</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s">&#34;Trun Down!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">DIRECTION</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">DIRECTION</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">move</span><span class="p">()</span> <span class="c1">// 修改各节点坐标以达到移动的目的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 覆盖尾部走过的痕迹
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">tft</span><span class="p">.</span><span class="nf">drawRect</span><span class="p">(</span><span class="n">SNAKE</span><span class="p">[</span><span class="n">SNAKE_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="mi">5</span><span class="p">,</span> <span class="n">SNAKE</span><span class="p">[</span><span class="n">SNAKE_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">TFT_BLACK</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">SNAKE_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">SNAKE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span> <span class="n">SNAKE</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">SNAKE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span> <span class="n">SNAKE</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">SNAKE</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">+=</span> <span class="n">DIRECTION</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 每次移动10pix
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">SNAKE</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span> <span class="o">+=</span> <span class="n">DIRECTION</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">SNAKE</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">WIDTH</span><span class="p">)</span> <span class="c1">// 如果越界，从另一边出来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">SNAKE</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SNAKE</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">SNAKE</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span> <span class="n">WIDTH</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SNAKE</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="n">HEIGHT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">SNAKE</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SNAKE</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">SNAKE</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span> <span class="n">HEIGHT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">eat_egg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">fabs</span><span class="p">(</span><span class="n">SNAKE</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">EGG</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="o">&amp;&amp;</span> <span class="nf">fabs</span><span class="p">(</span><span class="n">SNAKE</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">EGG</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// shade old egg
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">tft</span><span class="p">.</span><span class="nf">drawCircle</span><span class="p">(</span><span class="n">EGG</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">EGG</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">TFT_BLACK</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">creat_egg</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// add snake node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">SNAKE_LEN</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">SNAKE_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">SNAKE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span> <span class="n">SNAKE</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">SNAKE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">=</span> <span class="n">SNAKE</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">SNAKE</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">+=</span> <span class="n">DIRECTION</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 每次移动10pix
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">SNAKE</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span> <span class="o">+=</span> <span class="n">DIRECTION</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">draw</span><span class="p">()</span> <span class="c1">// 画出蛇和食物
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SNAKE_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">tft</span><span class="p">.</span><span class="nf">drawRect</span><span class="p">(</span><span class="n">SNAKE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="mi">5</span><span class="p">,</span> <span class="n">SNAKE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">TFT_BLUE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">tft</span><span class="p">.</span><span class="nf">drawCircle</span><span class="p">(</span><span class="n">EGG</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">EGG</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">TFT_RED</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">eat_self</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">SNAKE_LEN</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SNAKE_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">fabs</span><span class="p">(</span><span class="n">SNAKE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">SNAKE</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="o">&amp;&amp;</span> <span class="nf">fabs</span><span class="p">(</span><span class="n">SNAKE</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">SNAKE</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">tft</span><span class="p">.</span><span class="nf">setTextColor</span><span class="p">(</span><span class="n">TFT_RED</span><span class="p">,</span> <span class="n">TFT_BLACK</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">tft</span><span class="p">.</span><span class="nf">drawString</span><span class="p">(</span><span class="s">&#34;GAME OVER!&#34;</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nf">delay</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nf">setup</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码就这么点，没几行，接下来我们来接一下按键电路，这部分是参考了 arduino 的官方文档 <a href="https://docs.arduino.cc/built-in-examples/digital/Button" target="_blank" rel="noopener noreferrer">How to Wire and Program a Button</a></p>
<p>接线方式如下，主要原理就是通过 GND 接线，使四个方向键对应的 GPIO 口默认值为低电平。
当按键按下时，GPIO 口会被拉升成高电平，从而使程序识别到该按键被按下。</p>
<p>接线示意图如下（简单起见，省略了前面的显示屏接线部分）：</p>
<figure><img src="/images/ee-basics-2-esp32-display/esp32-wiring-4-buttons.webp" width="60%"/><figcaption>
            <h4>使用 wokwi.com 制作的示意图</h4>
        </figcaption>
</figure>

<p>现在运行程序，效果如下（手上只有两个按键，所以是双键模式请见谅&hellip;）：</p>
<div class="bilibili"><iframe src="//player.bilibili.com/player.html?bvid=BV1jT411e7HJ&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe></div>

<!-- 
因为买的摇秆有问题，没焊好，各种锡把引脚连在了一起，暂时放弃此想法。

## 四、换成用摇杆控制贪吃蛇吧

用按键控制总还是差了点意思，换成用摇杆控制看看是不是更爽一点。

之前在淘宝上买的一堆元件中有一个 HW-504 摇秆，查了下找到这篇文章 [arduino-joystick](https://arduinogetstarted.com/tutorials/arduino-joystick) 详细说明了怎么在 Arduino 中用它，在 ESP32-Arduino 上使用方法也完全类似。

根据其说明，HW-504 这类摇秆的五个引脚功能分别如下：

- GDN: 接地
- VCC/5V: 接 5V 电源
- VRx 与 VRy: 分别输出 X 轴与 Y 轴的偏移量，是模拟信号
- SW: 对应摇秆内部的按键，按下摇秆会使 SW 输出高电平

我们暂时用不到摇秆的按键，所以只需要接上另外四根引脚就行，而 VRx 与 VRy 因为输出的是模拟量，需要用到 ESP32 的 ADC 功能（Analog to Digital Converter 模数转换器）。

根据 ESP32 官方文档 [Analog to Digital Converter (ADC) - ESP32  Peripherals API](https://docs.espressif.com/projects/esp-idf/en/v4.4.4/esp32/api-reference/peripherals/adc.html) 描述，ESP32 包含两个模数转换器 ADC1 与 ADC2，其中 ADC2 在启用 Wi-Fi 时会被 WiFi 占用导致无法使用，所以我们写程序通常仅使用 ADC1。

然后根据前面的文章内容修改 C 代码，用摇秆控制逻辑取代掉按键相关的内容，改好后的代码内容如下：

```c

``` -->
]]></content></entry><entry><title type="html">EE 入门（一） - 电子电路基础知识</title><link href="https://thiscute.world/posts/electrical-engineering-circuits-basics-1/"/><id>https://thiscute.world/posts/electrical-engineering-circuits-basics-1/</id><author><name>ryan4yin</name></author><published>2023-01-31T22:33:51+08:00</published><updated>2023-01-31T22:33:51+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/electrical-engineering-circuits-basics-1/8051-display-2023.webp" height="2108" width="1044"><figcaption></figcaption>
        </figure><h2 id="前言" class="headerLink">
    <a href="#%e5%89%8d%e8%a8%80" class="header-mark"></a>前言</h2><p>我是从去年 12 月开始玩电子的，起因是 11 月搞了个 Homelab，然后就一路玩到 ESPHome，买了一堆传感器。
玩了一阵后 ESPHome 这种小白式玩法就满足不了我了，于是开始学习电路知识，用树莓派跟其他单片机开始折腾遥控小车、简易机械臂、跑马灯等等，可以说是玩得很尽兴。</p>
<p>今年我也打算继续玩一玩这一块，尤其想玩一玩用 ESP32/STM32 自制无人机，如果能搞搞无人机编队飞行就更好了~</p>
<p>言归正传，这篇文章是我入门电子电路的第一篇笔记，涵盖最基础的电路理论与一些焊接知识，末尾还包含了后续的学习规划。</p>
<p>笔记内容参考了许多网上的资料，主要有如下几个：</p>
<ul>
<li><a href="https://rmxd.gitee.io/guide/elec_start/" target="_blank" rel="noopener noreferrer">纵横向导 - 电路入门</a>
<ul>
<li>采用类比的方法来讲解电路基础，很适合业余玩家零基础快速入门。</li>
</ul>
</li>
<li><a href="https://www.sparkfun.com/engineering_essentials" target="_blank" rel="noopener noreferrer">Electrical Engineering Essentails - sparkfun</a>
<ul>
<li>同样是零基础入门，尤其是还介绍了电烙铁等玩电路板的实用知识。</li>
</ul>
</li>
<li><a href="https://elamazing.com/" target="_blank" rel="noopener noreferrer">The Amazing World of Electronics - Only the Cool Stuff :-)</a>
<ul>
<li>这个是一篇篇零散的文章，每篇文章一个知识点，但是讲得比较深入透彻。</li>
</ul>
</li>
</ul>
<p>我看完上面的文章后，随着玩得越来越深入，又陆续了解了这些内容：</p>
<ul>
<li>电路基础
<ul>
<li>什么是面包板、面包线、杜邦线</li>
<li>如何使用万用表测电压、电流、电阻、电容，判断二极管、三极管引脚。
<ul>
<li>（N 年前学这玩意儿时用的是最简单易懂的物理指针表，但是实际显然是电子的用着更方便）</li>
<li>回忆下用法：首先调到合适档位，然后测电流要串联到电路中、测电压要与被测器件并联、测电阻直接接在被测器件两端即可。</li>
<li>对于手动量程万用表（如 DT-9205A），它的显示单位为量程名字末尾非数字部分。
<ul>
<li>比如电阻 200 量程的显示单位就为 Ω；2K/20K/200K 这三个量程的显示单位都为 KΩ；2M/20M/200M 的显示单位都为 MΩ</li>
<li>对于电流/电压/电容也是一样。</li>
</ul>
</li>
</ul>
</li>
<li>什么元件需要防静电，以及有线防静电手环/台垫</li>
<li>如何读色环电阻的阻值？（不会读不如直接万用表走起&hellip;）</li>
<li>如何选购、使用电烙铁/吸锡器等焊接工具</li>
<li>&hellip;</li>
</ul>
</li>
<li>单片机（MCU）与单板计算机（SBC）
<ul>
<li>什么是开发版</li>
<li>什么是 TTL 串口、串口驱动、波特率</li>
<li>什么是 SPI/UART/I$^{2}$C 数据传输协议</li>
<li>什么是 GPIO 引脚，以及开发版的引脚各有什么功能</li>
<li>如何使用 USB 转 TTL 串口板给 ESP32/ESP8266/51/STM32 等单片机刷固件</li>
<li>ST-Link/J-Link/DAPLink 调试编程器（仿真器）与 TTL 串口有何区别，JTAG 和 SWD 接口又是个啥？该用哪个？</li>
<li>如何使用 C 语言为单片机编写程序？如何上传编译好的固件？如何调试？</li>
<li>&hellip;</li>
</ul>
</li>
</ul>
<p>总之兴趣驱动，不会的东西就 Google 一下或者问问 ChatGPT，玩起来~</p>
<h2 id="一常见基础公式" class="headerLink">
    <a href="#%e4%b8%80%e5%b8%b8%e8%a7%81%e5%9f%ba%e7%a1%80%e5%85%ac%e5%bc%8f" class="header-mark"></a>一、常见基础公式</h2><ol>
<li>欧姆定律： $U = IR$
<ol>
<li>电压 U 单位伏特 Volt，符号 $V$</li>
<li>电流 I 单位安培 Ampere，符号 $A$</li>
<li>电阻 R 单位欧姆 Ohm，符号 $\Omega$</li>
</ol>
</li>
<li>电功率公式： $p= UI$
<ol>
<li>功率 p 单位瓦特 Watt，符号 $W$，等同于 $V \cdot A$ 的缩写</li>
</ol>
</li>
<li>电能公式： $w = pT$
<ol>
<li>其中 p 为电功率，单位前面说了就是 Watt</li>
<li>T 为时间，单位秒 Second</li>
<li>$w$ 电能的单位为焦耳 joule，等同于 $V \cdot A \cdot s$</li>
<li>常见的电池通常会使用 $mA \cdot h$ 或者 $w \cdot h$ 来标记其电能容量。
<ol>
<li>$mA \cdot h$ 乘上电压再转换下电流跟时间的单位为 A 跟 s，就得到焦耳数</li>
<li>$w \cdot h$ 直接乘 3600（1 小时的秒数）就得到焦耳数</li>
</ol>
</li>
</ol>
</li>
<li>电容量公式： $C = Q/U$
<ol>
<li>电容量 C 单位为法拉 Farad，符号为 $F$</li>
<li>带电量 Q 的单位为库仑 Coulomb，符号为 $C$</li>
</ol>
</li>
<li>库仑的定义： $1C = 1A \cdot s$
<ol>
<li>1 库仑即 $6.24146 \times 10^{18}$ 个电子所带的电荷量</li>
</ol>
</li>
<li>电感 TODO（貌似用得比较少&hellip;待补充）</li>
</ol>
<h2 id="二常用电子元件介绍" class="headerLink">
    <a href="#%e4%ba%8c%e5%b8%b8%e7%94%a8%e7%94%b5%e5%ad%90%e5%85%83%e4%bb%b6%e4%bb%8b%e7%bb%8d" class="header-mark"></a>二、常用电子元件介绍</h2><p>常见电子元器件：</p>
<ul>
<li>电阻</li>
<li>二极管 Diode
<ul>
<li>发光二极管</li>
<li>整流二极管</li>
<li>稳压二极管</li>
</ul>
</li>
<li>三极管</li>
<li>MOSFET 场效应管
<ul>
<li>电压转换器（power converter）：整流器（rectifier）、逆变器（inverter）、斩波器（chopper）及变频驱动器（VFD）</li>
</ul>
</li>
<li>电容
<ul>
<li>电解电容</li>
<li>瓷片电容</li>
<li>独石电容</li>
</ul>
</li>
<li>晶振</li>
</ul>
<h3 id="1-二极管-diode" class="headerLink">
    <a href="#1-%e4%ba%8c%e6%9e%81%e7%ae%a1-diode" class="header-mark"></a>1. 二极管 Diode</h3><blockquote>
<p><a href="https://learn.sparkfun.com/tutorials/diodes" target="_blank" rel="noopener noreferrer">https://learn.sparkfun.com/tutorials/diodes</a></p>
</blockquote>
<p>二极管是一种<strong>只允许电流由单一方向流过</strong>，具有两个电极的元件，是现代电子产业的基石。
可类比水流中的单向阀门，水只能从一端流向另一端，而不能逆流。</p>
<p>最初的二极管是真空电子二极管，很大、需要预热、功耗大，易破碎。
后来美国人使用半导体材料发明了晶体二极管（或者叫半导体二极管）。
目前常用的二极管都是晶体二极管，主要使用硅或者锗这类半导体材料。</p>
<p>晶体二极管的核心是 PN 结（p–n junction），要了解  PN 结，需要先介绍半导体的几个概念：</p>
<ul>
<li>空穴：又称 Electron hole，物理学中指原子的共价键上流失一个电子，最后在共价键上留下的空位。</li>
<li>载流子：半导体中有两种载流子，即价带中带正电的空穴，和导带中带负电的电子。</li>
<li>P 型半导体：P 表示 Positive，指以带正电的空穴导电为主的半导体，也叫空穴半导体。
<ul>
<li>在纯净的硅晶体中掺入三价元素（如硼），使之取代晶格中硅原子的位置，就形成P型半导体。</li>
</ul>
</li>
<li>N 型半导体：N 表示 Negative，指自由电子浓度远大于空穴浓度的杂质半导体。
<ul>
<li>例如，含有适量五价元素砷、磷、锑等的锗或硅等半导体。</li>
</ul>
</li>
</ul>
<p>懂了上面这些后，让我们考虑在一个 N 型半导体跟 P 型半导体形成的 PN 结中，电子显然只能从 N 极流向 P 极，因为只有 N 极才有足够的电子。相反电流只能从 P 级流向 N 极，因为只有 P 极才有足够的空穴。</p>
<p>如果电流要反向流动，那 PN 结的 P 极的电子会更多，而 N 级的空穴也会更多，电势差会更大，显然就会非常费劲。</p>
<p>二极管在导通状态下二示意图如下，其中也展示了二极管对应的符号与真实二极管的结构（带环的一侧为其 N 极）：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/diode-1.webp" width="50%"/>
</figure>

<p>电阻拥有线性的伏安特性曲线，遵从欧姆定律。而二极管则完全不同，它伏安特性曲线（Current-Voltage Graph）如下：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/diode-current-voltage-graph.png" width="50%"/>
</figure>

<p>几个主要特征与相关名词介绍：</p>
<blockquote>
<p>更详细的文章：<a href="https://elamazing.com/2021/04/13/pn-junction-diode/" target="_blank" rel="noopener noreferrer">PN Junction Diode</a></p>
</blockquote>
<ul>
<li>正向压降 Forward Voltage: 指使电流能够导通的最小电压 $V_F$
<ul>
<li>「正向压降」被用于克服二极管的内部电场了，所以在电流通过二极管后，电压需要减去这个电压，这也是中文名「正向压降」的由来。
<ul>
<li>硅二极管的正向压降通常为 0.6v - 1v，锗二极管的正向压降通常为 0.3v</li>
</ul>
</li>
<li>根据伏安特性曲线，实际上随着电流的变化，「正向压降」也是有小幅波动的，不过计算时一般都认为它是固定值。</li>
</ul>
</li>
<li>击穿电压 Breakdown Voltage: 指使电流能否反向导通的最小电压，从图中标识看 $V_{BR}$ 为 -50v，显然它远大于不到 1v 的「正向压降」。
<ul>
<li>当电流能经过二极管反向导通时，我们称二极管被击穿（Breakdown）</li>
</ul>
</li>
</ul>
<p>二极管依据其设计目标，分类了许多不同类别：</p>
<ul>
<li>普通二极管</li>
<li>整流器(rectifier) / 功率二极管（power diode）
<ul>
<li>依靠二极管只能单向导通的原理，可以使用它将交流电变成直流电。</li>
<li>能承受较大的正向电流和较高的反向电压</li>
</ul>
</li>
<li>发光二极管（Light-Emitting Diodes, LEDs）
<ul>
<li>LED 的正向压降取决于它的颜色，而且比较固定，通常红色约为 1.6v，绿色有 2v 和 3v 两种，黄色和橙色约为 2.2v，蓝色约为 3.2v</li>
</ul>
</li>
<li>稳压二极管
<ul>
<li>利用二极管在反向击穿状态，其电流可在很大范围内变化而电压基本不变的现象，制成的起稳压作用的二极管。</li>
</ul>
</li>
<li>开关二极管
<ul>
<li>能够快速由导通变为截止或由截止变为导通的一种二极管。</li>
</ul>
</li>
<li>检波二极管
<ul>
<li>TODO</li>
</ul>
</li>
<li>阻尼二极管
<ul>
<li>具有较低有电压降和较高的工作频率，且能承受较高的反向击穿电压和较大的峰值电流。</li>
</ul>
</li>
</ul>
<p>还有二极管堆组：</p>
<ul>
<li>整流桥堆(半桥、全桥)
<ul>
<li>菱形联接</li>
</ul>
</li>
</ul>
<p>等等&hellip;</p>
<h3 id="2-三极管-triode--bipolar-transistor" class="headerLink">
    <a href="#2-%e4%b8%89%e6%9e%81%e7%ae%a1-triode--bipolar-transistor" class="header-mark"></a>2. 三极管 triode / bipolar transistor</h3><p>三极管即双极型晶体管，缩写 BJT，前面介绍了二极管结构为单个 PN 结，而三极管的结构则为 PNP 或者 NPN 结构，<strong>具有电流放大作用</strong>，是电子电路的核心元件之一。</p>
<p>它的工作方式就像是一个一个液压阀门，通过小电流来顶开中间的通路，使大电流得以通过，一个 NPN 型放大器电路的示意图如下：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/bipolar-transistor-1.jpg" width="70%"/>
</figure>

<p>b 与 e 之间的电压形成一个小电流，这个小电流越大，c 与 e 之间的电阻就越小。</p>
<p>就像是如下液压阀门，b 处的水压越大，液压阀门被推得越开，c 与 e 之间的水流就越大：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/bipolar-transistor-vs-hydraulic-valve.png" width="40%"/>
</figure>

<p>三极管不是凭空把电放大了，而是说： 小的电信号（小水流）把另一个通路的大电流的阀门打开了，后面的器件能够感受到这个大电流， 所以是放大了。对电来说 实际有两个电源供电的 一个是小电源（小信号、信号源） 一个是大电源。</p>
<p>咱们的收音机，实际就是天线，接收到空气中的小电流，你可以理解为毛毛雨。</p>
<p>这个毛毛雨到了三极管的一个脚上打开阀门， 电池供电通过另外两个脚流动，再打开一个后面的三极管， 一级级的这样不断打开，一般收音机最早的时候是三管收音机、六管收音机，就是这么个意思一直到这个水流大到能够推动喇叭就发声了。</p>
<p>一个极简三级放大收音机电路：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/minimalist-triode-radio.png" width="60%"/>
</figure>

<p>两种三极管的符号与识别：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/pnp-npn-transistor.png" width="60%"/>
</figure>

<p>三个电极介绍：</p>
<ul>
<li>C: 即 Collector 集电极</li>
<li>B: 即 Base 基极</li>
<li>E: 即 Emitter 发射极</li>
</ul>
<p>可以看到 NPN 跟 PNP 三极管最大的区别，是在于电流流向：</p>
<ul>
<li>NPN 的 Base 基极是 P 对应正极，电流从 B 与 C 极 流向 E 极</li>
<li>PNP 的 Base 基极是 N 对应负极，电流从 E 极流向 B 与 C 两个电极</li>
</ul>
<p>根据 B 极电流 $I_B$ 的变化，$V_{CE}$ 的变化曲线如图：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/output-characteristics-curves-of-bipolar-transistor.webp" width="60%"/>
</figure>

<p>可以看到<strong>在 $I_{B}$ 一定的情况下，不论 $V_{CE}$ 在 2v 以上如何变化，$I_{C}$ 的电流都几乎是恒定的</strong>。换个角度看电压在 2v - 12v 之间时，$I_{B}$ 与 $I_{C}$ 几乎是完全的线性关系，不受电压波动的影响。</p>
<blockquote>
<p>注意 12v 以上只是没有画出来，假使这个三极管最多只能承受 12v 电压，那更高的电压会击穿它，你就能看到三极管冒火花了&hellip;</p>
</blockquote>
<p>$\frac{I_{C}}{I_{B}}$ 之间的比率（常数）被称做三极管的电流增益（Current Gain），一般使用 $\beta$ 表示。</p>
<p>因为实际场景中 $I_{B}$ 不太好判断，通常都是直接调整 $V_{BE}$，因此我们再换个角度，对比下 $I_{C}$ 与 $V_{BE}$：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/npn-transistor-Ic-vs-Vbe.png" width="40%"/>
</figure>

<p>通过上图可以发现三极管的另外两个特征：</p>
<ol>
<li><strong>$V_{BE}$ 需要一个启动电压，大约在 0.7v 左右，低于 0.7v 时$I_C$ 的电流一直非常小</strong>。</li>
<li><strong>在 $V_{BE}$ 超过 0.7v 后，任何此电压的小变化，都会导致 $I_{C}$ 的剧烈变化</strong>。</li>
</ol>
<p>一个常见的单状态 NPN 放大器电路如下：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/npn-transistor-aimplifier-circuit.webp" width="60%"/>
</figure>

<p>可以注意到，输入 $V_{in}$是一个很小的交流信号，过来之前加了一个电容隔绝掉其中参杂的直流信号。</p>
<p>其次因为 $V_{BE}$ 需要一个启动电压才能进入电流放大的工作区间，这里通过 $R1$ 与 $R2$ 为 $V_{BE}$ 提供了一个启动电压 DC Biasing Point.</p>
<h3 id="3-mosfet-金属氧化物场效应晶体管" class="headerLink">
    <a href="#3-mosfet-%e9%87%91%e5%b1%9e%e6%b0%a7%e5%8c%96%e7%89%a9%e5%9c%ba%e6%95%88%e5%ba%94%e6%99%b6%e4%bd%93%e7%ae%a1" class="header-mark"></a>3. MOSFET 金属氧化物场效应晶体管</h3><blockquote>
<p><a href="https://elamazing.com/2021/03/31/mosfet/" target="_blank" rel="noopener noreferrer">https://elamazing.com/2021/03/31/mosfet/</a></p>
</blockquote>
<blockquote>
<p>MOSFET 与三极管的区别与选用：https://www.eet-china.com/mp/a17394.html</p>
</blockquote>
<blockquote>
<p>CMOS 集成电路工艺 - 百科: <a href="https://www.zgbk.com/ecph/words?SiteID=1&amp;ID=124559&amp;Type=bkzyb" target="_blank" rel="noopener noreferrer">https://www.zgbk.com/ecph/words?SiteID=1&ID=124559&Type=bkzyb</a></p>
</blockquote>
<p><strong>MOSFET 晶体管一般简称 MOS 管，是电压控制元件（通过栅极电压控制源漏间导通电阻），而双极型晶体管（三极管）是电流控制元件（通过基极较小的电流控制较大的集电极电流）</strong>。</p>
<p>MOS 管在导通压降下，导通电阻小，栅极驱动不需要电流，损耗小，驱动电路简单，自带保护二极管，热阻特性好，适合大功率并联，缺点开关速度不高，比较昂贵。</p>
<p>而功能与 MOS 管类似的三极管，特点是开关速度高，大型三极管的 IC 可以做的很大，缺点损耗大，基极驱动电流大，驱动复杂。</p>
<p>一般来说低成本场合，普通应用优先考虑用三极管，不行的话才考虑 MOS 管。</p>
<p>场效应管能在很小电流和很低电压的条件下工作，功耗低，而且可以很方便地把很多场效应管集成在一块硅片上，因此场效应管在大规模集成电路中得到了广泛的应用。
目前主流的数字集成电路，包括 CPU/GPU/RAM，基本都是通过光刻制造的 CMOS 集成电路（Complementary Metal-Oxide-Semiconductor Integrated Circuit），CMOS 就是基于 MOSFET 技术实现的。</p>
<p>MOSFET 管的结构、极性，用法等内容，待补充&hellip;</p>
<p>TODO</p>
<h3 id="4-电容-capacitor" class="headerLink">
    <a href="#4-%e7%94%b5%e5%ae%b9-capacitor" class="header-mark"></a>4. 电容 Capacitor</h3><p>电容是电能的容器，里面存储的是电荷，电容在电路中是储能、缓冲、减压、过滤器件。。</p>
<p>水要通过池塘、湖泊，首先需要灌满它才能过得去。所以这部分水（电能）可以被这些容器保存下来，这是<strong>电容的储能作用</strong>，另外很明显，无论前面的水流多么湍急，到了湖泊就要先灌满它，湖泊开口再向下游流水，自然流水就缓慢一些，所以它<strong>也有缓冲的作用</strong>。大波浪到了湖泊变平稳，实际变成了小波浪，波的形状都变了，这就是<strong>过滤的作用，只允许特定的波通过</strong>。</p>
<p>再回顾下电容相关的公式：</p>
<ol>
<li>电容量公式： $C = Q/U$
<ol>
<li>电容量 C 单位为法拉 Farad，符号为 $F$</li>
<li>带电量 Q 的单位为库仑 Coulomb，符号为 $C$</li>
</ol>
</li>
<li>库仑的定义： $1C = 1A \cdot s$
<ol>
<li>1 库仑即 $6.24146 \times 10^{18}$ 个电子所带的电荷量</li>
</ol>
</li>
</ol>
<p>电容的类型：</p>
<ul>
<li>瓷片电容
<ul>
<li>用陶瓷材料作介质，在陶瓷表面涂覆一层金属（银）薄膜，再经高温烧结后作为电极而成。</li>
<li>用途：通常用于高稳定振荡回路中，作为回路、旁路电容器及垫整电容器。但仅限于在工作频率较低的回路中作旁路或隔直流用，或对稳定性和损耗要求不高的场合〈包括高频在内〉。瓷片电容不宜使用在脉冲电路中，因为它们易于被脉冲电压击穿。</li>
</ul>
</li>
<li>铝电解电容（有极性）
<ul>
<li>有极性铝电解电容器是将附有氧化膜的铝箔（正极）和浸有电解液的衬垫纸，与阴极（负极）箔叠片一起卷绕而成。</li>
<li><strong>优点</strong>: 容量范围大，一般为1~10 000 μF，额定工作电压范围为6.3 V~450 V。</li>
<li><strong>缺点</strong>: 介质损耗、容量误差大（最大允许偏差+100%、–20%）耐高温性较差，存放时间长容易失效。</li>
<li><strong>用途</strong>: 通常在直流电源电路或中、低频电路中起滤波、退耦、信号耦合及时间常数设定、隔直流等作用。</li>
<li>注意：因其具有极性，不能用于交流电路。</li>
</ul>
</li>
<li>独石电容
<ul>
<li>独石电容是用钛酸钡为主的陶瓷材料烧结制成的多层叠片状超小型电容器。</li>
<li><strong>优点</strong>: 性能可靠、耐高温、耐潮湿、容量大（容量范围1 pF ~ 1 μF）、漏电流小等</li>
<li><strong>缺点</strong>: 工作电压低（耐压低于100 V）</li>
<li><strong>用途</strong>: 广泛应用于谐振、旁路、耦合、滤波等。 常用的有CT4 （低频） 、CT42（低频）；CC4（高频）、CC42（高频）等系列。</li>
</ul>
</li>
<li>钽电解电容
<ul>
<li>有两种制作工艺：
<ul>
<li>箔式钽电解电容器：内部采用卷绕芯子,负极为液体电解质，介质为氧化钽</li>
<li>粉烧结式： 阳极（正极）用颗粒很细的钽粉压块后烧结而成</li>
</ul>
</li>
<li><strong>优点</strong>: 介质损耗小、频率特性好、耐高温、漏电流小。</li>
<li><strong>缺点</strong>: 生产成本高、耐压低</li>
<li><strong>用途</strong>: 广泛应用于通信、航天、军工及家用电器上各种中 、低频电路和时间常数设置电路中。</li>
</ul>
</li>
<li>等等</li>
</ul>
<h3 id="5-电感-inductance" class="headerLink">
    <a href="#5-%e7%94%b5%e6%84%9f-inductance" class="header-mark"></a>5. 电感 Inductance</h3><p>「电磁感应（Electromagnetic induction）」我们都学过，它是指放在变化磁通量中的导体，会产生电动势。 此电动势称为感应电动势或感生电动势，若将此导体闭合成一回路，则该电动势会驱使电子流动，形成感应电流（感生电流）。
<strong>简单的说就是磁场变化能产生电能，电流变化也会形成磁场</strong>。</p>
<p>电磁感应最为人所知的应用应该就是「发电机」、「电动马达」跟「变压器」了。「发电机」通过电磁感应将机械能转换为电能，而「电动马达」刚好相反，它通过电磁感应将电能转换为机械能。
这个转换实际上都是依靠磁场与「电磁感应」实现的。</p>
<p>而我们这里提的电感这种元器件，其核心原理是楞次定律（Lenz&rsquo;s law）：</p>
<blockquote>
<p>由于磁通量的改变而产生的感应电流，此电流的流向为抗拒磁通量改变的方向。</p>
</blockquote>
<p>将楞次定律应用在闭合回路的自感效应中，得到的结论是：</p>
<blockquote>
<p>电路上所诱导出的电动势的方向，总是使得它所驱动的电流，会阻碍原先产生它（即电动势）的磁通量之变化。</p>
</blockquote>
<p>具体而言，<strong>对于「电感」，当电流增加时它会将能量以磁场的形式暂时存储起来，等到电流减小时它又会将磁场的能量释放出来，这会产生抵抗电流变化的效果</strong>。</p>
<p>电感并不损耗能量，它只是临时将电流存储起来，待会儿再释放出来而已（这叫什么？削峰填谷，平滑算法）。</p>
<p>电感的结构通常是漆包铜线缠绕在一个永磁体上，因为需要有电流的变化才能工作，通常仅应用在交流电领域。</p>
<h3 id="6-电阻" class="headerLink">
    <a href="#6-%e7%94%b5%e9%98%bb" class="header-mark"></a>6. 电阻</h3><blockquote>
<p>足够深入的分析：<a href="https://www.zhihu.com/question/68567332" target="_blank" rel="noopener noreferrer">电阻的定义到底是什么？</a></p>
</blockquote>
<p>我们对电阻最直观的理解，是中学时学过的：</p>
<p>$$R =  \frac{V}{I}$$</p>
<p>但是在简单的含有电阻 R + 一个电感或电容的直流电路中，电流是随时间变化的，并在最终达到一个稳态。</p>
<p>这时根据上面的公式计算，因为电压是固定的，我们发现电路中电阻 R 的阻值实际是随时间变化的。</p>
<p>这个问题在直流电路中并不明显，因为电路最终仍然会达到稳态，这时电阻就跟它的标称电阻差距不大了。</p>
<p>但是在交流电路中，因为电流始终是在震荡的，这个问题就会变得相当明显，以至于无法简单地使用「电阻」来表达一个电阻器的特性，为此引入了一个新概念叫「阻抗」。</p>
<blockquote>
<p>在具有电阻、电感和电容的电路里，对电路中的电流所起的阻碍作用叫做阻抗。阻抗常用Z表示，是一个复数，实部称为电阻，虚部称为电抗，其中电容在电路中对交流电所起的阻碍作用称为容抗 ,电感在电路中对交流电所起的阻碍作用称为感抗，电容和电感在电路中对交流电引起的阻碍作用总称为阻抗。 阻抗的单位是欧姆。阻抗的概念不仅存在于电路中，在力学的振动系统中也有涉及。</p>
</blockquote>
<p>如果仔细看看你买过的耳机的相关参数，会发现它就包含一个「阻抗」参数，知乎上就有相关讨论 <a href="https://www.zhihu.com/question/22519059" target="_blank" rel="noopener noreferrer">耳机是不是阻抗越高越好？</a>.</p>
<p>对电阻更精确的理解是：电阻是电压对电流的变化率，它不一定是一个静态值（也就是说可能是非线性的，比如二极管的伏安特性曲线就不是直线）。</p>
<h4 id="单片机的下拉电阻与上拉电阻" class="headerLink">
    <a href="#%e5%8d%95%e7%89%87%e6%9c%ba%e7%9a%84%e4%b8%8b%e6%8b%89%e7%94%b5%e9%98%bb%e4%b8%8e%e4%b8%8a%e6%8b%89%e7%94%b5%e9%98%bb" class="header-mark"></a>单片机的下拉电阻与上拉电阻</h4><p>用单片机设计电路时，一个重要的点就是下拉电阻与上拉电阻。</p>
<p>不太好直接解释，直接看视频吧，下面这两个视频解释得很清晰：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1W34y1579U/" target="_blank" rel="noopener noreferrer">上拉电阻的通俗解释</a></li>
<li><a href="https://www.bilibili.com/video/BV1ZU4y1Q7eo/" target="_blank" rel="noopener noreferrer">下拉电阻的通俗解释</a></li>
</ul>
<p>再补充一个博友的文章 <a href="https://panqiincs.me/2019/09/25/mcu-gpio-settings/" target="_blank" rel="noopener noreferrer">单片机的GPIO配置</a>，详细解释了 GPIO 相关的配置原理。</p>
<h3 id="7-晶振-xtal-与振荡电路" class="headerLink">
    <a href="#7-%e6%99%b6%e6%8c%af-xtal-%e4%b8%8e%e6%8c%af%e8%8d%a1%e7%94%b5%e8%b7%af" class="header-mark"></a>7. 晶振 (Xtal) 与振荡电路</h3><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/72583737" target="_blank" rel="noopener noreferrer">秒懂单片机晶振电路原理</a></p>
</blockquote>
<p>石英晶体或晶振，是利用石英晶体（又称水晶）的压电效应，用来产生高精度振荡频率的一种电子器件，属于被动器件（无源源件）。</p>
<p>晶体是指其中的原子、分子、或离子以规则、重复的模式朝各方向延伸的一种固体。
晶体与几乎所有的弹性物质都具有自然共振频率，透过适当的传感器可加以利用。</p>
<p>石英晶体的优点是在温度变化时，影响震荡频率的弹性系数与尺寸变化轻微，因而在频率特性上表现稳定。</p>
<p>石英晶体谐振器的原理：</p>
<ul>
<li>石英晶体上的电极对一颗被适当切割并安置的石英晶体施以电场时，晶体会产生形变。这与晶体受压力产生电势的现象刚好相反，因此被称做<strong>逆压电效应</strong>。</li>
<li>当外加电场移除时，石英晶体又会恢复原状并发出电场，因而在电极上产生电压，这是我们熟知的<strong>压电效应</strong>。</li>
<li><strong>逆压电效应</strong> + <strong>压电效应</strong> 这两个特性造成石英晶体在电路中的行为，类似于某种电感器、电容器、与电阻器所组合成的 RLC 电路。组合中的电感电容谐振频率则反映了石英晶体的实体共振频率。</li>
<li>当外加交变电压的频率与晶片的固有频率（决定于晶片的尺寸与切割方法）相等时，机械振动的幅度将急剧增加，这种现象称为<strong>压电谐振</strong>。</li>
</ul>
<p>可能有些初学者会对晶振的频率感到奇怪，12M、24M 之类的晶振较好理解，选用如 11.0592MHZ 的晶振给人一种奇怪的感觉，这个问题解释起来比较麻烦，如果初学者在练习串口编程的时候就会对此有所理解，这种晶振主要是可以方便和精确的设计串口或其它异步通讯时的波特率。</p>
<h3 id="8-地" class="headerLink">
    <a href="#8-%e5%9c%b0" class="header-mark"></a>8. 地</h3><p>电路中每个器件上有电能量集聚，形成电势差，就相当于物体的高度差。
假设没有一个参考基准点，就没法测量这个电势差了，因此规定电路的某个点就是作为基准面，也就是地（GND/Ground）了。</p>
<p>地/GND 并不需要是真正的地面，对于我主要关注的弱电电路板而言，电路的负极就是地。</p>
<p>同理可推出，如果需要将同一个电路板同时接入多个源电路，则必须将这多个电路板的负极连接在一起，这样它们的「GND」参考基准点才是一致的！</p>
<h4 id="静电破坏与防静电" class="headerLink">
    <a href="#%e9%9d%99%e7%94%b5%e7%a0%b4%e5%9d%8f%e4%b8%8e%e9%98%b2%e9%9d%99%e7%94%b5" class="header-mark"></a>静电破坏与防静电</h4><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/570713171" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/570713171</a></p>
</blockquote>
<p>弱电领域另外一个常见的接地应该就是静电接地了，这是为了确保人体/工作台与地面的电势差为零，避免工作时静电放电导致元器件损坏。</p>
<p>人体感应的静电电压一般在 2KV-4KV 左右，通常是人体轻微运动或与绝缘摩擦引起的。
这么高的电压，足够击穿很多电子元件了，所以电子厂都会强制员工穿戴防静电装置（有线防静电手环）。</p>
<p>静电接地通常要求接真正的地面，比如与建筑物接触紧密的金属门窗、水龙头等都算是「地」。
个人用的话，据朋友介绍效果最好的方法是：穿拖鞋，并且一只脚踩地上哈哈~</p>
<h2 id="三常见电路计算方式" class="headerLink">
    <a href="#%e4%b8%89%e5%b8%b8%e8%a7%81%e7%94%b5%e8%b7%af%e8%ae%a1%e7%ae%97%e6%96%b9%e5%bc%8f" class="header-mark"></a>三、常见电路计算方式</h2><h3 id="1-如何选用正确的电阻" class="headerLink">
    <a href="#1-%e5%a6%82%e4%bd%95%e9%80%89%e7%94%a8%e6%ad%a3%e7%a1%ae%e7%9a%84%e7%94%b5%e9%98%bb" class="header-mark"></a>1. 如何选用正确的电阻？</h3><p>这需要使用到我们中学学过的物理学欧姆定律公式：</p>
<p>$$V =  I \cdot R$$</p>
<p>首先针对电子电路领域的 hello world，即发光二极管 + 电阻：</p>
<figure><img src="/images/electrical-engineering-circuits-basics-1/helloworld-led%2Bresistor.png" width="40%"/>
</figure>

<p>我们可以根据 LED 灯的最大电流来估算电阻值，根据欧姆定律有</p>
<p>$$R = \frac{V}{I}$$</p>
<p>普通发光二极管的正常工作电流通常为 $2 \text{mA}$ ~ $20 \text{mA}$，电流越大它就越亮，正向压降有好几种，假设我们的为 $3.3v$。</p>
<p>因此电路允许的最大电流为 $0.02 \text{A}$，如果电源电压为 3.7v，那电阻得到的电压大概为 $0.4 \text{V}$，这样可计算得到 $R$ 为 $20 \Omega$.</p>
<p>发光二极管在正常工作状态几乎没有电阻，因此可以直接将上面计算出的结果当作串联电阻的阻值。</p>
<p>因此为了使发光二极管正常工作，串联电阻应该略大于 $25 \Omega$.</p>
<h3 id="2-电路分析中的两个重要定律" class="headerLink">
    <a href="#2-%e7%94%b5%e8%b7%af%e5%88%86%e6%9e%90%e4%b8%ad%e7%9a%84%e4%b8%a4%e4%b8%aa%e9%87%8d%e8%a6%81%e5%ae%9a%e5%be%8b" class="header-mark"></a>2. 电路分析中的两个重要定律</h3><ul>
<li>KAL 基尔霍夫电流定律：所有进入某节点的电流的总和等于所有离开这节点的电流的总和</li>
<li>KVL 基尔霍夫电压定律：沿着闭合回路所有元件两端的电势差（电压）的代数和等于零</li>
</ul>
<p>这两个定律感觉通过「能量守恒」去理解，会显得很直观，不论是电流还是电压，都不会无中生有，在整个电路上它始终是守恒的。</p>
<p>KVL + 节点电压法是分析电路的一种有效手段。</p>
<h3 id="3-隔直通交与隔交通直" class="headerLink">
    <a href="#3-%e9%9a%94%e7%9b%b4%e9%80%9a%e4%ba%a4%e4%b8%8e%e9%9a%94%e4%ba%a4%e9%80%9a%e7%9b%b4" class="header-mark"></a>3. 隔直通交与隔交通直</h3><p>上面这个是常见的简单特性描述，但是不够准确，准确的说：</p>
<ul>
<li>电容是隔断不变的电信号，通过变化的电信号。</li>
<li>电感是阻碍变化的电信号，通过不变的电信号。</li>
</ul>
<p>显然直流电的电流也是可以变化的，比如刚过了整流桥的直流电就是一个脉动信号。</p>
<h3 id="4-交直流叠加信号" class="headerLink">
    <a href="#4-%e4%ba%a4%e7%9b%b4%e6%b5%81%e5%8f%a0%e5%8a%a0%e4%bf%a1%e5%8f%b7" class="header-mark"></a>4. 交直流叠加信号</h3><p>交流信号就很好，很真实，为什么还要有交流直流叠加信号，到最后还要把直流信号去掉，只保留交流信号，多麻烦。这是因为，任何器件如果想打开或者处于一定状态，多少都需要一定的能量驱动的，如果这个能量不足，让器件处于不稳定的状态，我们还原不了真实的信号，所以三极管放大加上静态偏置，实际上就是为了让他先工作在临近放大区，再来交流信号才能正确还原。</p>
<p>所谓的静态偏置，实际上就是挂上个电阻先给这个三极管的某个引脚加上直流电。再来的交流信号与直流叠加变成交直流混叠信号，来驱动三极管的b极。</p>
<p>犹如大坝的开口在5米处，但是交流信号（变化的信号）只有1米的波动，所以先把水位抬高到5米，这个波动才能送过去。</p>
<p>现在信号放大电路大部分被运算放大器替代，两个运放之间有一个隔直电容，这是因为运放不需要这种类似三极管的偏置，它不需要抬高水位，本身它建立的条件就是你来波动我就能正常反馈到后级，你这个时候如果叠加了直流信号，反而出问题了，因为你把水位抬高了，比较低的信号不能正常反馈到后级被这个直流信号掩盖了。</p>
<h2 id="四电子电路工具套装介绍" class="headerLink">
    <a href="#%e5%9b%9b%e7%94%b5%e5%ad%90%e7%94%b5%e8%b7%af%e5%b7%a5%e5%85%b7%e5%a5%97%e8%a3%85%e4%bb%8b%e7%bb%8d" class="header-mark"></a>四、电子电路工具套装介绍</h2><p>玩硬件的话，工具套装是必不可少的，最先遇到的场景就是——很多的传感器都需要自己焊接排针。</p>
<p>常用工具的主要有这些：</p>
<ul>
<li>万用电表（Multimeter）</li>
<li>面包板（Breadboard）</li>
<li>电烙铁（Soldering Iron）</li>
<li>玻纤洞洞板（Stripboard / Perfboard）</li>
</ul>
<p>其他进阶玩耍时可能会用到的工具：</p>
<ul>
<li>示波器（Oscilloscope）</li>
<li>可调直流稳压电源（Adjustable DC Power Supply）</li>
<li>频谱分析仪</li>
</ul>
<p>电子元器件又主要分类两类：</p>
<ul>
<li>插式元器件
<ul>
<li>传统电子元器件，都带有较长引脚，PCB 版需要为引脚预留通孔。</li>
<li>相关技术：through-hole technology</li>
<li>这种元件比较大个，都很适合手工焊接，焊接完成后还需要剪掉多余引脚。</li>
</ul>
</li>
<li>片式元器件 SMD (surface-mount device)
<ul>
<li>一种新型元器件，也叫贴片元件。</li>
<li>比插式元器件要小很多，而且 PCB 板不需要预留插孔，更节省材料跟空间，广泛应用在各种小型化电子设备中。</li>
<li>相关技术：(SMT) Surface-mount technology</li>
<li>相关设备：激光打印钢网、贴片机（巨贵）</li>
<li>贴片元件手工焊接时不适合用电烙铁焊，因为它太小了，这样焊接会很费劲。</li>
<li>贴片元件最简单的手工焊接方法是使用针筒焊锡膏在 PCB 触点上涂好锡膏，可用牙签去掉多余锡膏，然后用镊子将贴片元件放上去，最后使用恒温焊台加热完成焊接。元件放歪点没关系，加热时它会因为液态锡的表面张力自动正位。</li>
</ul>
</li>
</ul>
<h3 id="1-电烙铁篇" class="headerLink">
    <a href="#1-%e7%94%b5%e7%83%99%e9%93%81%e7%af%87" class="header-mark"></a>1. 电烙铁篇</h3><p>电烙铁主要考虑的是升温速度跟温度保持能力，便宜的电烙铁基本都有升温慢、焊接中途易失温等毛病。
目前总结的电烙铁信息如下：</p>
<ul>
<li>便携电烙铁：入门级别推荐
<ul>
<li><strong>优缺点</strong>: 便携、价格低。但是升温相对焊台要慢一些，温控相对不够精确，而且无自动休眠，空烧烙铁头容易氧化，再有就是它没有接地不防经典，焊接精密元件比较危险。</li>
<li>貌似主要推荐广东黄花 907 电烙铁，淘宝官方店买个刀头的 54 大洋</li>
</ul>
</li>
<li>热风枪：主要用来拆焊，以及焊接贴片元件 + 芯片。
<ul>
<li>我买了一把德力西 2000W 的数显热风枪，不过貌似更多人推荐那种二合一焊台，直接控制热风枪跟电烙铁两个玩意儿。</li>
</ul>
</li>
<li>焊台：进阶推荐，也可考虑一步到位&hellip;
<ul>
<li><strong>优缺点</strong>: 发热很快、热容相对较大，自动休眠不会空烧、还有过流保护、单片机稳定温控。缺点是要贵一些，另外相对没那么便携。</li>
<li>相关流行产品
<ul>
<li><a href="https://hackmd.io/@openlabtaipei/SyfdnAPtU" target="_blank" rel="noopener noreferrer">白菜白光 T12 恒温焊台</a>，最早是网友基于日本白光公司 T12 烙铁头（日本工厂到期强制报废的洋垃圾）配上自制恒温控制电路完成的 DIY 焊台，因为相对高端焊台相当便宜所以冠以「白菜」之名。
<ul>
<li>淘宝上有一些卖这个的，质量见仁见智吧，我没买过。</li>
</ul>
</li>
<li>日本白光 HAKKO 焊台：这个很多人推荐，说是质量好。不过贵，新手用可能有点奢侈了。</li>
</ul>
</li>
</ul>
</li>
<li>二合一焊台：焊台自带热风枪 + 高频电烙铁两件套，高手必备（一般拆机才会用到热风枪）
<ul>
<li>高频电烙铁使用的是跟电磁炉一样的高频涡流发热原理，电烙铁头自身发热，不需要任何发热芯，发热很快、热容大、烙铁头更换便宜。高端烙铁头都是高频的。</li>
<li>反正就很高级也很贵啦。我现阶段买了它也是浪费钱，所以没了解具体型号啥的了</li>
</ul>
</li>
<li>恒温加热台：功能跟热风枪差不多，但是体积大很多，而且更贵，新手不推荐买。</li>
</ul>
<p>关于电烙铁头，貌似刀头是最推荐的，因为它用途最广泛，热容大，基本适用所有场景。</p>
<p>电烙铁，我最后买的第一把电烙铁是网友 DIY 的「<strong>L245 焊笔 玫瑰金</strong>」，铝合金 CNC 切割工艺，Type-C 供电，最高支持到 PD 120W，颜值很高，口碑也很好，价格是 148 大洋。
使用起来还是比较 OK 的，热得很快，热容也 OK。不过毕竟是 DIY 的便宜焊笔，质量不稳，我有遇到过多次误休眠、未识别到焊芯、芯片系统崩溃等问题，都是靠断电重启解决的。</p>
<h4 id="电烙铁的使用与保养" class="headerLink">
    <a href="#%e7%94%b5%e7%83%99%e9%93%81%e7%9a%84%e4%bd%bf%e7%94%a8%e4%b8%8e%e4%bf%9d%e5%85%bb" class="header-mark"></a>电烙铁的使用与保养</h4><blockquote>
<p>参考：http://www.cxg.cn/newshow1346.html</p>
</blockquote>
<p>前面讲了，我毕竟买的是 150 一把的焊笔，C245 这个烙铁头也不便宜，直接当耗材随便折腾就太浪费了。有必要搞清楚怎么使用与保养电烙铁：</p>
<ul>
<li>焊接作业前，先为高温海绵加水湿润，再挤掉部分水分。
<ul>
<li>如果使用非湿润的清洁海绵，会使烙铁头受损氧化，导致不沾锡。</li>
<li>另外我发现「<strong>镀铜钢丝球</strong>」确实比高温海绵好用多了，墙裂推荐！笔不干净了往钢丝球里插一插，立即光亮如新。</li>
</ul>
</li>
<li>焊接作业中，每次都先在高温海绵上擦干净烙铁头上的旧锡，再进行焊接。
<ul>
<li>如果是用「<strong>镀铜钢丝球</strong>」，那就直接在钢丝球里插一插，立即光洁如新。</li>
<li>中途不使用时，如果无自动休眠功能，可以手动将温度调低至 200 度以下，避免空烧。空烧会降低烙铁头寿命。</li>
</ul>
</li>
<li>焊接完毕后，将温度调至约 250 摄氏度，使用湿润的高温海绵清洁烙铁头，最后将烙铁头加上一层新锡作保护，这样可以保护烙铁头和空气隔离，烙铁头不会氧化变黑。</li>
<li>烙铁头已经氧化、不沾锡时应如何处理
<ul>
<li>先把温度调到 300 摄氏度，用清洁海绵清理烙铁头，并检查烙铁头状况。</li>
<li>如果烙铁头的镀锡层部分含有黑色氧化物时，可镀上新锡层，再用清洁海绵抹净烙铁头。如此重复清理，直到彻底去除氧化物，然后在镀上新锡层。
<ul>
<li>将温度调至 200 摄氏度左右貌似比较容易上锡，不易聚成球。</li>
<li>实测上锡再用海绵抹除，每次都能摸走一些黑色氧化物，非常有效。不过要清理干净还是需要一些耐心。</li>
</ul>
</li>
<li>如果烙铁头变形或穿孔，必须替换新咀。</li>
</ul>
</li>
<li>其他注意事项
<ul>
<li>勿大力焊接：只要让烙铁头充分接触焊点，热量就可传递，无需大力焊接。</li>
<li>尽量低温焊接：高温焊接会加速烙铁头氧化，降低烙铁头使用寿命。如烙铁头温度超过470℃，它的氧化速度是380℃的两倍。</li>
<li>经常保持烙铁头上锡：这可以减低烙铁头的氧化机会，使烙铁头更耐用。</li>
<li>保持烙铁头清洁与及时清理氧化物</li>
<li>小心放入烙铁架：如果烙铁头接触到烙铁架无法自动休眠，长时间空烧将会毁掉烙铁头。</li>
<li>选用活性低的助焊剂：最便宜的就是松香，更好一点的是无铅无酸无卤素助焊剂。</li>
</ul>
</li>
</ul>
<h4 id="焊锡丝在焊接过程中为什么会爆锡" class="headerLink">
    <a href="#%e7%84%8a%e9%94%a1%e4%b8%9d%e5%9c%a8%e7%84%8a%e6%8e%a5%e8%bf%87%e7%a8%8b%e4%b8%ad%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e7%88%86%e9%94%a1" class="header-mark"></a>焊锡丝在焊接过程中为什么会爆锡？</h4><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/584316437" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/584316437</a></p>
</blockquote>
<p>建议直接看上面的文章，可能的原因大概是：</p>
<ol>
<li>受潮</li>
<li>焊锡丝混有杂质，或者助焊剂含量过高</li>
<li>焊接操作时手上有汗或是洗过手后手没有完全干就开始焊接</li>
<li>烙铁温度过高</li>
</ol>
<p><del>我最近买的两卷焊锡丝就有爆锡的问题，烙铁温度是设的很常规的 320 度甚至更低的 290 度，现在怀疑是不是这个无铅焊锡丝有问题</del>。
罪魁祸首找到了，是因为我的锡线架，它下方就是湿润的高温海绵&hellip;这显然很容易受潮&hellip;</p>
<h4 id="如何使用电烙铁进行拆焊" class="headerLink">
    <a href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8%e7%94%b5%e7%83%99%e9%93%81%e8%bf%9b%e8%a1%8c%e6%8b%86%e7%84%8a" class="header-mark"></a>如何使用电烙铁进行拆焊</h4><p>当你焊错焊反了元件，或者你需要修修改改电路板时，就需要先进行拆焊。</p>
<p>用电烙铁进行拆焊需要注意这些事项：</p>
<ul>
<li>温度必须要高，起码 350 以上</li>
<li>烙铁尖必须留点锡在上面。如果烙铁尖不挂锡，焊接的时候会发现即使温度高，电路板的焊锡也很难融化</li>
<li>另一个方式是先加点有铅锡丝降低焊锡熔点，然后再用吸锡器或吸锡带来吸</li>
<li>如果用吸锡器，发现不撤烙铁头直接把吸锡器怼上去，效果是最好的</li>
<li>如果使用的是吸锡带，温度就必须更高，估计至少得 380 甚至更高
<ul>
<li>因为吸锡带一般是纯铜，导热性能很好。一般 320 度就很容易熔的锡，上了吸锡带后热量全被吸锡带传导走了，温度不高根本融化不了</li>
</ul>
</li>
</ul>
<p>或者直接上热风枪+镊子也行（我还没试过&hellip;）。</p>
<h3 id="2-其他工具与材料" class="headerLink">
    <a href="#2-%e5%85%b6%e4%bb%96%e5%b7%a5%e5%85%b7%e4%b8%8e%e6%9d%90%e6%96%99" class="header-mark"></a>2. 其他工具与材料</h3><p>焊材（建议日常用贵一点的无铅锡丝，虽然熔点高些，但对身体好）：</p>
<ul>
<li><strong>焊锡丝</strong>：最常见的焊材，不过稍微要求一点焊接技术，可能需要大约半个小时熟悉下
<ul>
<li>常用 0.8mm 跟 1.0mm 的锡丝</li>
<li>个人玩建议买无铅的，虽然贵点熔点高一点，但更环保，对身体也好。</li>
</ul>
</li>
<li><strong>锡膏</strong>：新型焊接材料，由焊锡粉、助焊剂以及其它的表面活性剂等混合成的膏状物。
<ul>
<li>对于常用焊接场景，可以直接抹上锡膏，然后用热风枪一吹，或者用烙铁刀头拖焊，或者直接上发热板 / 恒温加热台，据说非常简单好用。</li>
<li>最常用的场景是复杂 PCB 板子，直接用定制的钢丝网覆盖 PCB 板子刷上锡膏、直接就把触点都刷上了，然后再用镊子手工贴上贴片元器件。不过这个有难度&hellip;已经是高手玩法了。最省心是花钱直接找 PCB 厂子给打印 + 焊接（钞能力）。</li>
<li>对于焊点不多的贴片，可以直接使用针筒式的锡膏挤上去，然后再用牙签或镊子去掉多余的锡膏，用镊子把贴片元件放上去（有点歪没事，加热时焊锡的张力会使它自动回正），最后直接上热风枪或加热台就能焊接 ok 了。</li>
<li>同样建议买无铅的，虽然贵点熔点高一点，但更环保，对身体也好。</li>
</ul>
</li>
<li><strong>高温海绵</strong>：可以说是焊接必备了，一定要加水湿润后再使用。可以多备几片，脏了洗洗，洗不干净就换。</li>
<li><strong>镀铜钢丝球</strong>：同样是用于清洁烙铁头的，前面讲焊接技术时已经说过了，这个确实比高温海绵好用很多。</li>
<li><strong>助焊剂 Flux</strong>：
<ul>
<li>在焊接工艺中能帮助和促进焊接过程，同时具有保护作用、阻止氧化反应的化学物质。</li>
<li>高纯度松香：便宜常用，一般焊个传感器跟普通 PCB 板子完全够用。
<ul>
<li>如果板子要长期使用，那焊完需要用酒精浸泡清洗，避免助焊剂碳化导致绝缘性能下降。（如果只是练手的板子，那就无所谓了）</li>
</ul>
</li>
<li>无铅无卤无酸助焊剂：高端助焊剂，免洗
<ul>
<li>无铅主要是为了环保，对身体好。</li>
<li>因为卤素离子很难清洗干净，助焊剂残留将导致绝缘性能下降，因此免洗助焊剂必须得无卤素。</li>
<li>无酸是为了避免助焊剂腐蚀电路板跟、引脚、烙铁头。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以及其他焊接相关工具：</p>
<ul>
<li>吸锡器：主要用于电器拆焊
<ul>
<li>场景：一是焊错了或者锡多了，拆焊后重新焊接。二是拆焊其他电路</li>
<li>这玩意儿一个便宜的才十多块，入门阶段买一个也行。不过也有说拿电烙铁热一下然后一磕，焊锡就自己掉下去了，自己玩不一定需要这玩意儿。</li>
</ul>
</li>
<li>吸锡带：拿来清理表贴焊盘上的残锡。就是一卷细铜丝编制的带子，融化的锡容易被它吸走
<ul>
<li>比吸锡器更便宜万用，缺点是需要更高的温度，可以考虑买一卷。</li>
</ul>
</li>
<li>热风枪：貌似主要是拆焊用的，当然用来吹热缩管也很好用。</li>
<li>焊台夹具：焊线焊板子都挺实用，相当于长出来四只手。而且相比放桌面，它的散热速度低很多，更难失温。</li>
<li>尖嘴钳：焊接完一些非贴片元件，必须要把多余的引脚剪掉，尖嘴钳感觉挺需要的。</li>
<li>维修工作台（耐高温硅胶垫）：淘宝上一二十块钱一块，可以保护桌子、方便放一些小元器件。</li>
</ul>
<p>还有就是跟焊接没啥关系，但是 DIY 常用的工具：</p>
<ul>
<li>切割垫：如果需要做一些切割，这个应该也很有用，看许多网友都有，不过我暂时没搞清楚自己是否需要。</li>
<li>螺丝磁性收纳垫：其实跟焊接关系不大了，不过也列一下</li>
<li>螺丝刀 + 万能扳手 + 水口钳：这个好像跟焊接没啥关系，不过也可以列一下
<ul>
<li>尤其是电动螺丝刀，刀头一定要买好一点的，并且最好是标准有替代品的。我以前用电动螺丝刀就遇到过刀头硬度不行被十字螺丝刀头磨平了的情况&hellip;</li>
<li>水口钳推荐德力西</li>
</ul>
</li>
<li>螺丝 + 螺母：螺丝刀跟扳手都有了，螺丝螺母不得买几套？
<ul>
<li>其中有些特别的是自锁螺母，这种螺母自带尼龙自锁圈，即使没拧到位也能自锁。不过需要用比较大的力气才能拧进去，这是正常现象。</li>
<li><a href="https://zhuanlan.zhihu.com/p/107820259" target="_blank" rel="noopener noreferrer">螺母防松的六种基本方法，你知道几个？（动图）</a></li>
<li>螺丝的型号，DIY 中常用的，M3即螺絲外徑為 3mm, M4 即螺絲外徑為 4mm，同理 M5 即 5mm
<ul>
<li>有時會註明螺絲牙距，如 M3x0.5，M4x0.70，M5x0.8，M6x1，但因為这是標準規範，通常不提</li>
</ul>
</li>
<li>对结构强度要求不高的场景，也可以自己用 3D 打印机打印螺丝螺母。</li>
<li>螺丝更详细的中英术语对照：<a href="https://www.weicheng-screw.com.tw/news-detail-1432955.html" target="_blank" rel="noopener noreferrer">螺絲規格與定義 - 緯丞螺絲</a></li>
</ul>
</li>
<li>游标卡尺 + 卷尺：最简单的是买数字的，不需要费心思读数&hellip;也推荐德力西的</li>
<li>3D 打印机、激光切割机等等其他 DIY 工具</li>
</ul>
<h2 id="五后续学习路线" class="headerLink">
    <a href="#%e4%ba%94%e5%90%8e%e7%bb%ad%e5%ad%a6%e4%b9%a0%e8%b7%af%e7%ba%bf" class="header-mark"></a>五、后续学习路线</h2><p>有了电路基础后，首先可以买一些入门的焊接套件练练焊接技术，并搞明白它的原理。
我在淘宝「电子爱好者之家」上买了几个焊接套件，如指尖陀螺、5v 升 12v 升压板、LED 摇摇棒、十二个实验洞洞板套件、高压发生器等。</p>
<p>边玩边学习相关知识是最有意思的，玩到一定阶段后，可以再考虑补一补基础知识。
基础理论方面我查到这几本（为了我的英语能力，选择读英文的）：</p>
<ul>
<li><a href="https://book.douban.com/subject/30332697/" target="_blank" rel="noopener noreferrer">Practical Electronics for Inventors, Fourth Edition</a>: 中文版名为《实用电子元器件与电路基础》，是评论区 <a href="https://github.com/panqiincs" target="_blank" rel="noopener noreferrer">@辛未羊</a> 推荐的，感觉确实很适合我这种业余新手入门~</li>
<li><a href="https://book.douban.com/subject/1926610/" target="_blank" rel="noopener noreferrer">Foundations of Analog and Digital Electronic Circuits</a>：这本书比较受推荐，中文版《模拟和数字电子电路基础》，豆瓣评分 9.3，不过我看了下比上面那本要难，感觉适合后面进阶看。</li>
</ul>
<p>学习基础的电路理论时可以仿真软件同步学习，如：</p>
<ul>
<li>Multisim（元器件仿真）、Proteus（单片机仿真）
<ul>
<li>这两个软件都非常流行，不过基本都仅支持 Windows 系统，我选择放弃。</li>
</ul>
</li>
<li>EDA（Electronic Design Automation） 电路板原理图、PCB（Printed Circuit Board） 设计工具
<ul>
<li><a href="https://lceda.cn/" target="_blank" rel="noopener noreferrer">立创 EDA</a>: 国产 EDA，全平台支持，也提供 Web 版</li>
<li><a href="https://github.com/KiCad" target="_blank" rel="noopener noreferrer">KiCAD</a>: 开源电路板设计工具，功能强大，支持插件，社区资源多。</li>
</ul>
</li>
</ul>
<h3 id="1-单片机" class="headerLink">
    <a href="#1-%e5%8d%95%e7%89%87%e6%9c%ba" class="header-mark"></a>1. 单片机</h3><p>有一定电路基础后，就可以开始玩单片机了。</p>
<ul>
<li>介绍：单片机的英文名叫 Microcontroller Unit，缩写为 <strong>MCU</strong>. 它是把 CPU、RAM、定时/计数器（timer/counter）、I/O 接口等都集成在一块集成电路芯片上的微型计算机。</li>
<li>应用：主要用于前端的无操作系统、以实时控制为主的环境，如电子钟表、电机控制等。在硬件爱好者手中可用于机器人前端控制，四轴飞行器前端控制，3D打印机前端控制等。</li>
<li>典型产品：
<ul>
<li>Arduino: AVR 单片机为核心控制器的单片机应用开发板，是开源硬件，新手友好</li>
<li>STM32: 貌似是单片机从业人员的入行首选，使用 ARM Cortex-M 系列核心。</li>
</ul>
</li>
<li>补充说明：
<ul>
<li>单片机非常简单，因为很接近底层，而且硬件配置极差，干不了太多的事。主要的优势就是稳定、开发也简单。</li>
<li>单片机跟硬件的绑定很严重，经常出现一套代码换一个单片机平台，就得完全重写。</li>
</ul>
</li>
</ul>
<p>单片机最简单的玩法当属 <a href="https://github.com/esphome/esphome" target="_blank" rel="noopener noreferrer">esphome</a>，只需要会 yaml 配置语言就能开始用 ESP32/ESP8266/ESP32-C3 等 MCU 玩智能家居，不需要写任何代码，生态非常丰富，作为入门路径感觉很合适（文章开头就说了，我就是从这玩意儿入坑的硬件&hellip;）</p>
<p>但是 ESPHome 毕竟太简单，用的都是别人写好的现成模块，想实现点更自定义的功能就得自己学习单片机编程了。</p>
<p>我的单片机编程学习路径大概是：</p>
<ul>
<li>8051: 最简单最经典的单片机
<ul>
<li>我的 8051 汇编学习笔记与代码：<a href="https://github.com/ryan4yin/learn-8051-asm" target="_blank" rel="noopener noreferrer">ryan4yin/learn-8051-asm</a></li>
</ul>
</li>
<li>STM32: 工业届应用最广泛的单片机，网上资料众多。
<ul>
<li>开发工具链很成熟完善，不过有点偏底层，适合用于学习底层知识。</li>
<li>我的 STM32 学习笔记与代码（持续更新中，使用 C 语言，后续打算试下 Rust）：<a href="https://github.com/ryan4yin/learn-stm32f103c8t6" target="_blank" rel="noopener noreferrer">ryan4yin/learn-stm32f103c8t6</a></li>
</ul>
</li>
<li>ESP32: 包含 wifi 蓝牙功能的 IoT 单片机，在物联网领域应用非常广泛，硬件发烧友的最爱。
<ul>
<li>乐鑫官方的 ESP-IDF 完全开源，功能比较完善，封装层次比 STM32 HAL 更高，而且迭代很快，用起来更简单（不过相对地就对底层更缺乏掌控）。</li>
<li>我的 ESP32 学习笔记与代码（同样持续更新中，也是用的 C，后面也打算用 Rust 搞搞）：<a href="https://github.com/ryan4yin/knowledge/tree/master/electrical-engineering/esp32" target="_blank" rel="noopener noreferrer">electrical-engineering/esp32</a></li>
</ul>
</li>
<li>其他
<ul>
<li>买了块矽速科技新出的 Maix Zero M0S，使用 RISC-V 架构的 MCU，貌似目前必须用芯片官方（博流智能）的 SDK 写代码，待研究玩法。</li>
</ul>
</li>
</ul>
<blockquote>
<p>单片机领域目前仍然是 ARM32 架构的天下，不过开源免费的 RISC-V 架构发展迅猛，有望与 ARM32 分庭抗礼。目前乐鑫基于 RISC-V 的 ESP32C3 就挺受欢迎的，还出了书，另外后续版本 ESP32C5 也已经被 ESP-IDF 支持了，发展很快。</p>
</blockquote>
<h3 id="2-嵌入式-linuxlinux-on-embedded-system" class="headerLink">
    <a href="#2-%e5%b5%8c%e5%85%a5%e5%bc%8f-linuxlinux-on-embedded-system" class="header-mark"></a>2. 嵌入式 Linux（Linux on Embedded System）</h3><blockquote>
<p>嵌入式系统（Embedded System），是指嵌入机械或电气系统内部、具有专一功能和实时计算性能的计算机系统。</p>
</blockquote>
<p>单片机玩够了后，就可以开始玩嵌入式 Linux了。</p>
<ul>
<li>介绍：嵌入式 Linux，即运行 Linux 操作系统的、性能比 MCU 更高的微型计算机，行业上最常用 ARM Cortex-A5X 系列芯片与 Linux 开发一些嵌入式设备。</li>
<li>应用：路由器、电视盒子、智能家居等。在硬件爱好者手里可以用来做计算机视觉控制小车、WiFi、蓝牙控制中枢等等。</li>
<li>典型产品
<ul>
<li>Raspberry Pi: 使用 ARM Cortex-A 系列 CPU 的微型计算机，社区庞大，生态丰富。</li>
<li>其他各种国产派，如基于瑞芯微 RK35XX 系列 SoC 的 OrangePi、RockPi、野火鲁班猫等，它们都比现在的树莓派便宜很多（2023 年的 4B 2G 全新要 1000+ 太恐怖了），性能也更高，生态差一些不过瑕不掩瑜。</li>
<li>STM32/IMX6ULL 也有相关产品</li>
</ul>
</li>
<li>补充说明
<ul>
<li>嵌入式 Linux 代码的可移植性相对要好很多，因为硬件相关的逻辑都封装在驱动层了。</li>
</ul>
</li>
</ul>
<p>我目前的学习顺序与进度：</p>
<ul>
<li>瑞芯微 RK3588s 系列国产派: 性能贼强，还自带 NPU(2TOPS * 3)
<ul>
<li>玩耍的笔记代码放在了这里（Python 与 C 语言）<a href="https://github.com/ryan4yin/knowledge/tree/master/electrical-engineering/rk3588" target="_blank" rel="noopener noreferrer">electrical-engineering/rk3588</a></li>
</ul>
</li>
<li>树莓派 4B:
<ul>
<li>玩耍笔记与代码：<a href="https://github.com/ryan4yin/knowledge/tree/master/electrical-engineering/raspberrypi" target="_blank" rel="noopener noreferrer">electrical-engineering/raspberrypi</a></li>
</ul>
</li>
<li>其他
<ul>
<li>除了前面俩，还兜兜转转玩了很多新产品，笔记都写在这里面了：<a href="https://github.com/ryan4yin/knowledge/tree/master/electrical-engineering/" target="_blank" rel="noopener noreferrer">electrical-engineering</a></li>
<li>MAIX-III AXera-Pi AX620A（爱芯派），1.8TOPS 算力（标称 3.6TOPS 的一半不能用于 AI）
<ul>
<li>这块板子的 NPU 感觉性能还可以，但是 CPU 跟 IO 都有点拉，跑个 <code>pip3 list</code> 都要卡老半天。毕竟 A7 内核，估计性能也就这样了，全靠交叉编译续命。</li>
</ul>
</li>
<li>鲁班猫 0 无线版（LubanCat Zero W）
<ul>
<li>基于 RK3566，开放的资料非常全，包含 SoC 原厂的各种文档、SDK 驱动开发包、核心板封装库，还提供许多免费的在线文档，内容包含  Linux 内核编译部署、Linux 驱动开发、嵌入式 QT 开发等等</li>
<li>因为资料很全，用来学 Linux 内核驱动开发感觉是比较合适的。</li>
</ul>
</li>
<li>矽速科技的 LicheePi 4A，国产高性能 RISC-V 开发版，预定了但还没出货。</li>
</ul>
</li>
</ul>
<p>其他我感兴趣的资料（资料内容有一定的重叠）：</p>
<ul>
<li>《<a href="https://man7.org/tlpi/index.html" target="_blank" rel="noopener noreferrer">Linux/Unix 系统编程手册</a>》：讲解 Linux 的主要系统 API</li>
<li>野火嵌入式 Linux 系列教程：
<ol>
<li><a href="https://doc.embedfire.com/linux/imx6/linux_base/zh/latest/index.html" target="_blank" rel="noopener noreferrer">基础使用 + 内核编程</a>：感觉跟《Linux/Unix 系统编程手册》内容是重复的，可以简单过一过</li>
<li><a href="https://doc.embedfire.com/linux/rk356x/build_and_deploy/zh/latest/index.html" target="_blank" rel="noopener noreferrer">Linux 镜像构建与部署</a>: 跟随此文档自己构建一个 Linux 镜像部署到板卡上，这样可以更好的理解 Linux 的启动过程</li>
<li><a href="https://doc.embedfire.com/linux/rk356x/driver/zh/latest/index.html" target="_blank" rel="noopener noreferrer">Linux 驱动开发入门 - 基于鲁班猫 RK356X 系列板卡</a>: Linux 驱动开发入门教程。</li>
</ol>
</li>
<li><a href="https://github.com/PacktPublishing/Linux-Device-Driver-Development-Second-Edition" target="_blank" rel="noopener noreferrer">Linux Device Driver Development - Second Edition</a>: Linux 驱动编程入门，2022 年出的新书，基于 Linux 5.10，amazon 上评价不错，目前只有英文版，写的很好，对新手很友好。内容跟野火的教程差不多，可以对照学习。
<ul>
<li>另外还有本 2018 年出的 <a href="https://github.com/ALIBERA/linux_book_2nd_edition" target="_blank" rel="noopener noreferrer">Linux Driver Development for Embedded Processors 2nd Edition</a> 可当作参考书看，写得没上面那本好、内容也没那么新，但是看评价也不错，特点是有许多的 Lab 可做。</li>
</ul>
</li>
<li><a href="https://book.douban.com/subject/35415097/" target="_blank" rel="noopener noreferrer">Linux Kernel Programming: A comprehensive guide to kernel internals</a>: Linux 内核编程领域的新书，适合入门 Linux 内核，amazon 上评价挺好，先收藏一个</li>
<li><a href="https://nju-projectn.github.io/ics-pa-gitbook/" target="_blank" rel="noopener noreferrer">南京大学 计算机科学与技术系 计算机系统基础 课程实验 (PA)</a></li>
<li><a href="https://book.douban.com/subject/1776614/" target="_blank" rel="noopener noreferrer">Understanding the Linux Kernel, 3rd Edition</a>：Linux 内核技术进阶。</li>
</ul>
<blockquote>
<p>嵌入式 Linux 领域目前也仍然是 ARM32 架构的天下，但是开源免费的 RISC-V 架构发展也很快，目前（2023-03-10）已有稳定出货的昉星光 2，以及预售的 LicheePi4A，性能越来越强，生态越来越好，很值得期待。</p>
</blockquote>
<h2 id="社区公众号收藏" class="headerLink">
    <a href="#%e7%a4%be%e5%8c%ba%e5%85%ac%e4%bc%97%e5%8f%b7%e6%94%b6%e8%97%8f" class="header-mark"></a>社区公众号收藏</h2><p>单纯一个人埋头自学未免太过枯燥，效率也不一定高，偶尔也可以逛逛各种社区、看看相关的技术博客、文章，是一个更丰富的信息源。</p>
<p>我收集的一些相关论坛、公众号、交流群总结在了这里，可供参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/352385472/answer/2921790194" target="_blank" rel="noopener noreferrer">可以给我推荐几个相关的论坛或者微信公众号吗？ - 知乎</a></li>
</ul>
<h2 id="最后简单总结下" class="headerLink">
    <a href="#%e6%9c%80%e5%90%8e%e7%ae%80%e5%8d%95%e6%80%bb%e7%bb%93%e4%b8%8b" class="header-mark"></a>最后简单总结下</h2><p>上面这些都学了一遍的话，业余玩玩硬件应该就很够用了，期待我完成这个学习路线的那一天&hellip;</p>
]]></content></entry><entry><title type="html">2022 年年终总结</title><link href="https://thiscute.world/posts/2022-summary/"/><id>https://thiscute.world/posts/2022-summary/</id><author><name>ryan4yin</name></author><published>2023-01-02T18:00:45+08:00</published><updated>2023-01-02T18:00:45+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/2022-summary/github-profile-2022-ryan4yin.webp" height="1772" width="882"><figcaption></figcaption>
        </figure><h2 id="闲言碎语" class="headerLink">
    <a href="#%e9%97%b2%e8%a8%80%e7%a2%8e%e8%af%ad" class="header-mark"></a>闲言碎语</h2><p>是的又过去一年，又到了一年一度的传统节目——年终总结时间。</p>
<h2 id="2022-年流水账" class="headerLink">
    <a href="#2022-%e5%b9%b4%e6%b5%81%e6%b0%b4%e8%b4%a6" class="header-mark"></a>2022 年流水账</h2><p>先简单过一下我 2022 年的流水账（有记录一个 <code>/history</code>，回顾起来就是方便）：</p>
<ul>
<li>1 月
<ul>
<li>购入 Synthesizer V + 青溯 AI 声库，简单调了几首歌试试，效果非常棒。然后就一直放了一年没碰它&hellip;还试用了免费的 ACE 虚拟歌姬，合成效果确实很强，跟收费的 Synthesizer V 有的一拼。</li>
<li>在家过春节，给家里二楼装了空调、加湿器跟地垫。但是没买地暖垫，导致开了空调后地上的垫子冰凉。后面补买了地暖垫但是已经要上班了没体验上。</li>
</ul>
</li>
<li>2 月跟 3 月
<ul>
<li>想学下区块链技术，结果发现课程一开始就讲加密哈希函数的基本性质，就决定先搞一波密码学，结果就是输出了一个<a href="https://thiscute.world/posts/practical-cryptography-basics-1/" target="_blank" rel="noopener noreferrer">《写给开发人员的实用密码学》系列文章</a>，内容大部分是翻译的，少部分是我自己补充。</li>
<li>主要工作：跟推荐系统大佬一起将服务从 HTTP 切换到 gRPC，效果立竿见影，服务流量下降 50% ~ 60%，延迟下降 30% ~ 50%。</li>
</ul>
</li>
<li>4 月份
<ul>
<li>读完了 <a href="https://github.com/ethereumbook/ethereumbook" target="_blank" rel="noopener noreferrer">Mastering Ethereum</a>，对以太坊有了基本的了解。</li>
<li>读了《Go 程序设计语言（英文版）》
<ul>
<li><figure><a class="lightgallery" href="/images/now/the-go-programming-language.webp" title="/images/now/the-go-programming-language.webp" data-thumbnail="/images/now/the-go-programming-language.webp" data-sub-html="<h2>Go 程序设计语言（英文版） 2022-08-19 补图</h2>">
        <img
            
            loading="lazy"
            src="/images/now/the-go-programming-language.webp"
            srcset="/images/now/the-go-programming-language.webp, /images/now/the-go-programming-language.webp 1.5x, /images/now/the-go-programming-language.webp 2x"
            sizes="auto"
            alt="/images/now/the-go-programming-language.webp">
    </a><figcaption class="image-caption">Go 程序设计语言（英文版） 2022-08-19 补图</figcaption>
    </figure></li>
</ul>
</li>
<li>很高兴通过了职级晋升，不再是 SRE 萌新了。</li>
<li>主要工作：使用 <a href="https://github.com/aws/karpenter" target="_blank" rel="noopener noreferrer">aws/karpenter</a> 实现离线计算集群的弹性扩缩容，省了一波成本。</li>
</ul>
</li>
<li>5 月份
<ul>
<li>主要是学完了《深入浅出 Kubernetes》这个极客时间专栏</li>
<li>通过《分布式协议与算法实战》等相关资料简单了解了下分布式共识算法的原理，记录了些笔记，8 月份的时候把笔记整理输出为了一篇博客 <a href="https://thiscute.world/posts/consistency-and-consensus-algorithm/" target="_blank" rel="noopener noreferrer">分布式系统的一致性问题与共识算法</a></li>
<li>还读了许多社区的区块链相关资料，包括但不限于 <a href="https://www.zhihu.com/special/1452635344142909440" target="_blank" rel="noopener noreferrer">Web 3.0：穿越十年的讨论 - 知乎</a>、<a href="https://guoyu.mirror.xyz/RD-xkpoxasAU7x5MIJmiCX4gll3Cs0pAd5iM258S1Ek" target="_blank" rel="noopener noreferrer">《Web3 DApp 最佳编程实践指南》</a>、<a href="https://github.com/dcbuild3r/blockchain-development-guide" target="_blank" rel="noopener noreferrer">dcbuild3r/blockchain-development-guide</a></li>
<li>因为 AI 发展迅猛，来了三分钟兴趣学了一点 <a href="https://github.com/d2l-ai/d2l-zh" target="_blank" rel="noopener noreferrer">动手学深度学习 - Pytorch 版</a>，但是进度条走了不到 15% 就不了了之了。</li>
<li>主要工作：研究跨云应用部署方案与跨云 kubernetes 网络方案，如 karmada/kubevela/istio，以及 L4/L7 层的开源/商业网关方案</li>
</ul>
</li>
<li>6 月份
<ul>
<li>读完了《在生命的尽头拥抱你-临终关怀医生手记》</li>
<li>读了一点买的新书：《语言学的邀请》跟《Intimate Relationship》</li>
</ul>
</li>
<li>7 月份
<ul>
<li>主要工作：确定并实施网关架构优化的初步方案，使用 Go 语言写了一个 Nginx Gateway 控制器，迁移流量到新容器化网关省了一波成本。</li>
</ul>
</li>
<li>8 月
<ul>
<li>读完了《在峡江的转弯处 - 陈行甲人生笔记》
<ul>
<li><figure><a class="lightgallery" href="/images/now/life-notes-of-chenxingjia.webp" title="/images/now/life-notes-of-chenxingjia.webp" data-thumbnail="/images/now/life-notes-of-chenxingjia.webp" data-sub-html="<h2>陈行甲人生笔记</h2>">
        <img
            
            loading="lazy"
            src="/images/now/life-notes-of-chenxingjia.webp"
            srcset="/images/now/life-notes-of-chenxingjia.webp, /images/now/life-notes-of-chenxingjia.webp 1.5x, /images/now/life-notes-of-chenxingjia.webp 2x"
            sizes="auto"
            alt="/images/now/life-notes-of-chenxingjia.webp">
    </a><figcaption class="image-caption">陈行甲人生笔记</figcaption>
    </figure></li>
</ul>
</li>
<li>延续上个月对 Linux 系统的兴趣，快速过了一遍 The ANSI C Programming Language 以熟悉 C 的语法，之后开始阅读 <a href="https://man7.org/tlpi/" target="_blank" rel="noopener noreferrer">Linux/Unix 系统编程手册（上册）</a>
<ul>
<li>写了一个小项目 <a href="https://github.com/ryan4yin/video2ascii-c" target="_blank" rel="noopener noreferrer">video2ascii-c</a> 练手 C 语言。</li>
<li><figure><a class="lightgallery" href="/images/now/the-asni-c-programming-language.webp" title="/images/now/the-asni-c-programming-language.webp" data-thumbnail="/images/now/the-asni-c-programming-language.webp" data-sub-html="<h2>The ANSI C Programming Language</h2>">
        <img
            
            loading="lazy"
            src="/images/now/the-asni-c-programming-language.webp"
            srcset="/images/now/the-asni-c-programming-language.webp, /images/now/the-asni-c-programming-language.webp 1.5x, /images/now/the-asni-c-programming-language.webp 2x"
            sizes="auto"
            alt="/images/now/the-asni-c-programming-language.webp">
    </a><figcaption class="image-caption">The ANSI C Programming Language</figcaption>
    </figure></li>
</ul>
</li>
<li>因为今年搞网关 APISIX/Nginx 接触比较多，看了一点极客时间《OpenResty 从入门到实战》但是因为兴趣并不强烈，又不了了之了。</li>
<li>主要工作：
<ul>
<li>搞网关优化省了一波成本，但是期间也搞出一个严重故障&hellip;</li>
<li>承接了一个数据上报网关的需求，需要在网关层支持一些稍微复杂点的功能确保升级流程的稳定性。跟 APISIX 官方沟通后得到了比较好的解决方案 <a href="https://github.com/apache/apisix/discussions/7773" target="_blank" rel="noopener noreferrer">custom plugin - set an upstream as a http fallback server</a></li>
</ul>
</li>
</ul>
</li>
<li>9 月
<ul>
<li>偶然发现手机桌面上有一个安装了好久但是一直没用过的 APP 英语流利说，顺手用它测了下自己的英文水平。然后就对英语感兴趣了，制定了英语学习计划并发布对应的博文 <a href="https://thiscute.world/posts/learn-english-again/" target="_blank" rel="noopener noreferrer">Learn English Again</a>，然后就开始坚持学英语，感觉整个过程都很顺利。</li>
<li>主要工作：
<ul>
<li>仍然是搞网关优化省成本，因为各种原因，再次输出一篇 Post Mortem</li>
<li>搞数据上报网关的需求</li>
</ul>
</li>
</ul>
</li>
<li>10 月
<ul>
<li>找了很多英语学习资料，通过每日的坚持学习，渐渐找到了自己的英语学习节奏，完善了学习规划。</li>
<li>《Linux/Unix 系统编程手册（上册）》阅读进度过半，但是业余时间就这么点，同时用来学习 Linux 跟英语实在有点吃力，这本书的阅读就慢慢放下了。
<ul>
<li><figure><a class="lightgallery" href="/images/now/the-linux-programming-interface.webp" title="/images/now/the-linux-programming-interface.webp" data-thumbnail="/images/now/the-linux-programming-interface.webp" data-sub-html="<h2>Linux/Unix 系统编程手册（上册）</h2>">
        <img
            
            loading="lazy"
            src="/images/now/the-linux-programming-interface.webp"
            srcset="/images/now/the-linux-programming-interface.webp, /images/now/the-linux-programming-interface.webp 1.5x, /images/now/the-linux-programming-interface.webp 2x"
            sizes="auto"
            alt="/images/now/the-linux-programming-interface.webp">
    </a><figcaption class="image-caption">Linux/Unix 系统编程手册（上册）</figcaption>
    </figure></li>
</ul>
</li>
<li>通过友链漫游，发现了 <a href="https://0xffff.one" target="_blank" rel="noopener noreferrer">0xFFFF 社区</a>，内容质量很高，也在社区的 QQ 群里跟群友们聊了些有意思有价值的内容。</li>
<li>打游戏学英语
<figure><a class="lightgallery" href="/images/learn-english-again/genshin-impact-noelle.webp" title="/images/learn-english-again/genshin-impact-noelle.webp" data-thumbnail="/images/learn-english-again/genshin-impact-noelle.webp" data-sub-html="<h2>超飒的重剑女仆 Noelle</h2>">
        <img
            
            loading="lazy"
            src="/images/learn-english-again/genshin-impact-noelle.webp"
            srcset="/images/learn-english-again/genshin-impact-noelle.webp, /images/learn-english-again/genshin-impact-noelle.webp 1.5x, /images/learn-english-again/genshin-impact-noelle.webp 2x"
            sizes="auto"
            alt="/images/learn-english-again/genshin-impact-noelle.webp">
    </a><figcaption class="image-caption">超飒的重剑女仆 Noelle</figcaption>
    </figure>
<figure><a class="lightgallery" href="/images/learn-english-again/demo2-talk-1.webp" title="/images/learn-english-again/demo2-talk-1.webp" data-thumbnail="/images/learn-english-again/demo2-talk-1.webp" data-sub-html="<h2>DEEMO 2 中丰富的对话内容</h2>">
        <img
            
            loading="lazy"
            src="/images/learn-english-again/demo2-talk-1.webp"
            srcset="/images/learn-english-again/demo2-talk-1.webp, /images/learn-english-again/demo2-talk-1.webp 1.5x, /images/learn-english-again/demo2-talk-1.webp 2x"
            sizes="auto"
            alt="/images/learn-english-again/demo2-talk-1.webp">
    </a><figcaption class="image-caption">DEEMO 2 中丰富的对话内容</figcaption>
    </figure></li>
<li>因为许多原因，中概股大跌，公司架构大调整，走了很多大佬，包括去年带我冲浪的算法部门前辈。</li>
<li>主要工作
<ul>
<li>搞数据上报网关的需求，一路踩坑，总算把数万 QPS 的流量全部迁移到新网关上了。</li>
</ul>
</li>
</ul>
</li>
<li>11 月
<ul>
<li>重新对搞 Homelab 产生了兴趣，买了三台 MINI 主机组了一个 Homelab，时隔一年多又开始折腾 Proxmox VE，做各种规划。</li>
<li>迭代了很多次后的个人 Homelab 文档：<a href="https://github.com/ryan4yin/knowledge/tree/master/homelab" target="_blank" rel="noopener noreferrer">ryan4yin/knowledge/homelab</a>
<ul>
<li><figure><a class="lightgallery" href="/images/now/dashy-homepage.webp" title="/images/now/dashy-homepage.webp" data-thumbnail="/images/now/dashy-homepage.webp" data-sub-html="<h2>我的 Homelab 导航页 2022-11-12</h2>">
        <img
            
            loading="lazy"
            src="/images/now/dashy-homepage.webp"
            srcset="/images/now/dashy-homepage.webp, /images/now/dashy-homepage.webp 1.5x, /images/now/dashy-homepage.webp 2x"
            sizes="auto"
            alt="/images/now/dashy-homepage.webp">
    </a><figcaption class="image-caption">我的 Homelab 导航页 2022-11-12</figcaption>
    </figure></li>
</ul>
</li>
<li>因为业余时间沉迷搞 Homelab，英语打卡就变得断断续续了&hellip;但是词汇量测试的效果出乎意料，进步速度喜人，阅读能力也能感觉到有明显提升。</li>
<li>月底搬家换了个新租房，床是挂天花板上的，房间就宽敞了很多，而且拉了独立的电信宽带，网速杠杠的。</li>
<li>11/25 去东莞松山湖跟高中同学聚会，然后跟几位同学打麻将打到半夜三点多&hellip; 还远远眺望了眼同学读博的地方——「<a href="http://english.ihep.cas.cn/csns/" target="_blank" rel="noopener noreferrer">中国散裂中子源</a>」，感觉很高大上
<figure><a class="lightgallery" href="/images/now/play-mahjong-with-classmates.webp" title="/images/now/play-mahjong-with-classmates.webp" data-thumbnail="/images/now/play-mahjong-with-classmates.webp">
        <img
            
            loading="lazy"
            src="/images/now/play-mahjong-with-classmates.webp"
            srcset="/images/now/play-mahjong-with-classmates.webp, /images/now/play-mahjong-with-classmates.webp 1.5x, /images/now/play-mahjong-with-classmates.webp 2x"
            sizes="auto"
            alt="/images/now/play-mahjong-with-classmates.webp">
    </a></figure>
<figure><a class="lightgallery" href="/images/now/china-spallation-neutron-source.webp" title="/images/now/china-spallation-neutron-source.webp" data-thumbnail="/images/now/china-spallation-neutron-source.webp">
        <img
            
            loading="lazy"
            src="/images/now/china-spallation-neutron-source.webp"
            srcset="/images/now/china-spallation-neutron-source.webp, /images/now/china-spallation-neutron-source.webp 1.5x, /images/now/china-spallation-neutron-source.webp 2x"
            sizes="auto"
            alt="/images/now/china-spallation-neutron-source.webp">
    </a></figure></li>
<li>主要工作：继续推进线上网关优化项目，以及调研 K8s / Istio 的新版本变化，为集群升级做预备工作。</li>
</ul>
</li>
<li>12 月
<ul>
<li>从 Homelab 折腾到 HomeAssistant/ESPHome，然后就折腾 ESP32/ESP8266，结果很意外地就买了一堆硬件，入手了电烙铁热风枪万用表等各种仪器，ESP/51/STM32 都玩了个遍&hellip;
<ul>
<li>输出内容有两个代码仓库：<a href="https://github.com/ryan4yin/learn-8051-asm" target="_blank" rel="noopener noreferrer">learn-8051-asm</a> 与 <a href="https://github.com/ryan4yin/learn-stm32f103c8t6" target="_blank" rel="noopener noreferrer">learn-stm32f103c8t6</a>，以及一份 EE 笔记：<a href="https://github.com/ryan4yin/knowledge/blob/master/electrical-engineering/Electrical%20Engineering.md" target="_blank" rel="noopener noreferrer">Electrical Engineering.md</a>
<figure><img src="/images/now/experience-of-electrical-engineering.webp" width="60%"/><figcaption>
                  <h4>我的电子电路初体验</h4>
              </figcaption>
      </figure>

<figure><img src="/images/now/8051-display-2023.webp" width="70%"/><figcaption>
                  <h4>8051 汇编 - 数码管显示 2023</h4>
              </figcaption>
      </figure>
</li>
</ul>
</li>
<li>ChatGPT 横空出世，引发全网热潮。有技术大佬感慨，这个时刻竟然来临得如此之快，惊喜之余也有点猝不及防。我也把玩了一波，也用它帮助我学了许多硬件相关的东西，很有帮助。
<ul>
<li>个人猜测未来 ChatGPT 成熟后大概率能极大提升技术人员的工作效率，很可能间接影响到许多人的工作。</li>
</ul>
</li>
<li>年底还入手了一台 3D 打印机 ELEGOO Neptune 3 Pro&hellip;</li>
<li>全国逐渐放开疫情管控，我得了新冠，然后康复&hellip;</li>
<li>这个月折腾硬件，英语漏打卡更严重了，但是词汇量仍然在稳步增长，阅读起来也是越来越顺畅。</li>
<li>主要工作：
<ul>
<li>线上网关优化项目基本落地，取得了预期收益，但是没达到之前设的激进目标。（旧网关仍留存极少部分流量，还需要时间去统一网关架构）</li>
<li>做 K8s 集群升级准备，然后月底公司大面积新冠，拖慢了这项工作的进度，即使后调了升级时间，仍然感觉有点虚&hellip;</li>
</ul>
</li>
</ul>
</li>
<li>最后是连续三年蝉联我年度歌手的天依同学，截图放这里纪念一下：
<figure><img src="/images/now/netease-cloud-music-2022-singer-of-ryan4yin.webp" width="50%"/><figcaption>
              <h4>我的网易云年度歌手</h4>
          </figcaption>
  </figure>
</li>
</ul>
<h2 id="2022-年-highlight" class="headerLink">
    <a href="#2022-%e5%b9%b4-highlight" class="header-mark"></a>2022 年 Highlight</h2><h3 id="1-英语" class="headerLink">
    <a href="#1-%e8%8b%b1%e8%af%ad" class="header-mark"></a>1. 英语</h3><p>英语也是我今年比较惊喜的一个部分，很长一段时间内，我都觉得英语的优先级并不高，一直没有把它的学习排上日程，水平也一直没啥显著提升。</p>
<p>但是从今年 9 月份开始到现在这四个月的英语学习中，我的进步相当明显，从去年大概  4700 词，到现在测试结果为 6583 词，涨了近 2000 词，月均接近 500 词（按这个速度，2023 年 10000 词的目标好像没啥难度了）。</p>
<p>词汇量测试结果按时间排序如下，使用的测试工具是 <a href="https://preply.com/en/learn/english/test-your-vocab" target="_blank" rel="noopener noreferrer">Test Your Vocabulary</a> ：</p>
<p><figure><img src="/images/now/2023-01-02-test-your-vocabulary-result.webp" width="70%"/><figcaption>
            <h4>2023-01-02 词汇量测试结果：6583 词</h4>
        </figcaption>
</figure>

<figure><img src="/images/now/2022-12-19-test-your-vocabulary-result.webp" width="40%"/><figcaption>
            <h4>2022-12-19 词汇量测试结果：6300 词</h4>
        </figcaption>
</figure>

<figure><img src="/images/learn-english-again/2022-11-17-test-your-vocabulary-result.webp" width="65%"/><figcaption>
            <h4>2022-11-17 词汇量测试结果：5600 词</h4>
        </figcaption>
</figure>

<figure><img src="/images/learn-english-again/2022-10-18-test-your-vocabulary-result.webp" width="40%"/><figcaption>
            <h4>2022-10-18 词汇量测试结果：5100 词</h4>
        </figcaption>
</figure>
</p>
<p>另外因为主要是靠读书来学英语，今年的英文阅读能力也有明显提升，跟 9 月份刚开始读的时候比，阅读体验要流畅多了。
一些英文原版书阅读成就：</p>
<figure><img src="/images/now/mintreading-first-100days-achivement.webp" width="35%"/><figcaption>
            <h4>在薄荷阅读上读完的第一本英语原版书</h4>
        </figcaption>
</figure>

<p>而口语、写作这些今年基本没练习，原地踏步。</p>
<h3 id="2-业余技术" class="headerLink">
    <a href="#2-%e4%b8%9a%e4%bd%99%e6%8a%80%e6%9c%af" class="header-mark"></a>2. 业余技术</h3><p>今年业余搞的技术，感觉这些都是我比较满意的：</p>
<ul>
<li>Web3: 今年上半年花了不少时间去了解 Web3，但是仍然没敢说自己已经懂了它。水比较深，浅尝辄止。</li>
<li>电子电路（硬件）：点亮这个技能完全是个意外&hellip;但也挺惊喜的，毕竟我大学学的建筑声学，以前都没接触过硬件。</li>
<li>Go 语言：去年底定的目标是将 Go 语言应用在至少两个项目上，实际上只用在了一个项目上，完成度 50% 吧。</li>
<li>Linux: Linux 今年主要是复习了一遍 C 语言，然后看了半本《Linux/Unix 系统编程手册（上册）》，之后因为学英语就给放下了。
<ul>
<li>毕竟英语的成果很不错，这个结果我觉得也是预期内的。</li>
</ul>
</li>
<li>博客：今年博客经营得尚可，数了下有 18 篇技术干货，四篇非技术文章。最主要是三月份翻译密码学的文章冲了一波内容量。虽然 12 月份又鸽掉了&hellip;总体还是满意的。</li>
</ul>
<h3 id="3-工作" class="headerLink">
    <a href="#3-%e5%b7%a5%e4%bd%9c" class="header-mark"></a>3. 工作</h3><p>SRE 组 2022 年工作的主旋律其实就是省钱，我 2022 年的工作上有更多的挑战，不过因为得心应手很多，反倒没什么想特别着墨描述的了。</p>
<p>我上半年工作成果比较突出，下半年虽然工作成果差一些，但是业余的学习成果相当突出，总体很满意自己今年的成绩。</p>
<p>单纯从工作方面讲，我给自己的评价仍然是「良好」。</p>
<h3 id="4-阅读" class="headerLink">
    <a href="#4-%e9%98%85%e8%af%bb" class="header-mark"></a>4. 阅读</h3><p>2022 年一共读完了这些书：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 《人间失格》</li>
<li><input checked="" disabled="" type="checkbox"> 《月宫》</li>
<li><input checked="" disabled="" type="checkbox"> 《<a href="https://github.com/nakov/Practical-Cryptography-for-Developers-Book" target="_blank" rel="noopener noreferrer">Practical Cryptography for Developers</a>》</li>
<li><input checked="" disabled="" type="checkbox"> 《<a href="https://github.com/ethereumbook/ethereumbook" target="_blank" rel="noopener noreferrer">Mastering Ethereum</a>》</li>
<li><input checked="" disabled="" type="checkbox"> 《Go 程序设计语言（英文版）》</li>
<li><input checked="" disabled="" type="checkbox"> 《深入浅出 Kubernetes - 张磊》</li>
<li><input checked="" disabled="" type="checkbox"> 《在生命的尽头拥抱你-临终关怀医生手记》</li>
<li><input checked="" disabled="" type="checkbox"> 《在峡江的转弯处 - 陈行甲人生笔记》</li>
<li><input checked="" disabled="" type="checkbox"> 《The ANSI C Programming Language》</li>
<li><input checked="" disabled="" type="checkbox"> The Time Machine</li>
<li><input checked="" disabled="" type="checkbox"> Learn Robotics With Raspberry Pi
<ul>
<li>学习使用树莓派控制智能小车，结合本书与网上资料，我制作了一台使用 Xbox One 手柄遥控的四驱小车，相当有意思~</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> Learn Robotics Programming, 2nd Edition
<ul>
<li>跟前面那本一样是讲树莓派小车的，不过这本书更深入，代码含量高很多。</li>
<li>快速翻了一遍，跳过了其中大部分代码，因为书中的小车不太符合我的需求。</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> The Unlikely Pilgrimage of Harold Fry</li>
<li><input checked="" disabled="" type="checkbox"> 51 单片机自学笔记</li>
</ul>
<p>看起来，去年定的一个月至少读一本书的目标，还是达成了滴~</p>
<h2 id="2023-年的展望" class="headerLink">
    <a href="#2023-%e5%b9%b4%e7%9a%84%e5%b1%95%e6%9c%9b" class="header-mark"></a>2023 年的展望</h2><h3 id="技术侧" class="headerLink">
    <a href="#%e6%8a%80%e6%9c%af%e4%be%a7" class="header-mark"></a>技术侧</h3><p>2022 年的结果跟年初的展望区别仍然是挺大的，但是我个人挺满意。</p>
<p>这里再记一下 2023 年技术上的展望，看看今年能实现多少，又会点出多少意料之外的技能吧哈哈：</p>
<ul>
<li>云原生
<ul>
<li>去年定的阅读 k8s 及相关生态的源码没任何进度，2023 年继续&hellip;</li>
<li>2019 年到现在，我的工作时长已经有三年半了，希望更多的东西能通过学习底层知识去知其所以然，而不是全靠网上找资料，人云亦云一知半解地去解决问题。</li>
</ul>
</li>
<li>Linux 与网络
<ul>
<li>2023 年把《Linux/Unix 系统编程手册》这套书看完，并且过完 <a href="https://0xffff.one/d/1085-mit6-s081-operating-system" target="_blank" rel="noopener noreferrer">0xFFFF - MIT6.S081 Operating System Engineering (Fall 2020)</a> 这个课，对 Linux 内核与操作系统形成较深入的理解。</li>
<li>借着对硬件的兴趣学一学 Linux 驱动开发。</li>
<li>学习学习时下超流行的 eBPF 技术</li>
</ul>
</li>
<li>3D 打印
<ul>
<li>2022 年底买了台打印机，那不必须得打印点自己设计的东西？</li>
<li>FreeCAD 学！Blender 可能跟 3D 打印没啥关系但是也要学！</li>
</ul>
</li>
<li>编程语言
<ul>
<li>今年 Go/C 两个语言的技能点感觉是点出来了，2023 年需要巩固下，用它们完成些更复杂的任务。</li>
<li>另外借着搞硬件的兴趣，把 Rust/C++ 两门语言也玩一玩
<ul>
<li>C++ 主要是用来玩 ESP32/ESP8266，rust 那可是时下最潮的系统级语言，2022 年虽然用 rust 写了点 demo 但离熟练还差很远。</li>
</ul>
</li>
</ul>
</li>
<li>其他
<ul>
<li>2022 年我给开源社区提交的代码贡献几乎没有，希望 2023 年能至少给三个开源项目提交一些代码贡献，这也是检验自己的代码水平。</li>
<li>制作一台自己的无人机或者穿越机（虽然还不太懂什么是穿越机&hellip;），并借此练习自己学习的软硬件知识。</li>
<li>更多地在公司内部、博客等地方分享自己所学的知识，提升所学知识的可复用性，同时也碰撞出更多的灵光，更深入地理解它们。</li>
</ul>
</li>
</ul>
<h3 id="生活侧" class="headerLink">
    <a href="#%e7%94%9f%e6%b4%bb%e4%be%a7" class="header-mark"></a>生活侧</h3><p>2022 年初我写的生活上的展望，貌似只有「阅读」这一项达标了&hellip;
不过今年也仍旧记录下 2023 年的展望：</p>
<ul>
<li>2022 年因为疫情以及自己懒，参与的户外活动相当少，2023 年希望能更多的做些户外运动，身体还是很重要的啊。</li>
<li>把轮滑水平练上去一点，轮滑鞋在 2022 年吃灰了几乎一整年&hellip;</li>
<li>音乐上，口琴、竹笛、midi 键盘、Synthesizer V / ACE Studio / Reaper，总要把其中一个练一练吧&hellip;（什么？学吉他？？不敢开新坑了，旧坑都还没填完呢&hellip;）</li>
<li>阅读：仍然跟去年保持一样的节奏就好，目标是一个月至少阅读一本书。</li>
<li>英语：英语的规划在 <a href="https://thiscute.world/posts/learn-english-again/" target="_blank" rel="noopener noreferrer">Learn English Again</a> 中已经做得比较详尽了，这里仅摘抄下目标。
<ul>
<li>2023 年达到 CEFR 的 C1 等级，报考并取得 BEC 高级证书</li>
<li>2023 年底词汇量超过 10000</li>
</ul>
</li>
</ul>
<h2 id="结语" class="headerLink">
    <a href="#%e7%bb%93%e8%af%ad" class="header-mark"></a>结语</h2><p>2021 年的年终总结文末，我给自己 2022 年的期许是「更上一层楼」，感觉确实应验了。</p>
<p>那么 2023 年，我希望自己能够「认识更多有趣的人，见识下更宽广的世界」~</p>
<blockquote>
<p>更多有趣的的 2022 年度总结：<a href="https://github.com/saveweb/review-2022" target="_blank" rel="noopener noreferrer">https://github.com/saveweb/review-2022</a></p>
</blockquote>
]]></content></entry><entry><title type="html">Proxmox Virtual Environment 使用指南</title><link href="https://thiscute.world/posts/proxmox-virtual-environment-instruction/"/><id>https://thiscute.world/posts/proxmox-virtual-environment-instruction/</id><author><name>ryan4yin</name></author><published>2022-11-27T22:38:03+08:00</published><updated>2022-11-27T22:38:03+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/proxmox-virtual-environment-instruction/proxmox-logo.webp" height="2019" width="854"><figcaption></figcaption>
        </figure><blockquote>
<p>本文介绍我使用 PVE 的一些心得（不保证正确 emmmm），可能需要一定使用经验才能顺畅阅读。</p>
</blockquote>
<h2 id="前言" class="headerLink">
    <a href="#%e5%89%8d%e8%a8%80" class="header-mark"></a>前言</h2><p>我在去年的文章 <a href="https://thiscute.world/posts/QEMU/KVM-usage/" target="_blank" rel="noopener noreferrer">「QEMU/KVM 虚拟化环境的搭建与使用」</a> 中介绍了如何使用 QEMU/KVM 作为桌面虚拟化软件，其功能对标开源免费的 <a href="https://www.virtualbox.org/" target="_blank" rel="noopener noreferrer">Oracle VM VirtualBox</a> 以及收费但是用户众多的 <a href="https://www.vmware.com/products/workstation-pro.html" target="_blank" rel="noopener noreferrer">VMware Workstation Pro</a>.</p>
<p>虽然我们也可以远程使用 QEMU/KVM，但是使用门槛比较高。而且如果要管理多台服务器，各种命令也比较繁琐。
我们显然需要更易用的软件来管理服务器场景下的虚拟化。</p>
<p>而这篇文章介绍的 <a href="https://pve.proxmox.com/wiki/Main_Page" target="_blank" rel="noopener noreferrer">Proxmox Virtual Environment</a>（后续简称 PVE），就是一个基于 QEMU/KVM 的虚拟机集群管理平台。</p>
<p>PVE 以 Debian + QEMU/KVM + LXC 为基础进行了深度定制，提供了一套比较完善的 Web UI，基本上 95% 的操作都可以直接通过它的 Web UI 完成，但是仍然有些功能只需要使用它的 CLI 完成，或者说需要手动修改一些配置文件。</p>
<p>PVE 完全基于 Linux 世界的各种开源技术，存储技术使用了 LVM（也支持 Ceph/iSCSI/NFS），也支持通过 cloudinit 预配置网络、磁盘扩容、设置 hostname（这其实是 libvirtd 的功能）。
它的文档也比较齐全，而且写得清晰易懂，还包含许多它底层的 QEMU/KVM/CEPH/Cloudinit 等开源技术的内容，对学习 Linux 虚拟化技术也有些帮助。（这里必须喷下 VMware 的文档，真的是写得烂得一批，不知所云）</p>
<p>总的来说，PVE 没有 <a href="https://www.vmware.com/cn/products/vsphere-hypervisor.html" target="_blank" rel="noopener noreferrer">vShpere Hypervisor</a> 跟 <a href="https://learn.microsoft.com/en-us/windows-server/virtualization/hyper-v/hyper-v-technology-overview" target="_blank" rel="noopener noreferrer">Windows Hyper-V</a> 那么成熟、完善、稳定，但是基于 QEMU/KVM 且能够免费使用，很适合 Linux/开源/虚拟化 爱好者折腾。</p>
<blockquote>
<p>你可能还听说过 OpenStack，不过这个玩意儿我没接触过，所以这里略过了它。</p>
</blockquote>
<p>因为这些原因，我选择了 PVE 作为我的 Homelab 系统。</p>
<p>先贴一张我当前 Homelab 的 PVE 控制台截图，然后就进入正文。</p>
<p><figure><a class="lightgallery" href="/images/proxmox-ve-instruction/ryan-pve-console.webp" title="/images/proxmox-ve-instruction/ryan-pve-console.webp" data-thumbnail="/images/proxmox-ve-instruction/ryan-pve-console.webp" data-sub-html="<h2>我的 PVE 集群</h2>">
        <img
            
            loading="lazy"
            src="/images/proxmox-ve-instruction/ryan-pve-console.webp"
            srcset="/images/proxmox-ve-instruction/ryan-pve-console.webp, /images/proxmox-ve-instruction/ryan-pve-console.webp 1.5x, /images/proxmox-ve-instruction/ryan-pve-console.webp 2x"
            sizes="auto"
            alt="/images/proxmox-ve-instruction/ryan-pve-console.webp">
    </a><figcaption class="image-caption">我的 PVE 集群</figcaption>
    </figure></p>
<blockquote>
<p>如果你想了解我的 PVE 集群都跑了些啥，可以瞅一瞅 <a href="https://github.com/ryan4yin/knowledge/tree/master/homelab" target="_blank" rel="noopener noreferrer">homelab - ryan4yin/knowledge</a>.</p>
</blockquote>
<h2 id="一安装-pve-系统" class="headerLink">
    <a href="#%e4%b8%80%e5%ae%89%e8%a3%85-pve-%e7%b3%bb%e7%bb%9f" class="header-mark"></a>一、安装 PVE 系统</h2><p>建议直接使用 <a href="https://github.com/ventoy/Ventoy" target="_blank" rel="noopener noreferrer">ventoy</a> 制作一个 U 盘启动盘，把官网下载的 PVE ISO 镜像拷贝进去，即可使用它进行系统安装。
安装过程中需要注意的点有：</p>
<ul>
<li>如果你有多台机器，每台机器需要使用不同的主机名称（hostname），否则后面组建 PVE 集群时会有麻烦。
<ul>
<li>建议使用机器型号 + 数字编号作为机器的 hostname</li>
</ul>
</li>
<li>为每台 PVE 节点配置静态 IP，避免 IP 变更。</li>
</ul>
<p>系统安装好后即可按照提示直接访问其 Web UI，会提示 HTTPS 证书无效，忽略即可。另外还会有一个烦人的 PVE 订阅提示，也可直接忽略（7.2 及以上版本，暂时没找到怎么禁用掉这个提示）。</p>
<p>此外对于国内环境，建议使用如下命令配置国内镜像源（提升软件安装速度）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 设置 debian 的阿里镜像源</span>
</span></span><span class="line"><span class="cl">cp /etc/apt/sources.list /etc/apt/sources.list.bak
</span></span><span class="line"><span class="cl">sed -i <span class="s2">&#34;s@\(deb\|security\).debian.org@mirrors.aliyun.com@g&#34;</span> /etc/apt/sources.list
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 设置 pve 国内镜像源</span>
</span></span><span class="line"><span class="cl"><span class="c1"># https://mirrors.bfsu.edu.cn/help/proxmox/</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s1">&#39;deb https://mirrors.bfsu.edu.cn/proxmox/debian buster pve-no-subscription&#39;</span> &gt; /etc/apt/sources.list.d/pve-no-subscription.list
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="组建-pve-集群" class="headerLink">
    <a href="#%e7%bb%84%e5%bb%ba-pve-%e9%9b%86%e7%be%a4" class="header-mark"></a>组建 PVE 集群</h3><blockquote>
<p>如果你仅使用单机 PVE，可忽略这一节内容。</p>
</blockquote>
<p>将多台 PVE 节点组成一个集群，可以获得很多新玩法，比如虚拟机在多节点间的热迁移。</p>
<blockquote>
<p>注意 CPU 架构差别较大很可能会导致无法热迁移，建议使用同品牌、同代的 CPU，最好是 CPU 型号完全一致。比如都是 Intel 的 12 代 CPU，或者都是 AMD 的 5 代 CPU。</p>
</blockquote>
<p>这个也还挺简单的，首先随便登入一台机器的 Web Console，点击「Datacenter」=&gt;「Cluster」=&gt;「Create Cluster」即可创建一个 PVE 集群。</p>
<p>接着复制「Join Information」中的内容，在其他每台 PVE 节点的 Web Console 页面中，点击「Datacenter」=&gt;「Cluster」=&gt;「Join Cluster」，然后粘贴前面复制的「Join Information」，再输入前面节点的密码，等待大约一分钟，然后刷新页面，PVE 集群即组建完成。</p>
<p><figure><a class="lightgallery" href="/images/proxmox-ve-instruction/pve-cluster-configuration.webp" title="/images/proxmox-ve-instruction/pve-cluster-configuration.webp" data-thumbnail="/images/proxmox-ve-instruction/pve-cluster-configuration.webp" data-sub-html="<h2>PVE 集群配置</h2>">
        <img
            
            loading="lazy"
            src="/images/proxmox-ve-instruction/pve-cluster-configuration.webp"
            srcset="/images/proxmox-ve-instruction/pve-cluster-configuration.webp, /images/proxmox-ve-instruction/pve-cluster-configuration.webp 1.5x, /images/proxmox-ve-instruction/pve-cluster-configuration.webp 2x"
            sizes="auto"
            alt="/images/proxmox-ve-instruction/pve-cluster-configuration.webp">
    </a><figcaption class="image-caption">PVE 集群配置</figcaption>
    </figure></p>
<p>PVE 集群的所有节点是完全平等的，集群组建完成后，登录其中任意一个节点的 Web Console 都可以管理集群中所有节点的资源。</p>
<h2 id="二pve-控制台的使用" class="headerLink">
    <a href="#%e4%ba%8cpve-%e6%8e%a7%e5%88%b6%e5%8f%b0%e7%9a%84%e4%bd%bf%e7%94%a8" class="header-mark"></a>二、PVE 控制台的使用</h2><p>PVE 控制台的使用还挺简单的，多试试基本就会用了。这里不做详细介绍，主要说明下创建虚拟机时一些重要的参数：</p>
<ul>
<li>CPU
<ul>
<li>将 CPU 类型设置为 <code>host</code> 可以提高性能，适合比较吃性能或者对实时性要求高的虚拟机如 windows/openwrt</li>
<li>对于虚拟机核数，建议将 <code>sockets</code> 设为 1（即 CPU 插槽数，一般物理服务器才会有 2 及以上的 CPU 插槽），cores 设为你想分配给该虚拟机的 CPU 核数</li>
<li>仅针对多物理 CPU 场景（多 <code>sockets</code>）才需要启用 NUMA（个人猜测，可能有错）</li>
</ul>
</li>
<li>磁盘、网卡
<ul>
<li>磁盘驱动建议用 <code>virtio SCSI</code>、网卡驱动建议用 <code>VirtIO(paravirtualized)</code>，它的性能更高。
<ul>
<li>Linux 虚拟机原生支持 virtio 半虚拟化，而 windows 想要完全开启半虚拟化，需要手动安装驱动，详见 <a href="https://pve.proxmox.com/wiki/Windows_VirtIO_Drivers" target="_blank" rel="noopener noreferrer">Windows_VirtIO_Drivers - Proxmox WIKI</a>，简单的说就是要下个 iso 挂载到 windows 主机中，并安装其中的驱动。</li>
</ul>
</li>
<li>如果硬盘是 SSD，虚拟机磁盘可以启用 <code>SSD Emulation</code>，对于 IO 性能要求高的场景还可以为磁盘勾选 <code>IO  Thread</code> 功能</li>
</ul>
</li>
<li>显示器
<ul>
<li>默认使用 std 类型，兼容性最好，但是是纯 CPU 模拟的，比较耗 CPU。</li>
<li>如果你有需要显卡加速的桌面虚拟机，但是又不想搞复杂的显卡直通，可以选择 <code>VirGL GPU(virtio-gl)</code> 类型（注意不是 <code>VirtIO-GPU(virtio)</code>，这个驱动没有显卡加速能力），它能以较小的性能损耗将虚拟机中的 3D/2D 运算 offload 到 host GPU，而且避免复杂的驱动配置，只需要在 PVE 中执行。但是目前它仅支持 Linux 4.4+ 的 Guest 主机，并且要求 mesa (&gt;=11.2) compiled with the option <code>gallium-drivers=virgl</code>（我感觉这功能目前还有点鸡肋）。
<ul>
<li>要使用 <code>VirGL GPU(virtio-gl)</code>，还需要在 PVE 主机上安装额外的依赖：<code>apt install libgl1 libegl1</code>，安装好后即可使用。</li>
</ul>
</li>
<li>详见 <a href="https://pve.proxmox.com/pve-docs/chapter-qm.html#qm_display" target="_blank" rel="noopener noreferrer">QEMU Graphic card - Proxmox VE</a></li>
</ul>
</li>
<li>其他选项
<ul>
<li>调整启动项顺序，对于 cloud image 建议只启用 scsi0 这个选项</li>
</ul>
</li>
<li>虚拟机模板（Template）与克隆（Clone）
<ul>
<li>建议首先使用 ubuntu/opensuse cloud image 配置好基础环境（比如安装好 vim/curl/qemu-guest-agent），然后转换为 template，其他所有 Linux 虚拟机都可以直接 clone 一个，改个新名字，再改改 cloudinit 配置跟磁盘大小，就能直接启动使用了。相当方便。</li>
<li>仅 Full Clone 的虚拟机才可以在 PVE 集群节点间随意迁移，因此如果你需要虚拟机迁移功能，请不要使用 Link Clone.</li>
</ul>
</li>
<li>BIOS 通常都建议使用默认的 SeaBIOS，仅 Windows 等场景才建议换成 OMVF(UEFI)
<ul>
<li>OMVF 的分辨率、Secure Boot 等参数，都可以在启动时按 ESC 进入 UEFI 配置界面来调整。</li>
</ul>
</li>
</ul>
<p>上面这些内容，官方有详细文档，能读英文的话可以直接看 <a href="https://pve.proxmox.com/wiki/Qemu/KVM_Virtual_Machines" target="_blank" rel="noopener noreferrer">Qemu/KVM Virtual Machines - Proxmox WIKI</a>.</p>
<h3 id="1-使用-cloudinit-自动配置网卡ssh密钥存储空间" class="headerLink">
    <a href="#1-%e4%bd%bf%e7%94%a8-cloudinit-%e8%87%aa%e5%8a%a8%e9%85%8d%e7%bd%ae%e7%bd%91%e5%8d%a1ssh%e5%af%86%e9%92%a5%e5%ad%98%e5%82%a8%e7%a9%ba%e9%97%b4" class="header-mark"></a>1. 使用 cloudinit 自动配置网卡、SSH密钥、存储空间</h3><blockquote>
<p>完全参照官方文档 <a href="https://pve.proxmox.com/wiki/Cloud-Init_Support" target="_blank" rel="noopener noreferrer">Cloud-Init_Support - PVE Docs</a></p>
</blockquote>
<blockquote>
<p>注意：下面的几种镜像都分别有自己的坑点，仅 Ubuntu/OpenSUSE 测试通过，其他发行版的 Cloud 镜像都有各种毛病&hellip;</p>
</blockquote>
<p>一般配 Linux 虚拟机，我们当然希望能在虚拟机启动时，就自动配置好 IP 地址、SSH 密钥、文件系统自动扩容，这样能免去很多手工操作。cloudinit 就是一个能帮你自动完成这些功能的工具，AWS、阿里云等各大云服务厂商都支持这种配置方式，好消息是 PVE 也支持。</p>
<p>下面简单介绍下如何使用 cloudinit 来自动化配置 Linux 虚拟机。</p>
<p>首先 cloudinit 必须使用特殊的系统镜像，下面是几个知名发行版的 Cloud 系统镜像：</p>
<ol>
<li><a href="https://cloud-images.ubuntu.com/releases/" target="_blank" rel="noopener noreferrer">Ubuntu Cloud Images (RELEASED)</a>: 提供 img 格式的裸镜像（PVE 也支持此格式）
<ul>
<li>请下载带有 .img 结尾的镜像，其中以 <code>kvm.img</code> 结尾的镜像会更精简一点，而名称中不包含 kvm 的镜像会稍微大一点，但是带了所有常用的内核模块。（如果你不理解前者精简了啥，请选择后者——也就是稍大的这个镜像文件。）</li>
</ul>
</li>
<li><a href="https://download.opensuse.org/repositories/Cloud:/Images:/" target="_blank" rel="noopener noreferrer">OpenSUSE Cloud Images</a>
<ul>
<li>请下载带有 NoCloud 或者 OpenStack 字样的镜像。</li>
</ul>
</li>
<li>对于其他镜像，可以考虑手动通过 iso 来制作一个 cloudinit 镜像，参考 <a href="https://docs.openstack.org/image-guide/ubuntu-image.html" target="_blank" rel="noopener noreferrer">openstack - create ubuntu cloud images from iso</a></li>
</ol>
<blockquote>
<p>注：<a href="https://cdimage.debian.org/cdimage/cloud/" target="_blank" rel="noopener noreferrer">Debian Cloud Images</a> 的镜像无法使用，其他 ubuntu/opensuse 的 cloud 镜像也各有问题&hellip;在后面的常见问题中有简单描述这些问题。</p>
</blockquote>
<blockquote>
<p>这里评论区有些新内容，指出 cloud image 的各种毛病可能的解决方案，想深入了解请移步评论区。</p>
</blockquote>
<p>上述镜像和我们普通虚拟机使用的 ISO 镜像的区别，一是镜像格式不同，二是都自带了 <code>cloud-init</code>/<code>cloud-utils-growpart</code> 等用于自动化配置虚拟机的相关工具。</p>
<p>其名字中的 NoCloud 表示支持 cloudinit NoCloud 数据源——即使用 <code>seed.iso</code> 提供 user-data/meta-data/network-config 配置，PVE 就是使用的这种模式。
而 Openstack 镜像通常也都支持 NoCloud 模式，所以一般也是可以使用的。</p>
<p>以 ubuntu 的 cloudimg 镜像为例，下载好镜像后，首先创建虚拟机，并以导入的磁盘为该虚拟机的硬盘，命令如下：</p>
<blockquote>
<p>如下操作也可在 Web UI 上操作，这里仅以命令行为例。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 创建新虚拟机</span>
</span></span><span class="line"><span class="cl">qm create <span class="m">9000</span> --name ubuntu-bionic-template --memory <span class="m">2048</span> --net0 virtio,bridge<span class="o">=</span>vmbr0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 将下载好的 img/qcow2 镜像导入为新虚拟机的硬盘</span>
</span></span><span class="line"><span class="cl">qm importdisk <span class="m">9000</span> ubuntu-20.10-server-cloudimg-amd64.img local-lvm
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 通过 scsi 方式，将导入的硬盘挂载到虚拟机上</span>
</span></span><span class="line"><span class="cl">qm <span class="nb">set</span> <span class="m">9000</span> --scsihw virtio-scsi-pci --scsi0 local-lvm:vm-9000-disk-0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># qcow2 镜像默认仅 2G 大小，需要手动扩容到 32G，否则虚拟机启动会报错</span>
</span></span><span class="line"><span class="cl">qm resize <span class="m">9000</span> scsi0 32G
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后创建挂载 cloud-init 的 seed.iso，修改启动项以及其他：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 创建一个 cloud-init 需要使用的 CDROM 盘(sr0)</span>
</span></span><span class="line"><span class="cl">qm <span class="nb">set</span> <span class="m">9000</span> --ide2 local-lvm:cloudinit
</span></span><span class="line"><span class="cl"><span class="c1"># 设置系统引导盘</span>
</span></span><span class="line"><span class="cl">qm <span class="nb">set</span> <span class="m">9000</span> --boot c --bootdisk scsi0
</span></span><span class="line"><span class="cl"><span class="c1"># 设置 serial0 为显示终端，很多云镜像都需要这个。</span>
</span></span><span class="line"><span class="cl">qm <span class="nb">set</span> <span class="m">9000</span> --serial0 socket --vga serial0
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的工作都完成后，还需要做一些后续配置</p>
<ol>
<li>手动设置 cloud-init 参数，<strong>重新生成 cloudinit image</strong>，启动虚拟机，并通过 ssh 登入远程终端
<ol>
<li>cloud image 基本都没有默认密码，并且禁用了 SSH 密码登录。必须通过 cloud-init 参数添加私钥、设置账号、密码、私钥。</li>
</ol>
</li>
<li>检查 qemu-guest-agent，如果未自带，一定要手动安装它！
<ol>
<li>ubuntu 需要通过 <code>sudo apt install qemu-guest-agent</code> 手动安装它</li>
</ol>
</li>
<li>安装所需的基础环境，如 docker/docker-compose/vim/git/python3</li>
<li>关闭虚拟机，然后将虚拟机设为模板</li>
</ol>
<p>接下来就可以从这个模板虚拟机，克隆各类新虚拟机了~</p>
<p><figure><a class="lightgallery" href="/images/proxmox-ve-instruction/pve-cloudinit-configuration.webp" title="/images/proxmox-ve-instruction/pve-cloudinit-configuration.webp" data-thumbnail="/images/proxmox-ve-instruction/pve-cloudinit-configuration.webp" data-sub-html="<h2>保险起见，改完配置后记得点下 Regenerate Image</h2>">
        <img
            
            loading="lazy"
            src="/images/proxmox-ve-instruction/pve-cloudinit-configuration.webp"
            srcset="/images/proxmox-ve-instruction/pve-cloudinit-configuration.webp, /images/proxmox-ve-instruction/pve-cloudinit-configuration.webp 1.5x, /images/proxmox-ve-instruction/pve-cloudinit-configuration.webp 2x"
            sizes="auto"
            alt="/images/proxmox-ve-instruction/pve-cloudinit-configuration.webp">
    </a><figcaption class="image-caption">保险起见，改完配置后记得点下 Regenerate Image</figcaption>
    </figure></p>
<p>其他 cloudinit 相关文档：</p>
<ul>
<li><a href="https://support.huaweicloud.com/usermanual-ims/ims_01_0407.html" target="_blank" rel="noopener noreferrer">配置 Cloud-Init 工具 - 华为云</a></li>
<li><a href="https://github.com/canonical/cloud-init" target="_blank" rel="noopener noreferrer">canonical/cloud-init - github</a></li>
<li><a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/amazon-linux-2-virtual-machine.html" target="_blank" rel="noopener noreferrer">Run Amazon Linux 2 as a virtual machine on premises</a></li>
</ul>
<h3 id="2-虚拟机硬盘扩容" class="headerLink">
    <a href="#2-%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%a1%ac%e7%9b%98%e6%89%a9%e5%ae%b9" class="header-mark"></a>2. 虚拟机硬盘扩容</h3><p>CentOS/Ubuntu/Debian 提供的 Cloud 镜像，都自带了 <code>cloud-utils-growpart</code> 这个组件，可以实现在扩容物理硬盘时，自动调整 Linux 的分区大小。</p>
<p>因此需要扩容虚拟机时，直接通过 UI 面板/命令行扩容虚拟机的硬盘，然后重启虚拟机即可，Linux 的分区会在系统启动阶段被 <code>cloud-utils-growpart</code> 自动扩容。</p>
<p>PVE 可通过如下命令进行磁盘扩容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 将 id 为 9000 的虚拟机的 scsi0 磁盘，扩容到 32G</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 请自行修改虚拟机 ID 与磁盘大小，注意仅支持扩容！不能缩容。</span>
</span></span><span class="line"><span class="cl">qm resize <span class="m">9000</span> scsi0 32G
</span></span></code></pre></td></tr></table>
</div>
</div><p>而其他非 Cloud 镜像，则需要在扩容磁盘后再进入虚拟机手动扩容分区跟磁盘，具体命令就不介绍了，请自行查阅相关文档吧。</p>
<blockquote>
<p>因为这个方便的特性，也为了减少虚拟化的开销，Cloud 镜像默认是不使用 LVM 逻辑分区的。
LVM 逻辑分区虽然方便，但是它对物理机的作用更大些。虚拟机因为本身就能动态扩容“物理硬盘”的大小，基本不用不到 LVM。</p>
</blockquote>
<blockquote>
<p>还有一点，就是虚拟机通常只需要一个根分区就行，尤其是归 openstack/kubernetes 管的虚拟机。
只有在使用分布式存储之类的场景下，数据需要独立存储，才需要用到额外的分区(<code>/data</code> 之类的)。
一般只有物理机，才需要像网上很多文章提的那样，为 <code>/boot</code> <code>/</code> <code>/home</code> 去单独分区。
而且现在大家都用 SSD 了，物理机这样做分区的都少了，比如我个人电脑，就是一个 <code>/</code> 分区打天下。。。</p>
</blockquote>
<h2 id="三常见问题" class="headerLink">
    <a href="#%e4%b8%89%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98" class="header-mark"></a>三、常见问题</h2><h3 id="1-导入已有的-qcow2-镜像" class="headerLink">
    <a href="#1-%e5%af%bc%e5%85%a5%e5%b7%b2%e6%9c%89%e7%9a%84-qcow2-%e9%95%9c%e5%83%8f" class="header-mark"></a>1. 导入已有的 qcow2 镜像</h3><blockquote>
<p>这一步必须要命令行操作，WebUI 界面不支持。</p>
</blockquote>
<p>首先在页面上新建一台新虚拟机，记录下虚拟机 ID。</p>
<p>假设你创建的虚拟机 id 为 201，现在通过 scp/rsync 等手段将 qcow2 传输到 PVE 节点上，然后命令行使用如下命令导入 qcow2/img 镜像：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 命令格式</span>
</span></span><span class="line"><span class="cl">qm importdisk &lt;vmid&gt; &lt;source&gt; &lt;storage&gt;
</span></span><span class="line"><span class="cl"><span class="c1"># 示例</span>
</span></span><span class="line"><span class="cl">qm importdisk <span class="m">201</span> vm-201-disk-1.qcow2 local-lvm
</span></span></code></pre></td></tr></table>
</div>
</div><p>导入完成后，在虚拟机的 WebUI 界面中，会看到底下多了一个「未使用的磁盘 0」。</p>
<p>接着删除掉默认的磁盘（分离+删除，要两步），再挂载这个「未使用的磁盘 0」。</p>
<p>挂载完成后直接启动是不行的，还需要在设置中将新磁盘添加到启动项中，这样就能正常启动了。</p>
<h3 id="2-点击-shutdown-后-pve-系统卡住" class="headerLink">
    <a href="#2-%e7%82%b9%e5%87%bb-shutdown-%e5%90%8e-pve-%e7%b3%bb%e7%bb%9f%e5%8d%a1%e4%bd%8f" class="header-mark"></a>2. 点击 shutdown 后 PVE 系统卡住</h3><p>PVE 的 <code>shutdown</code> 功能依赖 <code>qemu-guest-agent</code>，对于还没有安装 <code>qemu-guest-agent</code> 的任何主机，或者已经卡死无响应的虚拟机，千万不要点 <code>shutdown</code> 按钮，因为一定会卡住很久，最后失败！</p>
<p><code>shutdown</code> 卡住的解决办法：手动在下方的「Tasks」面板中双击卡住的「Shutdown」操作，然后点击「stop」停止该操作。</p>
<p>该如何关闭这类没有 <code>qemu-guest-agent</code> 或者已经卡死无响应的主机？答案是使用 <code>stop</code>！</p>
<h3 id="3-cant-lock-file-varlockqemu-serverlock-xxxconf--got-timeout" class="headerLink">
    <a href="#3-cant-lock-file-varlockqemu-serverlock-xxxconf--got-timeout" class="header-mark"></a>3. can’t lock file ‘/var/lock/qemu-server/lock-xxx.conf’ – got timeout</h3><p>PVE 虚拟机卡在 BIOS 系统引导这一步，无法启动，也无法 <code>stop</code>！</p>
<p>解决方法：手动删除掉 lockfile: <code>/var/lock/qemu-server/lock-xxx.conf</code></p>
<p>因为虚拟机还卡在 BIOS 引导这一步，删除掉 lockfile 再关闭虚拟机并不会导致数据丢失。</p>
<h3 id="4-pve-集群有一个节点宕机如何解除关联" class="headerLink">
    <a href="#4-pve-%e9%9b%86%e7%be%a4%e6%9c%89%e4%b8%80%e4%b8%aa%e8%8a%82%e7%82%b9%e5%ae%95%e6%9c%ba%e5%a6%82%e4%bd%95%e8%a7%a3%e9%99%a4%e5%85%b3%e8%81%94" class="header-mark"></a>4. PVE 集群有一个节点宕机，如何解除关联？</h3><p>将多个节点组成一个 PVE Cluster 是很自然的一个选择，它能提供虚拟机热迁移、统一管理面板等非常方便的功能。
但是这会带来集群级别的高可用问题。</p>
<p>根据官方文档 <a href="https://pve.proxmox.com/wiki/Cluster_Manager" target="_blank" rel="noopener noreferrer">Cluster_Manager - Proxmox</a>，如果你需要容忍一定数量的节点宕机，PVE Cluster 至少需要三台主机（这跟 Etcd 一样，大概是 Raft 共识算法的要求），并且所有节点的 PVE 版本要完全一致。</p>
<p>那么如果个别节点出了问题，无法修复，该如何将它踢出集群呢？</p>
<p>如果在线节点占比超过 50%，节点删除的流程如下：</p>
<ul>
<li>首先通过访问节点的 shell 界面，通过命令 <code>pvecm nodes</code> 确认集群的所有节点</li>
<li>将需要移除的节点彻底关机，并且确保它不会以当前配置再次启动（也就是说关机后需要清空硬盘，避免数据混乱）
<ul>
<li>如果被删除节点已宕机，则可跳过 关机 步骤</li>
</ul>
</li>
<li>通过命令 <code>pvecm delnode xxx</code> 将问题节点移除集群</li>
<li>重置旧节点硬盘，并重新装机，用做其他用途。</li>
</ul>
<p>如果你的集群只有 2 个节点，或者有超过 3 个节点但是宕机节点数不低于 50%，那出于数据一致性要求 Raft 算法会禁止更新集群数据，上面的流程就走不通了。如果你直接走上面的流程，它会报错 <code>cluster not ready - no quorum?</code> 这时需要首先修改配置，使剩下的节点重新达成一致。其实就是修改选主节点时的投票数。</p>
<p>对于 2 个节点但挂掉 1 个的情况，首先执行如下指令允许当前节点自己选主：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 设置只需要 1 票就能当前主节点</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 潜在问题是可能有些集群元数据只在损坏节点上有，这么改会导致这些数据丢失，从而造成一些问题。</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 安全起见，建议在修复集群后，再重启一遍节点...</span>
</span></span><span class="line"><span class="cl">pvecm expected <span class="m">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在 quorum 就已经恢复了，可以走前面给出的节点移除流程。</p>
<p>如果节点已经删除，但是 Web GUI 上仍然显示有被删除的节点，可以在集群的所有剩余节点上，手动删除掉 <code>/etc/pve/nodes/node-name/</code> 文件夹，即可从集群中彻底删除该节点的数据，注意千万别删错了，不然就尴尬了&hellip;</p>
<p>如果 corosync 完全无法启动，上面给出的命令也会修改选主投票参数也会失败，这时可以直接手动修改 <code>/etc/corosync/corosync.conf</code> 删除掉有问题的节点对应的配置，调低 expceted 投票数，使 corosync 能正常启动，再执行前述操作。</p>
<h3 id="5-cloud-image-的坑" class="headerLink">
    <a href="#5-cloud-image-%e7%9a%84%e5%9d%91" class="header-mark"></a>5. cloud image 的坑</h3><h4 id="ubuntu-cloud-image-的坑" class="headerLink">
    <a href="#ubuntu-cloud-image-%e7%9a%84%e5%9d%91" class="header-mark"></a>ubuntu cloud image 的坑</h4><ul>
<li>ubuntu 启动时会报错 <code>no such device: root</code>，但是过一会就会正常启动。
<ul>
<li>这是 ubuntu cloud image 的 bug: <a href="https://bugs.launchpad.net/cloud-images/&#43;bug/1726476" target="_blank" rel="noopener noreferrer">https://bugs.launchpad.net/cloud-images/+bug/1726476</a></li>
</ul>
</li>
<li>ubuntu 启动后很快就会进入登录界面，但是 root 密码可能还没改好，登录会报密码错误，等待一会再尝试登录就 OK 了</li>
<li>ubuntu 的默认网卡名称是 ens3，不是 eth0，注意修改 network_config 的网卡名称，否则网络配置不会生效</li>
<li>以 kvm 结尾的 Ubuntu Cloud Image 无法识别到 USB 设备，将 USB 端口映射到该虚拟机中没有任何作用。
<ul>
<li>kvm 使用了精简版的 linux 内核，去掉了 USB 等在云上用不到的驱动，建议改用无 kvm 结尾的镜像。</li>
</ul>
</li>
</ul>
<h5 id="ubuntu-cloud-image-无法识别到-usb-设备的排查记录" class="headerLink">
    <a href="#ubuntu-cloud-image-%e6%97%a0%e6%b3%95%e8%af%86%e5%88%ab%e5%88%b0-usb-%e8%ae%be%e5%a4%87%e7%9a%84%e6%8e%92%e6%9f%a5%e8%ae%b0%e5%bd%95" class="header-mark"></a>「Ubuntu Cloud Image 无法识别到 USB 设备」的排查记录</h5><p>现象：</p>
<ul>
<li>在尝试使用 PVE 将 USB 接口直通到 Ubuntu Cloud Image 启动的虚拟机作为 NAS 系统时，发现 <code>lsblk</code> 根本无法找到我的 USB 硬盘</li>
<li>换成我笔记本接硬盘盒，能够正常识别并挂载硬盘</li>
<li>使用 <code>lsusb</code> 不会报错，但是也看不到任何内容</li>
<li>使用 <code>lspci</code> 能找到 USB 对应的 PCI 设备</li>
<li>进一步使用 <code>cat /proc/modules | grep usb</code> 与 <code>lsmod | grep usb</code> 均查不到任何 usb 相关的内核模块
<ul>
<li>而在我笔记本上 <code>lsmod | grep usb</code> 能够输出 <code>usb_storage</code> <code>usb_core</code> 等多项内核模块。</li>
</ul>
</li>
<li>再用 <code>modprobe usb</code> 会提示 <code>modprobe: FATAL: Module usb not found in directory /lib/modules/5.15.0-1021-kvm</code></li>
</ul>
<p>问题原因很明显了，Ubuntu 根本没有为 cloud image 预置 usb 内核模块，所以才有这个问题&hellip;</p>
<p>进一步搜索发现这个帖子：<a href="https://askubuntu.com/questions/1315370/whats-the-difference-between-ubuntus-amd64-disk-kvm-img-and-the-regular-amd64" target="_blank" rel="noopener noreferrer">What&rsquo;s the difference between ubuntu&rsquo;s amd64-disk-kvm.img and the regular amd64.img cloud images?</a>，解答了我的疑惑。</p>
<p>原因是，我使用了 ubuntu 为 cloud 环境做了精简的 kvm 内核，非常轻量，但是缺少 usb 等常用内核模块。</p>
<p>对于 NAS 外接存储这个场景，我应该使用不以 kvm 结尾的 ubuntu cloud image，换了个基础镜像后问题就解决了~</p>
<h4 id="opensuse-cloud-image-的坑" class="headerLink">
    <a href="#opensuse-cloud-image-%e7%9a%84%e5%9d%91" class="header-mark"></a>opensuse cloud image 的坑</h4><ul>
<li>opensuse leap 15 只支持 network_config v1，对 v2 的支持有 bug，<code>gateway4</code> 不会生效</li>
</ul>
<h4 id="debian-cloud-image-的坑" class="headerLink">
    <a href="#debian-cloud-image-%e7%9a%84%e5%9d%91" class="header-mark"></a>debian cloud image 的坑</h4><p>debian 的 cloud 镜像根本没法用，建议避免使用它。</p>
<ul>
<li>debian 启动时会彻底卡住，或者直接报错 kernel panic
<ul>
<li>原因是添加了 spice 图形卡，换成 vnc 就正常了</li>
</ul>
</li>
<li><a href="https://cdimage.debian.org/cdimage/cloud/" target="_blank" rel="noopener noreferrer">Debian Cloud Images</a> 中的 nocloud 镜像不会在启动时运行 cloudinit，cloudinit 完全不生效
<ul>
<li>不知道是啥坑，没解决</li>
</ul>
</li>
</ul>
<h3 id="6-克隆创建的虚拟机卡在-booting-from-hard-disk-状态" class="headerLink">
    <a href="#6-%e5%85%8b%e9%9a%86%e5%88%9b%e5%bb%ba%e7%9a%84%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%8d%a1%e5%9c%a8-booting-from-hard-disk-%e7%8a%b6%e6%80%81" class="header-mark"></a>6. 克隆创建的虚拟机，卡在 <code>Booting from Hard Disk...</code> 状态</h3><p>被用做模板的虚拟机可以正常启动，但是克隆的虚拟机就卡住了。</p>
<p>可能的原因：</p>
<ol>
<li>磁盘有问题，出这个问题的 cloud image 是 <code>ubuntu-20.10-server-cloudimg-amd64.img</code>，我更换成 <code>ubuntu-20.10-server-cloudimg-amd64-disk-kvm.img</code> 就没问题了。
<ol>
<li>磁盘镜像均下载自 <a href="https://cloud-images.ubuntu.com/releases/groovy/release-20201210/" target="_blank" rel="noopener noreferrer">https://cloud-images.ubuntu.com/releases/groovy/release-20201210/</a></li>
</ol>
</li>
<li>BIOS 不匹配：将 BIOS 从 SeaBIOS 切换到 OVMF(UEFI)
<ol>
<li>如果仍然无法启动，请进入 OVMF 的 BIOS 界面关闭「Secure Boot」后再重启看看</li>
</ol>
</li>
</ol>
<h3 id="7-虚拟机启动时-cloudinit-报错-faild-to-start-openbsd-secure-shell-server" class="headerLink">
    <a href="#7-%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%90%af%e5%8a%a8%e6%97%b6-cloudinit-%e6%8a%a5%e9%94%99-faild-to-start-openbsd-secure-shell-server" class="header-mark"></a>7. 虚拟机启动时 cloudinit 报错 faild to start OpenBSD Secure Shell server</h3><p>有如下几种可能：</p>
<ul>
<li><strong>可能性一：虚拟机名称包含非法字符</strong>
<ul>
<li>pve 的 cloudinit 配置会在启动时尝试将虚拟机 hostname 修改为与虚拟机一致，但是又没有对虚拟机名称做合法性校验&hellip;</li>
<li>当你使用的虚拟机名称包含了非法字符时就会出这个问题，比如 <code>ubuntu-22.10-cloudimage-template</code>，其中的 <code>.</code> 就是非法的， <code>.</code> 在 DNS 中用于划分不同的域！</li>
<li><strong>解决方法</strong>：克隆个新虚拟机并改用合法名称，再删除旧虚拟机，问题就解决了。</li>
</ul>
</li>
<li><strong>可能性二：磁盘空间不足</strong>
<ul>
<li>qcow 镜像转换成的虚拟机磁盘很小，只有 2G，如果不扩容，启动时就会出各种奇怪的问题。</li>
<li><strong>解决方法</strong>：通过 Web UI 扩容磁盘大小，建议至少给 32G。</li>
</ul>
</li>
</ul>
<h3 id="8-修改-linux-虚拟机的-hostname" class="headerLink">
    <a href="#8-%e4%bf%ae%e6%94%b9-linux-%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%9a%84-hostname" class="header-mark"></a>8. 修改 Linux 虚拟机的 Hostname</h3><p>如前所述，pve 的 cloudinit 配置会在启动时尝试将虚拟机 hostname 修改为与虚拟机一致，这导致手动修改无法生效无效。</p>
<p>解决方法：从旧的虚拟机克隆一个新虚拟机，将新虚拟机名称设为你期望的 hostname，然后删除旧虚拟机，启动新克隆的虚拟机，即完成了 hostname 重命名。</p>
<h3 id="9-虚拟机迁移时报错-host-key-verification-failed" class="headerLink">
    <a href="#9-%e8%99%9a%e6%8b%9f%e6%9c%ba%e8%bf%81%e7%a7%bb%e6%97%b6%e6%8a%a5%e9%94%99-host-key-verification-failed" class="header-mark"></a>9. 虚拟机迁移时报错 <code>Host key verification failed</code></h3><blockquote>
<p>社区相关帖子：https://forum.proxmox.com/threads/host-key-verification-failed-when-migrate.41666/</p>
</blockquote>
<p>这通常是因为节点增删，或者不小心动到了 <code>~/.ssh/known_hosts</code> 文件，导致的问题。</p>
<p>可以通过手动在每台节点上执行如下命令解决：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ssh -o <span class="s1">&#39;HostKeyAlias=&lt;Target node Name&gt;&#39;</span> root@&lt;Target node IP&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意将上述命令中的 <code>Target node Name&gt;</code> 改为节点名称，将 <code>&lt;Target node IP&gt;</code> 改为节点 IP 地址。</p>
<h3 id="10-pve-的-vm-不支持-vmxsvm-虚拟化指令集" class="headerLink">
    <a href="#10-pve-%e7%9a%84-vm-%e4%b8%8d%e6%94%af%e6%8c%81-vmxsvm-%e8%99%9a%e6%8b%9f%e5%8c%96%e6%8c%87%e4%bb%a4%e9%9b%86" class="header-mark"></a>10. PVE 的 vm 不支持 vmx/svm 虚拟化指令集</h3><p>在 Linux 虚拟机中运行如下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">egrep <span class="s1">&#39;(vmx|svm)&#39;</span> --color<span class="o">=</span>always /proc/cpuinfo
</span></span></code></pre></td></tr></table>
</div>
</div><p>有输出则说明此虚拟机本身也支持 vmx/svm 虚拟化指令集（vmx 是 intel 指令集，svm 是 amd 的指令集）。</p>
<p>如果没有任何输出，说明此虚拟机不支持嵌套虚拟机，无法在其内部运行 Hyper-V 或者 kvm 虚拟化程序。</p>
<p>一般来说 PVE 宿主机默认就会启用嵌套虚拟化功能，可通过如下指令验证：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># intel 用这个命令，输出 Y 则表示启用了嵌套虚拟化</span>
</span></span><span class="line"><span class="cl">cat /sys/module/kvm_intel/parameters/nested
</span></span><span class="line"><span class="cl"><span class="c1"># amd 用如下指令，输出 1 则表示启用了嵌套虚拟化</span>
</span></span><span class="line"><span class="cl">cat /sys/module/kvm_amd/parameters/nested
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果输出不是 <code>Y</code>/<code>1</code>，则需要手动启用嵌套虚拟化功能。</p>
<p>如果是 intel cpu，需要使用如下命令启用嵌套虚拟化功能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1">## 1. 关闭所有虚拟机，并卸载 kvm_intel 内核模块</span>
</span></span><span class="line"><span class="cl">sudo modprobe -r kvm_intel
</span></span><span class="line"><span class="cl"><span class="c1">## 2. 启用嵌套虚拟化功能</span>
</span></span><span class="line"><span class="cl">sudo modprobe kvm_intel <span class="nv">nested</span><span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="c1">## 3. 保存配置，使嵌套虚拟化功能在重启后自动启用</span>
</span></span><span class="line"><span class="cl">cat <span class="s">&lt;&lt;EOF | sudo tee /etc/modprobe.d/kvm.conf
</span></span></span><span class="line"><span class="cl"><span class="s">options kvm_intel nested=1
</span></span></span><span class="line"><span class="cl"><span class="s">EOF</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果是 amd cpu，则应使用如下命令启用嵌套虚拟化功能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1">## 1. 关闭所有虚拟机，并卸载 kvm_intel 内核模块</span>
</span></span><span class="line"><span class="cl">sudo modprobe -r kvm_amd
</span></span><span class="line"><span class="cl"><span class="c1">## 2. 启用嵌套虚拟化功能</span>
</span></span><span class="line"><span class="cl">sudo modprobe kvm_amd <span class="nv">nested</span><span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="c1">## 3. 保存配置，使嵌套虚拟化功能在重启后自动启用</span>
</span></span><span class="line"><span class="cl">cat <span class="s">&lt;&lt;EOF | sudo tee /etc/modprobe.d/kvm.conf
</span></span></span><span class="line"><span class="cl"><span class="s">options kvm_amd nested=1
</span></span></span><span class="line"><span class="cl"><span class="s">EOF</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面这么一堆操作后，宿主机就已经启用了嵌套虚拟化，但是虚拟机内部却仍然不一定能有虚拟化指令集。</p>
<p><strong>根本原因是 PVE 默认使用 kvm64 这种虚拟化的 CPU 类型，它不支持 vmx/svm 指令集！将虚拟机的 CPU 类型改为 <code>host</code>，然后重启虚拟机，问题就解决了</strong>。</p>
<h3 id="backup" class="headerLink">
    <a href="#backup" class="header-mark"></a>11. 如何在多台主机间同步 iso 镜像、backup 文件</h3><p>PVE 自动创建的备份，默认都只会保存到本机的 <code>local</code> 分区中，那万一机器出了问题，很可能备份就一起丢了。
为了确保数据安全，就需要做多机备份，或者将数据统一备份到另一个 NAS 系统。</p>
<p>我考虑了如下几个备份方案：</p>
<ol>
<li><a href="https://www.proxmox.com/en/proxmox-backup-server" target="_blank" rel="noopener noreferrer">proxmox-backup-server</a>：proxmox 官方推出的一个备份工具，使用 rust 编写。
<ol>
<li>它的主要好处在于，支持直接在 proxmox-ve 中将其添加为 cluster 级别的 storage，然后就可以通过 PVE 的定时备份任务，直接将数据备份到 proxmox-backup-server 中。但是我遇到这么几个问题，导致我放弃了它:
<ol>
<li>一是我想直接把数据通过 SMB 协议备份到 Windows Server 远程存储中，但是将 SMB 挂载磁盘用做  proxmox-backup-server 的 Datastore 会出问题，备份时 pbs 会创建一些特殊的临时文件，可能要用到 SMB 挂载插件不支持的特性，导致操作会失败。</li>
<li>二是我的 proxmox-backup-server 跟 Windows Server 都跑在 proxmox 虚拟机里面，那它就不能备份它自己，一备份就会卡住。</li>
</ol>
</li>
</ol>
</li>
<li>cronab + rclone/rsync: 极简方案，使用 crontab 跑定时脚本，用 rclone/rsync 同步数据。流程大致如下：
<ol>
<li>首先在 PVE DataCenter =&gt; Backup 中创建一个定期备份任务，将所有 vm 都备份到 local 存储中，它实际就存储位置为宿主机的 <code>/var/lib/vz/dump</code>。</li>
<li>通过 crontab 定时任务跑脚本，使用 rclone 将每个节点的 <code>/var/lib/vz/</code> 中的文件全部通过 SMB 协议同步到 HDD 中。crontab 的运行时间设置在 PVE 完成后为最佳。并且将同步指标上传到 victoria-metrics 监控系统，如果备份功能失效，监控系统将通过短信或邮件告警。</li>
<li><code>/var/lib/vz/</code> 中除了备份文件外还保存了 iso 镜像等文件，这里也一起备份了。</li>
</ol>
</li>
<li><a href="https://github.com/restic/restic" target="_blank" rel="noopener noreferrer">restic</a>: 一个更专业的远程增量备份工具，通过 rclone 支持几乎所有常见协议的远程存储（s3/ssh/smb 等），支持多种备份策略、版本策略、保留策略，支持加密备份。
<ol>
<li>restic 看着确实挺棒，但是感觉有点复杂了，很多功能我都不需要。PVE 自带的备份功能已经提供了备份的「保留策略」，我这里实际只需要一个数据同步工具。因此没选择它。</li>
</ol>
</li>
</ol>
<p>如上文所述，一番研究后我抛弃了 proxmox-backup-server 与 restic，最终选择了最简单的 cronab + rclone 方案，简单实用又符合我自己的需求（仅我个人的选择，建议结合需求自行抉择）。</p>
<p>同步脚本也很简单，首先通过 <code>rclone config</code> 手动将所有 PVE 节点加入为 rclone 的 remote，再将我的 smb 远程存储加进来（也可以手动改 <code>~/.config/rclone/rclone.conf</code>）。</p>
<blockquote>
<p>这个方案最大的缺点是，所有备份都需要保存在每台节点的 local 卷中，所以有必要给 local 分配较大的磁盘空间，不然机器多的话很快就满了&hellip;</p>
</blockquote>
<p>rclone 配置好后，我写了个几行的 shell 脚本做备份同步：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 我的三台 pve 节点，对应的 rclone remote 名称</span>
</span></span><span class="line"><span class="cl"><span class="nb">declare</span> -a <span class="nv">pve_nodes</span><span class="o">=(</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;pve-um560&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;pve-gtr5&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;pve-s500plus&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># crontab 执行任务，需要指定下配置文件的绝对路径</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> node in <span class="s2">&#34;</span><span class="si">${</span><span class="nv">pve_nodes</span><span class="p">[@]</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">  rclone sync --progress <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --config<span class="o">=</span>/home/ryan/.config/rclone/rclone.conf  <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  <span class="si">${</span><span class="nv">node</span><span class="si">}</span>:/var/lib/vz <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  smb-downloads:/Downloads/proxmox-backup/<span class="si">${</span><span class="nv">node</span><span class="si">}</span>/
</span></span><span class="line"><span class="cl"><span class="k">done</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># TODO 上传监控指标到监控系统，用于监控任务是否成功。</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后手动执行 <code>/bin/bash /home/ryan/rclone-sync-to-nas.sh &gt; /home/ryan/rclone-sync.log</code> 看看是否运行正常。</p>
<p>运行没问题后，再添加这么一个每天晚上 5 点（UTC 21 点）多执行的定时任务进行同步，就完成了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 为了均衡负载，建议分钟值随便填个奇数。</span>
</span></span><span class="line"><span class="cl"><span class="m">17</span> <span class="m">21</span> * * * /bin/bash /home/ryan/rclone-sync-to-nas.sh &gt; /home/ryan/rclone-sync.log
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以把运行时间调整到 1 分钟后确认下效果，如果要看实时日志可以用 <code>tail -f /home/ryan/rclone-sync.log</code> 查看。</p>
<p>如果任务未执行，可以通过 <code>sudo systmctl status cron</code> 查看任务执行日志，排查问题。</p>
<h3 id="12-使用-cloud-image-创建的虚拟机扩容磁盘并重启后文件系统未自动扩容" class="headerLink">
    <a href="#12-%e4%bd%bf%e7%94%a8-cloud-image-%e5%88%9b%e5%bb%ba%e7%9a%84%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%89%a9%e5%ae%b9%e7%a3%81%e7%9b%98%e5%b9%b6%e9%87%8d%e5%90%af%e5%90%8e%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e6%9c%aa%e8%87%aa%e5%8a%a8%e6%89%a9%e5%ae%b9" class="header-mark"></a>12. 使用 cloud image 创建的虚拟机扩容磁盘并重启后，文件系统未自动扩容</h3><p>这个我遇到过几次，都是因为磁盘容量用尽，导致 cloudinit 扩容脚本运行失败，只要手动回收些空间，再重启系统，就能自动扩容。</p>
<p>我试了只要能确保系统还剩余 100M 左右的存储空间就能正常扩容了，更低的还没试过。</p>
<p>如果数据实在不能清，也可以考虑手动扩容，请自行搜索相关内容（基本流程就是用 <code>fdisk</code> 先删除分区，再重新创建分区，实现修改分区表扩容，操作得当不会丢数据）。</p>
<h2 id="四pve-网络配置" class="headerLink">
    <a href="#%e5%9b%9bpve-%e7%bd%91%e7%bb%9c%e9%85%8d%e7%bd%ae" class="header-mark"></a>四、PVE 网络配置</h2><h3 id="1-桥接多张物理网卡" class="headerLink">
    <a href="#1-%e6%a1%a5%e6%8e%a5%e5%a4%9a%e5%bc%a0%e7%89%a9%e7%90%86%e7%bd%91%e5%8d%a1" class="header-mark"></a>1. 桥接多张物理网卡</h3><p>示例如下，主要就是在 vmbr0 网桥的 <code>Bridge Ports</code> 里面：</p>
<p><figure><a class="lightgallery" href="/images/proxmox-ve-instruction/pve-multiple-nic.webp" title="/images/proxmox-ve-instruction/pve-multiple-nic.webp" data-thumbnail="/images/proxmox-ve-instruction/pve-multiple-nic.webp" data-sub-html="<h2>桥接多张物理网卡</h2>">
        <img
            
            loading="lazy"
            src="/images/proxmox-ve-instruction/pve-multiple-nic.webp"
            srcset="/images/proxmox-ve-instruction/pve-multiple-nic.webp, /images/proxmox-ve-instruction/pve-multiple-nic.webp 1.5x, /images/proxmox-ve-instruction/pve-multiple-nic.webp 2x"
            sizes="auto"
            alt="/images/proxmox-ve-instruction/pve-multiple-nic.webp">
    </a><figcaption class="image-caption">桥接多张物理网卡</figcaption>
    </figure></p>
<h3 id="2-手动添加-usb-物理网卡" class="headerLink">
    <a href="#2-%e6%89%8b%e5%8a%a8%e6%b7%bb%e5%8a%a0-usb-%e7%89%a9%e7%90%86%e7%bd%91%e5%8d%a1" class="header-mark"></a>2. 手动添加 USB 物理网卡</h3><blockquote>
<p>参考官方文档: <a href="https://pve.proxmox.com/pve-docs/chapter-sysadmin.html#sysadmin_network_configuration" target="_blank" rel="noopener noreferrer">SysAdmin - Network Configuration</a></p>
</blockquote>
<p>我遇到这个问题的场景是：我的 mini 主机（GTR5）只有两个 2.5G 网卡，不太够用。而家里的路由器剩下的都是千兆网口，路由器也难以拓展网卡。
网上搜了下 2.5G 交换机又发现价格 429 起步，所以决定买两张 USB 2.5GbE 网卡插在这台小主机上作为便宜的网口拓展方案。</p>
<p>现在网卡有了，有两种方式可以让 PVE 识别到这张网卡：</p>
<blockquote>
<p>好像 PVE 偶尔也能自动识别到网卡，就是比较慢&hellip;</p>
</blockquote>
<ol>
<li>方法一：直接重启机器，然后就能在 Web UI 的 <code>Network</code> 配置中见到这张 USB 网卡了。之后直接把该网卡加入到 vmbr 网桥的 <code>Bridge Ports</code> 中并应用配置，就大功告成了。</li>
<li>方法二：不重启机器实现添加 USB 网卡。如果机器不能重启，就可以走这个流程：
<ol>
<li>首先，使用 <code>ip link</code> 命令打印出当前的所有网络接口</li>
<li>将 2.5GbE 网卡插到 USB3.0 端口上，Linux 将自动识别到它</li>
<li>现在再使用 <code>ip link</code> 命令查看所有网络接口，找到新增的接口名称（通常在输出内容最末尾）。
<ol>
<li>在我的环境中新的 USB 网卡名称为 <code>enx00e04c680178</code></li>
</ol>
</li>
<li>在配置文件 <code>/etc/network/interfaces</code> 的末尾新增一行：<code>iface enx00e04c680178 inet manual</code>（注意替换网卡名称）</li>
<li>现在直接刷新 Web UI 页面， USB 网卡就会出现了。之后直接把该网卡加入到 vmbr 网桥的 <code>Bridge Ports</code> 中并应用配置，就大功告成了。</li>
</ol>
</li>
</ol>
<h3 id="3-配置-wifi-网卡" class="headerLink">
    <a href="#3-%e9%85%8d%e7%bd%ae-wifi-%e7%bd%91%e5%8d%a1" class="header-mark"></a>3. 配置 WiFi 网卡</h3><p>如果主机自带了 WiFi 网卡，启动后 Proxmox VE 能识别到该网卡，但是无法通过 Web UI 修改它的任何配置。</p>
<p>那么本着物尽其用的精神，该如何利用上这张 WiFi 网卡呢？</p>
<p>根据 PVE 官方文档 <a href="https://pve.proxmox.com/wiki/WLAN" target="_blank" rel="noopener noreferrer">WLAN - Proxmox VE Docs</a>，并不建议在 PVE 上使用 WLAN，它存在如下问题：</p>
<ul>
<li>WiFi 自身必须是一个 Linux Bridge 设备，无法被桥接到 vmbr0 等网桥上。因为大多数 Access Point 都会直接拒绝掉未授权的源地址发过来的数据包&hellip;</li>
<li>与有线连接相比，WiFi 的延迟要高得多，而且延迟波动较大。</li>
</ul>
<p>因此仅建议在不得已的情况下，才使用 WiFi 网卡.</p>
<p>如果要配置 WLAN 网卡的话，官方建议直接参考 Debian 的官方文档进行配置：<a href="https://wiki.debian.org/WiFi/HowToUse" target="_blank" rel="noopener noreferrer">How to use a WiFi interface - Debian</a>，不过这里也找到一篇中文博客：</p>
<ul>
<li><a href="https://foxi.buduanwang.vip/virtualization/pve/1939.html/" target="_blank" rel="noopener noreferrer">proxmox中使用ax210连接无线网络 - 佛西博客</a></li>
</ul>
<h2 id="五提升-pve-的安全性" class="headerLink">
    <a href="#%e4%ba%94%e6%8f%90%e5%8d%87-pve-%e7%9a%84%e5%ae%89%e5%85%a8%e6%80%a7" class="header-mark"></a>五、提升 PVE 的安全性</h2><h3 id="1-配置-acme-证书并使其自动更新" class="headerLink">
    <a href="#1-%e9%85%8d%e7%bd%ae-acme-%e8%af%81%e4%b9%a6%e5%b9%b6%e4%bd%bf%e5%85%b6%e8%87%aa%e5%8a%a8%e6%9b%b4%e6%96%b0" class="header-mark"></a>1. 配置 ACME 证书并使其自动更新</h3><p>对于个人使用而言，不配置证书好像也 ok，虽然访问 Web UI 时浏览器会提示不安全，但也不影响使用。</p>
<p>如果你拥有自己的域名，同时也期望更高的安全性，根据<a href="https://pve.proxmox.com/wiki/Certificate_Management#sysadmin_certs_acme_dns_challenge" target="_blank" rel="noopener noreferrer">Certificate Management - 官方文档</a>，pve 可借助 acme.sh 进行证书的申请与自动更新。</p>
<p>TODO</p>
<h3 id="2-ssh-禁用密码登录" class="headerLink">
    <a href="#2-ssh-%e7%a6%81%e7%94%a8%e5%af%86%e7%a0%81%e7%99%bb%e5%bd%95" class="header-mark"></a>2. SSH 禁用密码登录</h3><p>pve 的 ssh 默认是启用了密码登录的，为了安全性，建议上传 ssh 密钥改用密钥登录，并禁用密码登录功能。</p>
<p>详见 <a href="https://github.com/ryan4yin/knowledge/blob/master/linux/Linux%20%E4%B8%BB%E6%9C%BA%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE.md" target="_blank" rel="noopener noreferrer">Linux 主机安全设置.md - ryan4yin</a></p>
<h3 id="3-用户管理" class="headerLink">
    <a href="#3-%e7%94%a8%e6%88%b7%e7%ae%a1%e7%90%86" class="header-mark"></a>3. 用户管理</h3><p>PVE 支持对接多种授权协议，对于个人使用而言，直接使用 Linux PAM 是最简单的。</p>
<p>即使是在内网，为了安全性，也建议设置复杂密码，同时所有虚拟机也建议仅启用密钥登录，所有 Web 页面都建议设置复杂密码。（特别是家里没有访客网络的时候&hellip;）</p>
<h2 id="六pcie-直通显卡硬盘usb-设备等" class="headerLink">
    <a href="#%e5%85%adpcie-%e7%9b%b4%e9%80%9a%e6%98%be%e5%8d%a1%e7%a1%ac%e7%9b%98usb-%e8%ae%be%e5%a4%87%e7%ad%89" class="header-mark"></a>六、PCI(e) 直通（显卡、硬盘、USB 设备等）</h2><p>QEMU/KVM 的 PCI(e) 直通功能可以让虚拟机<strong>独占</strong>指定的 PCI(e) 设备，越过宿主机控制器直接与该 PCI(e) 设备通信。</p>
<p>相比使用 QEMU/KVM 提供的 virtio 半虚拟化硬件，PCI(e) 直通有如下优势：</p>
<ul>
<li>大大提升虚拟机与 PCI(e) 设备的 IO 性能（更低的延迟，更高的速度，更低的资源占用）。</li>
<li>可以利用上 QEMU/KVM 本身不支持的硬件特性，比如 PCI 直通最常见的使用场景——显卡直通。</li>
</ul>
<p>那么最常见的 PCI(e) 直通需求有：</p>
<ul>
<li><strong>显卡直通</strong>，实现在内部 windows 主机中用宿主机显卡看影视、玩游戏、剪视频</li>
<li><strong>硬盘或 USB 直通</strong>，以提升硬盘或 USB 的 IO 性能。</li>
</ul>
<p>首先列举下相关的文档：</p>
<ul>
<li><a href="https://pve.proxmox.com/wiki/PCI%28e%29_Passthrough" target="_blank" rel="noopener noreferrer">PCI(e) Passthrough - Proxmox WIKI</a>.</li>
<li><a href="https://pve.proxmox.com/wiki/Pci_passthrough#GPU_OVMF_PCI_Passthrough_.28recommended.29" target="_blank" rel="noopener noreferrer">GPU OVMF PCI Passthrough (recommended) - Proxmox WIKI</a></li>
<li><a href="https://wiki.archlinux.org/title/QEMU/Guest_graphics_acceleration" target="_blank" rel="noopener noreferrer">QEMU/Guest graphics acceleration - Arch WIKI</a></li>
</ul>
<p>TODO 实操内容待补充&hellip;</p>
<h2 id="拓展---cloudinit-高级配置" class="headerLink">
    <a href="#%e6%8b%93%e5%b1%95---cloudinit-%e9%ab%98%e7%ba%a7%e9%85%8d%e7%bd%ae" class="header-mark"></a>拓展 - cloudinit 高级配置</h2><p>PVE 使用 CDROM 只读盘(<code>/dev/sr0</code>)来进行 cloud-init 的配置。
在虚拟机启动后，<code>/dev/sr0</code> 将被卸载。</p>
<p>可挂载上该只读盘，查看其中的初始化配置内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ mkdir cloud-config
</span></span><span class="line"><span class="cl">$ mount /dev/sr0 cloud-config
</span></span><span class="line"><span class="cl">mount: /dev/sr0 is write-protected, mounting read-only
</span></span><span class="line"><span class="cl">$ ls cloud-config
</span></span><span class="line"><span class="cl">meta-data  network-config  user-data
</span></span></code></pre></td></tr></table>
</div>
</div><p>查看其中内容，会发现 <code>user-data</code> 有很多参数都被硬编码了，没有通过 PVE Web Console 暴露出来，导致我们无法自定义这些配置。</p>
<p>比如它硬编码了 <code>manage_etc_hosts: true</code>，强制每次都使用虚拟机的名称作为 hostname.</p>
<p>如果确认有修改这些配置的需求，完全可以修改掉 PVE 代码里的硬编码参数。
通过全文搜索即可找到硬编码参数的位置，以 <code>manage_etc_hosts</code> 为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 在 /usr/share 中全文搜索 manage_etc_hosts 这个关键字</span>
</span></span><span class="line"><span class="cl">grep -r manage_etc_hosts /usr/share
</span></span></code></pre></td></tr></table>
</div>
</div><p>直接就搜索到了硬编码位置是 <code>/usr/share/perl5/PVE/QemuServer/Cloudinit.pm</code>，修改对应的 cloudinit 配置模板，然后重启节点（重启才能重新加载对应的 ruby 程序），即可实现对该硬编码参数的修改。</p>
<h2 id="拓展---自动化配置与监控告警" class="headerLink">
    <a href="#%e6%8b%93%e5%b1%95---%e8%87%aa%e5%8a%a8%e5%8c%96%e9%85%8d%e7%bd%ae%e4%b8%8e%e7%9b%91%e6%8e%a7%e5%91%8a%e8%ad%a6" class="header-mark"></a>拓展 - 自动化配置与监控告警</h2><p>自动化配置相关工具：</p>
<ol>
<li><a href="https://github.com/Telmate/terraform-provider-proxmox/" target="_blank" rel="noopener noreferrer">Telmate/terraform-provider-proxmox</a>: 用户最多，但是只支持管理虚拟机资源</li>
<li><a href="https://github.com/danitso/terraform-provider-proxmox" target="_blank" rel="noopener noreferrer">danitso/terraform-provider-proxmox</a>: stars 少，但是可以管理 PVE 的大部分资源，包括节点、用户、资源池、TLS证书等等
<ul>
<li>代码更顺眼，但是作者忙，没时间合并 pr，导致 Bug 更多一些，而且很久没更新了&hellip;</li>
</ul>
</li>
<li><a href="https://github.com/ryan4yin/pulumi-proxmox" target="_blank" rel="noopener noreferrer">ryan4yin/pulumi-proxmox</a>: 我维护的一个 proxmox 自动配置工具（很久没更新了&hellip;）</li>
<li><a href="https://github.com/proxmoxer/proxmoxer" target="_blank" rel="noopener noreferrer">Python SDK</a></li>
</ol>
<p>监控告警：</p>
<ul>
<li><a href="https://github.com/prometheus-pve/prometheus-pve-exporter" target="_blank" rel="noopener noreferrer">prometheus pve expoter</a>: 通过 prometheus+grafana 监控 PVE 集群</li>
</ul>
<h2 id="拓展---pve-运行在-arm-开发版上" class="headerLink">
    <a href="#%e6%8b%93%e5%b1%95---pve-%e8%bf%90%e8%a1%8c%e5%9c%a8-arm-%e5%bc%80%e5%8f%91%e7%89%88%e4%b8%8a" class="header-mark"></a>拓展 - PVE 运行在 ARM 开发版上</h2><p>PVE 官方目前还未推出 ARM 支持，但是社区已有方案：</p>
<ul>
<li><a href="https://github.com/pimox/pimox7" target="_blank" rel="noopener noreferrer">pimox7</a></li>
<li><a href="https://foxi.buduanwang.vip/virtualization/pve/1902.html/" target="_blank" rel="noopener noreferrer">安装Arm版本的Proxmox VE - 佛西博客</a></li>
<li><a href="https://github.com/jiangcuo/Proxmox-Arm64" target="_blank" rel="noopener noreferrer">Proxmox-Arm64</a></li>
</ul>
<p>proxmox 社区比较活跃，建议多在社区内看看相关进展。</p>
<h2 id="拓展---其他-qemukvm-相关的虚拟化平台" class="headerLink">
    <a href="#%e6%8b%93%e5%b1%95---%e5%85%b6%e4%bb%96-qemukvm-%e7%9b%b8%e5%85%b3%e7%9a%84%e8%99%9a%e6%8b%9f%e5%8c%96%e5%b9%b3%e5%8f%b0" class="header-mark"></a>拓展 - 其他 QEMU/KVM 相关的虚拟化平台</h2><p>PVE 毕竟是一个商业系统，虽然目前可以免费用，但是以后就不一定了。</p>
<p>如果你担心 PVE 以后会不提供免费使用的功能，或者单纯想折腾折腾的技术，还可以试试下面这些虚拟化平台：</p>
<ul>
<li><a href="https://github.com/retspen/webvirtcloud" target="_blank" rel="noopener noreferrer">webvirtcloud</a>: 其前身是 webvirtmgr，一个完全开源的 QEMU/KVM Web UI，额外提供了用户管理功能。</li>
<li><a href="https://github.com/kubevirt/kubevirt" target="_blank" rel="noopener noreferrer">kubevirt</a>: 基于 Kubernetes 进行虚拟化管理</li>
<li><a href="https://github.com/rancher/harvester" target="_blank" rel="noopener noreferrer">rancher/harvester</a>: Rancher 开源的基于 Kubernetes 的超融合平台(HCI)
<ul>
<li>其底层使用 kubevirt 提供虚拟化能力，通过 longhorn 提供分布式存储能力。</li>
<li>HCI 超融合 = 计算虚拟化 + 网络虚拟化 + 分布式存储，它和传统的虚拟化软件最大的不同是：分布式存储。</li>
<li>企业级场景下一般至少得 10GbE 网络 + SSD 才能 hold 住 HCI 超融合架构。</li>
<li>超融合对存储的一些要求：
<ul>
<li>软件定义 – 解除硬件绑定，可通过升级拓展更丰富的功能，自动化能力高</li>
<li>全分布式架构 - 扩展性好，消除单点故障风险</li>
<li>高可靠性 - 智能的故障恢复功能，丰富的数据保护手段</li>
<li>高性能 – 支持多种存储介质，充分挖掘和利用新式硬件的性能</li>
<li>高度融合 – 架构简单并易于管理</li>
</ul>
</li>
<li>超融合架构可以降低私有云的构建与维护难度，让私有云的使用维护和公有云一样简单。</li>
<li>超融合架构下，虚拟机的计算和存储是完全高可用的：计算资源能智能动态更换，存储也是分布式存储，底层计算和存储也可以很简单的扩缩容。</li>
</ul>
</li>
</ul>
<p>我打算有时间在 PVE 集群里跑个 rancher/harvester 玩玩 emmmm</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/49118355" target="_blank" rel="noopener noreferrer">KVM 虚拟化环境搭建 - ProxmoxVE</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/49120559" target="_blank" rel="noopener noreferrer">KVM 虚拟化环境搭建 - WebVirtMgr</a></li>
<li><a href="https://pve.proxmox.com/wiki/Main_Page" target="_blank" rel="noopener noreferrer">Proxmox Virtual Environment - Proxmox WIKI</a></li>
<li><a href="https://wiki.archlinux.org/title/QEMU#top-page" target="_blank" rel="noopener noreferrer">QEMU - Arch Linux WIKI</a></li>
<li><a href="https://foxi.buduanwang.vip/category/virtualization/pve/" target="_blank" rel="noopener noreferrer">佛西博客 - PVE 相关</a>: 这位博主写了很多 pve 相关的内容，而且比较有深度</li>
</ul>
]]></content></entry><entry><title type="html">刻意练习</title><link href="https://thiscute.world/posts/deliberate-practice/"/><id>https://thiscute.world/posts/deliberate-practice/</id><author><name>ryan4yin</name></author><published>2022-10-05T13:31:00+08:00</published><updated>2022-10-05T13:31:00+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/deliberate-practice/deliberate-practice-achieve-mastery-in-anything.webp" height="1280" width="720"><figcaption></figcaption>
        </figure><p>我最近理解到一个事实——<strong>许多知识或者技能，都是可以通过正确的学习方法，加上短时间大量的练习，就能达到 60 分及格标准的</strong>。
而这个及格水平，相对于完全没有进行过这样训练的其他人而言，可能就已经很惊艳了。</p>
<p>如果你总是半途而废，可能只是你受了快餐式短期快乐的诱惑而放弃，或者你潜意识觉得它并不重要从而无法坚持。</p>
<h2 id="佐证之一---英语口语" class="headerLink">
    <a href="#%e4%bd%90%e8%af%81%e4%b9%8b%e4%b8%80---%e8%8b%b1%e8%af%ad%e5%8f%a3%e8%af%ad" class="header-mark"></a>佐证之一 - 英语口语</h2><p>受限于国内英语教育的方法，很多的同学朋友口语发音都比较糟糕。
但我实践发现，纠正自己的口语发音，达到到 60 分水平，并不是一件很难的事。
真正的问题在于，绝大多数人从没有去查过相关资料、并进行大量的练习。</p>
<p>我大三之前发音也惨不忍睹，然后因为个人兴趣与需求想把英语学好，就查了很多资料，跟着恶魔奶爸给出的英语口语学习方法，花了大概一个月的时间专门练了一波，效果立竿见影。</p>
<h2 id="佐证之二---练字" class="headerLink">
    <a href="#%e4%bd%90%e8%af%81%e4%b9%8b%e4%ba%8c---%e7%bb%83%e5%ad%97" class="header-mark"></a>佐证之二 - 练字</h2><p>我堂弟之前分享过他练字的经历给我。</p>
<p>他大学之前的字跟我一样丑不拉几。
大学期间因为无聊，就专门查了很多资料，定下了练字计划。
统共就练了两三个月，现在他写的字的美观程度，已经吊打我这个菜鸡。</p>
<h2 id="佐证之三---减肥" class="headerLink">
    <a href="#%e4%bd%90%e8%af%81%e4%b9%8b%e4%b8%89---%e5%87%8f%e8%82%a5" class="header-mark"></a>佐证之三 - 减肥</h2><p>我有一个同村的朋友，也是我小学同学。
他从初中开始就胖得不行，一直到结婚工作，体重都没减下来。</p>
<p>但是在去年因为婚姻变故以及一些其他原因，比较失意，突然就打算减肥，就开始坚持跑步。</p>
<p>跑多远忘了，可能慢慢加量到每天十公里吧。
他晚饭不吃，饿了就疯狂喝水。一开始因为体重太高，一趟下来膝关节直接跑到浮肿。</p>
<p>就这样坚持了大概三个月，直接瘦了 50 斤，整个人清爽帅气太多了。</p>
<h2 id="结语" class="headerLink">
    <a href="#%e7%bb%93%e8%af%ad" class="header-mark"></a>结语</h2><p>经常听人说要「<strong>踏出舒适区</strong>」、「<strong>延迟满足</strong>」，其实是一个道理。</p>
<p>即使掌握了正确的练习方法，如果因为坚持了三天发现没效果，就坚持不下去了，那无论如何都不会有好的效果。
可如果把这个时间放大十倍——三十天，视目标的难度，就会开始出现比较明显的效果了。</p>
<p>如果你对自己比较狠（高强度练习），再把坚持的时间再放大到三个月，你的技能水平就能获得相当显著的提升！就像我那位减肥的朋友、我练字的堂弟一样！</p>
<p>三个月的时间，对于学习一项技能而言，真的是很短的一段时间，但是却有能力使你入门一项终生受益的技能。
对未来的自己好一点，多投资投资自己，诸君共勉。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://www.youtube.com/watch?v=1-sjUoGO250" target="_blank" rel="noopener noreferrer">Deliberate Practice: Achieve Mastery in Anything - Youtube</a></li>
</ul>
]]></content></entry><entry><title type="html">Learn English Again</title><link href="https://thiscute.world/posts/learn-english-again/"/><id>https://thiscute.world/posts/learn-english-again/</id><author><name>ryan4yin</name></author><published>2022-09-04T13:22:00+08:00</published><updated>2022-09-04T13:22:00+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/learn-english-again/english-word.webp" height="626" width="313"><figcaption></figcaption>
        </figure><h3 id="一缘起与学习目标" class="headerLink">
    <a href="#%e4%b8%80%e7%bc%98%e8%b5%b7%e4%b8%8e%e5%ad%a6%e4%b9%a0%e7%9b%ae%e6%a0%87" class="header-mark"></a>一、缘起与学习目标</h3><p>工作了三年多了，我的英语阅读水平大致一直处在「能较流畅地阅读各类技术文档，但是阅读与理解速度不够快」的程度。
工作以来没有专门去学过英语，不过会有意识地尽量去阅读英文技术文档、英文技术书籍，或者在 Youtube 上找一些国际技术会议视频学习（如 KubeCon、IstioCon），所以这三年多我的英语水平提升应该是有一个缓慢的提升。</p>
<p>这周五的时候（是的就是 2022-09-02），偶然发现自己手机里还装了个英语流利说 APP，安装了两年多但一直没碰过它 emmmm 突然来了兴趣就打算试用一波，由此开始了我的重学英语之旅&hellip;</p>
<p>首先肯定是要测试一下自己的英文水平，确定英语学习的起点。流利说 APP 把英语分成 7 个 Level，它评价我属于 Lv.5，大致对应 CEFR 评级 B2。五个评级维度中我的发音是最好的，口语是最差的。而词汇量大概在 5000 这个档位（我觉得如果算上我懂的计算机名词可能会更高些 emmmm）。</p>
<p>测出的结果跟我的自我感觉基本吻合。
之前有跟 AWS 工程师做过几次英语沟通，发现我的口语勉强可以支撑日常技术沟通，但是感觉很费劲，原因显然是口语基本没怎么练过。
而我的发音之所以还不错，主要是大三的时候专门跟着奶爸推荐的《赖世雄美语音标》、《American Spoken English》等资料练习过，我当时还写过篇文章讲这个——<a href="https://thiscute.world/posts/learning-english/" target="_blank" rel="noopener noreferrer">学英语啊学英语</a>。</p>
<p>先不提细节，总之我就是这么着，突然对学英语又来了兴趣~ 当天就深入探索了下英语流利说这个 APP，又花 49 元买了一个月的「懂你英语 A+ 个性化学习计划」，这个计划还给分配微信学习社群跟班主任，每天坚持 30 到 60 分钟。第一天体验这个学习计划，感觉确实跟我比较契合，而且也不枯燥，打算坚持一个月试试。</p>
<p>最后，为了更有目的性地提升自己的英语，我总结了下我此次「重学英语」的目的，以及当前的水平（按优先级排序）：</p>
<ul>
<li><strong>能流畅地用英语交流</strong>：流利说测试显示我这项技能很差，亟待提升。</li>
<li><strong>流畅阅读各类英文资料</strong>：我目前可以无障碍阅读大多数编程相关的英文博客跟文档，但是阅读速度不够快，有些长句经常要读好几次才能理解大意。另外词汇量偏低，非技术类的资料我读起来非常吃力。</li>
<li><strong>无障碍看美剧</strong>：我的听力水平跟词汇水平大概差不多，看美剧还是得有个英文字幕，还需要提升。</li>
<li><strong>写英文博客</strong>：高中毕业后就没学过语法，也没怎么练过写作，词汇量又低，我的写作能力显然还有很大的提升空间。</li>
</ul>
<h3 id="二英语自学路线完全指南" class="headerLink">
    <a href="#%e4%ba%8c%e8%8b%b1%e8%af%ad%e8%87%aa%e5%ad%a6%e8%b7%af%e7%ba%bf%e5%ae%8c%e5%85%a8%e6%8c%87%e5%8d%97" class="header-mark"></a>二、英语自学路线完全指南</h3><p>因为最近对英语来了电，就打算深入了解下市面上常见的英语学习路径，争取找到最佳学习路线。</p>
<h4 id="1-不花钱的自学路线" class="headerLink">
    <a href="#1-%e4%b8%8d%e8%8a%b1%e9%92%b1%e7%9a%84%e8%87%aa%e5%ad%a6%e8%b7%af%e7%ba%bf" class="header-mark"></a>1. 不花钱的自学路线</h4><p>首先是不花钱的自学路线，这个我在大三时有过实践，当时打算考研，专门练过一波英语，大致路线是这样的：</p>
<ul>
<li>恶魔奶爸总结的 <a href="https://zhuanlan.zhihu.com/p/20836532" target="_blank" rel="noopener noreferrer"><strong>练习英语口语的办法</strong></a>，本人实测效果显著
<ul>
<li>其中介绍的 ESLPod、EnglishPod 等材料，不仅可以提升语感，也能帮助提升听力。</li>
</ul>
</li>
<li>如果是进阶的话，可以<strong>去 Youtube 上看一些流行的 Talk Show</strong>，这类视频很有意思、语速快信息量又大，是很合适的进阶学习材料
<ul>
<li>以看视频的方式学英语，一个要点就是「<strong>重复</strong>」或者说「<strong>精听</strong>」。</li>
<li>「一点英语」就是在这上面下了不少功夫，要选那种第一遍听有难度的视频，最好内容还比较有趣（比如 Talk Show 就比较有意思）。</li>
<li>可行的学习方法：第一遍带字幕看视频，但是尽量别看字幕；第二遍带字幕反复精看听不懂的部分，第三遍再完全关掉字幕验证学习效果。</li>
</ul>
</li>
<li>还有就是很多人推荐的<strong>阅读英文原版书</strong>
<ul>
<li>一开始可能会读得很慢，这个时候最重要的就是坚持！阅读量上来了，速度自然就提升了。</li>
<li>让自己更容易坚持的阅读方法：
<ul>
<li>要找一些<strong>你感兴趣的</strong>、难度适中的原版书（比如感兴趣的小说、专业相关的技术书等）。因为阅读的首要点是要能感受到乐趣，否则会很枯燥，很难坚持。</li>
<li>然后<strong>要做好规划并坚持执行</strong>，比如每天读 10 页。</li>
</ul>
</li>
</ul>
</li>
<li>当然你也可以走传统的背单词、词组、例句这样的路线，这条路线的好处是能快速提升自己的英语能力，但是相对的也很难坚持。
<ul>
<li>常见的有新东方的词汇录播课（网上能找到免费的资料分享），以前听过新东方朱伟老师的《恋练有词》，感觉挺不错的。</li>
<li>不背单词、百词斩这类 APP 也可以试试，不过我个人体验是基本坚持不了多久&hellip;</li>
</ul>
</li>
<li><strong>每日英语听力</strong>
<ul>
<li>跟欧路词典是同一家公司做的，很良心。</li>
<li>不过因为我已经买了其他课程了，这个 APP 目前用得比较少。</li>
</ul>
</li>
<li><a href="https://www.bilibili.com/video/BV1U7411a7xG/" target="_blank" rel="noopener noreferrer">每日英语听写 Daily English Dictation 1-400</a>
<ul>
<li>这是 Youtube 上相当火的一个英语听写系列视频，做得非常棒，坚持听完 400 期，听力就神功大成了！</li>
<li>个人感觉起码得有个 CET4 水平，才能比较舒服地跟这个课程。</li>
</ul>
</li>
<li>一些对话、角色设定、世界观设定较多的游戏也是学英语的好材料，比如「Genshin Imapct」、「DEEMO 2」，或者一些 Galgame 都可。娱乐跟英语两不误 emmm</li>
</ul>
<p><figure><a class="lightgallery" href="/images/learn-english-again/genshin-impact-noelle.webp" title="/images/learn-english-again/genshin-impact-noelle.webp" data-thumbnail="/images/learn-english-again/genshin-impact-noelle.webp" data-sub-html="<h2>Genshin Impact 里超飒的重剑女仆 Noelle</h2>">
        <img
            
            loading="lazy"
            src="/images/learn-english-again/genshin-impact-noelle.webp"
            srcset="/images/learn-english-again/genshin-impact-noelle.webp, /images/learn-english-again/genshin-impact-noelle.webp 1.5x, /images/learn-english-again/genshin-impact-noelle.webp 2x"
            sizes="auto"
            alt="/images/learn-english-again/genshin-impact-noelle.webp">
    </a><figcaption class="image-caption">Genshin Impact 里超飒的重剑女仆 Noelle</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="/images/learn-english-again/demo2-talk-1.webp" title="/images/learn-english-again/demo2-talk-1.webp" data-thumbnail="/images/learn-english-again/demo2-talk-1.webp" data-sub-html="<h2>DEEMO 2 中丰富的对话内容</h2>">
        <img
            
            loading="lazy"
            src="/images/learn-english-again/demo2-talk-1.webp"
            srcset="/images/learn-english-again/demo2-talk-1.webp, /images/learn-english-again/demo2-talk-1.webp 1.5x, /images/learn-english-again/demo2-talk-1.webp 2x"
            sizes="auto"
            alt="/images/learn-english-again/demo2-talk-1.webp">
    </a><figcaption class="image-caption">DEEMO 2 中丰富的对话内容</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="/images/learn-english-again/demo2-collections.webp" title="/images/learn-english-again/demo2-collections.webp" data-thumbnail="/images/learn-english-again/demo2-collections.webp" data-sub-html="<h2>DEEMO 2 的一些设定</h2>">
        <img
            
            loading="lazy"
            src="/images/learn-english-again/demo2-collections.webp"
            srcset="/images/learn-english-again/demo2-collections.webp, /images/learn-english-again/demo2-collections.webp 1.5x, /images/learn-english-again/demo2-collections.webp 2x"
            sizes="auto"
            alt="/images/learn-english-again/demo2-collections.webp">
    </a><figcaption class="image-caption">DEEMO 2 的一些设定</figcaption>
    </figure></p>
<p>上面主要是针对 CET4 四级以上水平的英语学习者，如果基础比较差，可以考虑按照恶魔奶爸推荐的零基础英语学习路线进行自学：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/19768351" target="_blank" rel="noopener noreferrer">英语：壹章 - 恶魔奶爸</a>：针对零基础/基础超级不好的同学</li>
<li><a href="https://zhuanlan.zhihu.com/p/19768409" target="_blank" rel="noopener noreferrer">英语：贰章 - 恶魔奶爸</a>：针对处于英语初级阶段的同学</li>
<li><a href="https://zhuanlan.zhihu.com/p/19768454" target="_blank" rel="noopener noreferrer">英语：叁章 - 恶魔奶爸</a>：针对大学四六级水平的同学（就跟我上面列的差不多了）</li>
</ul>
<h4 id="2-花钱抄捷径" class="headerLink">
    <a href="#2-%e8%8a%b1%e9%92%b1%e6%8a%84%e6%8d%b7%e5%be%84" class="header-mark"></a>2. 花钱抄捷径</h4><p>而对于我这种上班族或者其他有闲钱的学生，而且不求快速提升英语能力的人而言，如果愿意花点小钱，也是有捷径可以抄的。</p>
<p>首先就是线下课程跟线上视频课程（比如新东方、山姆英语），这个没时间参加，时间安排也不够灵活，而且可能会比较枯燥，直接 Pass.</p>
<p>其次就是英语学习类 APP 了，这个市面上还有挺多的，我试用了一波后感觉很适合我，并且筛选出了下面几个比较中意的 APP：<strong>欧路词典</strong>、<strong>知米阅读</strong>、<strong>开言英语</strong>以及<strong>一点英语</strong>。</p>
<p>并且使用上述几款软件提供的英语能力测试，完整评估了下我的英语水平。下图从左至右依次是一点英语、开言英语，以及英语流利说的整体英语水平跟口语水平两项测试结果（结果偏高，仅供参考）：</p>
<p><figure><a class="lightgallery" href="/images/now/ryan4yin-english-level.webp" title="/images/now/ryan4yin-english-level.webp" data-thumbnail="/images/now/ryan4yin-english-level.webp" data-sub-html="<h2>各 APP 的英语水平测评结果（一点英语的结果明显偏高）</h2>">
        <img
            
            loading="lazy"
            src="/images/now/ryan4yin-english-level.webp"
            srcset="/images/now/ryan4yin-english-level.webp, /images/now/ryan4yin-english-level.webp 1.5x, /images/now/ryan4yin-english-level.webp 2x"
            sizes="auto"
            alt="/images/now/ryan4yin-english-level.webp">
    </a><figcaption class="image-caption">各 APP 的英语水平测评结果（一点英语的结果明显偏高）</figcaption>
    </figure></p>
<p><figure><a class="lightgallery" href="/images/learn-english-again/%e6%b5%81%e5%88%a9%e8%af%b4-English-Level.webp" title="/images/learn-english-again/流利说-English-Level.webp" data-thumbnail="/images/learn-english-again/流利说-English-Level.webp" data-sub-html="<h2>流利说英语评级对照表</h2>">
        <img
            
            loading="lazy"
            src="/images/learn-english-again/%e6%b5%81%e5%88%a9%e8%af%b4-English-Level.webp"
            srcset="/images/learn-english-again/%e6%b5%81%e5%88%a9%e8%af%b4-English-Level.webp, /images/learn-english-again/%e6%b5%81%e5%88%a9%e8%af%b4-English-Level.webp 1.5x, /images/learn-english-again/%e6%b5%81%e5%88%a9%e8%af%b4-English-Level.webp 2x"
            sizes="auto"
            alt="/images/learn-english-again/流利说-English-Level.webp">
    </a><figcaption class="image-caption">流利说英语评级对照表</figcaption>
    </figure></p>
<p>下面详细介绍下我比较推荐的英语学习类 APP 跟课程：</p>
<ul>
<li><strong>欧路词典</strong>
<ul>
<li>最牛逼的词典软件，非常适合用于日常查词。</li>
<li>最强的一点在于它能导入各种离线词典，<a href="https://site.douban.com/195274/widget/notes/12076215/note/265205135/" target="_blank" rel="noopener noreferrer">详见恶魔奶爸有分享的词典文章</a>，我用到的有如下几本：
<ul>
<li>中英双解词典
<ul>
<li><strong>柯林斯双解 Collins Cobuild Advanced Learner&rsquo;s English Dictionary</strong>：包含中文翻译、英英释义跟句子示例，还提供 1-5 的单词使用频率标识</li>
<li><strong>Microsoft Bing Dictionary</strong>：是网友抓取制作的必应大词典，跟 Collins Cobuild 类似，包含级别（CET4/CET6/GRE）、中文翻译、英英释义跟句子翻译</li>
</ul>
</li>
<li>英英词典
<ul>
<li><strong>LDOCE朗文当代5 英英版</strong>: 光体积就 1G，包含了所有单词例句的录音，是非常详尽的一本英英学习词典。收词量相当大，短语、用法完备</li>
</ul>
</li>
<li>词组搭配、同义词词典
<ul>
<li>牛津搭配词典第二版</li>
<li>Collins Thesaurus</li>
<li>Collins COBUILD English Usage</li>
<li>WordNet 3.0</li>
<li><strong>USE THE RIGHT WORD</strong>: 同义近义词用法解释，很详细</li>
<li>Merriam-Webster&rsquo;s Vocabulary Builder: 通过词根词缀来关联起各种相关单词</li>
<li>英语常用词疑难用法手册</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>薄荷阅读</strong>：199 元 / 100 天
<ul>
<li><strong>阅读原版书学习英语</strong></li>
<li>用它辅助阅读原版书的好处有：
<ul>
<li>会提前帮你选出生词进行预习</li>
<li>提供配套的有声书，可以听书也可以看书</li>
<li>随时双击查词，查词非常方便</li>
<li>学习完成后还有提供配套的讲义，对各项单词、词组、疑难句进行详细解释，这个感觉会非常有用！</li>
</ul>
</li>
<li>缺点
<ul>
<li>每逢购物活动就开始打广告，让人有点烦。</li>
<li>相比后面的竞品，价格有点太高了&hellip;</li>
</ul>
</li>
</ul>
</li>
<li><strong>知米阅读</strong>：199 元，365 天畅读所有书单
<ul>
<li><strong>阅读原版书学习英语</strong></li>
<li>跟薄荷阅读几乎一样的模式，功能大同小异。
<ul>
<li>但是它的年费会员仅为薄荷阅读 VIP 的 1/5，而且还能畅读所有书单！</li>
</ul>
</li>
<li>个人感觉它的小程序设计感比薄荷阅读更好</li>
</ul>
</li>
<li><strong>一点英语</strong>：
<ul>
<li>折后 1998 元 270 天</li>
<li>如果坚持打卡 270 天，期末还返 1000 现金 + 500 续课券（实测大半年下来意外太多，基本不可能拿到、但是万一就成功了呢&hellip;）</li>
<li><strong>通过「演讲/动漫/喜剧/音乐现场」等各种视频内容学习英语单词，同时练习听力跟口语</strong></li>
<li>相比其他 APP，它的课程<strong>会有趣很多，不那么枯燥</strong>。我觉得用它练习听力非常合适。</li>
<li>缺陷：
<ul>
<li>它的视频语料有部分跟单词有点对不上，有时候会遇上，不过无伤大雅。</li>
<li>它背单词的功能跟「不背单词」或者「欧路词典」差距较大。其中英解释比较简陋、记忆算法强度没不背单词高，也没有词根词缀功能，此外例句偶尔会有些错误。</li>
</ul>
</li>
</ul>
</li>
<li><strong>开言英语</strong>
<ul>
<li><strong>通过外教录制的视频 + 程序控制实现了一定的可交互性</strong>，感觉课程比英语流利说做得要有趣些。</li>
<li><strong>开言英语的 WeMeet 英语角体验真的超棒</strong>，而且还免费！
<ul>
<li>第一次参加时，一起聊天的两位朋友，一位在万豪酒店工作了差不多 10 年，另一位是产品经理，在腾讯、搜狐、美团等公司工作了差不多 15 年，聊得非常开心，很有收获！</li>
</ul>
</li>
<li>价格
<ul>
<li>外教系统课是 2598 一年，提供海量外教视频互动课跟音频课</li>
<li>还有个外教视频课，互动性会更高，价格是 1598 一年</li>
</ul>
</li>
<li>《潘吉 Jenny 告诉你》这个口碑在，我觉得开言英语的外教课程是可以考虑的</li>
</ul>
</li>
<li><a href="https://www.koolearn.com" target="_blank" rel="noopener noreferrer"><strong>新东方在线</strong></a>
<ul>
<li>在线录播课、直播课，从以前学过的考研英语看，还是很专业、很成体系的。</li>
<li>对 BEC、雅思、托福都有对应的课程可选，价格对工作党而言问题不大。</li>
</ul>
</li>
<li><strong>VoiceTube</strong>：价格还不太清楚
<ul>
<li>应该是最早做「看视频学英语」功能的 APP 之一，它最初发布于 2013/09，而前面介绍的「一点英语」最初发布于 2018 年（而且 UI 布局也跟 VoiceTube 很类似）。</li>
<li>获得了 Facebook 2016 年年度最佳 APP 奖项</li>
<li>但是（因为版权原因）它基本都是直接内嵌的 Youtube 视频，它需要同时安装 Youtube（同时还需要一些使你能访问 Youtube 的特殊手段）。</li>
</ul>
</li>
</ul>
<p>另外一些我用过但是不推荐的 APP 也简单说下问题所在：</p>
<ul>
<li>英语流利说 懂你英语 A+
<ul>
<li>课程质量确实不错，但是<strong>全都是 AI 语音，虽然很标准，但是太机械了，不带啥感情</strong>，我学了才 6 天就开始厌倦了。个人不推荐选它</li>
</ul>
</li>
<li>百词斩
<ul>
<li>更适合用于趣味性背单词</li>
</ul>
</li>
</ul>
<blockquote>
<p>对很多学生党（比如大学期间的我）而言这些 APP 一年下来好几千的费用确实是难以承担，但是对我这样的工作党而言，不失为一个很好的学习手段。</p>
</blockquote>
<p>上述这些软件最大的优势是「互动」，这会使它比单纯自学有趣很多，更容易坚持。</p>
<p>除薄荷英语外，其他三个 APP 都有提供长短不一的会员体验时间，有兴趣的话可以自己试用下~</p>
<p>总结下，目前已买课程：</p>
<ul>
<li>「<strong>知米阅读</strong>」199 元，365 天畅读所有书单。看的第一本书是「Time Machine」。阅读体验很不错，而且比薄荷阅读便宜太多了。</li>
<li>「<strong>一点英语</strong>」看视频/听歌学英语真的非常棒！已经花 1998 元买了 270 天的会员
<ul>
<li><del>争取每天打卡，赚到 1000 现金返还</del>目前（2022-11-07）进度是 62 天，已经漏打卡 5 天&hellip;部分原因是漏打卡第一天后，争取每天打卡的执念就没那么强烈了，偶尔哪一天太累了或者别的事没搞完，就直接不打卡了&hellip;</li>
</ul>
</li>
<li>「薄荷英语」花了 199 元买了《一个人的朝圣》这个原版书，书已经看完了。内容不错，就是跟知米阅读比太贵了。</li>
<li>「英语流利说」花了 49 元，买了个 30 天的懂你英语 A+ 体验课，但是因为前述原因（AI 语音太死板，听多了烦）就用了一周就没继续用了。</li>
</ul>
<h2 id="三如何练习英语口语" class="headerLink">
    <a href="#%e4%b8%89%e5%a6%82%e4%bd%95%e7%bb%83%e4%b9%a0%e8%8b%b1%e8%af%ad%e5%8f%a3%e8%af%ad" class="header-mark"></a>三、如何练习英语口语？</h2><p>首先，上面已经提过了，「开言英语」的线上英语角 WeMeet 非常的棒。这个功能是免费的，但是需要交 5 块钱押金，我觉得这 5 块钱的押金大大提升了这个英语角的队友质量，能确保大家都是有强烈意愿去用英语聊天的。
实际的体验也非常棒，不仅能练习口语，还能交到各行各业喜欢英语的朋友。</p>
<p>其次，如果你的上网工具能使你用上 Discord，也有一些英语学习的 Discord Server 非常值得推荐，你能在上面跟各种母语、各个国家、各种口音的朋友一起用英语聊天，体验还不错，还能交到有意思的国外朋友。</p>
<p>英语学习 Discord Server 地址:</p>
<ul>
<li><a href="https://discord.gg/english" target="_blank" rel="noopener noreferrer">https://discord.gg/english</a></li>
<li><a href="https://discord.gg/c-e" target="_blank" rel="noopener noreferrer">https://discord.gg/c-e</a></li>
</ul>
<p>加入 Server 后要往下翻很多页才能到 English Practice 部分，目前分别有 8 个「Beginner English」聊天室跟 8 个「Intermeidate/Advanced English」聊天室，赶快加入开聊吧~</p>
<p>此外，如果你想走高效的氪金路线，也有很多<strong>线上真人上外教</strong>平台供你选择，主要有如下几个：</p>
<ul>
<li><a href="https://www.lingoda.com/en/" target="_blank" rel="noopener noreferrer">Lingoda</a>: 被认为是最佳成人英语学习平台之一，它有部分课还提供了学费返还机制，可以了解下。</li>
<li><a href="https://www.cambly.com/english" target="_blank" rel="noopener noreferrer">Cambly</a>: twitter 上推友推荐的，最流行的英语学习平台之一，真人外教一对一教学
<ul>
<li>据说打折时很便宜，优惠价只要人民币 30 元 30 分钟</li>
</ul>
</li>
<li><a href="https://preply.com/en/online/english-tutors" target="_blank" rel="noopener noreferrer">Preply</a>: 我用的词汇测试站点，现在就属于这家公司的产品。据说比较专业，提供 4-5 人小组教学跟一对一教学两种学习模式
<ul>
<li>貌似比较贵：$15-20 per hour</li>
<li>你还可以在这个站点上面应聘汉语教学（有 20%-30% 的抽成，150 美刀才能提现）</li>
</ul>
</li>
<li><a href="https://www.verbling.com/zh" target="_blank" rel="noopener noreferrer">Verbling</a>: 一样也是一个老牌语言学习站点
<ul>
<li>据说价格比较优惠，还支持免费试课。</li>
<li>跟 Preply 一样你也可以在这个站点上面应聘汉语教学作为兼职。</li>
</ul>
</li>
<li><a href="https://www.italki.com/en" target="_blank" rel="noopener noreferrer">ITalk</a>: 国内创办的比较大的语言交换平台，据说是最 casual 的学习平台，所以不太适合自我驱动力不强的朋友。</li>
</ul>
<h2 id="四总而言之" class="headerLink">
    <a href="#%e5%9b%9b%e6%80%bb%e8%80%8c%e8%a8%80%e4%b9%8b" class="header-mark"></a>四、总而言之</h2><p>嗯，毕竟是花了钱的，这次的大目标就是用近一年的时间，全面提升英语水平。</p>
<p>听说考 BEC 高级对英语水平提升帮助很大，为了提供一点压力与动力，就定一个硬性目标：</p>
<ul>
<li>2023 年达到 CEFR 的 C1 等级，报考并取得 BEC 高级证书</li>
<li>2023 年底词汇量超过 10000</li>
</ul>
<h2 id="其他资料" class="headerLink">
    <a href="#%e5%85%b6%e4%bb%96%e8%b5%84%e6%96%99" class="header-mark"></a>其他资料</h2><p>文末再分享几篇我收藏的英语学习相关的资料，个人感觉读了有些帮助：</p>
<ul>
<li><a href="https://www.zhihu.com/question/35779181/answer/64441076" target="_blank" rel="noopener noreferrer">编程的技术资料好多都是全英文的该怎么学习？</a>
<ul>
<li>关键点总结：你要能接受自己不能 100% 看懂资料</li>
</ul>
</li>
<li><a href="https://www.zhihu.com/question/20364185/answer/68330933" target="_blank" rel="noopener noreferrer">如何做到流畅阅读英文资料和听懂国外公开课？</a>
<ul>
<li>提升阅读速度过程中<strong>一个最基本的因素就是阅读量</strong>，跳出舒适区，刻意练习。</li>
</ul>
</li>
<li><a href="https://www.zhihu.com/question/20727479/answer/57511389" target="_blank" rel="noopener noreferrer">如何有效提高英语写作？</a>
<ul>
<li>关键点总结：提高英文写作水平的第一步是「大量阅读」</li>
</ul>
</li>
<li><a href="https://www.zhihu.com/question/26757493/answer/33915992" target="_blank" rel="noopener noreferrer">YouTube 上有哪些质量不错的英文教学视频和英文视频？</a>
<ul>
<li>这些视频很多都能在 Bilibili 上搜到</li>
</ul>
</li>
<li><a href="https://www.zhihu.com/question/20189363/answer/29690361" target="_blank" rel="noopener noreferrer">通过「听写」学习英语，效果怎么样？</a></li>
<li><a href="https://www.zhihu.com/question/25379922/answer/30602611" target="_blank" rel="noopener noreferrer">英语学习过程中如何有效地提升词汇功底？</a>
<ul>
<li>关键点总结：学习一门语言文字的最短最佳途径，是掌握它的词根（root），也就是那些其他单词借以形成的原生词</li>
</ul>
</li>
<li><a href="https://www.zhihu.com/topic/19558435/top-answers" target="_blank" rel="noopener noreferrer">知乎「英语学习」话题下的精华回答</a></li>
</ul>
<hr>
<h2 id="学习成果记录---持续更新" class="headerLink">
    <a href="#%e5%ad%a6%e4%b9%a0%e6%88%90%e6%9e%9c%e8%ae%b0%e5%bd%95---%e6%8c%81%e7%bb%ad%e6%9b%b4%e6%96%b0" class="header-mark"></a>学习成果记录 - 持续更新</h2><p>先简单记录下学习时间线：</p>
<ul>
<li>2022/9 - 2022/12
<ul>
<li>平均每天大概花 30 分钟学习英语（偶尔兴之所至可能会花 1 小时甚至更多，也偶尔会断几天）。</li>
<li>主要学习方法就是通过「薄荷阅读」「知米阅读」读英文原版书，以及通过「<strong>一点英语</strong>」看视频练听力、记单词。</li>
</ul>
</li>
<li>2023/1: 基本算是休息了一个月，没怎么学。</li>
<li>未完待续</li>
</ul>
<h3 id="1-词汇量" class="headerLink">
    <a href="#1-%e8%af%8d%e6%b1%87%e9%87%8f" class="header-mark"></a>1. 词汇量</h3><p>词汇量测试结果按时间排序如下，使用的测试工具是 <a href="https://preply.com/en/learn/english/test-your-vocab" target="_blank" rel="noopener noreferrer">Test Your Vocabulary</a> ：</p>
<ul>
<li>2022 年 9 月初，测试结果：4700 词（无截图）</li>
<li>2022-10-18 词汇量测试结果：5100 词 <figure><img src="/images/learn-english-again/2022-10-18-test-your-vocabulary-result.webp" width="40%"/><figcaption>
            <h4>2022-10-18 词汇量测试结果：5100 词</h4>
        </figcaption>
</figure>
</li>
<li>2022-11-17 词汇量测试结果：5600 词 <figure><img src="/images/learn-english-again/2022-11-17-test-your-vocabulary-result.webp" width="65%"/>
</figure>
</li>
<li>2022-12-19 词汇量测试结果： 6300 词 <figure><img src="/images/now/2022-12-19-test-your-vocabulary-result.webp" width="40%"/>
</figure>
</li>
<li>2023-01-02 词汇量测试结果：6583 词 <figure><img src="/images/now/2023-01-02-test-your-vocabulary-result.webp" width="70%"/>
</figure>
</li>
<li>2023 年 1 月份暂停了学习，词汇量基本没涨，算是休息了一个月。</li>
</ul>
<h3 id="2-口语交流能力" class="headerLink">
    <a href="#2-%e5%8f%a3%e8%af%ad%e4%ba%a4%e6%b5%81%e8%83%bd%e5%8a%9b" class="header-mark"></a>2. 口语交流能力</h3><p>2022 年只是参与了两次「开言英语」的线上英语角 WeMeet，另外探索了下学习方法，但是时间原因未持续推进。</p>
<p>计划在 2023 年进行专门练习，未完待续&hellip;</p>
<h3 id="3-其他进展" class="headerLink">
    <a href="#3-%e5%85%b6%e4%bb%96%e8%bf%9b%e5%b1%95" class="header-mark"></a>3. 其他进展</h3><ul>
<li>写作能力
<ul>
<li>计划在 2023 年进行专门练习，未完待续&hellip;</li>
</ul>
</li>
<li>阅读能力
<ul>
<li>2022 年的 4 个月里，阅读是我提升词汇量的主要手段之一，看统计读了有 15 万词，词汇量跟阅读速度都有明显提升。</li>
<li><figure><img src="/images/now/mintreading-first-100days-achivement.webp" width="35%"/><figcaption>
            <h4>在薄荷阅读上读完的第一本英语原版书</h4>
        </figcaption>
</figure>
</li>
</ul>
</li>
</ul>
]]></content></entry><entry><title type="html">分布式数据库的一致性问题与共识算法</title><link href="https://thiscute.world/posts/consistency-and-consensus-algorithm/"/><id>https://thiscute.world/posts/consistency-and-consensus-algorithm/</id><author><name>ryan4yin</name></author><published>2022-08-07T04:11:23+08:00</published><updated>2022-08-07T04:11:23+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/consistency-and-consensus-algorithm/featured-image.webp" height="974" width="312"><figcaption></figcaption>
        </figure><blockquote>
<p>个人笔记，不保证正确！</p>
</blockquote>
<p>谈到分布式数据库，不论是 Etcd/Zookeeper 这样的中心化数据库，还是 Ethereum 区块链这样的去中心化数据库，都避免不了两个关键词：「<strong>一致性</strong>」跟「<strong>共识</strong>」。</p>
<p>本文是笔者学习「<strong>一致性</strong>」和「<strong>共识</strong>」以及相关的理论知识时记录的笔记，这些知识能帮助我们了解 Etcd/Zookeeper/Consul/MySQL/PostgreSQL/DynamoDB/Cassandra/MongoDB/CockroachDB/TiDB 等一众数据库的区别，理解各数据库的优势与局限性，搞懂数据库隔离级别的含义以及应该如何设置，并使我们能在各种应用场景中选择出适用的数据库。</p>
<p>如果你对区块链感兴趣，那这篇文章也能帮助你了解区块链这样的去中心化数据库，跟业界流行的分布式数据库在技术上有何区别，又有哪些共同点，具体是如何实现。</p>
<h2 id="一一致性---consistency" class="headerLink">
    <a href="#%e4%b8%80%e4%b8%80%e8%87%b4%e6%80%a7---consistency" class="header-mark"></a>一、一致性 - Consistency</h2><p>「一致性」本身是一个比较模糊的定义，视使用场景的不同，存在许多不同的含义。
由于数据库仍然是一个新兴领域，目前存在许多不同的一致性模型，其中的一些术语描述的一致性之间可能还有重叠关系，这些关系甚至会困扰专业的数据库开发人员。</p>
<p>但是究其根本，实际上在谈论一致性时，我们是在谈论<strong>事务一致性</strong>跟<strong>数据一致性</strong>，下面我们分别介绍下这两个一致性。</p>
<h3 id="1-事务一致性---transactions-consistency" class="headerLink">
    <a href="#1-%e4%ba%8b%e5%8a%a1%e4%b8%80%e8%87%b4%e6%80%a7---transactions-consistency" class="header-mark"></a>1. 事务一致性 - Transactions Consistency</h3><p>「事务一致性」指的是数据库中事务的一致性，它是 ACID 理论中最不起眼的特性，也并不是本文的重点。
但是这里就写这么一句话也说不过去，所以下面就仔细介绍下事务与 ACID 理论。</p>
<h4 id="事务与-acid-理论" class="headerLink">
    <a href="#%e4%ba%8b%e5%8a%a1%e4%b8%8e-acid-%e7%90%86%e8%ae%ba" class="header-mark"></a>事务与 ACID 理论</h4><p>事务是一种「要么全部完成，要么完全不做（All or Nothing）」的指令运行机制。</p>
<p><strong>ACID 理论</strong>定义，拥有如下四个特性的「数据库指令序列」，就被称为事务：</p>
<ul>
<li><strong>原子性 Atomicity</strong>：事务是一个不可分割的工作单元，事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在某个中间状态。
<ul>
<li>比如 A 转账 100 元给 B，要么转账失败，要么转账成功，不可能卡在 A 被扣除了 100 元，而 B 还没收到 100 元的中间状态。</li>
<li>原子性在单机数据库上已得到妥善解决，但是在分布式数据库上它成为一项新的挑战。要在分布式架构下支持原子性并不容易，所以不少 NoSQL 产品都选择绕过这个问题，聚焦到那些对原子性不敏感的细分场景。</li>
</ul>
</li>
<li><strong>一致性 Consistency</strong>：也叫数据的「<strong>正确性 Correctness</strong>」或者完整性，指事务对数据库状态的变更必须满足所有预定义的规则，包括「约束 constraints」、「级联 cascades」、「触发器 triggers」以及这些规则的任何组合。
<ul>
<li>比如如果用户为某个字段设置了约束条件 <code>unique</code>，那么事务对该表的所有修改都必须保证此约束成立，否则它将会失败。</li>
<li>是存在感最低的特性</li>
</ul>
</li>
<li><strong>隔离性 Isolation</strong>：<strong>并发执行的多个事务之间是完全隔离的</strong>，它们的执行效果跟按事务的开始顺序串行执行完全一致。
<ul>
<li>事务中最复杂的特性</li>
</ul>
</li>
<li><strong>持久性 Durability</strong>：事务执行完毕后，结果就保存不变了。这个最好理解。</li>
</ul>
<p>ACID 是传统的单机数据库的核心特性，比如 MySQL/PostgreSQL.</p>
<h4 id="acid-中最复杂的特性---隔离性" class="headerLink">
    <a href="#acid-%e4%b8%ad%e6%9c%80%e5%a4%8d%e6%9d%82%e7%9a%84%e7%89%b9%e6%80%a7---%e9%9a%94%e7%a6%bb%e6%80%a7" class="header-mark"></a>ACID 中最复杂的特性 - 隔离性</h4><p>完全地实现 ACID 得到的数据库，性能是非常差的。
因此在关系数据库中，设计者通常会选择牺牲相对不重要的「隔离性」来获取更好的性能。</p>
<p>而一旦隔离不够彻底，就可能会遇到一些事务之间互相影响的异常情况，这些异常被分为如下几种：</p>
<ul>
<li><strong>脏写 Dirty writes</strong>：即事务 T1 跟事务 T2 同时在原数据的基础上更新同一个数据，导致结果不符合预期。
<ul>
<li>案例：两个事务同时尝试从账户中扣款 1000 元，但是它们读到的初始状态都是 5000 元，于是都尝试将账户修改为 4000 元，结果就是少扣了 1000 元。</li>
<li>最简单的解决方法：针对 <code>UPDATE table SET field = field - 1000 WHERE id = 1</code> 这类数据增删改的逻辑，需要对被更新的行加一把「行写锁」，使其他需要写此数据的事务等待。</li>
</ul>
</li>
<li><strong>脏读 Dirty reads</strong>：事务 T1 读取了事务 T2 未提交的数据。这个数据不一定准确，被称为脏数据，因为假如事务 T2 回滚了，T1 拿到的就是一个错误的数据
<ul>
<li>案例：假设小明小红在一个银行账户存了 5000 元，小明小红在用这同一个账户消费 1000 元，这中间小明付款的事务读取到账户已经被小红的事务修改为了 4000 元，于是它把余额修改为 3000 元，然后付款成功。但是在小明的付款事务成功后，小红的付款失败回滚了，余额又从 3000 被修改回 5000 元。小明就完成了 0 元购的壮举。</li>
<li>最简单的解决方法：事务 T2 写数据时对被修改的行加「行写锁」，T2 结束后再释放锁，这样事务 T1 的读取就会被阻塞，直到锁释放。</li>
</ul>
</li>
<li><strong>不可重复读 Non-repeatable reads</strong>：事务 T1 读取数据后，紧接着事务 T2 就更新了数据并提交，事务 T1 再次读取的时候发现数据不一致了
<ul>
<li>案例：
<ul>
<li>小明在京东上抢购商品，抢购事务启动时事务读到还剩 36 件商品，于是继续执行抢购逻辑，之后事务因为某种原因需要再读一次商品数量，结果发现商品数量已经变成 0 了，抢购失败。</li>
<li>更麻烦的是，不可重复读导致 SELECT 跟 UPDATE 之间也可能出现数据变更，如果你在事务中先通过 <code>SELECT field INTO myvar FROM mytable WHERE uid = 1</code> 读到余额，再在此基础上通过 <code>UPDATE</code> 去更新余额，很可能导致数据变得一团糟！
<ul>
<li>正确的做法是使用 <code>UPDATE mytable SET field = field - 1000 WHERE id = 1</code>，因为每一条 SQL 命令本身都是原子的，这个 SQL 不会有问题。</li>
</ul>
</li>
</ul>
</li>
<li>最简单的解决办法：事务 T1 读数据时，也加一把「行」锁，直到不再需要读该数据了，再释放锁。</li>
</ul>
</li>
<li><strong>幻读 Phantom reads</strong>：事务 T1 在多次批量读数据时，事务 T2 往其中执行了插入/删除操作，导致 T1 读到的是旧数据的一个残影，而非当前真实的数据状态。
<ul>
<li>最简单的解决办法：事务 T1 在批量读数据时，先加一把范围锁，在事务 T1 结束读取之后，再释放这把锁。这能同时解决「幻读」跟「不可重复读」的问题。</li>
</ul>
</li>
</ul>
<p>根据隔离程度，ANSI SQL-92 标准中将「隔离性」细分为四个等级（避免「脏写」是数据库的必备要求，因此未记录在下面的四个等级中）：</p>
<ul>
<li><strong>串行化 Serializable</strong>：也就是完全的隔离，只要事务之间存在互相影响的可能，就（通过锁机制）强制它们串行执行。</li>
<li><strong>可重复读 Repeatable read</strong>：可避免脏读、不可重复读的发生，但是解决不了幻读的问题。</li>
<li><strong>读已提交 Read committed</strong>：只能避免脏读</li>
<li><strong>读未提交 Read uncommitted</strong>：最低级别，完全放弃隔离性</li>
</ul>
<p>MySQL 默认的隔离级别为「可重复读 Repeatable Read」，PostgreSQL 和 Oracle 默认隔离级别为「读已提交 Read committed」。</p>
<p>为什么 MySQL/PostgreSQL/Oracle 的默认隔离级别是这样设置的呢？该如何选择正确的隔离级别呢？
我们针对普通的高并发业务场景做个简单分析：</p>
<ul>
<li>首先，「脏读」是必须避免的，它会使事务读到错误的数据！最低的「读未提交」级别直接排除</li>
<li>「串行化」的性能太差，也直接排除</li>
<li>只要 SQL 用得对，「不可重复读」问题对业务逻辑的正确性通常并无影响，所以是可以容忍的。</li>
<li><strong>因此一般「读已提交」是最佳的隔离级别</strong>，这也是 PostgreSQL/Oracle 将其设为默认隔离级别的原因。</li>
<li>那么为什么 MySQL 这么特立独行，将默认隔离级别提高到了「可重复读」呢？为啥阿里这种大的互联网公司又会把 MySQL 默认的隔离级别改成「读已提交」？
<ul>
<li>根据网上查到的资料，这是 MySQL 的历史问题导致的。MySQL 5.0 之前只支持 statement 这种 binlog 格式，此格式在「读已提交」的隔离级别下会出现诸多问题，最明显的就是可能会导致主从数据库的数据不一致。</li>
<li>除了设置默认的隔离级别外，MySQL 还禁止在使用 statement 格式的 binlog 时，使用 READ COMMITTED 作为事务隔离级别，尝试修改隔离级别会报错 <code>Transaction level 'READ-COMMITTED' in InnoDB is not safe for binlog mode 'STATEMENT'</code></li>
<li>而互联网公司将隔离级别改为「读已提交」的原因也很好理解，正如前文所述「读已提交」是最佳的隔离级别，这样修改能够提升数据库的性能。</li>
</ul>
</li>
</ul>
<p>「隔离性」的本质其实就是<strong>事务的并发控制</strong>，不同的隔离级别代表了对并发事务的隔离程度，主要的实现手段是「<strong>多版本并发控制 MVCC</strong>」与「锁」。
锁机制前面已经简单介绍过了，而 MVCC 其实就是为每个事务创建一个特定隔离级别的快照，这样读写不会互相阻塞，性能就提升了。（MVCC 暂时也是超纲知识，后面再研究吧 emmmm）</p>
<p>ANSI SQL-92 对异常现象的分析仍然太过简单了，1995 年新发布的论文 <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf" target="_blank" rel="noopener noreferrer">A Critique of ANSI SQL Isolation Levels</a> 丰富和细化了 SQL-92 的内容，定义了六种隔离级别和八种异常现象（有大佬强烈建议通读此论文，重点是文中的快照隔离（Snapshot Isolation, SI）级别）。</p>
<h3 id="2-数据一致性-data-consistency" class="headerLink">
    <a href="#2-%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7-data-consistency" class="header-mark"></a>2. 数据一致性 Data Consistency</h3><p>「数据一致性」是指对数据库的每一次读操作都应该读到最新写入的数据，或者直接报错。</p>
<p>对单机数据库而言「数据一致性」往往不是问题，因为它通常只有一份保存在磁盘或内存中的数据。
但是在分布式系统中，为了数据安全性或者为了性能，往往每一份数据都在多个节点上存有其副本，这就引出了数据副本们的一致性问题。
因此，我们通常谈论的「数据一致性」就是指分布式系统的「数据一致性」。</p>
<p><strong>CAP 原则</strong>是分布式系统领域一个著名的理论，它告诉我们在分布式系统中如下三种属性不可能全部达成，因此也被称作「<strong>CAP 不可能三角</strong>」：</p>
<ul>
<li><strong>数据一致性 Data Consistency</strong>：客户端的每次读操作，不管访问系统的哪个节点，要么读到的都是同一份最新写入的数据，要么读取失败
<ul>
<li>强调数据完全正确</li>
</ul>
</li>
<li><strong>可用性 Availability</strong>：任何来自客户端的请求，不管访问哪个非故障节点，都能得到响应数据，但不保证是同一份最新数据
<ul>
<li>强调的是服务可用，但不保证数据正确</li>
</ul>
</li>
<li><strong>分区容错性 Partition Tolerance</strong>：即使节点之间出现了任意数量的消息丢失或者高延迟，系统仍能正常运行
<ul>
<li>就是说网络丢包或延迟会导致系统被分成多个 Partition，系统能够容忍这种情况</li>
</ul>
</li>
</ul>
<p>为了保证分区容错性 P，考虑当分布式系统因为网络问题被割裂成多个分区时，每个分区只有如下两种选择，A 跟 C 必须牺牲掉其中之一：</p>
<ul>
<li>取消操作并拒绝提供服务，这降低了可用性，但是能确保数据一致性</li>
<li>继续处理请求，这确保了可用性，但是数据一致性就无法保证了</li>
</ul>
<p>如果系统的多个分区都在同时提供服务，导致数据不一致并且存在冲突无法合并，这就被称为分布式系统的「<strong>脑裂</strong>」，显然任何分布式系统都不会希望发生「脑裂」。</p>
<p>因为分布式系统与单机系统不同，它涉及到多节点间的网络通讯和交互，但是只要有网络交互就一定会有延迟和数据丢失，节点间的分区故障是很有可能发生的。因此为了正常运行，P 是分布式系统必须保证的特性，<strong>在出现分区故障时，为了 P 只能牺牲掉 A 或者 C</strong>。</p>
<p>工程上是要 AP 还是 CP，得视情况而定：</p>
<ul>
<li>Etcd/Zookeeper/Consul: 它们通常被用于存储系统运行的关键元信息，每次读，都要能读取到最新数据。因此它们实现了 CP，牺牲了 A</li>
<li>DynamoDB/Cassandra/MongoDB：不要求数据一致性，一段时间内用旧的缓存问题也不大，但是要求可用性，因此应该实现 AP，牺牲掉 C</li>
</ul>
<h4 id="数据一致性模型" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7%e6%a8%a1%e5%9e%8b" class="header-mark"></a>数据一致性模型</h4><p>分布式系统中，多副本数据上的一组读写策略，被称为「（数据）一致性模型 Consistency Model」。
一致性模型数量很多，让人难以分辨。
为了便于理解，我们先从状态视角出发区分一下强一致与弱一致的概念，在这个的基础上再从操作视角去理解这众多的一致性模型。</p>
<h5 id="1-状态视角---强一致与弱一致" class="headerLink">
    <a href="#1-%e7%8a%b6%e6%80%81%e8%a7%86%e8%a7%92---%e5%bc%ba%e4%b8%80%e8%87%b4%e4%b8%8e%e5%bc%b1%e4%b8%80%e8%87%b4" class="header-mark"></a>1. 状态视角 - 强一致与弱一致</h5><p>我们首先把整个分布式系统看作一个<strong>白盒</strong>，从状态视角看，任何变更操作后，分布式系统的多个数据副本只有如下三种状态：</p>
<ul>
<li>在某些条件下，各副本状态不一致的现象只是暂时的，后续还会转换到一致的状态，这被称为「<strong>弱一致</strong>」；
<ul>
<li>这通常是使用<strong>异步复制</strong>来同步各副本的状态。</li>
</ul>
</li>
<li>相对的说，如果系统各副本不存在「不一致」这种状态，只要变更操作成功数据就一定完全一致，那它就被称为「<strong>强一致</strong>」。
<ul>
<li>这要求所有副本之间的数据更新必须完全同步，就必须使用<strong>全同步复制</strong>。</li>
</ul>
</li>
<li><strong>永远不会一致</strong>：这在分布式系统中就是 bug 了，也被称为「脑裂」。</li>
</ul>
<p>上面描述的是整个系统的客观、实际状态，但对于绝大部分用户而言分布式系统更多的是一个<strong>黑盒</strong>，因此更流行的是基于「黑盒」的分类方式，它根据系统的对外状态将系统分成两种类型：</p>
<ul>
<li><strong>强一致</strong>：指对系统的任何节点/进程，写操作完成后，任何用户对任何节点的后续访问都能读到新的值。就好像系统只存在一个副本一样。
<ul>
<li>最常用算法是 Raft/Paxos，它们的写操作只要求超过半数节点写入成功，因此写入完成时，内部状态实际是不一致的，但是对它进行读写，效果跟「全同步复制」没有区别。</li>
</ul>
</li>
<li><strong>弱一致</strong>：指对系统的任何节点/进程，写操作完成后，后续的任何访问可能会拿到的值是不确定的，但经过一段时间后，后续的任何访问都能读到新的值。
<ul>
<li>弱一致是非常模糊的定义。如果我们把最终所有用户都能访问到新的值被称为「<strong>系统收敛</strong>」，系统收敛的用时可以有明确边界，也可以没有。系统收敛前的访问行为可以有明确规范，也可以不存在规范。一切都看具体系统的实现。</li>
<li>如果系统能够在有限时间内收敛，那它就是「<strong>最终一致</strong>」，否则可以认为它是「<strong>不一致</strong>」。</li>
</ul>
</li>
</ul>
<p>为了实际需要，数据库专家对系统收敛之前的读写效果进行各种限制，对系统的收敛时间进行各种限制，得到了许多一致性模型。</p>
<h5 id="2-操作视角---多种一致性模型" class="headerLink">
    <a href="#2-%e6%93%8d%e4%bd%9c%e8%a7%86%e8%a7%92---%e5%a4%9a%e7%a7%8d%e4%b8%80%e8%87%b4%e6%80%a7%e6%a8%a1%e5%9e%8b" class="header-mark"></a>2. 操作视角 - 多种一致性模型</h5><p>从每个客户端的操作角度看，有四种一致性模型：</p>
<ul>
<li><strong>写后读一致性 Read after Write Consistency</strong>：也被称作「读自己所写一致性」，即自己写完数据版本 N 后，后续读到的版本一定不小于版本 N。
<ul>
<li>它解决的问题：A 发了个抖音视频，刷新页面后却莫名其妙消失了（旧版本），几分钟后才重新刷出来。</li>
<li>实现方式之一：为写入者单独添加一个读取规则，他的读都由已更新其写入数据的副本来处理。</li>
</ul>
</li>
<li><strong>单调读一致性 Monotonic Read Consistency</strong>：保证多个读操作的顺序，即客户端一旦读到某个数据版本 N，后续不会读到比 N 更低的版本。
<ul>
<li>它解决的问题是：A 删除了一个抖音视频，可多次刷新，偶尔刷不到视频，偶尔又能刷到被删除视频（旧版本），几分钟后才彻底被删除。</li>
<li>实现方式之一：为每个用户的读都创建一个副本映射，后续的读都由一个固定的副本处理，避免随机切换副本而读到更老的值。</li>
</ul>
</li>
<li><strong>单调写一致性 Monotonic Write Consistency</strong>：保证多个写操作的顺序，即客户端对同一数据的两次写入操作，一定按其被提交的顺序被执行。</li>
<li><strong>读后写一致性 Write after Read Consistency</strong>：读后写一致性，保证一个客户端读到数据版本 N 后（可能是其他客户端写入的），随后对同一数据的写操作必须要在版本号大于等于 N 的副本上执行。</li>
</ul>
<p>上述四个一致性模型都只从每个客户端自身的角度定义规则，比较片面，因此它们都是「弱一致模型」。</p>
<p>而不考虑客户端，直接从所有数据库用户的操作视角看，有如下几种一致性模型：</p>
<ul>
<li><strong>线性一致性 Linearizability</strong>：线性一致性利用了事件的提交顺序，它保证任何读操作得到的数据，其顺序跟读/写事件的提交顺序一致。
<ul>
<li>简单的说它要求<strong>整个系统表现得像只存在一个副本</strong>，所有操作的执行结果就跟这些事件按提交顺序完全串行执行一样。这实际也是在说所有并发事件都是原子的，一旦互相之间存在冲突，就一定得按顺序执行，因此也有人称它为「原子一致性」。</li>
<li>线性一致性，完全等价于系统对外状态的「强一致性」</li>
<li>线性一致性的系统是完全确定性的</li>
<li>实现方式：需要一个所有节点都一致的「<strong>全局时钟</strong>」，这样才可以对所有事件进行全局排序。
<ul>
<li>大多数分布式数据库如 TiDB/Etcd 都是通过 NTP 等协议进行单点授时与同步实现的全局时钟。</li>
<li>有全球化部署需要的 Google Spanner 是使用 GPS + 原子钟实现的全局时钟 TrueTime，全局误差可以控制在 7ms 以内。</li>
</ul>
</li>
<li>局限性：根据爱因斯坦相对论，「时间是相对的」，实际上并不存在绝对的时间，因此线性一致性只在经典物理学范围内适用。</li>
</ul>
</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Consistency_model" target="_blank" rel="noopener noreferrer">顺序一致性 Sequentially Consistent</a></strong>：顺序一致性最早是 Leslie Lamport 用来描述多核 CPU 的行为的，在分布式系统领域用得较少。
<ul>
<li>顺序一致性的要求有两点：
<ul>
<li>从单个进程（副本）的角度看，所有指令的执行顺序跟代码逻辑的顺序完全一致。</li>
<li>从所有的处理器（整个分布式系统）角度看，写操作不必立即对所有用户可见，但是所有副本必须以相同的顺序接收这些写操作。</li>
</ul>
</li>
<li>顺序一致性和线性一致性都是要找到一个满足「写后读」的一组操作历史，差异在于<strong>线性一致性要求严格的时间序，而顺序一致性只要求满足代码的逻辑顺序</strong>，而其他代码逻辑未定义的事件顺序（比如多副本上各事件之间的顺序），具体是什么样的顺序无所谓，只要所有副本看到的事件顺序都相同就行。</li>
<li>顺序一致性并不能提供「确定性」，相同的两次操作仍然可能得到不同的事件顺序。</li>
<li>实现方式：因为不要求严格的全局时间序，它就不需要一个全局时钟了，但实际上为了满足全局的确定性，仍然需要一些复杂的操作。</li>
</ul>
</li>
<li><strong>因果一致性 Causal Consistency</strong>：线性一致性的全局时钟有其局限性，而因果一致性基于写事件的「偏序关系」提出了「<strong>逻辑时钟</strong>」的概念，并保证读顺序与逻辑时钟上的写事件顺序一致。
<ul>
<li>写事件的「偏序关系」关系是指，至少部分事件（比如一个节点内部的事件）是可以使用本地时钟直接排序的，而节点之间发生通讯时，接收方的事件一定晚于调用方的事件。基于这一点可以实现一个「<strong>逻辑时钟</strong>」，但逻辑时钟的缺点在于，如果某两个事件不存在相关性，那逻辑时钟给出的顺序就没有任何意义。</li>
<li>多数观点认为，因果一致性弱于线性一致性，但<strong>在并发性能上具有优势，也足以处理多数的异常现象</strong>，所以因果一致性也在工业界得到了应用。</li>
<li>CockroachDB 和 YugabyteDB 都在设计中采用了逻辑混合时钟（Hybrid Logical Clocks），这个方案源自 Lamport 的逻辑时钟，也取得了不错的效果</li>
</ul>
</li>
<li><strong>前缀一致性 Consistent Prefix</strong>：副本之间的同步过程中，会存在一些副本接收数据的顺序并不一致。「前缀一致性」是说所有用户读到的数据顺序的前缀永远是一致的。
<ul>
<li>「前缀」是指程序在执行写操作时，需要显式声明其「前缀」事件，这样每个事件就都存在一个由其他写事件排列而成的前缀。比如当前有写事件排列「A B C D」，那所有用户读到的数据都拥有同样的写事件前缀，比如「A」、「A B」、「A B C」、「A B C D」，但不可能出现「A C」或者「C A」等结果。</li>
<li>它解决的是<strong>分片分布式数据库</strong>的一致性问题：A B C 因为地域区别读写的是不同的副本，B 在抖音评论区问了个问题，然后 A 作出了回答。但是问题跟回答两个数据如果处于不同的分片，副本同步时这两个数据的顺序是无法保证的，C 可能会先读到回答信息，之后才刷新出 B 的提问，历史事件的顺序就乱了。</li>
<li>实现方式：需要程序主动为消息之间添加显式的依赖关系，再据此控制其读取顺序，实现比较复杂。</li>
<li>存在的问题：只有被显式定义了因果关系的事件，它们之间的顺序才能被保证。</li>
</ul>
</li>
</ul>
<p>其中<strong>线性一致性</strong>就是<strong>强一致性</strong>，其他所有的模型都是<strong>弱一致性模型</strong>或者说<strong>最终一致性模型</strong>。所有这些模型按强度降序排列如下：</p>
<ul>
<li>线性一致性/强一致性：系统对外表现得好像整个系统完全一致，不存在不一致的情况。</li>
<li>顺序一致性：只保证每个节点上的事件顺序一致，对节点之间的事件顺序只有非常宽松的要求。</li>
<li>因果一致性：同样只保证每个节点上的事件顺序一致，但是对节点之间的事件顺序的要求比顺序一致性更宽松。</li>
<li>有界旧一致性（Bounded Staleness）：保证读到的数据与最新版本的差距不超过 K 个版本</li>
<li>会话一致性（Session Consistency）：在一个会话内保证单调读，单调写，和读自己所写，会话之间不保证</li>
<li>前缀一致性：在每个会话内保证了单调读，会话之间不保证</li>
<li>客户端角度的四个一致性模型：写后读、单调读、单调写、读后写。这四个模型的视角都非常片面，通常被包含在前述的一致性模型中。</li>
</ul>
<p>更完整的关系树状图：<a href="https://jepsen.io/consistency" target="_blank" rel="noopener noreferrer">Consistency Models</a></p>
<h2 id="二分布式系统的-base-与最终一致性" class="headerLink">
    <a href="#%e4%ba%8c%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e7%9a%84-base-%e4%b8%8e%e6%9c%80%e7%bb%88%e4%b8%80%e8%87%b4%e6%80%a7" class="header-mark"></a>二、分布式系统的 BASE 与最终一致性</h2><p>BASE 理论：</p>
<ul>
<li><strong>基本可用 Basically Available</strong>：当分布式系统在出现不可预知的故障时，允许损失部分功能的可用性，保障核心功能的可用性
<ul>
<li>四种实现基本可用的手段：流量削峰、延迟响应、体验降级、过载保护</li>
</ul>
</li>
<li><strong>软状态 Soft state</strong>：在柔性事务中，允许系统存在中间状态，且这个中间状态不会影响系统整体可用性。比如，数据库读写分离，写库同步到读库（主库同步到从库）会有一个延时，其实就是一种柔性状态。</li>
<li><strong>最终一致性 Eventually consistent</strong>：前面已经说得很详细了，它指对系统的任何节点/进程，写操作完成后，后续的任何访问可能会拿到的值是不确定的，但经过有限的一段时间后，后续的任何访问都能读到新的值。</li>
</ul>
<p>ACID 与 BASE 实质上是分布式系统实现中的的两个极端：</p>
<ul>
<li>ACID 理论就如它的含义「<strong>酸</strong>」一样，是 CAP 原则中一致性的边界——<strong>最强的一致性</strong>，是牺牲掉 A 后达到 CP 的极致。</li>
<li>BASE 翻译过来就是「<strong>碱</strong>」，它是 CAP 原则中可用性的边界——<strong>最高的可用性，最弱的一致性</strong>，通过牺牲掉 C 来达到 AP 的极致。</li>
</ul>
<p>根据 CAP 理论，如果在分布式系统中实现了一致性，可用性必然受到影响。
比如，如果出现一个节点故障，则整个分布式事务的执行都是失败的。实际上，绝大部分场景对一致性要求没那么高，短暂的不一致是能接受的，另外，也基于可用性和并发性能的考虑，建议在开发实现分布式系统时，<strong>如果不是必须，尽量不要实现事务，可以考虑采用最终一致性</strong>。</p>
<p>最终一致性的实现手段：</p>
<ul>
<li><strong>读时修复</strong>：在读取数据时，检测数据的不一致，进行修复</li>
<li><strong>写时修复</strong>：在写入数据时，检测数据的不一致，进行修复</li>
<li><strong>异步修复</strong>：这个是最常用的方式，通过定时对账，检测副本数据的一致性并修复</li>
</ul>
<p>在实现最终一致性的时候，还推荐同时实现自定义写一致性级别（比如 All、Quorum、One、Any），许多分布式数据库的最终一致性级别都是可调的。</p>
<p>但是随着 TiDB 等分布式关系数据库的兴起，分布式领域的 BASE 理论实际上正在被 ACID 赶超，ACID 焕发又一春了。</p>
<h2 id="三共识算法" class="headerLink">
    <a href="#%e4%b8%89%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95" class="header-mark"></a>三、共识算法</h2><p>共识算法，也被称为一致性协议，是指在分布式系统中多个节点之间对某个提案 Proposal（例如多个事务请求，先执行谁？）达成一致看法的一套流程。</p>
<p>提案的含义在分布式系统中十分宽泛，如多个事件发生的顺序、某个键对应的值、谁是主节点……等等。可以认为任何可以达成一致的信息都是一个提案。</p>
<p>对于分布式系统来讲，各个节点通常都是相同的确定性状态机模型（又称为状态机复制问题，State-Machine Replication），从相同初始状态开始接收相同顺序的指令，则可以保证相同的结果状态。因此，系统中多个节点最关键的是对多个事件的顺序进行共识，即排序。</p>
<p><strong>共识算法是达成数据一致性的一种手段，而且是数据强一致性的必要非充分条件</strong>。比如直接使用 Raft 算法，但是允许读取集群的任何节点，只能得到数据的最终一致性，还需要其他手段才能确保强一致性。</p>
<h3 id="拜占庭将军问题与拜占庭容错" class="headerLink">
    <a href="#%e6%8b%9c%e5%8d%a0%e5%ba%ad%e5%b0%86%e5%86%9b%e9%97%ae%e9%a2%98%e4%b8%8e%e6%8b%9c%e5%8d%a0%e5%ba%ad%e5%ae%b9%e9%94%99" class="header-mark"></a>拜占庭将军问题与拜占庭容错</h3><p>拜占庭错误是 1982 年兰伯特在《拜占庭将军问题》中提出的一个错误模型，描述了在少数节点不仅存在故障，还存在恶意行为的场景下，能否达成共识这样一个问题，论文描述如下：</p>
<blockquote>
<p>9 位拜占庭将军分别率领一支军队要共同围困一座城市，因为这座城市很强大，如果不协调统一将军们的行动策略，部分军队进攻、部分军队撤退会造成围困失败，因此各位将军必须通过投票来达成一致策略，要么一起进攻，要么一起撤退。</p>
<p>因为各位将军分别占据城市的一角，他们只能通过信使互相联系。在协调过程中每位将军都将自己投票“进攻”还是“撤退”的消息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他将军送过来的投票，就可以知道投票结果，从而决定是进攻还是撤退。</p>
<p>而问题的复杂性就在于：将军中可能出现叛徒，他们不仅可以投票给错误的决策，还可能会选择性地发送投票。假设 9 位将军中有 1 名叛徒，8 位忠诚的将军中出现了 4 人投“进攻”，4 人投“撤退”，这时候叛徒可能故意给 4 名投“进攻”的将军投“进攻”，而给另外 4 名投“撤退”的将军投“撤退”。这样在 4 名投“进攻”的将军看来，投票是 5 人投“进攻”，从而发动进攻；而另外 4 名将军看来是 5 人投“撤退”，从而撤退。这样，一致性就遭到了破坏。</p>
<p>还有一种情况，因为将军之间需要通过信使交流，即便所有的将军都是忠诚的，派出去的信使也可能被敌军截杀，甚至被间谍替换，也就是说将军之间进行交流的信息通道是不能保证可靠性的。所以在没有收到对应将军消息的时候，将军们会默认投一个票，例如“进攻”。</p>
</blockquote>
<p>更一般地，在已知有 N 个将军谋反的情况下，其余 M 个忠诚的将军在不受叛徒的影响下能否达成共识？有什么样的前提条件，该如何达成共识？这就是拜占庭将军问题。</p>
<p>如果一个共识算法在一定条件下能够解决拜占庭将军问题，那我们就称这个算法是「<strong>拜占庭容错 Byzantine Fault Tolerance（BFT）</strong>」算法。
反之如果一个共识算法无法接受任何一个节点作恶，那它就被称为「<strong>非拜占庭容错 Crash Fault Tolerance (CFT)</strong>」算法。</p>
<p>可以通过简单穷举发现，二忠一叛是无法达成共识的，这个结论结合反证法可证明，<strong>拜占庭容错算法要求叛徒的比例必须低于 1/3</strong>。</p>
<h3 id="常用共识算法" class="headerLink">
    <a href="#%e5%b8%b8%e7%94%a8%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95" class="header-mark"></a>常用共识算法</h3><p>对于「<strong>非拜占庭容错 Crash Fault Tolerance (CFT)</strong>」的情况，已经存在不少经典的算法，包括 Paxos（1990 年）、Raft（2014 年）及其变种等。这类容错算法往往性能比较好，处理较快，容忍不超过一半的故障节点。</p>
<p>对于「<strong>拜占庭容错 Byzantine Fault Tolerance（BFT）</strong>」的情况，目前有 PBFT（Practical Byzantine Fault Tolerance，1999 年）为代表的确定性系列算法、PoW（1999 年）为代表的概率算法等算法可选。
确定性算法一旦达成共识就不可逆转，即共识是最终结果；
而概率类算法的共识结果则是临时的，随着时间推移或某种强化，共识结果被推翻的概率越来越小，最终成为事实上结果。
拜占庭类容错算法往往性能较差，容忍不超过 1/3 的故障节点。</p>
<p>此外，XFT（Cross Fault Tolerance，2015 年）等最近提出的改进算法可以提供类似 CFT 的处理响应速度，并能在大多数节点正常工作时提供 BFT 保障。
Algorand 算法（2017 年）基于 PBFT 进行改进，通过引入可验证随机函数解决了提案选择的问题，理论上可以在容忍拜占庭错误的前提下实现更好的性能（1000+ TPS）。</p>
<blockquote>
<p>注：实践中，对客户端来说要拿到共识结果需要自行验证，典型地，可访问足够多个服务节点来比对结果，确保获取结果的准确性。</p>
</blockquote>
<p>常见共识算法列举如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>拜占庭容错</th>
<th>一致性</th>
<th>性能</th>
<th>可用性（能容忍多大比例的节点出现故障）</th>
</tr>
</thead>
<tbody>
<tr>
<td>两阶段提交 2PC</td>
<td>否</td>
<td>强一致性</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>TCC(try-confirm-cancel)</td>
<td>否</td>
<td>最终一致性</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>Paxos</td>
<td>否</td>
<td>强一致性</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>ZAB</td>
<td>否</td>
<td>最终一致性</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>Raft</td>
<td>否</td>
<td>强一致性</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>Gossip</td>
<td>否</td>
<td>最终一致性</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>Quorum NWR</td>
<td>否</td>
<td>强一致性</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>PBFT</td>
<td>是</td>
<td>N/A</td>
<td>低</td>
<td>中</td>
</tr>
<tr>
<td>PoW</td>
<td>是</td>
<td>N/A</td>
<td>低</td>
<td>中</td>
</tr>
<tr>
<td>PoS</td>
<td>是</td>
<td>N/A</td>
<td>低</td>
<td>中</td>
</tr>
<tr>
<td><a href="https://medium.com/solana-labs/proof-of-history-explained-by-a-water-clock-e682183417b8" target="_blank" rel="noopener noreferrer">PoH</a></td>
<td>是</td>
<td>N/A</td>
<td>中</td>
<td>中</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注：这里虽然列出了 PoW/PoS/PoH 等应用在区块链中的一致性算法，但是它们跟 PBFT 等其他拜占庭容错算法存在很大的区别，后面会给出介绍。</p>
</blockquote>
<h3 id="不同共识算法的应用场景" class="headerLink">
    <a href="#%e4%b8%8d%e5%90%8c%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" class="header-mark"></a>不同共识算法的应用场景</h3><p>在不可信环境中，因为可能存在恶意行为，就需要使用支持拜占庭容错的共识算法如 PoW/PoS，使系统在存在部分节点作恶的情况下仍然能达成共识。这就是区块链使用 PoW/PoS 算法而不是 Paxos/Raft 算法的原因。</p>
<p>而在企业内网等场景下，可以认为是可信环境，基本不会出现恶意节点或者可以通过 mTLS 等手段进行节点身份认证，这种场景下系统具有故障容错能力就够了，就没必要做到拜占庭容错，因此常用 Raft/Paxos 等算法。</p>
<h3 id="非拜占庭错误共识算法-paxos-与-raft" class="headerLink">
    <a href="#%e9%9d%9e%e6%8b%9c%e5%8d%a0%e5%ba%ad%e9%94%99%e8%af%af%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95-paxos-%e4%b8%8e-raft" class="header-mark"></a>非拜占庭错误共识算法 Paxos 与 Raft</h3><p>受限于篇幅与笔者精力，这部分暂时跳过&hellip;后面可能会写篇新的文章专门介绍 Paxos/Raft 算法。</p>
<h3 id="能容忍拜占庭错误的-pow-概率共识算法" class="headerLink">
    <a href="#%e8%83%bd%e5%ae%b9%e5%bf%8d%e6%8b%9c%e5%8d%a0%e5%ba%ad%e9%94%99%e8%af%af%e7%9a%84-pow-%e6%a6%82%e7%8e%87%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95" class="header-mark"></a>能容忍拜占庭错误的 PoW 概率共识算法</h3><p>PoW 即 Proof of Work 工作量证明，指系统为达到某一目标而设置的度量方法。简单理解就是一份证明，用来确认你做过一定量的工作。
监测工作的整个过程通常是极为低效的，而通过对工作的结果进行认证来证明完成了相应的工作量，这个认证流程是非常简单高效的，这就是 PoW 的优势所在。</p>
<p>在 1993 年，<a href="http://www.wisdom.weizmann.ac.il/~naor/PAPERS/pvp.ps" target="_blank" rel="noopener noreferrer">Cynthia Dwork 和 Moni Naor 设计了一个系统用于反垃圾邮件、避免资源被滥用</a>，这是 PoW 算法的雏形。其核心思想如下：</p>
<blockquote>
<p>The main idea is to require a user to compute a moderately hard but not intractable function in order to gain access to the resource, thus preventing frivolous use.</p>
</blockquote>
<p>翻译成中文：</p>
<blockquote>
<p>其主要思想是要求用户计算一个中等难度但不难处理的函数，以获得对资源的访问，从而防止（系统资源被）滥用。</p>
</blockquote>
<p>在 1999 年，<a href="https://link.springer.com/chapter/10.1007/978-0-387-35568-9_18" target="_blank" rel="noopener noreferrer">Markus Jakobsson 与 Ari Juels 第一次从各种协议中提炼出 Proofs of Work 这个概念</a>。</p>
<p>POW 系统中一定有两个角色，工作者和验证者，他们需要具有以下特点：</p>
<ul>
<li>工作者需要完成的工作必须有一定的量，这个量由工作验证者给出。</li>
<li>验证者可以迅速的检验工作量是否达标。</li>
<li>工作者无法自己&quot;创造工作&quot;，必须由验证者发布工作。</li>
<li>工作者无法找到很快完成工作的办法。</li>
</ul>
<p>说到这里，我们对 PoW 应该有足够的理解了，它就是让工作者消耗一定的资源作为使用系统的成本。
对于正常的用户而言这部分被消耗的资源是完全可以接受的，但是对于恶意攻击者而言，它如果想滥用系统的资源或者发送海量的垃圾邮件，就需要消耗海量的计算资源作为成本，这样就极大地提升了攻击成本。</p>
<p>再总结下，PoW 算法的核心是<strong>它为信息发送加入了成本，降低了信息传递的速率</strong>。</p>
<p>把比特币区块链转换成拜占庭将军问题来看，它的思路是这样的：</p>
<ul>
<li>限制一段时间内提案的个数，只有拥有对应权限的节点（将军）可以发起提案。
<ul>
<li>这是通过 PoW 工作量证明实现的，比特币区块链要求节点进行海量的哈希计算作为<strong>获得提案权限的代价</strong>，算法难度每隔两周调整一次以保证整个系统找到正确 Hash 值的平均用时大约为 10 分钟。</li>
</ul>
</li>
<li>由强一致性放宽至最终一致性。
<ul>
<li>对应一次提案的结果不需要全部的节点马上跟进，只需要在节点能搜寻到的全网络中的所有链条中，选取最长的链条进行后续拓展就可以。</li>
</ul>
</li>
<li>使用非对称加密算法对节点间的消息传递提供签名技术支持，每个节点（将军）都有属于自己的秘钥（公钥私钥），唯一标识节点身份。
<ul>
<li>使用非对称加密算法传递消息，能够保证消息传递的私密性。而且消息签名不可篡改，这避免了消息被恶意节点伪造。</li>
</ul>
</li>
</ul>
<p>我们前面有给出一个结论：<strong>拜占庭容错算法要求叛徒的比例必须低于 1/3</strong>。</p>
<p>但是区块链与拜占庭将军问题的区别很大，举例如下：</p>
<ul>
<li>区块链允许任何节点随时加入或离开区块链，而拜占庭将军问题是预设了节点数，而且不考虑节点的添加或删除。</li>
<li>比特币区块链的 PoW 算法只能保证整个系统找到正确 Hash 值的<strong>平均用时</strong>大约为 10 分钟，那肯定就存在性能更好的节点用时更短，性能更差的节点用时更长，甚至某些节点运气好几秒钟就算出了结果，这都是完全可能的。而越早算出这个 Hash 值的节点，它的提案（区块）成为最长链条的概率就越大。</li>
<li>PoW 由强一致性放宽至最终一致性，系统总会选取最长的链进行后续拓展，那如果某个链条一开始不长，但是它的拓展速度足够快，它就能成为最长的链条。而拜占庭将军问题不允许任何分支，只存在一个结果！
<ul>
<li>只是受限于算力，随着时间的推移，短的链条追上最长链条的概率会越来越小。</li>
</ul>
</li>
</ul>
<p>总之因为区块链这样的特点，它会产生一些跟拜占庭容错算法不同的结果：</p>
<ul>
<li>攻击者拥有的节点数量占比是毫无意义的，核心是算力，也就对应着区块链中的提案权。
<ul>
<li>即使攻击者拥有了 99% 的节点，但是它的总体算力很弱的话，它的提案（区块）成为最长链条的概率也会很低。</li>
</ul>
</li>
<li><strong>区块链的 51% 攻击</strong>：因为「系统总是选取最长链条进行后续拓展」这个原则，只有某个攻击者拥有了超过 50% 算力的情况下，它才拥有绝对性的优势，使它的区块在一定时间后一定能成为最长的链条，并且始终维持这样一个优势，从而达成攻击目的。</li>
</ul>
<p>至于 PoW 算法的具体实现，以及它的替代算法 PoS/PoH 等新兴算法的原理与实现，将在后续的区块链系列文章中详细介绍，尽请期待&hellip;</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li>《Designing Data-Intensive Applications - The Big Ideas Behind Reliable, Scalable, and Maintainable Systems (Martin Kleppmann)》</li>
<li>极客时间《分布式数据库 30 讲》</li>
<li>极客时间《分布式协议与算法实战》</li>
<li><a href="https://zhuanlan.zhihu.com/p/34656939" target="_blank" rel="noopener noreferrer">分布式存储系统的一致性是什么？- OceanBase</a></li>
<li><a href="https://pingcap.com/zh/blog/linearizability-and-raft" target="_blank" rel="noopener noreferrer">线性一致性和 Raft - PingCAP</a></li>
<li><a href="https://int64.me/2020/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0.html" target="_blank" rel="noopener noreferrer">一致性模型笔记</a></li>
<li><a href="http://zhangtielei.com/posts/blog-distributed-strong-weak-consistency.html" target="_blank" rel="noopener noreferrer">条分缕析分布式：浅析强弱一致性 -  张铁蕾</a></li>
<li><a href="https://cloud.google.com/blog/products/databases/why-you-should-pick-strong-consistency-whenever-possible" target="_blank" rel="noopener noreferrer">Why you should pick strong consistency, whenever possible - Google Spanner</a></li>
<li><a href="https://www.infoq.cn/article/the-byzantine-generals-problem-and-blockchain" target="_blank" rel="noopener noreferrer">拜占庭将军问题与区块链</a></li>
<li><a href="https://paper.seebug.org/1643/" target="_blank" rel="noopener noreferrer">区块链协议安全系列— —当拜占庭将军犯错时，区块链共识还安全么？（上集）</a></li>
<li><a href="https://www.allthingsdistributed.com/2008/12/eventually_consistent.html" target="_blank" rel="noopener noreferrer">Eventually Consistent - Revisited</a></li>
</ul>
]]></content></entry><entry><title type="html">Kubernetes 中的证书管理工具 - cert-manager</title><link href="https://thiscute.world/posts/kubernetes-cert-management/"/><id>https://thiscute.world/posts/kubernetes-cert-management/</id><author><name>ryan4yin</name></author><published>2022-07-31T15:11:46+08:00</published><updated>2022-07-31T15:11:46+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/kubernetes-cert-management/cert-manager.webp" height="2020" width="630"><figcaption></figcaption>
        </figure><p>我在之前的文章 <a href="https://thiscute.world/posts/about-tls-cert/" target="_blank" rel="noopener noreferrer">写给开发人员的实用密码学（八）—— 数字证书与 TLS 协议</a> 中，介绍了如何使用 openssl 生成与管理各种用途的数字证书，也简单介绍了如何通过 certbot 等工具与 ACME 证书申请与管理协议，进行数字证书的申请与自动更新（autorenew）。</p>
<p>这篇文章要介绍的 cert-mangager，跟 certbot 这类工具有点类似，区别在于它是工作在 Kubernetes 中的。</p>
<p>cert-manager 是一个证书的自动化管理工具，用于在 Kubernetes 集群中自动化地颁发与管理各种来源、各种用途的数字证书。它将确保证书有效，并在合适的时间自动更新证书。</p>
<p>多的就不说了，证书相关的内容请参见我的 <a href="https://thiscute.world/posts/about-tls-cert/" target="_blank" rel="noopener noreferrer">写给开发人员的实用密码学（八）—— 数字证书与 TLS 协议</a> 或者其他资料，现在直接进入正题。</p>
<blockquote>
<p>注：cert-manager 的管理对象是「证书」，如果你仅需要使用非对称加密的公私钥对进行 JWT 签名、数据加解密，可以考虑直接使用 <a href="https://thiscute.world/posts/experience-of-vault/" target="_blank" rel="noopener noreferrer">secrets 管理工具 Vault</a>.</p>
</blockquote>
<h2 id="一部署" class="headerLink">
    <a href="#%e4%b8%80%e9%83%a8%e7%bd%b2" class="header-mark"></a>一、部署</h2><blockquote>
<p><a href="https://cert-manager.io/docs/installation/helm/" target="_blank" rel="noopener noreferrer">https://cert-manager.io/docs/installation/helm/</a></p>
</blockquote>
<p>官方提供了多种部署方式，使用 helm3 安装的方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 添加 cert-manager 的 helm 仓库</span>
</span></span><span class="line"><span class="cl">helm repo add jetstack https://charts.jetstack.io
</span></span><span class="line"><span class="cl">helm repo update
</span></span><span class="line"><span class="cl"><span class="c1"># 查看版本号</span>
</span></span><span class="line"><span class="cl">helm search repo jetstack/cert-manager -l <span class="p">|</span> head
</span></span><span class="line"><span class="cl"><span class="c1"># 下载并解压 chart，目的是方便 gitops 版本管理</span>
</span></span><span class="line"><span class="cl">helm pull jetstack/cert-manager --untar --version 1.8.2
</span></span><span class="line"><span class="cl">helm install <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  cert-manager ./cert-manager <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --namespace cert-manager <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --create-namespace <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  <span class="c1"># 下面这个参数会导致使用 helm 卸载的时候，会删除所有 CRDs，可能导致所有 CRDs 资源全部丢失！要格外注意</span>
</span></span><span class="line"><span class="cl">  --set <span class="nv">installCRDs</span><span class="o">=</span><span class="nb">true</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="二创建-issuer" class="headerLink">
    <a href="#%e4%ba%8c%e5%88%9b%e5%bb%ba-issuer" class="header-mark"></a>二、创建 Issuer</h2><p>cert-manager 支持多种 issuer，你甚至可以通过它的标准 API 创建自己的 Issuer。</p>
<p>但是总的来说不外乎三种：</p>
<ul>
<li>由权威 CA 机构签名的「公网受信任证书」: 这类证书会被浏览器、小程序等第三方应用/服务商信任</li>
<li>本地签名证书: 即由本地 CA 证书签名的数字证书</li>
<li>自签名证书: 即使用证书的私钥为证书自己签名</li>
</ul>
<p>下面介绍下如何申请公网证书以及本地签名证书。</p>
<h3 id="1-通过权威机构创建公网受信证书" class="headerLink">
    <a href="#1-%e9%80%9a%e8%bf%87%e6%9d%83%e5%a8%81%e6%9c%ba%e6%9e%84%e5%88%9b%e5%bb%ba%e5%85%ac%e7%bd%91%e5%8f%97%e4%bf%a1%e8%af%81%e4%b9%a6" class="header-mark"></a>1. 通过权威机构创建公网受信证书</h3><p>通过权威机构创建的公网受信证书，可以直接应用在边界网关上，用于给公网用户提供 TLS 加密访问服务，比如各种 HTTPS 站点、API。
这是需求最广的一类数字证书服务。</p>
<p>cert-manager 支持两种申请公网受信证书的方式：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Automatic_Certificate_Management_Environment" target="_blank" rel="noopener noreferrer">ACME（Automated Certificate Management Environment (ACME) Certificate Authority server）</a>证书自动化申请与管理协议。</li>
<li><a href="https://cert-manager.io/docs/configuration/venafi/#creating-a-venafi-as-a-service-issuer" target="_blank" rel="noopener noreferrer">venafi-as-a-service</a>: venafi 是一个证书的集中化管理平台，它也提供了 cert-manager 插件，可用于自动化申请 DigiCert/Entrust/GlobalSign/Let&rsquo;s Encrypt 四种类型的公网受信证书。</li>
</ul>
<p>这里主要介绍使用 ACMEv2 协议申请公网证书，支持使用此开放协议申请证书的权威机构有：</p>
<ul>
<li>免费服务
<ul>
<li>Let&rsquo;s Encrypt: 众所周知，它提供三个月有效期的免费证书。</li>
<li><a href="https://zerossl.com/documentation/acme/" target="_blank" rel="noopener noreferrer">ZeroSSL</a>:  貌似也是一个比较有名的 SSL 证书服务
<ul>
<li>通过 ACME 协议支持不限数量的 90 天证书，也支持多域名证书与泛域名证书。</li>
<li>它提供了一个额外的 Dashboard 查看与管理所有申请的证书，这是比较方便的地方。</li>
</ul>
</li>
</ul>
</li>
<li>付费服务
<ul>
<li>DigiCert: 这个非常有名（但也是相当贵），官方文档 <a href="https://docs.digicert.com/certificate-tools/Certificate-lifecycle-automation-index/acme-user-guide/" target="_blank" rel="noopener noreferrer">Digicert - Third-party ACME client automation</a></li>
<li>Google Public Authority(Google Trust Services): Google 推出的公网证书服务，也是三个月有效期，其根证书交叉验证了 GlobalSign，OCSP 服务器在国内速度也很快。
<ul>
<li>详见 <a href="https://github.com/acmesh-official/acme.sh/wiki/Google-Public-CA" target="_blank" rel="noopener noreferrer">acme.sh/wiki/Google-Public-CA</a></li>
<li>此功能目前（2022-08-10）仍处于 beta 状态，需要提表单申请才能获得使用</li>
<li>官方地址：https://pki.goog/</li>
</ul>
</li>
<li>Entrust: 官方文档 <a href="https://www.entrust.com/knowledgebase/ssl/how-to-use-acme-to-install-ssl-tls-certificates-in-entrust-certificate-services-apache#step1" target="_blank" rel="noopener noreferrer">Entrust&rsquo;s ACME implementation</a></li>
<li>GlobalSign: 官方文档 <a href="https://www.globalsign.com/en/acme-automated-certificate-management" target="_blank" rel="noopener noreferrer">GlobalSign ACME Service</a></li>
</ul>
</li>
</ul>
<p>这里也顺便介绍下收费证书服务对证书的分级，以及该如何选用：</p>
<ul>
<li>Domain Validated（DV）证书
<ul>
<li><strong>仅验证域名所有权</strong>，验证步骤最少，价格最低，仅需要数分钟即可签发。</li>
<li>优点就是易于签发，很适合做自动化。</li>
<li>各云厂商（AWS/GCP/Cloudflare，以及 Vercel/Github 的站点服务）给自家服务提供的免费证书都是 DV 证书，Let&rsquo;s Encrypt 的证书也是这个类型。
<ul>
<li>很明显这些证书的签发都非常方便，而且仅验证域名所有权。</li>
<li>但是 AWS/GCP/Cloudflare/Vercel/Github 提供的 DV 证书都仅能在它们的云服务上使用，不提供私钥导出功能！</li>
</ul>
</li>
</ul>
</li>
<li>Organization Validated (OV) 证书
<ul>
<li>是企业 SSL 证书的首选，通过企业认证确保企业 SSL 证书的真实性。</li>
<li>除域名所有权外，CA 机构还会审核组织及企业的真实性，包括注册状况、联系方式、恶意软件等内容。</li>
<li>如果要做合规化，可能至少也得用 OV 这个级别的证书。</li>
</ul>
</li>
<li>Extended Validation（EV）证书
<ul>
<li>最严格的认证方式，CA 机构会深度审核组织及企业各方面的信息。</li>
<li>被认为适合用于大型企业、金融机构等组织或企业。</li>
<li>而且仅支持签发单域名、多域名证书，不支持签发泛域名证书，安全性杠杠的。</li>
</ul>
</li>
</ul>
<p>ACME 支持 HTTP01 跟 DNS01 两种域名验证方式，其中 DNS01 是最简便的方法。</p>
<p>下面分别演示如何使用 AWS Route53 跟 AliDNS，通过 DNS 验证方式申请一个 Let&rsquo;s Encrypt 证书。（其他 DNS 提供商的配置方式请直接看官方文档）</p>
<h4 id="11-使用-aws-route53-创建一个证书签发者certificate-issuer" class="headerLink">
    <a href="#11-%e4%bd%bf%e7%94%a8-aws-route53-%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e8%af%81%e4%b9%a6%e7%ad%be%e5%8f%91%e8%80%85certificate-issuer" class="header-mark"></a>1.1 使用 AWS Route53 创建一个证书签发者「Certificate Issuer」</h4><blockquote>
<p>非 AWS Route53 用户可忽略这一节</p>
</blockquote>
<blockquote>
<p><a href="https://cert-manager.io/docs/configuration/acme/dns01/route53/" target="_blank" rel="noopener noreferrer">https://cert-manager.io/docs/configuration/acme/dns01/route53/</a></p>
</blockquote>
<h5 id="111-通过-iam-授权-cert-manager-调用-aws-route53-api" class="headerLink">
    <a href="#111-%e9%80%9a%e8%bf%87-iam-%e6%8e%88%e6%9d%83-cert-manager-%e8%b0%83%e7%94%a8-aws-route53-api" class="header-mark"></a>1.1.1 通过 IAM 授权 cert-manager 调用 AWS Route53 API</h5><blockquote>
<p>这里介绍一种不需要创建 ACCESS_KEY_ID/ACCESS_SECRET，直接使用 AWS EKS 官方的免密认证的方法。会更复杂一点，但是更安全可维护。</p>
</blockquote>
<p>首先需要为 EKS 集群创建 OIDC provider，参见 <a href="https://github.com/ryan4yin/knowledge/blob/master/kubernetes/security/aws-iam-and-kubernetes.md" target="_blank" rel="noopener noreferrer">aws-iam-and-kubernetes</a>，这里不再赘述。</p>
<p>cert-manager 需要查询与更新 Route53 记录的权限，因此需要使用如下配置创建一个 IAM Policy，可以命名为 <code>&lt;ClusterName&gt;CertManagerRoute53Access</code>（注意替换掉 <code>&lt;ClusterName&gt;</code>）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;Version&#34;</span><span class="p">:</span> <span class="s2">&#34;2012-10-17&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;Statement&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Effect&#34;</span><span class="p">:</span> <span class="s2">&#34;Allow&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Action&#34;</span><span class="p">:</span> <span class="s2">&#34;route53:GetChange&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Resource&#34;</span><span class="p">:</span> <span class="s2">&#34;arn:aws:route53:::change/*&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Effect&#34;</span><span class="p">:</span> <span class="s2">&#34;Allow&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Action&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl"> <span class="s2">&#34;route53:ChangeResourceRecordSets&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"> <span class="s2">&#34;route53:ListResourceRecordSets&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="p">],</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Resource&#34;</span><span class="p">:</span> <span class="s2">&#34;arn:aws:route53:::hostedzone/*&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Effect&#34;</span><span class="p">:</span> <span class="s2">&#34;Allow&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Action&#34;</span><span class="p">:</span> <span class="s2">&#34;route53:ListHostedZonesByName&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;Resource&#34;</span><span class="p">:</span> <span class="s2">&#34;*&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>比如使用 awscli 创建此 policy：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">aws iam create-policy <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --policy-name XxxCertManagerRoute53Access <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --policy-document file://cert-manager-route53-access.json
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后通过上述配置创建一个 IAM Role 并自动给 cert-manager 所在的 EKS 集群添加信任关系：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">CLUSTER_NAME</span><span class="o">=</span><span class="s2">&#34;xxx&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">AWS_ACCOUNT_ID</span><span class="o">=</span><span class="s2">&#34;112233445566&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用 eksctl 自动创建对应的 role 并添加信任关系</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 需要先安装好 eksctl</span>
</span></span><span class="line"><span class="cl">eksctl create iamserviceaccount <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --cluster <span class="s2">&#34;</span><span class="si">${</span><span class="nv">CLUSTER_NAME</span><span class="si">}</span><span class="s2">&#34;</span> --name cert-manager --namespace cert-manager <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --role-name <span class="s2">&#34;</span><span class="si">${</span><span class="nv">CLUSTER_NAME</span><span class="si">}</span><span class="s2">-cert-manager-route53-role&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --attach-policy-arn <span class="s2">&#34;arn:aws:iam::</span><span class="si">${</span><span class="nv">AWS_ACCOUNT_ID</span><span class="si">}</span><span class="s2">:policy/&lt;ClusterName&gt;CertManagerRoute53Access&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --role-only <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --approve
</span></span></code></pre></td></tr></table>
</div>
</div><p>之后需要为 cert-manager 的 ServiceAccount 添加注解来绑定上面刚创建好的 IAM Role，首先创建如下 helm values 文件 <code>cert-manager-values.yaml</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># 如果把这个改成 false，也会导致 cert-manager 的所有 CRDs 及相关资源被删除！</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">installCRDs</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">serviceAccount</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">annotations</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 注意修改这里的 ${AWS_ACCOUNT_ID} 以及 ${CLUSTER_NAME}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">eks.amazonaws.com/role-arn</span><span class="p">:</span><span class="w"> </span><span class="p">&gt;-</span><span class="sd">
</span></span></span><span class="line"><span class="cl"><span class="sd">      </span><span class="w">      </span><span class="l">arn:aws:iam::${AWS_ACCOUNT_ID}:role/${CLUSTER_NAME}-cert-manager-route53-role</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">securityContext</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 根据官方文档，还得修改下这个，允许 cert-manager 读取 ServiceAccount Token，从而获得授权</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">fsGroup</span><span class="p">:</span><span class="w"> </span><span class="m">1001</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然后重新部署 cert-manager:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">helm upgrade -i cert-manager ./cert-manager -n cert-manager -f cert-manager-values.yaml
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样就完成了授权。</p>
<h5 id="112-创建一个使用-aws-route53-进行验证的-acme-issuer" class="headerLink">
    <a href="#112-%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e4%bd%bf%e7%94%a8-aws-route53-%e8%bf%9b%e8%a1%8c%e9%aa%8c%e8%af%81%e7%9a%84-acme-issuer" class="header-mark"></a>1.1.2 创建一个使用 AWS Route53 进行验证的 ACME Issuer</h5><p>在 xxx 名字空间创建一个 Iusser：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">cert-manager.io/v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Issuer</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">letsencrypt-prod-aws</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">xxx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">acme</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 用于接受域名过期提醒的邮件地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">email</span><span class="p">:</span><span class="w"> </span><span class="l">user@example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># ACME 服务器，比如 let&#39;s encrypt、Digicert 等</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># let&#39;s encrypt 的测试 URL，可用于测试配置正确性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># server: https://acme-staging-v02.api.letsencrypt.org/directory</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># let&#39;s encrypt 的正式 URL，有速率限制</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">server</span><span class="p">:</span><span class="w"> </span><span class="l">https://acme-v02.api.letsencrypt.org/directory</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 用于存放 ACME 账号私钥的 Secret 名称，Issuer 创建时会自动生成此 secret</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">privateKeySecretRef</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">letsencrypt-prod-aws</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># DNS 验证设置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">solvers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># 在有多个 solvers 的情况下，会根据每个 solvers 的 selector 来确定优先级，选择其中合适的 solver 来处理证书申请事件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># 以 dnsZones 为例，越长的 Zone 优先级就越高</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># 比如在为 www.sys.exapmle.com 申请证书时，sys.example.com 的优先级就比 example.com 更高</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">dnsZones</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="s2">&#34;example.com&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">dns01</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># 使用 route53 进行验证</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">route53</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">region</span><span class="p">:</span><span class="w"> </span><span class="l">us-east-1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="c"># cert-manager 已经通过 ServiceAccount 绑定了 IAM Role</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="c"># 这里不需要补充额外的 IAM 授权相关信息！</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="12-使用-alidns-创建一个证书签发者certificate-issuer" class="headerLink">
    <a href="#12-%e4%bd%bf%e7%94%a8-alidns-%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e8%af%81%e4%b9%a6%e7%ad%be%e5%8f%91%e8%80%85certificate-issuer" class="header-mark"></a>1.2 使用 AliDNS 创建一个证书签发者「Certificate Issuer」</h4><blockquote>
<p><a href="https://cert-manager.io/docs/configuration/acme/dns01/#webhook" target="_blank" rel="noopener noreferrer">https://cert-manager.io/docs/configuration/acme/dns01/#webhook</a></p>
</blockquote>
<p>cert-manager 官方并未提供 alidns 相关的支持，而是提供了一种基于 WebHook 的拓展机制。社区有第三方创建了对 alidns 的支持插件：</p>
<ul>
<li><a href="https://github.com/DEVmachine-fr/cert-manager-alidns-webhook" target="_blank" rel="noopener noreferrer">cert-manager-alidns-webhook</a></li>
</ul>
<p>下面我们使用此插件演示下如何创建一个证书签发者。</p>
<h5 id="111-通过-iam-授权-cert-manager-调用-aws-route53-api-1" class="headerLink">
    <a href="#111-%e9%80%9a%e8%bf%87-iam-%e6%8e%88%e6%9d%83-cert-manager-%e8%b0%83%e7%94%a8-aws-route53-api-1" class="header-mark"></a>1.1.1 通过 IAM 授权 cert-manager 调用 AWS Route53 API</h5><p>首先需要在阿里云上创建一个子账号，名字可以使用 <code>alidns-acme</code>，给它授权 DNS 修改权限，然后为该账号生成 ACCESS_KEY_ID/ACCESS_SECRET。</p>
<p>完成后，使用如下命令将 key/secret 内容创建为 secret 供后续步骤使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 注意替换如下命令中的 &lt;xxx&gt; 为你的 key/secret</span>
</span></span><span class="line"><span class="cl">kubectl -n cert-manager create secret generic alidns-secrets <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --from-literal<span class="o">=</span><span class="s2">&#34;access-token=&lt;your-access-key-id&gt;&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --from-literal<span class="o">=</span><span class="s2">&#34;secret-key=&lt;your-access-secret-key&gt;&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来需要部署 <a href="https://github.com/DEVmachine-fr/cert-manager-alidns-webhook" target="_blank" rel="noopener noreferrer">cert-manager-alidns-webhook</a> 这个 cert-manager 插件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 添加 helm 仓库</span>
</span></span><span class="line"><span class="cl">helm repo add cert-manager-alidns-webhook https://devmachine-fr.github.io/cert-manager-alidns-webhook
</span></span><span class="line"><span class="cl">helm repo update
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 安装插件</span>
</span></span><span class="line"><span class="cl"><span class="c1">## 其中的 groupName 是一个全局唯一的标识符，用于标识创建此 webhook 的组织，建议使用公司域名</span>
</span></span><span class="line"><span class="cl"><span class="c1">## groupName 必须与后面创建的 Issuer 中的 groupName 一致，否则证书将无法通过验证！</span>
</span></span><span class="line"><span class="cl">helm -n cert-manager install alidns-webhook <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  cert-manager-alidns-webhook/alidns-webhook <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --set <span class="nv">groupName</span><span class="o">=</span>example.com
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="112-创建一个使用-alidns-进行验证的-acme-issuer" class="headerLink">
    <a href="#112-%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e4%bd%bf%e7%94%a8-alidns-%e8%bf%9b%e8%a1%8c%e9%aa%8c%e8%af%81%e7%9a%84-acme-issuer" class="header-mark"></a>1.1.2 创建一个使用 AliDNS 进行验证的 ACME Issuer</h5><p>在 xxx 名字空间创建一个 Iusser：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">cert-manager.io/v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Issuer</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">letsencrypt-prod-alidns</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">xxx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">acme</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 用于接受域名过期提醒的邮件地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">email</span><span class="p">:</span><span class="w"> </span><span class="l">user@example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># ACME 服务器，比如 let&#39;s encrypt、Digicert 等</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># let&#39;s encrypt 的测试 URL，可用于测试配置正确性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># server: https://acme-staging-v02.api.letsencrypt.org/directory</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># let&#39;s encrypt 的正式 URL，有速率限制</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">server</span><span class="p">:</span><span class="w"> </span><span class="l">https://acme-v02.api.letsencrypt.org/directory</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 用于存放 ACME 账号私钥的 Secret 名称，Issuer 创建时会自动生成此 secret</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">privateKeySecretRef</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">letsencrypt-prod-alidns</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># DNS 验证设置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">solvers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># 在有多个 solvers 的情况下，会根据每个 solvers 的 selector 来确定优先级，选择其中合适的 solver 来处理证书申请事件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># 以 dnsZones 为例，越长的 Zone 优先级就越高</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># 比如在为 www.sys.exapmle.com 申请证书时，sys.example.com 的优先级就比 example.com 更高</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c"># 适用场景：如果你拥有多个域名，使用了多个域名提供商，就可能需要用到它</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">dnsZones</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span>- <span class="s2">&#34;example.com&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">dns01</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">webhook</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">config</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="nt">accessTokenSecretRef</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">access-token</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">alidns-secrets</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="nt">regionId</span><span class="p">:</span><span class="w"> </span><span class="l">cn-beijing</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="nt">secretKeySecretRef</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">secret-key</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">alidns-secrets</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c"># 这个 groupName 必须与之前部署插件时设置的一致！</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">groupName</span><span class="p">:</span><span class="w"> </span><span class="l">example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">solverName</span><span class="p">:</span><span class="w"> </span><span class="l">alidns-solver</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="13-通过-acme-创建证书" class="headerLink">
    <a href="#13-%e9%80%9a%e8%bf%87-acme-%e5%88%9b%e5%bb%ba%e8%af%81%e4%b9%a6" class="header-mark"></a>1.3 通过 ACME 创建证书</h4><blockquote>
<p><a href="https://cert-manager.io/docs/usage/certificate/#creating-certificate-resources" target="_blank" rel="noopener noreferrer">https://cert-manager.io/docs/usage/certificate/#creating-certificate-resources</a></p>
</blockquote>
<p>在创建证书前，先简单过一下证书的申请流程，示意图如下（出问题时需要靠这个来排查）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(  +---------+  )
</span></span><span class="line"><span class="cl">  (  | Ingress |  ) Optional                                              ACME Only!
</span></span><span class="line"><span class="cl">  (  +---------+  )
</span></span><span class="line"><span class="cl">         |                                                     |
</span></span><span class="line"><span class="cl">         |   +-------------+      +--------------------+       |  +-------+       +-----------+
</span></span><span class="line"><span class="cl">         |-&gt; | Certificate |----&gt; | CertificateRequest | ----&gt; |  | Order | ----&gt; | Challenge | 
</span></span><span class="line"><span class="cl">             +-------------+      +--------------------+       |  +-------+       +-----------+
</span></span><span class="line"><span class="cl">                                                               |
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用如下配置创建证书，并将证书保存到指定的 Secret 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">cert-manager.io/v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Certificate</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">example-com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">xxx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># Secret names are always required.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># Istio Gateway/Ingress/Gateway API 都可以通过直接引用这个 secret 来添加 TLS 加密。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">secretName</span><span class="p">:</span><span class="w"> </span><span class="l">tls-example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># secretTemplate is optional. If set, these annotations and labels will be</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># copied to the Secret named tls-example.com. These labels and annotations will</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># be re-reconciled if the Certificate&#39;s secretTemplate changes. secretTemplate</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># is also enforced, so relevant label and annotation changes on the Secret by a</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># third party will be overwriten by cert-manager to match the secretTemplate.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">secretTemplate</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">annotations</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">my-secret-annotation-1</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;foo&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">my-secret-annotation-2</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;bar&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">my-secret-label</span><span class="p">:</span><span class="w"> </span><span class="l">foo</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">duration</span><span class="p">:</span><span class="w"> </span><span class="l">2160h</span><span class="w"> </span><span class="c"># 90d</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">renewBefore</span><span class="p">:</span><span class="w"> </span><span class="l">360h</span><span class="w"> </span><span class="c"># 15d</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># https://cert-manager.io/docs/reference/api-docs/#cert-manager.io/v1.CertificatePrivateKey</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">privateKey</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">algorithm</span><span class="p">:</span><span class="w"> </span><span class="l">ECDSA </span><span class="w"> </span><span class="c"># RSA/ECDSA/Ed25519，其中 RSA 应用最广泛，Ed25519 被认为最安全</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">encoding</span><span class="p">:</span><span class="w"> </span><span class="l">PKCS1 </span><span class="w"> </span><span class="c"># 对于 TLS 加密，通常都用 PKCS1 格式</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">size</span><span class="p">:</span><span class="w"> </span><span class="m">256</span><span class="w">  </span><span class="c"># RSA 默认为 2048，ECDSA 默认为 256，而 Ed25519 不使用此属性！</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">rotationPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">Always </span><span class="w"> </span><span class="c"># renew 时总是重新创建新的私钥</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># The use of the common name field has been deprecated since 2000 and is</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># discouraged from being used.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">commonName</span><span class="p">:</span><span class="w"> </span><span class="l">example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># At least one of a DNS Name, URI, or IP address is required.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">dnsNames</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="l">example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="s1">&#39;*.example.com&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">isCA</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">usages</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="l">server auth</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="l">client auth</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># uris:  # 如果想在证书的 subjectAltNames 中添加 URI，就补充在这里</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c">#   - spiffe://cluster.local/ns/sandbox/sa/example</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># ipAddresses:  # 如果想在证书的 subjectAltNames 添加 ip 地址，就补充在这里</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c">#   - 192.168.0.5</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">subject</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 证书的补充信息</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 字段索引：https://cert-manager.io/docs/reference/api-docs/#cert-manager.io/v1.X509Subject</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">organizations</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">xxx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># Issuer references are always required.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">issuerRef</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">letsencrypt-prod-aws</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># name: letsencrypt-prod-alidns  # 如果你前面创建的是 alidns 那就用这个</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Issuer </span><span class="w"> </span><span class="c"># 如果你创建的是 ClusterIssuer 就需要改下这个值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">group</span><span class="p">:</span><span class="w"> </span><span class="l">cert-manager.io</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>部署好 Certificate 后，describe 它就能看到当前的进度：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Events: 
</span></span><span class="line"><span class="cl">  Type    Reason     Age   From    Message 
</span></span><span class="line"><span class="cl">  ----    ------     ----  ----    ------- 
</span></span><span class="line"><span class="cl">  Normal  Issuing    117s  cert-manager-certificates-trigger   Issuing certificate as Secret does not exist      
</span></span><span class="line"><span class="cl">  Normal  Generated  116s  cert-manager-certificates-key-manager      Stored new private key in temporary Secret resource &#34;example.com-f044j&#34;     
</span></span><span class="line"><span class="cl">  Normal  Requested  116s  cert-manager-certificates-request-manager  Created new CertificateRequest resource &#34;example.com-unv3d&#34;   
</span></span><span class="line"><span class="cl">  Normal  Issuing    20s   cert-manager-certificates-issuing   The certificate has been successfully issued
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果发现证书长时间未 Ready，可以参照<a href="https://cert-manager.io/docs/faq/acme/" target="_blank" rel="noopener noreferrer">官方文档 - Troubleshooting Issuing ACME Certificates</a>，按证书申请流程进行逐层排查：</p>
<ul>
<li>首先 cert-manager 发现 Certificate 描述的 Secret 不存在，于是启动证书申请流程</li>
<li>首先生成私钥，存放在一个临时 Secret 中</li>
<li>然后通过私钥以及 Certificate 资源中的其他信息，生成 CSR 证书申请请求文件
<ul>
<li>这也是一个 CRD 资源，可以通过 <code>kubectl get csr -n xxx</code> 查看</li>
</ul>
</li>
<li>接着将 CSR 文件提交给 ACME 服务器，申请权威机构签发证书
<ul>
<li>这对应 CRD 资源 <code>kubectl get order</code></li>
</ul>
</li>
<li>对于上述 ACME 证书申请流程，Order 实际上会生成一个 DNS1 Challenge 资源
<ul>
<li>可以通过 <code>kubectl get challenge</code> 检查此资源</li>
</ul>
</li>
<li>challenge 验证通过后会逐层往回走，前面的 Order CSR 状态都会立即变成 valid</li>
<li>最终证书签发成功，Certificate 状态变成 Ready，所有 Order CSR challenge 资源都被自动清理掉。</li>
</ul>
<h4 id="14-通过-csi-driver-创建证书" class="headerLink">
    <a href="#14-%e9%80%9a%e8%bf%87-csi-driver-%e5%88%9b%e5%bb%ba%e8%af%81%e4%b9%a6" class="header-mark"></a>1.4 通过 csi-driver 创建证书</h4><blockquote>
<p><a href="https://cert-manager.io/docs/projects/csi-driver/" target="_blank" rel="noopener noreferrer">https://cert-manager.io/docs/projects/csi-driver/</a></p>
</blockquote>
<p>直接使用 <code>Certificate</code> 资源创建的证书，会被存放在 Kubernetes Secrets 中，被认为并非足够安全。
而 cert-manager csi-driver 则避免了这个缺陷，具体而言，它提升安全性的做法有：</p>
<ul>
<li>确保私钥仅保存在对应的节点上，并挂载到对应的 Pod，完全避免私钥被通过网络传输。</li>
<li>应用的每个副本都使用自己生成的私钥，并且能确保在 Pod 的生命周期中证书跟私钥始终存在。</li>
<li>自动 renew 证书</li>
<li>副本被删除时，证书就会被销毁</li>
</ul>
<p>总的说 csi-driver 主要是用来提升安全性的，有需要可以自己看文档，就不多介绍了。</p>
<h3 id="2-通过私有-ca-颁发证书" class="headerLink">
    <a href="#2-%e9%80%9a%e8%bf%87%e7%a7%81%e6%9c%89-ca-%e9%a2%81%e5%8f%91%e8%af%81%e4%b9%a6" class="header-mark"></a>2. 通过私有 CA 颁发证书</h3><p>Private CA 是一种企业自己生成的 CA 证书，通常企业用它来构建自己的 PKI 基础设施。</p>
<p>在 TLS 协议这个应用场景下，Private CA 颁发的证书仅适合在企业内部使用，必须在客户端安装上这个 CA 证书，才能正常访问由它签名的数字证书加密的 Web API 或者站点。<strong>Private CA 签名的数字证书在公网上是不被信任的</strong>！</p>
<p>cert-manager 提供的 Private CA 服务有：</p>
<ul>
<li><a href="https://cert-manager.io/docs/configuration/vault/" target="_blank" rel="noopener noreferrer">Vault</a>: 鼎鼎大名了，Vault 是一个密码即服务工具，可以部署在 K8s 集群中，提供许多密码、证书相关的功能。
<ul>
<li>开源免费</li>
</ul>
</li>
<li><a href="https://github.com/cert-manager/aws-privateca-issuer" target="_blank" rel="noopener noreferrer">AWS Certificate Manager Private CA</a>: 跟 Vault 的 CA 功能是一致的，区别是它是托管的，由 AWS 负责维护。
<ul>
<li>每个 Private CA 证书：$400/month</li>
<li>每个签发的证书（仅读取了私钥及证书内容后才会收费）：按梯度一次性收费，0-1000 个以内是 $0.75 每个</li>
</ul>
</li>
<li>其他的自己看文档&hellip;</li>
</ul>
<p>这个因为暂时用不上，所以还没研究，之后有研究再给补上。</p>
<p>TO BE DONE.</p>
<h2 id="三cert-manager-与-istioingress-等网关集成" class="headerLink">
    <a href="#%e4%b8%89cert-manager-%e4%b8%8e-istioingress-%e7%ad%89%e7%bd%91%e5%85%b3%e9%9b%86%e6%88%90" class="header-mark"></a>三、cert-manager 与 istio/ingress 等网关集成</h2><p>cert-manager 提供的 <code>Certificate</code> 资源，会将生成好的公私钥存放在 Secret 中，而 Istio/Ingress 都支持这种格式的 Secret，所以使用还是挺简单的。</p>
<p>以 Istio Gateway 为例，直接在 Gateway 资源上指定 Secret 名称即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">networking.istio.io/v1alpha3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Gateway</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">example-gateway</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">istio</span><span class="p">:</span><span class="w"> </span><span class="l">ingressgateway</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">servers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">port</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">number</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">http</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">protocol</span><span class="p">:</span><span class="w"> </span><span class="l">HTTP</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">hosts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="l">product.example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">tls</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">httpsRedirect</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># sends 301 redirect for http requests</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">port</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">number</span><span class="p">:</span><span class="w"> </span><span class="m">8443</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">https</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">protocol</span><span class="p">:</span><span class="w"> </span><span class="l">HTTPS</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">tls</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">mode</span><span class="p">:</span><span class="w"> </span><span class="l">SIMPLE</span><span class="w"> </span><span class="c"># enables HTTPS on this port</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">credentialName</span><span class="p">:</span><span class="w"> </span><span class="l">tls-example.com</span><span class="w"> </span><span class="c"># This should match the Certificate secretName</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">hosts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="l">product.example.com</span><span class="w"> </span><span class="c"># This should match a DNS name in the Certificate</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">networking.istio.io/v1alpha3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">VirtualService</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">product</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">hosts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="l">product.example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">gateways</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="l">example-gateway</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">http</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">route</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">destination</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">host</span><span class="p">:</span><span class="w"> </span><span class="l">product</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">port</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">number</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">product</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">product</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">prod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">grpc</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">9090</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">protocol</span><span class="p">:</span><span class="w"> </span><span class="l">TCP</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">9090</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">http</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">protocol</span><span class="p">:</span><span class="w"> </span><span class="l">TCP</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">product</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">sessionAffinity</span><span class="p">:</span><span class="w"> </span><span class="l">None</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">ClusterIP</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">networking.istio.io/v1alpha3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">DestinationRule</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">product</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">host</span><span class="p">:</span><span class="w"> </span><span class="l">product</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 定义了两个 subset</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">subsets</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="l">v2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">v2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 其他 deployment 等配置</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>之后再配合 VirtualService 等资源，就可以将 Istio 跟 cert-manager 结合起来啦。</p>
<h2 id="四将-cert-manager-证书挂载到自定义网关中" class="headerLink">
    <a href="#%e5%9b%9b%e5%b0%86-cert-manager-%e8%af%81%e4%b9%a6%e6%8c%82%e8%bd%bd%e5%88%b0%e8%87%aa%e5%ae%9a%e4%b9%89%e7%bd%91%e5%85%b3%e4%b8%ad" class="header-mark"></a>四、将 cert-manager 证书挂载到自定义网关中</h2><blockquote>
<p>注意，千万别使用 <code>subPath</code> 挂载，根据<a href="https://kubernetes.io/docs/concepts/configuration/secret/#mounted-secrets-are-updated-automatically" target="_blank" rel="noopener noreferrer">官方文档</a>，这种方式挂载的 Secret 文件不会自动更新！</p>
</blockquote>
<p>既然证书被存放在 Secret 中，自然可以直接当成数据卷挂载到 Pods 中，示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">nginx:latest</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">tls-example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;/certs/example.com&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">readOnly</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">tls-example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">secret</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">secretName</span><span class="p">:</span><span class="w"> </span><span class="l">tls-example.com</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">optional</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="c"># default setting; &#34;mysecret&#34; must exist</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于 nginx 而言，可以简单地搞个 sidecar 监控下，有配置变更就 reload 下 nginx，实现证书自动更新。</p>
<p>或者可以考虑直接写个 k8s informer 监控 secret 的变更，有变更就直接 reload 所有 nginx 实例，总之实现的方式有很多种。</p>
<h2 id="五注意事项" class="headerLink">
    <a href="#%e4%ba%94%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9" class="header-mark"></a>五、注意事项</h2><p>服务端 TLS 协议的配置有许多的优化点，有些配置对性能的提升是很明显的，建议自行网上搜索相关资料，这里仅列出部分相关信息。</p>
<h3 id="ocsp-证书验证协议会大幅拖慢-https-协议的响应速度" class="headerLink">
    <a href="#ocsp-%e8%af%81%e4%b9%a6%e9%aa%8c%e8%af%81%e5%8d%8f%e8%ae%ae%e4%bc%9a%e5%a4%a7%e5%b9%85%e6%8b%96%e6%85%a2-https-%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%93%8d%e5%ba%94%e9%80%9f%e5%ba%a6" class="header-mark"></a>OCSP 证书验证协议会大幅拖慢 HTTPS 协议的响应速度</h3><blockquote>
<p><a href="https://www.ssl.com/blogs/how-do-browsers-handle-revoked-ssl-tls-certificates/" target="_blank" rel="noopener noreferrer">https://www.ssl.com/blogs/how-do-browsers-handle-revoked-ssl-tls-certificates/</a></p>
</blockquote>
<blockquote>
<p><a href="https://imququ.com/post/why-can-not-turn-on-ocsp-stapling.html" target="_blank" rel="noopener noreferrer">https://imququ.com/post/why-can-not-turn-on-ocsp-stapling.html</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.digicert.com/help/" target="_blank" rel="noopener noreferrer">https://www.digicert.com/help/</a></p>
</blockquote>
<p>前面提到除了数字证书自带的有效期外，为了在私钥泄漏的情况下，能够吊销对应的证书，PKI 公钥基础设施还提供了 OCSP（Online Certificate Status Protocol）证书状态查询协议。</p>
<p>可以使用如下命令测试，确认站点是否启用了 ocsp stapling:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ openssl s_client -connect www.digicert.com:443 -servername www.digicert.com -status -tlsextdebug &lt; /dev/null 2&gt;&amp;1 | grep -i &#34;OCSP response&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果输出包含 <code>OCSP Response Status: successful</code> 就说明站点支持 ocsp stapling，
如果输出内容为 <code>OCSP response: no response sent</code> 则说明站点不支持ocsp stapling。</p>
<blockquote>
<p>实际上 Google/AWS 等大多数站点都不会启用也不需要启用 ocsp stapling，一是因为它们自己就是证书颁发机构，OCSP 服务器也归它们自己管，不存在隐私的问题。二是它们的 OCSP 服务器遍布全球，也不存在性能问题。
这种情况下开个 OCSP Stapling 反而是浪费流量，因为每次 TLS 握手都得发送一个 OCSP 状态信息。</p>
</blockquote>
<blockquote>
<p>我测试发现只有 <a href="https://www.digicert.com/www.douban.com" target="_blank" rel="noopener noreferrer">www.digicert.com/www.douban.com</a> 等少数站点启用了 ocsp stapling，www.baidu.com/www.google.com/www.zhihu.com 都未启用 ocsp stapling.</p>
</blockquote>
<p>这导致了一些问题：</p>
<ul>
<li>Chrome/Firefox 等浏览器都会定期通过 OCSP 协议去请求 CA 机构的 OCSP 服务器验证证书状态，这可能会拖慢 HTTPS 协议的响应速度。
<ul>
<li>所谓的定期是指超过上一个 OCSP 响应的 <code>nextUpdate</code> 时间（一般为 7 天），或者如果该值为空的话，Firefox 默认 24h 后会重新查询 OCSP 状态。</li>
</ul>
</li>
<li>因为客户端直接去请求 CA 机构的 OCSP 地址获取证书状态，这就导致 CA 机构可以获取到一些对应站点的用户信息（IP 地址、网络状态等）。</li>
</ul>
<p>为了解决这两个问题，<a href="https://www.rfc-editor.org/rfc/rfc6066" target="_blank" rel="noopener noreferrer">rfc6066</a> 定义了 OCSP stapling 功能，它使服务器可以提前访问 OCSP 获取证书状态信息并缓存到本地，基本 Nginx/Caddy 等各大 Web 服务器或网关，都支持 OCSP stapling 协议。</p>
<p>在客户端使用 TLS 协议访问 HTTPS 服务时，服务端会直接在握手阶段将缓存的 OCSP 信息发送给客户端。
因为 OCSP 信息会带有 CA 证书的签名及有效期，客户端可以直接通过签名验证 OCSP 信息的真实性与有效性，这样就避免了客户端访问 OCSP 服务器带来的开销。</p>
<p>而另一个方法，就是选用 ocsp 服务器在目标用户区域速度快的 CA 机构签发证书。</p>
]]></content></entry><entry><title type="html">Death Is But a Dream</title><link href="https://thiscute.world/posts/death-is-but-a-dream/"/><id>https://thiscute.world/posts/death-is-but-a-dream/</id><author><name>ryan4yin</name></author><published>2022-05-24T02:17:00+08:00</published><updated>2022-05-24T02:17:00+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/death-is-but-a-dream/death-is-but-a-dream.webp" height="1100" width="619"><figcaption></figcaption>
        </figure><blockquote>
<p>我并不知道何时才是死期，<br>
却日日问自己，<br>
会不会有幽灵来牵我的手，<br>
引我一路向西？<br>
可他们看到的光明又在哪里？<br>
会不会也为我亮起？<br>
这一切快来吧，我已等不及！<br>
——《红色地带的沉思》 by 临终患者 Patricia</p>
</blockquote>
<p>我最近在看一本书，《在生命的尽头拥抱你-临终关怀医生手记》，它的英文原名即本文的标题。
李白在《春夜宴从弟桃花园序》中写「而浮生若梦，为欢几何？」，仿照下文法，本文的标题「Death Is But a Dream」大概可以直译成「临终若梦」，跟此书的中文版名称有些不同的韵味在。</p>
<p>这书讲的是死亡的过程——临终梦境。
随着年龄渐长，老一辈们慢慢老去，我们都不可避免地会越来越多地接触到死亡。
这世间轮替更迭，爱恨情仇是不变的主题，但是死亡始终是配角，实在是因为每人一生都只有唯一一次机会去真正体味死亡，难有实感。
而且死亡往往代表着终结，我们做为生者，当然更向往书写生者的世界。</p>
<p>救人一命胜造七级浮屠，珍爱生命是我们从小到大被教育的思想。
但是这样的思想却也造成了许多悲剧，全世界有许多的患者痛苦不堪地活在世上，求死不能，最终在病魔的折磨下凄惨离世，如果我们能谨慎承认「死亡」的价值，从这个角度看也是拯救了许多的患者与家庭。</p>
<p>而关于死亡，在我亲身经历的几次长辈葬礼中，我发现父辈们对死亡大都看得很开，他们说「人总有一死，老人家过世了我们当子女的肯定要送最后一程，但是不需要想太多，魂归天地罢了。」，我佩服这种豁达。</p>
<p>但是说到临终梦境，我是真的没什么了解。
我从来没跟长辈交流过生命末期的梦境，脑海中也挖掘不出相关的记忆。
送走我爷爷的时候，看着爷爷因为呼吸困难而大口喘气，堂哥跪在我前面，双眼泛红隐含泪光，但我完全没有实感——一切都显得那么不真实。
听着爷爷被痰堵塞气管、艰难的呼吸声，我甚至感到害怕，想要逃离。</p>
<p>爷爷过世后，奶奶就是一个人生活了，一个人起居、一个人给菜苗松土，然后在菜地里不小心跌了一跤，就随着爷爷去了。</p>
<blockquote>
<p>2023/1/7 补充：跟堂弟印照记忆后发现，这里我的记忆或许已经不对了&hellip;</p>
</blockquote>
<p>我后来在爷爷奶奶房里一个壁橱上，找到三四枚铜钱，还沾着泥土，有些锈蚀痕迹。
我把其中一枚通宝红线串好，贴身带了好几年，心情不好的时候就凝视着这枚铜钱黯然神伤，心情好的时候也要捂着它入睡。</p>
<p>我还喜欢上了戏曲，缠着同学读了她的《中国戏剧史》。
大学的时候又喜欢上越剧，吴侬软语。
又因为初中时学过点竹笛，喜欢上了传统乐曲，我对一些经典老歌也情有独钟。
在很多同学跟同事的眼中，我的音乐品味是很「独特」的，这或许都源自爷爷奶奶的熏陶。
实际上我小的时候并不喜欢戏剧，我跟爷爷奶奶去看庙戏的目的，通常都只是为了吃一碗凉粉，或者为了去玩耍、看个热闹。偶尔去爷爷奶奶家玩，也只是觉得他们太孤单了，跟他们随便聊聊天，实际上这么多年，跟爷爷奶奶看过的戏曲，我就没听懂过几句台词。</p>
<p>那是多少年前了呢？只知道是很多年前了，不仔细回忆回忆、掐指算算，都搞不清具体过了多少年月。
这么多个日日夜夜里，我幼稚过、热血过，也迷茫过、颓废过，倒也不算庸庸碌碌，我还是知足的，这种心态貌似是被称作现充 emmm</p>
<p>高三时曾经看过一本超级喜欢的励志书，这么多年来我一直带在身边，名字叫《这一生再也不会有的奇遇》。书的扉页只有一句话：「当明天再也不是无限，你还会像今天一样度过你的人生吗？」</p>
<figure><img src="/images/death-is-but-a-dream/an-adventure-that-will-never-happen-again-in-this-life_cover.webp"/><figcaption>
            <h4>《这一生再也不会有的奇遇》已陪我度过了七八个春秋</h4>
        </figcaption>
</figure>

<figure><img src="/images/death-is-but-a-dream/an-adventure-that-will-never-happen-again-in-this-life_title-page.webp"/><figcaption>
            <h4>当明天再也不是无限</h4>
        </figcaption>
</figure>

<p>写到这儿，我又想起我高中时还看过一本书《刺猬的优雅》，它同样陪伴我度过了四年大学岁月，后来又辗转到了深圳，但现在倒是不在身边。书中有几句话我印象深刻，放在这篇文章里也挺应景的：</p>
<blockquote>
<p>话又说回来，不能因为有想死的心，往后就要像烂菜帮一样的过日子，甚至应该完全相反。</p>
</blockquote>
<blockquote>
<p>重要的不是死亡，而是在死亡的那一刻我们在做什么。<br>
我在做什么呢？<br>
我曾遇到一个人，而且我正准备爱上他。</p>
</blockquote>
<p>随意写下这些文字，脑子里各种想法恣意流淌，我打算提前写写我的临终遗言，把一切都准备好。</p>
<p>但在死亡到来之前，我仍要精彩的活！</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://book.douban.com/subject/35435120/" target="_blank" rel="noopener noreferrer">《在生命的尽头拥抱你-临终关怀医生手记》</a></li>
<li><a href="https://www.youtube.com/watch?v=vh-nacCekR4" target="_blank" rel="noopener noreferrer">Death Is But A Dream (2021) Official trailer</a></li>
<li><a href="https://www.youtube.com/watch?v=rbnBe-vXGQM" target="_blank" rel="noopener noreferrer">I See Dead People: Dreams and Visions of the Dying | Dr. Christopher Kerr | TEDxBuffalo</a></li>
<li><a href="https://www.drchristopherkerr.com/tools" target="_blank" rel="noopener noreferrer">End-of-Life Experiences - Dr. Christopher Kerr</a></li>
<li><a href="https://www.zhihu.com/question/21174281/answer/122969510" target="_blank" rel="noopener noreferrer">有谁看过《刺猬的优雅》这本书吗？如何？ - 於清樂</a></li>
<li><a href="https://www.zhihu.com/question/52078970/answer/128900485" target="_blank" rel="noopener noreferrer">有什么人生中值得一读的小说或名著？（最好现代作家的书）？ - 於清樂</a></li>
</ul>
]]></content></entry><entry><title type="html">NAT 网关、NAT 穿越以及虚拟网络</title><link href="https://thiscute.world/posts/about-nat/"/><id>https://thiscute.world/posts/about-nat/</id><author><name>ryan4yin</name></author><published>2022-05-13T11:46:00+08:00</published><updated>2022-05-13T11:46:00+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/about-nat/nat.webp" height="728" width="250"><figcaption></figcaption>
        </figure><blockquote>
<p>个人笔记，不一定正确&hellip;</p>
</blockquote>
<blockquote>
<p>当前文章完成度 - 70%</p>
</blockquote>
<h2 id="前言" class="headerLink">
    <a href="#%e5%89%8d%e8%a8%80" class="header-mark"></a>前言</h2><p>NAT，即 Network Address Translation，是 IPv4 网络中非常重要的一个功能，用于执行 IP 地址与端口的转换。</p>
<p>IPv4 的设计者没预料到因特网技术的发展会如此之快，在设计时只使用了 32bits 的地址空间，随着因特网的飞速发展，它很快就变得不够用了。
后来虽然设计了新的 IPv6 协议，但是它与 IPv4 不兼容，需要新的硬件设备以及各种网络程序支持，无法快速普及。</p>
<p>NAT 就是在 IPv6 普及前，临时解决 IPv4 地址空间不够用而开发的技术，通俗地讲 NAT 就是用来给 IPv4 续命的。它解决 IPv4 地址短缺问题的方法是：</p>
<ul>
<li>每个家庭、组织、企业，在内部都使用局域网通讯，不占用公网 IPv4 资源</li>
<li>在局域网与上层网络的交界处（路由器），使用 NAT 技术进行 IP/port 转换，使用户能正常访问上层网络</li>
</ul>
<p>在曾经 IPv4 地址还不是特别短缺的时候，普通家庭的网络架构通常是：「家庭局域网」=&gt;「NAT 网关（家庭路由器）」=&gt;「因特网」。</p>
<p>但是互联网主要发展于欧美，因此许多欧美的组织与机构在初期被分配了大量的 IPv4 资源，而后入场的中国分配到的 IPv4 地址就不太能匹配上我们的人口。
因此相比欧美，中国的 IPv4 地址是非常短缺的，即使使用上述这样的网络架构——也就是给每个家庭（或组织）分配一个 IPv4 地址——都有点捉襟见肘了。
于是中国电信等运营商不得不再加一层 NAT，让多个家庭共用同一个 IP 地址，这时网络架构会变成这样：「家庭局域网」=&gt;「家庭 NAT 网关」=&gt;「运营商广域网」=&gt;「运营商 NAT 网关」=&gt;「公共因特网」。
由于此架构通过两层 NAT 网关串联了三个不同的 IPv4 网络，它也被形象地称为 <strong>NAT444</strong> 技术，详见 <a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E4%BF%A1%E7%BA%A7NAT" target="_blank" rel="noopener noreferrer">电信级NAT - 维基百科</a>。</p>
<blockquote>
<p><a href="https://v2ex.com/t/876430" target="_blank" rel="noopener noreferrer">据 v2ex 上传闻</a>因为 IPv4 地址紧缺，国内运营商甚至开始尝试使用 <strong>NAT4444</strong> 了，就是中间加两层运营商的私有网络&hellip;</p>
</blockquote>
<blockquote>
<p>不过 IPv6 也正在变得越来越流行，看 v2ex 上最近（2022-08）就很多人在聊，一些城市在试点 ipv4 over ipv6 隧道技术，底层完全换成 IPv6 协议加 IPoE 拨号了，带来的问题是没法桥接，详见 <a href="https://www.v2ex.com/t/875362" target="_blank" rel="noopener noreferrer">电信又一新动作：上网业务不再使用 PPPoE 新装宽带无法改桥接 - v2ex</a>。</p>
</blockquote>
<p>总的来说，NAT 是一项非常成功的技术，它成功帮 IPv4 续命了几十年，甚至到如今 2022 年，全球网络仍然是 IPv4 的天下。</p>
<h2 id="nat-如何工作" class="headerLink">
    <a href="#nat-%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c" class="header-mark"></a>NAT 如何工作</h2><p>NAT 的工作方式，使用图例描述是这样的：</p>
<figure><img src="/images/about-nat/NAT-demo.webp"/><figcaption>
            <h4>NAT 示例</h4>
        </figcaption>
</figure>

<p>从外部网络看一个 NAT 网关（一个启用了 NAT 的路由器），它只是拥有一个 IPv4 地址的普通设备，所有从局域网发送到公网的流量，其 IP 地址都是这个路由器的 WAN IP 地址，在上图中，这个 IP 地址是 <code>138.76.29.7</code>.</p>
<p>本质上，NAT 网关隐藏了家庭网络的细节，从外部网络上看，整个家庭网络就像一台普通的网络设备。</p>
<p>下面我们会学习到，上述这个 NAT 工作方式实际上是 NAPT，它同时使用 L3/L4 的信息进行地址转换工作。</p>
<h2 id="nat-的地址映射方式" class="headerLink">
    <a href="#nat-%e7%9a%84%e5%9c%b0%e5%9d%80%e6%98%a0%e5%b0%84%e6%96%b9%e5%bc%8f" class="header-mark"></a>NAT 的地址映射方式</h2><p>NAT 的具体实现有许多的变种，不存在统一的规范，但是大体上能分为两种模型：「一对一 NAT」与「一对多 NAT」，下面分别进行介绍。</p>
<h3 id="1-一对一-nat" class="headerLink">
    <a href="#1-%e4%b8%80%e5%af%b9%e4%b8%80-nat" class="header-mark"></a>1. 一对一 NAT</h3><p>一对一 NAT，这种类型的 NAT 在 <a href="https://datatracker.ietf.org/doc/html/rfc2663" target="_blank" rel="noopener noreferrer">RFC2663</a> 中被称为  Basic NAT。
它在技术上比较简单，只利用网络层的信息，对 IP 地址进行转换。</p>
<p>简单的说，Basic NAT 要求每个内网 IP 都需要绑定一个唯一的公网 IP，才能连通外部网络。</p>
<p>其<strong>主要应用场景是，公网用户需要访问到内网主机</strong>。</p>
<p>Basic NAT 有三种类型：「<strong>静态 NAT</strong>」、「<strong>动态 NAT</strong>」以及「<strong>NAT Server</strong>」。</p>
<p>现在的很多家庭路由器都自带一个被称为 DMZ 主机的功能，它是「Demilitarized Zone」的缩写，意为隔离区。
它允许将某一台内网主机设置为 DMZ 主机（或者叫隔离区主机，仅此主机可供外网访问），所有从外部进来的流量，都会被通过 Basic NAT 修改为对应的内网 IP 地址，然后直接发送到该主机。
路由器的这种 DMZ 技术就是「静态 NAT」，因为 DMZ 主机对应的内网 IP 需要手动配置，不会动态变化。</p>
<figure><img src="/images/about-nat/dmz-host-topology.webp"/><figcaption>
            <h4>DMZ 主机拓扑结构</h4>
        </figcaption>
</figure>

<p>而「<strong>动态 NAT</strong>」则需要一个公网 IP 地址池，每次用户需要访问公网时，动态 NAT 会给它分配一个动态公网 IP 并自动配置相应的 NAT 规则，使用完再回收。</p>
<p>第三种是「<strong>NAT Server</strong>」，云服务商提供的「<strong>公网 IP</strong>」就是通过「<strong>NAT Server</strong>」实现的，在云服务器中使用 <code>ip addr ls</code> 查看你会发现，该主机上实际只配了局域网 IP 地址，但是它却能正常使用公网 IP 通信，原因就是云服务商在「<strong>NAT Server</strong>」上为这些服务器配置了 IP 转发规则。
为一台云服务器绑定一个公网 IP，实际上就是请求「<strong>NAT Server</strong>」从公网 IP 地址池中取出一个，并配置对应的 NAT 规则到这台云服务器的局域网 IP。</p>
<p>示例如下，其中的 Internet Gateway 实际上就是个一对一 NAT Server：</p>
<figure><img src="/images/about-nat/aws-vpc-nat-internet-gateway.webp"/><figcaption>
            <h4>AWS VPC 中的 NAT 网关以及 Internet 网关</h4>
        </figcaption>
</figure>

<blockquote>
<p>云服务 VPC 中的公有子网，实际上就是一个 DMZ(Demilitarized Zone) 隔离区，是不安全的。而私有子网则是安全区，公网无法直接访问到其中的主机。</p>
</blockquote>
<p>而「动态 NAT」则需要路由器维护一个<strong>公网 IP 地址池</strong>，内网服务器需要访问公网时，动态 NAT 就从地址池中拿出一个公网 IP 给它使用，用完再回收。
这种场景需要一个公网 IP 地址池，每当内部有服务需要请求外网时，就动态地为它分配一个公网 IP 地址，使用完再回收。</p>
<p>Basic NAT 的好处是，它仅工作在 L3 网络层，网络层上的协议都可以正常使用（比如 P2P），不需要啥「内网穿越」技术。</p>
<h3 id="2-一对多-nat---napt" class="headerLink">
    <a href="#2-%e4%b8%80%e5%af%b9%e5%a4%9a-nat---napt" class="header-mark"></a>2. 一对多 NAT - NAPT</h3><p>一对多 NAT，也被称为 NAPT（network address and port translation），同样在 <a href="https://datatracker.ietf.org/doc/html/rfc2663#section-4.0" target="_blank" rel="noopener noreferrer">RFC2663</a> 中被定义。Easy IP 是 NAPT 的一个特殊形式。</p>
<p><strong>NAPT 的主要应用场景是，内网用户需要访问到公网主机</strong>。绝大多数的家庭网络、办公网络都是 NAPT 类型的。
原因应该很好理解——家庭网络或办公网络都包含许多联网设备，但是这类网络通常只有一个或数个公网 IP，使用一对一 NAT 的话公网 IP 显然是不够用的，所以需要使用一对多 NAT.</p>
<p>NAPT 通过同时利用 L3 的 IP 信息，以及 L4 传输层的端口信息，来为局域网设备提供透明的、配置方便的、支持超高并发连接的外部网络通信，示意图如下：</p>
<figure><img src="/images/about-nat/napt.webp"/>
</figure>

<p>NAPT 的端口分配与转换规则（<strong>Mapping Behavior</strong>）以及对外来流量的过滤规则（<strong>Filtering Behavior</strong>）都存在许多不同的实现，没有统一的规范与标准，但是存在两种分类规范，这种分类方法主要用在 NAT 穿越技术中。</p>
<h4 id="rfc3489-定义的-nat-类型四种" class="headerLink">
    <a href="#rfc3489-%e5%ae%9a%e4%b9%89%e7%9a%84-nat-%e7%b1%bb%e5%9e%8b%e5%9b%9b%e7%a7%8d" class="header-mark"></a>RFC3489 定义的 NAT 类型（四种）</h4><p>在 <a href="https://datatracker.ietf.org/doc/html/rfc3489#section-5" target="_blank" rel="noopener noreferrer">RFC3489</a> 中将 NAPT 分为四种类型，这也是应用最为广泛的 NAT 分类方法，如下图：</p>
<figure><img src="/images/about-nat/nat-types-defined-in-stun.webp"/>
</figure>

<p>下面我们逐一介绍这四种不同的 NAPT 类型。</p>
<blockquote>
<p>从这里开始，下文中的 NAT 特指 NAPT，如果涉及「一对一 NAT」会使用它的全名。</p>
</blockquote>
<h5 id="1-full-cone-nat" class="headerLink">
    <a href="#1-full-cone-nat" class="header-mark"></a>1. Full-cone NAT</h5><p>Full-cone NAT 的特点如下：</p>
<ul>
<li>数据包流出：一旦内部地址（iAddr:iPort）映射到外部地址（eAddr:ePort），所有发自 iAddr:iPort 的数据包都经由 eAddr:ePort 向外发送。</li>
<li>数据包流入：任意主机发送到 eAddr:ePort 的数据包，都能通过 NAT 到达 iAddr:iPort.
<ul>
<li>也就是不对外部进来的数据做任何限制，全部放行。</li>
<li>cone 圆锥，个人理解是一个比喻，任意发送进来的数据（多），都能通过 NAT 到达这个内部地址（一），就像一个圆锥。</li>
</ul>
</li>
</ul>
<p>允许任意主机发送到 eAddr:ePort 的数据到达内部地址是很危险的行为，因为内部主机不一定配置了合适的安全策略。
因此 <strong>Full-cone NAT 比较少见</strong>，就算路由器等 NAT 设备支持 Full-cone NAT，通常也不会是默认选项。我们会在后面更详细地介绍它。</p>
<h5 id="2-address-restricted-cone-nat" class="headerLink">
    <a href="#2-address-restricted-cone-nat" class="header-mark"></a>2. (Address-)Restricted cone NAT</h5><ul>
<li>数据包流出：（跟 Full-cone NAT 完全一致）一旦内部地址（iAddr:iPort）映射到外部地址（eAddr:ePort），所有发自 iAddr:iPort 的数据包都经由 eAddr:ePort 向外发送。</li>
<li>数据包流入：只有内部地址（iAddr:iPort）主动连接过的<strong>外部主机</strong>（nAddr:<strong>any</strong>），发送到 eAddr:ePort 的数据包，才能通过 NAT 到达 iAddr:iPort.
<ul>
<li>跟 Full-cone NAT 的区别在于，它<strong>限制了外部主机的 IP 地址</strong>。只有主动连接过的主机，才能发送数据到 NAT 内部。这<strong>提升了一些安全性</strong>。</li>
</ul>
</li>
</ul>
<h5 id="3-port-restricted-cone-nat" class="headerLink">
    <a href="#3-port-restricted-cone-nat" class="header-mark"></a>3. Port-Restricted cone NAT</h5><ul>
<li>数据包流出：（跟 Full-cone NAT 完全一致）一旦内部地址（iAddr:iPort）映射到外部地址（eAddr:ePort），所有发自 iAddr:iPort 的数据包都经由 eAddr:ePort 向外发送。</li>
<li>数据包流入：只有内部地址（iAddr:iPort）主动连接过的<strong>外部程序</strong>（nAddr:<strong>nPort</strong>），发送到 eAddr:ePort 的数据包，才能通过 NAT 到达 iAddr:iPort.
<ul>
<li>与 Address-Restricted cone NAT 的区别在于，它<strong>同时限制了外部主机的 IP 与端口</strong>，可以说是更<strong>进一步地提升了安全性</strong>。</li>
</ul>
</li>
</ul>
<h5 id="4-symmetric-nat" class="headerLink">
    <a href="#4-symmetric-nat" class="header-mark"></a>4. Symmetric NAT</h5><ul>
<li>数据包流出：同一个内部地址（iAddr:iPort）与不同外部主机（nAddr:nPort）的通信，会随机使用不同的 NAT 外部端口（eAddr:<strong>randomPort</strong>）。也就是说内部地址与 NAT 外部地址的关系也是<strong>一对多</strong>！
<ul>
<li>为每个连接都随机选择一个不同的 NAT 端口，这实际是进一步强化了 NAT 内网的安全性。<strong>但这也是 NAT 穿越最大的难点——它导致 Symmetric NAT 的端口难以预测</strong>！</li>
</ul>
</li>
<li>数据包流入：只有内部地址（iAddr:iPort）主动连接过的外部程序（nAddr:nPort），发送到 eAddr:ePort 的数据包，才能通过 NAT 到达 iAddr:iPort.
<ul>
<li>这个数据流入规则，与 Port-Restricted cone NAT 是完全一致的。</li>
</ul>
</li>
</ul>
<p><strong>对称 NAT 是最安全的一种 NAT 结构，限制最为严格，应该也是应用最广泛的 NAT 结构</strong>。
但是它导致所有的 TCP 连接都只能由从内部主动发起，外部发起的 TCP 连接请求会直接被 NAT 拒绝，因此它也是 P2P 玩家最头疼的一种 NAT 类型。
解决方案是通过 UDP 迂回实现连接的建立，我们会在后面讨论这个问题。</p>
<h5 id="5-linux-中的-napt" class="headerLink">
    <a href="#5-linux-%e4%b8%ad%e7%9a%84-napt" class="header-mark"></a>5. Linux 中的 NAPT</h5><p>Linux 的网络栈中，可通过 <code>iptables/netfilter</code> 的 <code>SNAT/MASQUERADE</code> 实现 NAPT 网关，这种方式只能实现一个 Symmetric NAT.</p>
<p>也就是说绝大多数基于 Linux 实现的家庭局域网、Docker 虚拟网络、Kubernetes 虚拟网络、云服务的虚拟网络，都是 Symmetric NAT.</p>
<p>只有一些有 Full-cone NAT 需求的网吧、ISP 的 LSN(Large Scale NAT) 网关等组织，会使用非 Linux 内核的企业级路由器提供 Full-cone NAT 能力，这些设备可能是基于 FPGA 等专用芯片设计的。</p>
<p>想要将 Symmetric NAT 内的主机提供给外部访问，只能通过端口映射、一对一 NAT 等方式实现，后面会详细介绍这些方法。</p>
<h4 id="rfc5389-定义的-nat-类型九种" class="headerLink">
    <a href="#rfc5389-%e5%ae%9a%e4%b9%89%e7%9a%84-nat-%e7%b1%bb%e5%9e%8b%e4%b9%9d%e7%a7%8d" class="header-mark"></a>RFC5389 定义的 NAT 类型（九种）</h4><p>RFC3489 这个早期 RFC 存在一些问题，问题之一就是它对 NAT 归类过于笼统，很多 NAPT 网关都无法很好的匹配上其中某个类别。</p>
<p>于是后来，RFC3489 被废弃并由 <a href="https://www.rfc-editor.org/rfc/rfc5389" target="_blank" rel="noopener noreferrer">RFC5389</a> 来替代，在 RFC5389 中，将 Mapping Behavior（映射规则）和 Filtering Behavior（过滤规则）分开来，定义了 3 种 Mapping Behavior（映射规则）和 3 种 Filtering Behavior（过滤规则），一共有 9 种组合。</p>
<h5 id="1-映射规则" class="headerLink">
    <a href="#1-%e6%98%a0%e5%b0%84%e8%a7%84%e5%88%99" class="header-mark"></a>1. 映射规则</h5><p>三种映射规则如图所示，假设一个内网主机 HostX 的内网 IP 地址为 X，端口号为 x，经 NAT 映射后的外网 IP 地址为 M，端口号为 m。为方便描述，将内网的 Endpoint 记为 <code>Endpoint(X,x)</code>，映射后外网的 Endpoint 记为 <code>Endpoint(M,m)</code>。内网 <code>Endpoint(X,x)</code> 发往外网 HostD1 的 IP 地址和端口号记为目的 <code>Endpoint(D1,d1)</code>；发往外网 HostD2 的 IP 地址和端口号记为目的 <code>Endpoint(D2,d2)</code>。</p>
<figure><img src="/images/about-nat/rfc5389-mapping-behavior.webp"/><figcaption>
            <h4>NAT 映射规则</h4>
        </figcaption>
</figure>

<ul>
<li><strong>EIM</strong>(Endpoint-Independent Mapping) 外部地址无关映射
<ul>
<li>对于一个内网 <code>Endpoint(X,x)</code>，其映射的外网 <code>Endpoint(M,m)</code> 是固定的。即从相同的 <code>Endpoint(X,x)</code> 发送到任何外部 IP 地址和任何外部端口的报文在 NAT 设备上使用相同的映射。</li>
</ul>
</li>
<li><strong>ADM</strong>(Address-Dependent Mapping) 外部地址相关映射：对于一个内网 <code>Endpoint(X,x)</code>，发往目的 <code>Endpoint(D1,d1)</code> 的报文，<code>Endpoint(X,x)</code> 被映射成 <code>Endpoint(M1,m1)</code>；发往目的 <code>Endpoint(D2,d2)</code> 的报文，<code>Endpoint(X,x)</code> 被映射成 <code>Endpoint(M2,m2)</code>。只要D1=D2，不管d1和d2是多少，都有 <code>Endpoint(M1,m1)=Endpoint(M2,m2)</code>。即从相同的 <code>Endpoint(X,x)</code> 发送到相同外部 IP 地址和任何外部端口的报文在 NAT 设备上使用相同的映射。</li>
<li><strong>APDM</strong>（Address and Port-Dependent Mapping）外部地址和端口相关映射：对于一个内网 <code>Endpoint(X,x)</code>，发往目的 <code>Endpoint(D1,d1)</code> 的报文，<code>Endpoint(X,x)</code> 被映射成 <code>Endpoint(M1,m1)</code>；发往目的 <code>Endpoint(D2,d2)</code> 的报文， <code>Endpoint(X,x)</code> 被映射成 <code>Endpoint(M2,m2)</code>。只有当D1=D2，且d1=d2，才有 <code>Endpoint(M1,m1)=Endpoint(M2,m2)</code>。即从相同的 Endpoint(X,x) 发送到相同外部IP地址和相同外部端口的报文在NAT设备上使用相同的映射。</li>
</ul>
<h5 id="2-过滤规则" class="headerLink">
    <a href="#2-%e8%bf%87%e6%bb%a4%e8%a7%84%e5%88%99" class="header-mark"></a>2. 过滤规则</h5><figure><img src="/images/about-nat/rfc5389-filtering-behavior.webp"/><figcaption>
            <h4>NAT 过滤规则</h4>
        </figcaption>
</figure>

<ul>
<li>
<p><strong>EIF</strong>（Endpoint-Independent Filtering）外部地址无关过滤：对于一个内网 <code>Endpoint(X,x)</code>，只要它曾经向外网发送过数据，外网主机就可以获取到它经 NAT 映射后的外网 <code>Endpoint(M,m)</code> 。那么只要是发给 <code>Endpoint(M,m)</code> 的报文，不管来源于 D1 还是 D2，都能被转换并发往内网，其他报文被过滤掉。</p>
</li>
<li>
<p><strong>ADF</strong>（Address-Dependent Filtering）外部地址相关过滤：对于一个内网 <code>Endpoint(X,x)</code> ，只有它曾经向 IP 地址为 D1 的外网主机发送过报文，那么来自外网 HostD1 返回的任何端口的报文，都能被转换并发往内网，其他报文被过滤掉。</p>
</li>
<li>
<p><strong>APDF</strong>（Address and Port-Dependent Filtering）外部地址和端口相关过滤：对于一个内网 <code>Endpoint(X,x)</code> ，只有它曾经向 IP 地址为 D1，端口号为 d1 的外网目的 <code>Endpoint(D1,d1)</code> 发送过报文，那么也只有外网 HostD1 中来自<code>Endpoint(D1,d1)</code>返回的报文，才能被转换并发往内网，其他报文被过滤掉。</p>
</li>
</ul>
<h5 id="3-rfc3489-与-rfc5389-的-nat-类型定义关系" class="headerLink">
    <a href="#3-rfc3489-%e4%b8%8e-rfc5389-%e7%9a%84-nat-%e7%b1%bb%e5%9e%8b%e5%ae%9a%e4%b9%89%e5%85%b3%e7%b3%bb" class="header-mark"></a>3. RFC3489 与 RFC5389 的 NAT 类型定义关系</h5><ul>
<li>Full Cone NAT 是 EIM 和 EIF 的组合。</li>
<li>Restricted Cone NAT 是 EIM 和 ADF 的组合。</li>
<li>Port Restricted Cone NAT 是 EIM 和 APDF 的组合。</li>
<li>Symmetric NAT 是 APDM 和 APDF 的组合。</li>
</ul>
<h2 id="nat-的弊端" class="headerLink">
    <a href="#nat-%e7%9a%84%e5%bc%8a%e7%ab%af" class="header-mark"></a>NAT 的弊端</h2><ul>
<li><strong>IP 会话的保持时效变短</strong>：NAT 需要维护一个会话列表，如果会话静默时间超过一个阈值，将会被从列表中移除。
<ul>
<li>为了避免这种情况，就需要定期发送心跳包来维持 NAT 会话。俗称心跳保活</li>
</ul>
</li>
<li><strong>IP 跟踪机制失效</strong>：一对多 NAT 使得多个局域网主机共用一个公网 IP，这导致基于公网 IP 进行流量分析的逻辑失去意义。
<ul>
<li>比如很多站点都加了基于 IP 的访问频率限制，这会造成局域网内多个用户之间的服务抢占与排队。</li>
</ul>
</li>
<li><strong>NAT 的工作机制依赖于修改IP包头的信息，这会妨碍一些安全协议的工作</strong>。
<ul>
<li>因为 NAT 篡改了 IP 地址、传输层端口号和校验和，这会导致 IP 层的认证协议彻底不能工作，因为认证目的就是要保证这些信息在传输过程中没有变化。</li>
<li>对于一些隧道协议，NAT 的存在也导致了额外的问题，因为隧道协议通常用外层地址标识隧道实体，穿过 NAT 的隧道会有 IP 复用关系，在另一端需要小心处理。</li>
<li>ICMP 是一种网络控制协议，它的工作原理也是在两个主机之间传递差错和控制消息，因为IP的对应关系被重新映射，ICMP 也要进行复用和解复用处理，很多情况下因为 ICMP 报文载荷无法提供足够的信息，解复用会失败。</li>
<li>IP 分片机制是在信息源端或网络路径上，需要发送的 IP 报文尺寸大于路径实际能承载最大尺寸时，IP 协议层会将一个报文分成多个片断发送，然后在接收端重组这些片断恢复原始报文。IP 这样的分片机制会导致传输层的信息只包括在第一个分片中，NAT难以识别后续分片与关联表的对应关系，因此需要特殊处理。</li>
</ul>
</li>
</ul>
<h2 id="nat-穿越---nat-traversal" class="headerLink">
    <a href="#nat-%e7%a9%bf%e8%b6%8a---nat-traversal" class="header-mark"></a>NAT 穿越 - NAT Traversal</h2><p>天下苦 NAT 久矣，尤其是对各种 P2P 玩家，如 NAS 玩家、P2P 游戏玩家，以及需要搭建 VPN 虚拟私有网络的网络管理员而言。
在常见的联机游戏、BitTorrent 文件共享协议、P2P 聊天等点对点通讯场景中，通讯双方客户端通常都运行在家庭局域网中，也就是说中间隔着两层家庭路由器的 NAT，路由器的默认配置都是安全优先的，存在很多安全限制，直接进行 P2P 通讯大概率会失败。</p>
<p>为了穿越这些 NAT 网关进行 P2P 通讯，就需要借助 <a href="https://en.wikipedia.org/wiki/NAT_traversal" target="_blank" rel="noopener noreferrer">NAT 穿越技术</a>。</p>
<blockquote>
<p>这里讨论的前提是，你的网络只有单层 NAT，如果外部还存在公寓 NAT、ISP 广域网 NAT，那下面介绍的 NAT 提升技术实际上就没啥意义了。</p>
</blockquote>
<h3 id="1-dmz-主机或者定向-dnat-转发" class="headerLink">
    <a href="#1-dmz-%e4%b8%bb%e6%9c%ba%e6%88%96%e8%80%85%e5%ae%9a%e5%90%91-dnat-%e8%bd%ac%e5%8f%91" class="header-mark"></a>1. 「DMZ 主机」或者「定向 DNAT 转发」</h3><p>最简单的方法是 DMZ 主机功能，前面已经介绍过了，DMZ 可以直接给内网服务器绑定路由器的外部 IP，从该 IP 进来的所有流量都会直接被发送给这台内网服务器。
被指定的 DMZ 主机，其 NAT 类型将从 NAPT 变成一对一 NAT，而一对一 NAT 对 P2P 通讯而言是透明的，这样就可以愉快地玩耍了。</p>
<p>在 Linux 路由器上实现类似 DMZ 的功能，只需要两行 iptables 命令，这可以称作「定向 DNAT 转发」：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE <span class="c1"># 普通的SNAT</span>
</span></span><span class="line"><span class="cl">iptables -t nat -A PREROUTING -i eth0 -j DNAT --to-destination 192.168.1.3 <span class="c1"># 将入站流量DNAT转发到内网主机192.168.1.3</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这两项技术的缺点是只能将一台主机提供给外网访问，而且将整台主机开放到公网实际上是很危险的，如果不懂网络<strong>很容易被黑客入侵</strong>。</p>
<h3 id="2-静态端口转发" class="headerLink">
    <a href="#2-%e9%9d%99%e6%80%81%e7%ab%af%e5%8f%a3%e8%bd%ac%e5%8f%91" class="header-mark"></a>2. 静态端口转发</h3><p>退一步，可以直接用静态端口转发功能，就是在路由器上手动设置某个端口号的所有 TCP/UDP 流量，都直接 NAT 转发到到内网的指定地址。也就是往 NAT 的转发表中手动添加内容，示意图：</p>
<figure><img src="/images/about-nat/NAPT-en.svg"/><figcaption>
            <h4>NAPT tables</h4>
        </figcaption>
</figure>

<p>设置好端口转发后，只要使用的是被设定的端口，NAT 对 P2P 通信而言将完全透明。
绝大多数路由器都支持这项功能，NAS 发烧友们想玩 P2P 下载分享，基本都是这么搞的。</p>
<h3 id="3-upnp-动态端口转发" class="headerLink">
    <a href="#3-upnp-%e5%8a%a8%e6%80%81%e7%ab%af%e5%8f%a3%e8%bd%ac%e5%8f%91" class="header-mark"></a>3. UPnP 动态端口转发</h3><blockquote>
<p>最流行的 UPnP 实现是 <a href="https://github.com/miniupnp/miniupnp" target="_blank" rel="noopener noreferrer">https://github.com/miniupnp/miniupnp</a></p>
</blockquote>
<p>静态端口转发对用户的技术要求较高，我作为一个网络小白，希望有一个傻瓜式的开关能让我愉快地玩耍 Xbox/PS5 联机游戏，该怎么办呢？
你需要的只是在路由器上启用 UPnP(Universal Plug and Play) 协议，启用它后，内网游戏设备就可以通过 UPnP 向路由器动态申请一个端口号供其使用，UPnP 会自动配置对应的端口转发规则。
<strong>现在新出的路由器基本都支持 UPnP 功能，它是最简单有效的 NAT 提升方式</strong>。</p>
<p>UPnP 解决了「静态端口转发」需要手动配置的问题，在启用了 UPnP 后，对所有支持 UPnP 的内网程序而言，NAT 类型将提升到 Full-cone NAT.</p>
<h3 id="4-nat-穿越协议---stunturnice" class="headerLink">
    <a href="#4-nat-%e7%a9%bf%e8%b6%8a%e5%8d%8f%e8%ae%ae---stunturnice" class="header-mark"></a>4. NAT 穿越协议 - STUN/TURN/ICE</h3><p>如果很不幸前面提到的「DMZ 主机」/「静态端口转发」/「UPnP」 三项技术，你的路由器都不支持，那你就只能借助 NAT 穿越协议了。</p>
<p>目前有如下几个 NAT 穿越协议标准：</p>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc3489" target="_blank" rel="noopener noreferrer">RFC3489</a> Classic STUN
<ul>
<li>Classic STUN 是一个早期的 STUN 规范，它定义了一整套完整的 NAT 穿越方案，但是因为存在许多问题，已经被废弃。</li>
</ul>
</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc5389" target="_blank" rel="noopener noreferrer">RFC5389 - Simple Traversal of UDP Through NATs (STUN)</a>
<ul>
<li>RFC5389 所定义的 STUN 协议是对 Classic STUN 的改进，它的定位不再是一个完整的 NAT 穿越解决方案，而是作为其他协议（例如SIP、FTP、DNS）处理 NAT 穿越问题的一个工具。</li>
<li>其可以用于检查网络中NAT设备的存在，并确定两个通信端点被NAT设备分配的IP地址和端口号。然后，通过ICE（Interactive Connectivity Establishment），自动创建一条能够进行NAT穿越的数据通道。</li>
<li>STUN 支持除 Symmetric NAT 之外的另外三种 NAT 类型</li>
</ul>
</li>
<li><a href="https://tools.ietf.org/html/rfc5766" target="_blank" rel="noopener noreferrer">RFC5766 - Traversal Using Relays around NAT (TURN)</a>
<ul>
<li>TURN 在 STUN 协议之上添加了一个中继，以确保在无法实现 NAT 穿越的情况下，可以 fallback 到直接使用中继服务器进行通信。</li>
<li>这个中继的原理类似反向代理，单纯负责数据的转发</li>
<li>在美国有一项数据表示在进行 P2P 穿越的时候，穿越成功的概率为 70%，但是在国内这个成功率 50% 可能都到不了。因此就有必要使用 TURN 协议，这样才能保证在穿越失败的情况下，用户仍然能正常通信。</li>
</ul>
</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8445" target="_blank" rel="noopener noreferrer">RFC8445 - Interactive Connectivity Establishment (ICE)</a>
<ul>
<li>一个 NAT 穿越的协商协议，它统一了 STUN 与 TURN 两种协议，会尝试遍历所有可能的连接方案。</li>
</ul>
</li>
</ul>
<p>总的来说，标准的 NAT 穿越协议优先使用打洞（<strong><a href="https://en.wikipedia.org/wiki/Hole_punching_%28networking%29" target="_blank" rel="noopener noreferrer">NAT Hole Pounching</a></strong>）技术，如果打洞失败，就使用中继服务器技术兜底，确保能成功穿越。</p>
<h4 id="stunturnice-的-nat-类型检测" class="headerLink">
    <a href="#stunturnice-%e7%9a%84-nat-%e7%b1%bb%e5%9e%8b%e6%a3%80%e6%b5%8b" class="header-mark"></a>STUN/TURN/ICE 的 NAT 类型检测</h4><p>RFC5389 定义了对 NAT 映射类型以及过滤类型的检测方法。</p>
<p>TBD</p>
<h4 id="stunturnice-协议如何实现-nat-打洞" class="headerLink">
    <a href="#stunturnice-%e5%8d%8f%e8%ae%ae%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0-nat-%e6%89%93%e6%b4%9e" class="header-mark"></a>STUN/TURN/ICE 协议如何实现 NAT 打洞</h4><p>首先 P2P 双方如果只隔着 0-1 层 NAT，那是不需要使用 NAT 打洞技术的，可以直连或者反向连接。</p>
<p>下面就讨论下 P2P 双方隔着 2 层及以上 NAT 的场景下，如何利用 UDP 协议实现 NAT 打洞。</p>
<p>一个完整的 NAT 打洞方案，需要包含如下功能：</p>
<ul>
<li>A 跟 B 需要知道对方的公网 IP 以及监听的端口号
<ul>
<li>解决方法：需要一个公网<strong>中介</strong>来介绍双方认识（交换 IP/port）</li>
</ul>
</li>
<li>NAT 连通性测试，需要借助公网主机，<strong>检测双方中间网络的类型</strong></li>
<li>针对不同的 NAT 类型，存在哪些穿越手段？以何种顺序进行<strong>穿越尝试</strong>？</li>
</ul>
<p>NAT 打洞可以使用 UDP/TCP 两种 L4 协议，但是 TCP 面向连接的特性使它在这个场景中限制性更大（具体限制见参考文章，我有空再补充），因此各种 NAT 穿越协议通常都基于 UDP 实现。</p>
<p>此外，因为 NAT 的具体行为是非标准化的，路由器的防火墙策略也存在很大变动空间，再有就是 RF3489 的这种 NAT 分类方法不够精确，这些因素导致 NAT 穿透能否成功通常都是谈概率。</p>
<h5 id="1-a-与-b-在同一局域网中" class="headerLink">
    <a href="#1-a-%e4%b8%8e-b-%e5%9c%a8%e5%90%8c%e4%b8%80%e5%b1%80%e5%9f%9f%e7%bd%91%e4%b8%ad" class="header-mark"></a>1. A 与 B 在同一局域网中</h5><p>这是最简单的情况，最佳方案是直接走内网通讯，不经过 NAT.</p>
<p>第二个方案是，这两个同一局域网内的客户端不走内网，仍然通过 NAT 通讯。这种通讯方式被称作「回环 NAT(Loopback NAT)」或者「发夹 NAT(Hairpin NAT)」。
对于不支持或未启用「Hairpin NAT」的网关设备而言，这样的通讯尝试将会失败！</p>
<h5 id="2-a-与-b-分别在不同的局域网中" class="headerLink">
    <a href="#2-a-%e4%b8%8e-b-%e5%88%86%e5%88%ab%e5%9c%a8%e4%b8%8d%e5%90%8c%e7%9a%84%e5%b1%80%e5%9f%9f%e7%bd%91%e4%b8%ad" class="header-mark"></a>2. A 与 B 分别在不同的局域网中</h5><p>这样实际上 A 与 B 中间就隔了两个 NAT 网关，这是最普遍的一种情况。</p>
<p>STUN/TURN 的 NAT 穿透流程大致如下：</p>
<ul>
<li>首先，A 跟 B 两个程序启动时，需要把自己的内外网 IP 及端口信息上报到一台中介服务器 S</li>
<li>现在假设 A 想要跟 B 建立一个 P2P 连接，首先他们需要从 S 获得对方的 ID</li>
<li>A 将 B 的 ID 发送给中介服务器 S，请求与 B 建立 P2P 连接</li>
<li>中介服务器将 B 的内外网 IP 及端口信息发送给 A，同时将 A 的网络信息发送给 B</li>
<li>A 尝试请求 B 的公网地址 <code>B_public_ip:B_public_port</code>
<ul>
<li>这肯定会失败，但是会在 A 的 NAT 网关上留下记录：A 曾经请求过这个地址，那之后这个地址发到 A 的 NAT 网关的流量就可以进来了。</li>
</ul>
</li>
<li>B 尝试请求 A 的公网地址 <code>A_public_ip:A_public_port</code>
<ul>
<li>同样这肯定也会失败，但是会在 B 的 NAT 网关上流量记录：B 曾经请求过这个地址，那之后这个地址发到 B 的 NAT 网关的流量就可以进来了</li>
</ul>
</li>
<li>中间的两层 NAT 网关均形成 NAT 穿越记录，<strong>穿越完成</strong>。</li>
<li>现在 A 尝试请求 B 的公网地址 <code>B_public_ip:B_public_port</code>，由于 B 的 NAT 已有记录，流量顺利通过 NAT 到达程序 B</li>
<li>B 发送给 A 的数据也同样，可以顺利到达 A</li>
</ul>
<p>上述流程中的关键点在于，如何查出内网服务器被 NAT 分配的外部 IP 及端口，只要有了这两个信息，就可以通过 STUN 中介服务器交换这个信息，然后完成连接的建立了。
家庭服务器通常都只有一个公网 IP，所以基本可以认为 IP 是固定的，因此最关键的问题就是「<strong>如何知道 NAT 为会话分配的端口地址</strong>」。</p>
<p>对端口的限制严格程度跟 NAPT 的类型有关，<strong>Full-cone 跟 Restricted cone 对端口都没有任何限制，所以上述流程肯定可以成功</strong>；</p>
<p>TBD</p>
<p>一个穿越 Symmetric NATs 的 STUN 草案：<a href="https://tools.ietf.org/id/draft-takeda-symmetric-nat-traversal-00.txt" target="_blank" rel="noopener noreferrer">Symmetric NAT Traversal using STUN</a></p>
<p>在使用 STUN/TURN 进行 NAT 穿越时，支持的的 NAT 类型如下表。行与列分别代表双方的 NAT 类型，✅ 表示支持 UDP 穿越，❌ 表示 TURN 无法进行 UDP 穿越：</p>
<table>
<thead>
<tr>
<th>NAT 类型</th>
<th>Full Cone</th>
<th>Restricted</th>
<th>Port-Restricted</th>
<th>Symmetric</th>
</tr>
</thead>
<tbody>
<tr>
<td>Full Cone</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Restricted</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Port-Restricted</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>Symmetric</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>这种场景下 TURN 协议给出的解决方案是，fallback 到中继服务器策略作为兜底方案，保证连接能成功，但是这会给中继服务器带来很大压力，延迟等参数将不可避免地变差。</p>
<h5 id="3-a-与-b-之间隔着三层以上的-nat" class="headerLink">
    <a href="#3-a-%e4%b8%8e-b-%e4%b9%8b%e9%97%b4%e9%9a%94%e7%9d%80%e4%b8%89%e5%b1%82%e4%bb%a5%e4%b8%8a%e7%9a%84-nat" class="header-mark"></a>3. A 与 B 之间隔着三层以上的 NAT</h5><p>这种情况较为常见的有：</p>
<ul>
<li>ISP 为了节约使用公网 IP，给用户分配了个广域网 IP，中间就多了个广域网 NAT</li>
<li>大城市的各种租房公寓通常只会从 ISP 购买一两根宽带，二次分销给整栋楼的租客共用，这就造成中间多了一层公寓的 NAT</li>
</ul>
<p>这是最复杂的一种情况，基本上就没什么 NAT 穿透的希望了，只能走下面介绍的兜底策略——服务器中继。</p>
<p>TBD 待续</p>
<h5 id="4-特殊穿越方案---服务器中继" class="headerLink">
    <a href="#4-%e7%89%b9%e6%ae%8a%e7%a9%bf%e8%b6%8a%e6%96%b9%e6%a1%88---%e6%9c%8d%e5%8a%a1%e5%99%a8%e4%b8%ad%e7%bb%a7" class="header-mark"></a>4. 特殊穿越方案 - 服务器中继</h5><p>Relay 服务器中继是兼容性最佳，但是性能最差的方案，因为这个方案下，所有的 P2P 连接都需要经过中继服务器转发，在使用人数众多时这会给中继服务器造成很大的压力。</p>
<p>因此这个方案通常是用于兜底的。</p>
<h3 id="特定协议的自穿越技术" class="headerLink">
    <a href="#%e7%89%b9%e5%ae%9a%e5%8d%8f%e8%ae%ae%e7%9a%84%e8%87%aa%e7%a9%bf%e8%b6%8a%e6%8a%80%e6%9c%af" class="header-mark"></a>特定协议的自穿越技术</h3><p>在所有方法中最复杂也最可靠的就是自己解决自己的问题。比如 IKE 和 IPsec 技术，在设计时就考虑了到如何穿越 NAT 的问题。因为这个协议是一个自加密的协议并且具有报文防修改的鉴别能力，其他通用方法爱莫能助。因为实际应用的 NAT 网关基本都是 NAPT 方式，所有通过传输层协议承载的报文可以顺利通过 NAT。IKE 和 IPsec 采用的方案就是用 UDP 在报文外面再加一层封装，而内部的报文就不再受到影响。IKE 中还专门增加了 NAT 网关是否存在的检查能力以及绕开 NAT 网关检测 IKE 协议的方法。</p>
<h3 id="nat-algapplication-level-gateway" class="headerLink">
    <a href="#nat-algapplication-level-gateway" class="header-mark"></a>NAT ALG(Application Level Gateway)</h3><p>NAT ALG 是一种解决应用层协议（例如DNS、FTP）报文穿越 NAT 的技术，已经被 NAT 设备产商广泛采用，是 NAT 设备的必备功能。</p>
<p>TLDR 一句话介绍：NAT ALG 通过识别协议，直接修改报文数据部分（payload）的 IP 地址和端口信息，解决某些应用协议的报文穿越 NAT 问题。NAT ALG 工作在 L3-L7 层。</p>
<p>NAT ALG 的原理是利用带有 ALG 功能的 NAT 设备对特定应用层协议的支持，当设备检测到新的连接请求时，先根据传输层端口信息判断是否为已知应用类型。如果判断为已知应用，则调用该应用协议的 ALG 功能对报文的深层内容进行检查。若发现任何形式表达的 IP 地址和端口信息，NAT 都会将这些信息同步进行转换，并为这个新的连接建立一个附加的转换表项。当报文到达外网侧的目的主机时，应用层协议中携带的信息就是 NAT 设备转换后的IP地址和端口号，这样，就可以解决某些应用协议的报文穿越 NAT 问题。</p>
<p>目前支持NAT ALG功能的协议包括：DNS、FTP、SIP、PPTP和RTSP。NAT ALG 在对这些特定应用层协议进行 NAT 转换时，通过 NAT 的状态信息来改变封装在 IP 报文数据部分的特定数据，最终使应用层协议可以跨越不同范围运行。</p>
<h2 id="使用-go-实验-nat-穿透" class="headerLink">
    <a href="#%e4%bd%bf%e7%94%a8-go-%e5%ae%9e%e9%aa%8c-nat-%e7%a9%bf%e9%80%8f" class="header-mark"></a>使用 Go 实验 NAT 穿透</h2><p>Go 可用的 NAT 穿越库有：</p>
<ul>
<li><a href="https://github.com/coturn/coturn" target="_blank" rel="noopener noreferrer">coturn</a>: 貌似是最流行的 STUN/TURN/ICE server</li>
<li><a href="https://github.com/ccding/go-stun" target="_blank" rel="noopener noreferrer">go-stun</a>: 一个简洁的 stun client 实现，大概适合用于学习？</li>
<li><a href="https://github.com/pion/turn" target="_blank" rel="noopener noreferrer">pion/turn</a>: 一个 STUN/TURN/ICE client/client 实现</li>
<li><a href="https://github.com/pion/ice" target="_blank" rel="noopener noreferrer">pion/ice</a>: 一个 ice 实现</li>
</ul>
<p>TBD 待完善</p>
<h2 id="虚拟网络overlay-与-underlay" class="headerLink">
    <a href="#%e8%99%9a%e6%8b%9f%e7%bd%91%e7%bb%9coverlay-%e4%b8%8e-underlay" class="header-mark"></a>虚拟网络、Overlay 与 Underlay</h2><p>虚拟网络就是在物理网络之上，构建的逻辑网络，也被称作 overlay 网络。
比如 AWS VPC、Docker 容器网络、QEMU 的默认网络，都是虚拟网络。</p>
<p>而 underlay 网络，则是指承载 overlay 网络的底层网络。
我个人理解，它是一个相对的概念，物理网络一定是 underlay 网络，但是虚拟网络之上如果还承载了其他虚拟网络（套娃），那它相对上层网络而言，也是一个 underlay 网络。</p>
<p>overlay 本质上就是一种隧道技术，将原生态的二层数据帧报文进行封装后通过隧道进行传输。常见的 overlay 网络协议主要是 vxlan 以及新一代的 geneve，它俩都是使用 UDP 包来封装链路层的以太网帧。</p>
<p>vxlan 在 2014 年标准化，而 geneve 在 2020 年底才通过草案阶段，目前尚未形成最终标准。但是目前 linux/cilium 都已经支持了 geneve.</p>
<p>geneve 相对 vxlan 最大的变化，是它更灵活——它的 header 长度是可变的。</p>
<p>目前所有 overlay 的跨主机容器网络方案，几乎都是基于 vxlan 实现的（例外：cilium 也支持 geneve）。</p>
<p>vxlan/geneve 的详细介绍，参见 <a href="https://thiscute.world/posts/linux-virtual-network-interfaces/#vxlan-geneve" target="_blank" rel="noopener noreferrer">Linux 中的虚拟网络接口 - vxlan/geneve</a></p>
<p>顺带再提一嘴，cilium/calico/kube-ovn 等 overlay 容器网络，都是 SDN 软件定义网络。</p>
<h3 id="相关工具" class="headerLink">
    <a href="#%e7%9b%b8%e5%85%b3%e5%b7%a5%e5%85%b7" class="header-mark"></a>相关工具</h3><p>有一些专门用于跨网搭建私有虚拟网络的工具，由于家庭网络设备前面通常都有至少一层 NAT（家庭路由器），因此这些工具都重度依赖 NAT 穿越技术。
如果 NAT 层数太多无法穿越，它们会 fallback 到代理模式，也就是由一台公网服务器进行流量中继，但是这会对中继服务器造成很大压力，延迟跟带宽通常都会差很多。</p>
<p>如下是两个比较流行的 VPN 搭建工具：</p>
<ul>
<li><a href="https://github.com/zerotier/ZeroTierOne" target="_blank" rel="noopener noreferrer">zerotier</a>: 在 P2P 网络之上搭建的 SDN overlay 网络，使用自定义协议。</li>
<li><a href="https://github.com/tailscale/tailscale" target="_blank" rel="noopener noreferrer">tailscales</a>: 基于 wireguard 协议快速搭建私有虚拟网络 VPN</li>
</ul>
<h3 id="vpn-协议" class="headerLink">
    <a href="#vpn-%e5%8d%8f%e8%ae%ae" class="header-mark"></a>VPN 协议</h3><p>主流的 VPN 协议有：PPTP、L2TP、IPSec、OpenVPN、SSTP，以及最新潮的 Wireguard.</p>
<p>TBD</p>
<h2 id="拓展知识" class="headerLink">
    <a href="#%e6%8b%93%e5%b1%95%e7%9f%a5%e8%af%86" class="header-mark"></a>拓展知识</h2><h3 id="symmetric-nat-允许的最大并发-tcp-连接数是多少" class="headerLink">
    <a href="#symmetric-nat-%e5%85%81%e8%ae%b8%e7%9a%84%e6%9c%80%e5%a4%a7%e5%b9%b6%e5%8f%91-tcp-%e8%bf%9e%e6%8e%a5%e6%95%b0%e6%98%af%e5%a4%9a%e5%b0%91" class="header-mark"></a>Symmetric NAT 允许的最大并发 TCP 连接数是多少？</h3><p>TCP 并发连接数受许多参数的限制，以 Linux 服务器为例，默认参数无法满足需要，通常都会手动修改它的参数，放宽文件描述符限制以及 TCP 连接队列、缓存相关的限制。</p>
<p>单纯从网络协议层面分析，对于一个仅有一个公网 IP 的 Symmetric NAT 网关，它与某个外部站点 <code>http://x.x.x.x:xx</code> 要建立连接。
考虑到 TCP 连接的定义实际上是一个四元组 <code>(srcIP, srcPort, dstIP, dstPort)</code>，其中就只有 NAT 网关自己的 <code>srcPort</code> 是唯一的变量了，而端口号是一个 16bits 数字，取值范围为 0 - 65535。
此外低于 1024 的数字是操作系统的保留端口，因此 NAT 一般只会使用 1024-65535 这个区间的端口号，也就是说这个 NAT 网关最多只能与该站点建立 64512 个连接。</p>
<p>那么对于不同的协议 NAT 是如何处理的呢？NAT 肯定可以通过协议特征区分不同协议的流量，因此不同协议通过 NAT 建立的并发连接不会相互影响。</p>
<p>对于家庭网络而言 64512 个连接已经完全够用了，但是对于数据中心或者云上的 VPC 而言，就不一定够用了。
举个例子，在 <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html" target="_blank" rel="noopener noreferrer">AWS NAT 网关的文档</a>中就有提到，AWS NAT 网关最高支持与每个不同的地址建立 55000 个并发连接。destination 的 IP 地址、端口号、(TCP/UDP/ICMP) 任一个发生改变，都可以再建立其他 55000 个并发连接。
如果超过这个限制，就会发生「ErrorPortAllocation」错误。如果在 AWS 上遇到这个错误，那就说明你们的云上网络规划有问题了。</p>
<p>当然除了端口限制外，受限于 NAT 硬件、以太网协议以及其他影响，NAT 网关肯定还有包处理速率、带宽的限制，这个就略过不提了。</p>
<h3 id="aws-vpc-与-nat" class="headerLink">
    <a href="#aws-vpc-%e4%b8%8e-nat" class="header-mark"></a>AWS VPC 与 NAT</h3><p>AWS VPC(virtual private cloud) 是一个逻辑隔离的虚拟私有网络，云服务架构的最佳实践之一就是通过 VPC 搭建云上私有网络，提升网络安全性。</p>
<p>AWS VPC 提供两种网关类型：</p>
<ul>
<li><a href="https://docs.aws.amazon.com/zh_cn/vpc/latest/userguide/vpc-nat-gateway.html" target="_blank" rel="noopener noreferrer">NAT 网关</a>
<ul>
<li>支持三种协议：TCP, UDP, ICMP</li>
<li>支持 IPv4 与 IPv6 两种 IP 协议</li>
<li>支持 5 Gbps 带宽，可自动扩展到 45 Gbps
<ul>
<li>可通过划分子网并在多个子网中添加 NAT 网关的方式，获得超过 45Gbps 的带宽</li>
</ul>
</li>
<li>最高支持与每个不同的地址建立 55000 个并发连接</li>
<li>NAT 网关从属于 VPC 的子网</li>
<li>每个 NAT 网关只能绑定一个 IP
<ul>
<li>可通过划分子网并在多个子网中添加 NAT 网关的方式获得多个 IP</li>
</ul>
</li>
<li>可达到 100w packets 每秒的处理速度，并能自动扩展到 400w packets 每秒
<ul>
<li>同样，需要更高的处理速度，请添加更多 NAT 网关</li>
</ul>
</li>
<li>按处理数据量收费</li>
<li>默认路由到 NAT 子网，被称为「私有子网」（或者没默认路由，那就是无法访问公网的私有子网），连接只能由内网程序主动发起。</li>
<li>NAT 网关为流量执行「<strong>Symmetric NAT</strong>」</li>
</ul>
</li>
<li><a href="https://docs.aws.amazon.com/zh_cn/vpc/latest/userguide/VPC_Internet_Gateway.html" target="_blank" rel="noopener noreferrer">IGW 因特网网关</a>
<ul>
<li>IGW 是一个高度可用的逻辑组件，不会限制 VPC 的总带宽、处理能力。</li>
<li>IGW 实例直接关联 VPC，不从属于任何可用区或子网</li>
<li>IGW 实质上是一个 NAT 设备，为绑定了公网 IP 地址的 ENI/EC2 实例，执行「<strong>一对一 NAT</strong>」</li>
<li>默认路由到 IGW 的子网，被称为「公有子网」</li>
</ul>
</li>
</ul>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://info.support.huawei.com/info-finder/encyclopedia/en/NAT.html" target="_blank" rel="noopener noreferrer">What Is Network Address Translation (NAT)? - Huawei Docs</a></li>
<li><a href="https://info.support.huawei.com/info-finder/encyclopedia/en/STUN.html" target="_blank" rel="noopener noreferrer">What Is STUN? - Huawei Docs</a></li>
<li><a href="https://support.huawei.com/enterprise/zh/doc/EDOC1100112409/fd829977#ZH-CN_CONCEPT_0227014768" target="_blank" rel="noopener noreferrer">NetEngine AR V300R019 配置指南-IP业务 - NAT 穿越 - 华为文档</a></li>
<li><a href="http://www.52im.net/thread-50-1-1.html" target="_blank" rel="noopener noreferrer">P2P技术详解(一)：NAT详解——详细原理、P2P简介</a></li>
<li><a href="http://www.52im.net/thread-542-1-1.html" target="_blank" rel="noopener noreferrer">P2P技术详解(二)：P2P中的NAT穿越(打洞)方案详解</a></li>
<li><a href="http://www.52im.net/thread-2872-1-1.html" target="_blank" rel="noopener noreferrer">P2P技术详解(三)：P2P中的NAT穿越(打洞)方案详解(进阶分析篇)</a></li>
<li><a href="https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Internet_Gateway.html" target="_blank" rel="noopener noreferrer">Connect to the internet using an internet gateway - AWS VPC Internet Gateway</a></li>
<li><a href="https://blog.chionlab.moe/2018/02/09/full-cone-nat-with-linux/" target="_blank" rel="noopener noreferrer">从DNAT到netfilter内核子系统，浅谈Linux的Full Cone NAT实现</a></li>
<li><a href="https://en.wikipedia.org/wiki/Network_address_translation" target="_blank" rel="noopener noreferrer">Network address translation - wikipedia</a></li>
<li><a href="https://www.liveswitch.io/blog/webrtc-nat-traversal-methods-a-case-for-embedded-turn" target="_blank" rel="noopener noreferrer">WebRTC NAT Traversal Methods: A Case for Embedded TURN</a></li>
<li><a href="https://icloudnative.io/posts/wireguard-endpoint-discovery-nat-traversal/" target="_blank" rel="noopener noreferrer">WireGuard 教程：使用 DNS-SD 进行 NAT-to-NAT 穿透 - 云原生实验室</a></li>
</ul>
]]></content></entry><entry><title type="html">FinOps for Kubernetes - 如何拆分 Kubernetes 成本</title><link href="https://thiscute.world/posts/finops-for-kubernetes/"/><id>https://thiscute.world/posts/finops-for-kubernetes/</id><author><name>ryan4yin</name></author><published>2022-05-04T23:15:00+08:00</published><updated>2022-05-05T19:31:00+08:00</updated><content type="html"><![CDATA[<figure>
          <img class="lazyload" src="/posts/finops-for-kubernetes/finops-for-kubernetes.webp" height="900" width="460"><figcaption></figcaption>
        </figure><blockquote>
<p>FinOps 是一种不断发展的云财务管理学科和文化实践，通过帮助工程、财务、技术和业务团队在数据驱动的预算分配上进行协作，使成本预算能够产生最大的业务价值。</p>
</blockquote>
<h2 id="云计算成本管控" class="headerLink">
    <a href="#%e4%ba%91%e8%ae%a1%e7%ae%97%e6%88%90%e6%9c%ac%e7%ae%a1%e6%8e%a7" class="header-mark"></a>云计算成本管控</h2><p>随着越来越多的企业上云，云计算的成本管控也越来越受关注。在讨论 Kubernetes 成本之前，先简单聊下如何管控云计算成本，有一个新名词被用于形容这项工作——FinOps.</p>
<p>传统的数据中心的成本是比较固定的，所有的成本变动通常都伴随着硬件更替。
而在云上环境就很不一样了，由于云服务的按量收费特性，以及五花八门的计费规则，开发人员稍有不慎，云成本就可能会出现意料之外的变化。另一方面由于计费的复杂性，业务扩容对成本的影响也变得难以预测。</p>
<p>目前的主流云服务商（AWS/GCP/Alicloud/&hellip;）基本都提供基于资源标签的成本查询方法，也支持将成本导出并使用 SQL 进行细致分析。
因此其实要做到快速高效的<strong>云成本分析与管控</strong>，主要就涉及到如下几个点：</p>
<ul>
<li><strong>契合需求的标签规范</strong>: 从公司业务侧需求出发，制定出合理的、多维度的（Department/Team/Product/&hellip;）、有扩展空间的标签规范，这样才能按业务侧需要进行成本分析。</li>
<li><strong>资源标签的准确率</strong>: 随着公司业务的发展，标签规范的迭代，标签的准确率总是会上下波动。而标签准确率越高，我们对云计算成本的管控能力就越强。</li>
</ul>
<p>但是也存在许多特殊的云上资源，云服务商目前并未提供良好的成本分析手段，Kubernetes 集群成本就是其中之一。</p>
<h2 id="kubernetes-成本分析的难点" class="headerLink">
    <a href="#kubernetes-%e6%88%90%e6%9c%ac%e5%88%86%e6%9e%90%e7%9a%84%e9%9a%be%e7%82%b9" class="header-mark"></a>Kubernetes 成本分析的难点</h2><p>目前许多企业应该都面临着这样的场景：所有的服务都运行在一或多个 Kubernetes 集群上，其中包含多条业务线、多个产品、多个业务团队的服务，甚至除了业务服务，可能还包含 CICD、数据分析、机器学习等多种其他工作负载。而这些 Kubernetes 集群通常都由一个独立的 SRE 部门管理。</p>
<p>但是 Kubernetes 集群本身并不提供成本拆分的能力，我们只能查到集群的整体成本、每个节点组的成本等这样粗粒度的成本信息，缺乏细粒度的成本分析能力。
此外，Kubernetes 集群是一个非常动态的运行环境，其节点的数量、节点规格、Pod 所在的节点/Zone/Region，都可能会随着时间动态变动，这为成本分析带来了更大的困难。</p>
<p>这就导致我们很难回答这些问题：<strong>每条业务线、每个产品、每个业务团队、或者每个服务分别花了多少钱？是否存在资源浪费？有何优化手段</strong>？</p>
<p>而 FinOps for Kubernetes，就是通过工程化分析、可视化成本分析等手段，来回答这些成本问题，分析与管控 Kubernetes 的成本。</p>
<p>接下来我会先介绍下云上 Kubernetes 成本分析的思路与手段，最后再介绍如何使用 Kubecost 分析 Kubernetes 集群的成本。</p>
<p>要做好 Kubernetes 成本工作，有如下三个要点：</p>
<ul>
<li>理解 Kubernetes 成本的构成，搞懂准确分析 Kubernetes 成本有哪些难点</li>
<li>寻找优化 Kubernetes 集群、业务服务的手段</li>
<li>确定 Kubernetes 集群的成本拆分手段，建立能快速高效地分析与管控集群成本的流程</li>
</ul>
<h2 id="kubernetes-成本的构成" class="headerLink">
    <a href="#kubernetes-%e6%88%90%e6%9c%ac%e7%9a%84%e6%9e%84%e6%88%90" class="header-mark"></a>Kubernetes 成本的构成</h2><p>以 AWS EKS 为例，它的成本有这些组成部分：</p>
<ul>
<li>AWS EKS 本身有 $0.1 per hour 的固定费用，这个很低</li>
<li>EKS 的所有节点会收对应的 EC2 实例运行费用、EBS 数据卷费用</li>
<li>EKS 中使用的 PV 会带来 EBS  数据卷的费用</li>
<li>跨区流量传输费用
<ul>
<li>所有节点之间的通讯（主要是服务之间的互相访问），如果跨了可用区，会收跨区流量传输费用</li>
<li>EKS 中的服务访问其他 AWS 服务如 RDS/ElastiCache，如果是跨可用区，会收取跨区流量费用</li>
<li>如果使用了 Istio IngressGateway 或 traefik 等网关层代理 Pod，那这些 Pod 与服务实例之间，有可能会产生跨区流量</li>
</ul>
</li>
<li>NAT 网关费用
<ul>
<li>EKS 中的容器如果要访问因特网，就需要通过 NAT 网关，产生 NAT 费用</li>
<li>如果 VPC 未配置 endpoints 使访问 AWS 服务（dynamodb/s3 等）时直接走 AWS 内部网络，这些流量会经过 VPC 的 NAT 网关，从而产生 NAT 网关费用</li>
<li>对于托管版 NAT 网关，费用又包含两部分：公网流量费 + NAT 数据处理费用。其中数据处理费用可通过自建 NAT 实例来缩减。</li>
</ul>
</li>
<li>服务如果要对外提供访问，最佳实践是通过 aws-load-balancer-controller 绑定 AWS ALB, 这里会产生 ALB 费用</li>
<li>监控系统成本
<ul>
<li>Kubernetes 的监控系统是不可或缺的</li>
<li>如果你使用的是 Datadog/NewRelic 等云服务，会造成云服务的成本；如果是自建 Prometheus，会造成 Prometheus 的运行成本，以及 Pull 指标造成的跨区流量成本</li>
</ul>
</li>
</ul>
<p><strong>总结下，其实就是三部分成本：计算、存储、网络</strong>。其中计算与存储成本是相对固定的，而网络成本就比较动态，跟是否跨区、是否通过 NAT 等诸多因素有关。</p>
<h2 id="kubernetes-资源分配的方式" class="headerLink">
    <a href="#kubernetes-%e8%b5%84%e6%ba%90%e5%88%86%e9%85%8d%e7%9a%84%e6%96%b9%e5%bc%8f" class="header-mark"></a>Kubernetes 资源分配的方式</h2><p>Kubernetes 提供了三种资源分配的方式，即服务质量 QoS，不同的分配方式，成本的计算难度也有区别：</p>
<ul>
<li>Guaranteed resource allocation(保证资源分配): 即将 requests 与 limits 设置为相等，确保预留所有所需资源
<ul>
<li>最保守的策略，服务性能最可靠，但是成本也最高</li>
<li>这种方式分配的资源，拆分起来是最方便的，因为它的计算成本是静态的</li>
</ul>
</li>
<li>Burstable resource allocation(突发性能): 将 requests 设置得比 limits 低，这样相差的这一部分就是服务的可 Burst 资源量。
<ul>
<li>最佳实践，选择合适的 requests 与 limits，可达成性能与可靠性之间的平衡</li>
<li>这种资源，它 requests 的计算成本是静态的，Burstable 部分的计算成本是动态的</li>
</ul>
</li>
<li>Best effort resource allocation(尽力而为): 只设置 limits，不设置 requests，让 Pod 可以调度到任何可调度的节点上
<ul>
<li>下策，这个选项会导致服务的性能无法保证，通常只在开发测试等资源受限的环境使用</li>
<li>这种方式分配的资源，完全依赖监控指标进行成本拆分</li>
</ul>
</li>
</ul>
<h2 id="最佳实践" class="headerLink">
    <a href="#%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5" class="header-mark"></a>最佳实践</h2><p>要做到统一分析、拆分 Kubernetes 与其他云资源的成本，如下是一些最佳实践：</p>
<ul>
<li>按产品或者业务线来划分名字空间，不允许跨名字空间互相访问。
<ul>
<li>如果存在多个产品或业务线共用的服务，可以在每个产品的名字空间分别部署一个副本，并把它们当成不同的服务来处理。</li>
<li>这样名字空间就是成本划分的一个维度，我们还可以在名字空间上为每个产品设置资源上限与预警。</li>
</ul>
</li>
<li>按产品或业务线来划分节点组，通过节点组的标签来进行成本划分
<ul>
<li>这是第二个维度，但是节点组划分得太细，可能会导致资源利用不够充分。</li>
<li>这个方案仅供参考，不一定好用</li>
</ul>
</li>
<li>为 Kubernetes 服务设计与其他云资源一致的成本标签，添加到 Pod 的 label 中，通过 kubecost 等手段，基于 label 进行更细致的成本分析
<ul>
<li>标签一致的好处是可以统一分析 Kubernetes 与其他云资源的成本</li>
</ul>
</li>
<li>定期（比如每周一） check 云成本变化，定位并解决成本异常</li>
<li>建立自动化的成本异常检测与告警机制（部分云服务有提供类似的服务，也可自建），收到告警即触发成本异常分析任务</li>
<li>始终将资源标签准确率维持在较高数值，准确率低于一定数值即自动告警，触发标签修正任务</li>
<li>将成本上升的压力与成本下降的效益覆盖到开发人员，授权他们跟踪服务的 Kubernetes 利用率与成本，以激励开发人员与 SRE 合作管控服务成本。</li>
</ul>
<p>成本优化实践：</p>
<ul>
<li>多种工作负载混合部署，提升资源利用率。但是需要合理规划避免资源竞争</li>
<li>调节集群伸缩组件，在保障 SLA 的前提下提升资源利用率
<ul>
<li>比如 aws 就可以考虑在一些场景下用 karpenter 来做扩缩容、引入 <a href="https://github.com/aws/aws-node-termination-handler" target="_blank" rel="noopener noreferrer">AWS Node Termination Handler</a> 提升 Spot 实例的 SLA</li>
</ul>
</li>
<li>尽量使用竞价实例，AWS 的竞价实例单价平均优惠超过 50%</li>
<li>合理地购买 Saving Plans 与 Reserved Instances，达成成本节约。</li>
</ul>
<h2 id="多云环境" class="headerLink">
    <a href="#%e5%a4%9a%e4%ba%91%e7%8e%af%e5%a2%83" class="header-mark"></a>多云环境</h2><p>上述讨论的绝大部分策略，都适用于多云环境。在这种涉及多个云服务提供商的场景，最重要的一点是：<strong>搭建平台无关的成本分析与管控平台</strong>。而其核心仍然是文章最前面提到的两点，只需要补充两个字 <strong>一致</strong>：</p>
<ul>
<li><strong>一致的资源标签规范</strong>: 从公司业务侧需求出发，制定出<strong>跨平台一致的</strong>标签规范，这样才能统一分析多云成本。</li>
<li><strong>资源标签的准确率</strong>: 随着公司业务的发展，标签规范的迭代，标签的准确率总是会上下波动。而标签准确率越高，我们对云计算成本的管控能力就越强。</li>
</ul>
<p>这样就可以把不同云服务商的数据转换成统一的格式，然后在自有的成本平台上进行统一的分析了。</p>
<p>搭建一个这样的成本分析平台其实并不难，许多大公司都是这么干的，小公司也可以从一个最小的平台开始做起，再慢慢完善功能。</p>
<p>以我现有的经验看，其实主要就包含这么几个部分：</p>
<ul>
<li>成本数据转换模块：将来自不同云的成本数据，转换成与云服务无关的格式，方便统一处理</li>
<li>折扣模块：处理不同资源的折扣
<ul>
<li>比如 CDN 在用量高的时候通常会有很高的折扣比例</li>
<li>还有 SavingPlans/CommitmentDiscounts 也需要特殊的处理</li>
</ul>
</li>
<li>标签修整模块
<ul>
<li>随着标签体系的发展，总会有些标签的变更，不方便直接在资源上执行，就需要在成本计算这里进行修正、增补或者删除</li>
</ul>
</li>
<li>成本拆分模块
<ul>
<li>有些资源的成本是共用的，就需要结合其他来源的数据进行成本拆分，比如 Kubernetes 集群的成本</li>
</ul>
</li>
<li>成本报表：将最终的数据制作成符合各类人员需求的可视化图表，按需求还可以考虑添加交互式特征
<ul>
<li>可使用 Grafana/Google DataStudio 等报表工具</li>
</ul>
</li>
</ul>
<p>此外这样一个跨云的成本管控平台也不一定需要完全自己来做，已经有很多公司看到了这块的前景，做出了现成的方案，可以看看 Gartner 的如下报告：</p>
<ul>
<li><a href="https://www.gartner.com/reviews/market/cloud-management-tooling" target="_blank" rel="noopener noreferrer">Cloud Management Tooling Reviews and Ratings - Gartner</a></li>
</ul>
<p>多云场景下其实要考虑的还有很多，目前多云网络（multicloud networking）、多云财务（multicloud finops）、多云应用管理（multicloud application management）领域的需求越来越强劲，相关产品也越来越多，有需要可以自行研究。</p>
<h2 id="kubernetes-成本分析" class="headerLink">
    <a href="#kubernetes-%e6%88%90%e6%9c%ac%e5%88%86%e6%9e%90" class="header-mark"></a>Kubernetes 成本分析</h2><p>前面讨论的内容都很「虚」，下面来点更「务实」的：Kubernetes 成本分析实战。</p>
<p>目前据我所知，主要有如下两个相关的开源工具：</p>
<ul>
<li><a href="https://github.com/opencost/opencost" target="_blank" rel="noopener noreferrer">Kubecost/Opencost</a>: kubecost 应该是目前最优秀的开源成本分析工具了，self-hosted 是免费的，支持按 deployment/service/label 等多个维度进行成本拆分，而且支持拆分网络成本。收费版提供更丰富的功能以及更长的数据存储时间。
<ul>
<li>kubecost 的核心部分已捐献给 CNCF，并改名为 opencost.</li>
</ul>
</li>
<li><a href="https://github.com/gocrane/crane" target="_blank" rel="noopener noreferrer">crane</a>: 腾讯开源的一款 Kubernetes 成本优化工具，支持成本报表以及 EHPA 两个功能，（截止 2022-05-04）才刚开源几个月，目前还比较简陋。
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1960014" target="_blank" rel="noopener noreferrer">腾讯推出国内首个云原生成本优化开源项目 Crane</a></li>
<li>腾讯云在国内上线了 crane 的闭源版本「<a href="https://cloud.tencent.com/document/product/457/64169" target="_blank" rel="noopener noreferrer">容器服务成本大师</a>」，如果你使用的是腾讯云，可以体验看看（感觉跟 kubecost 很像）</li>
</ul>
</li>
</ul>
<p>其中 kubecost 是最成熟的一个，我们接下来以 kubecost 为例介绍下如何分析 Kubernetes 成本。</p>
<h3 id="安装-kubecost" class="headerLink">
    <a href="#%e5%ae%89%e8%a3%85-kubecost" class="header-mark"></a>安装 kubecost</h3><p>kubecost 有两种推荐的安装方法：</p>
<ul>
<li>使用 helm 安装免费版
<ul>
<li>包含如下组件：
<ul>
<li>frontend 前端 UI 面板</li>
<li>cost-model 核心组件，提供基础的成本拆分能力</li>
<li>postgres 长期存储，仅企业版支持</li>
<li>kubecost-network-costs 一个 daemonset，提供网络指标用于计算网络成本（貌似未开源）</li>
<li>cluster-controller 提供集群「大小调整（RightSizing）」以及「定时关闭集群」的能力</li>
</ul>
</li>
<li>只保留 15 天的指标，无 SSO/SAML 登录支持，无 alerts/notification, 不可保存 reportes 报表</li>
<li>每个 kubecost 只可管理一个集群</li>
</ul>
</li>
<li>只安装 Apache License 开源的 cost-model，它仅提供基础的成本拆分功能以及 API，无 UI 面板、长期存储、网络成本拆分、SAML 接入及其他商业功能。</li>
</ul>
<p>开源的 cost-model 直接使用此配置文件即可部署：<a href="https://github.com/kubecost/cost-model/blob/master/kubernetes/exporter/exporter.yaml" target="_blank" rel="noopener noreferrer">https://github.com/kubecost/cost-model/blob/master/kubernetes/exporter/exporter.yaml</a></p>
<p>而如果要部署带 UI 的商业版，需要首先访问 <a href="https://www.kubecost.com/install#show-instructions" target="_blank" rel="noopener noreferrer">https://www.kubecost.com/install#show-instructions</a> 获取到 <code>kubecostToken</code>，然后使用 helm 进行部署。</p>
<p>首先下载并编辑 values.yaml 配置文件：<a href="https://github.com/kubecost/cost-analyzer-helm-chart/blob/develop/cost-analyzer/values.yaml" target="_blank" rel="noopener noreferrer">https://github.com/kubecost/cost-analyzer-helm-chart/blob/develop/cost-analyzer/values.yaml</a>，示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># kubecost-values.yaml</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 通过 http://kubecost.com/install 获取 token，用于跟踪商业授权状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kubecostToken</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;xxx&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">global</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 自动部署 prometheus + nodeExporter，也可以直接对接外部 prometheus</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">prometheus</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 如果 enable=false，则使用如下地址连接外部 prometheus</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">fqdn</span><span class="p">:</span><span class="w"> </span><span class="l">http://cost-analyzer-prometheus-server.default.svc</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># 自动部署 grafana，也可对接外部 grafana 面板</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">grafana</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 如果 enable=false，则使用如下地址连接外部 grafana</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">domainName</span><span class="p">:</span><span class="w"> </span><span class="l">cost-analyzer-grafana.default.svc</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">scheme</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;http&#34;</span><span class="w"> </span><span class="c"># http or https, for the domain name above.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">proxy</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># If true, the kubecost frontend will route to your grafana through its service endpoint</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># grafana 子 chart 的配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c">## 更好的选择是单独部署 grafana，不使用 kubecost 的 subchart</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">grafana</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">image</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">repository</span><span class="p">:</span><span class="w"> </span><span class="l">grafana/grafana </span><span class="w"> </span><span class="c"># 建议替换成私有镜像仓库地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">tag</span><span class="p">:</span><span class="w"> </span><span class="m">8.3.2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># prometheus 子 chart 的配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c">## 更好的选择是单独部署 prometheus，不使用 kubecost 的 subchart</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">prometheus</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">server</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">persistentVolume</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">size</span><span class="p">:</span><span class="w">  </span><span class="l">32Gi</span><span class="w"> </span><span class="c"># 这个大小得视情况调整，集群较大的话 32Gi 肯定不够</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">retention</span><span class="p">:</span><span class="w"> </span><span class="l">15d </span><span class="w"> </span><span class="c"># p8s 指标保留时长</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">nodeExporter</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c">## If true, node-exporter pods share the host network namespace</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">hostNetwork</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c">## If true, node-exporter pods share the host PID namespace</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">hostPID</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c">## node-exporter container name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">node-exporter</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c">## node-exporter container image</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">repository</span><span class="p">:</span><span class="w"> </span><span class="l">quay.io/prometheus/node-exporter </span><span class="w"> </span><span class="c"># 替换成 quay 仓库避免 docker 仓库拉取限制</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">tag</span><span class="p">:</span><span class="w"> </span><span class="l">v0.18.1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">pullPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">IfNotPresent</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c">## Monitors ConfigMap changes and POSTs to a URL</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c">## Ref: https://github.com/jimmidyson/configmap-reload</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c">##</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">configmapReload</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">prometheus</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c">## If false, the configmap-reload container will not be deployed</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c">## configmap-reload container name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">configmap-reload</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c">## configmap-reload container image</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">image</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">repository</span><span class="p">:</span><span class="w"> </span><span class="l">jimmidyson/configmap-reload </span><span class="w"> </span><span class="c"># 建议替换成私有仓库避免 docker 仓库拉取限制</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">tag</span><span class="p">:</span><span class="w"> </span><span class="l">v0.7.1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">persistentVolume</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">size</span><span class="p">:</span><span class="w"> </span><span class="l">32Gi </span><span class="w"> </span><span class="c"># 同前所述</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># storageClass: &#34;-&#34; #</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 配置 ingress 入口，供外部访问</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">ingress</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># className: nginx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">annotations</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># kubernetes.io/ingress.class: nginx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># kubernetes.io/tls-acme: &#34;true&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">paths</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;/&#34;</span><span class="p">]</span><span class="w"> </span><span class="c"># There&#39;s no need to route specifically to the pods-- we have an nginx deployed that handles routing</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">pathType</span><span class="p">:</span><span class="w"> </span><span class="l">ImplementationSpecific</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">hosts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="l">cost-analyzer.local</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">nodeSelector</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 提升网络安全性的配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">networkPolicy</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">denyEgress</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># create a network policy that denies egress from kubecost</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">sameNamespace</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c"># Set to true if cost analyser and prometheus are on the same namespace</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c"># namespace: kubecost # Namespace where prometheus is installed</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 分析网络成本，需要额外部署一个 daemonset</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">networkCosts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">config</span><span class="p">:</span><span class="w"> </span>{}<span class="w">  </span><span class="c"># 详见 values.yaml 内容</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">serviceAccount</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">create</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">annotations</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 如果是 aws 上的集群，可以通过 serviceAccount 授权访问 ec2 pricing API 及 cur 数据</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 也可以直接为服务提供 AccessKeyID/Secret 进行授权</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># 与 AWS 的集成会在后面详细介绍</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">eks.amazonaws.com/role-arn</span><span class="p">:</span><span class="w"> </span><span class="l">arn:aws:iam:112233445566:role/KubecostRole </span><span class="w"> </span><span class="c"># 注意替换这个 role-arn</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 如下配置也可通过 Kubecost product UI 调整</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c"># 但是此处的配置优先级更高，如果在这里配置了默认值，容器重启后就会使用此默认值，UI 上的修改将失效</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kubecostProductConfigs</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然后部署：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># 添加 repo</span>
</span></span><span class="line"><span class="cl">helm repo add kubecost https://kubecost.github.io/cost-analyzer/
</span></span><span class="line"><span class="cl"><span class="c1"># 查看版本号</span>
</span></span><span class="line"><span class="cl">helm search repo kubecost/cost-analyzer -l <span class="p">|</span> head
</span></span><span class="line"><span class="cl"><span class="c1"># 下载并解压某个 chart</span>
</span></span><span class="line"><span class="cl">helm pull kubecost/cost-analyzer --untar --version 1.92.0
</span></span><span class="line"><span class="cl"><span class="c1"># 使用自定义 values 配置安装或更新本地的 chart</span>
</span></span><span class="line"><span class="cl">helm upgrade --create-namespace --install kubecost ./cost-analyzer -n kubecost -f kubecost-values.yaml
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 port-forward 访问：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">kubectl port-forward --namespace kubecost deployment/kubecost-cost-analyzer <span class="m">9090</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在访问 <a href="http://localhost:9090" target="_blank" rel="noopener noreferrer">http://localhost:9090</a> 就能进入 Kubecost 的 UI 面板，其中最主要的就是 Allocation 成本拆分功能。</p>
<figure><img src="/images/finops-for-kubernetes/kubecost-demo.webp"/><figcaption>
            <h4>Kubecost 示例</h4>
        </figcaption>
</figure>

<h3 id="kubecost-的成本统计原理" class="headerLink">
    <a href="#kubecost-%e7%9a%84%e6%88%90%e6%9c%ac%e7%bb%9f%e8%ae%a1%e5%8e%9f%e7%90%86" class="header-mark"></a>kubecost 的成本统计原理</h3><h4 id="1-cpuramgpustorage-成本分析" class="headerLink">
    <a href="#1-cpuramgpustorage-%e6%88%90%e6%9c%ac%e5%88%86%e6%9e%90" class="header-mark"></a>1. CPU/RAM/GPU/Storage 成本分析</h4><p>Kubecost 通过 AWS/GCP 等云服务商 API 动态获取各 region/zone 的上述四项资源的每小时成本：CPU-hour, GPU-hour, Storage Gb-hour 与 RAM Gb-hour，或者通过 json 文件静态配置这几项资源的成本。
OD 按需实例的资源价格通常比较固定，而 AWS Spot 实例的成本波动会比较大，可以通过 SpotCPU/SpotRAM 这两个参数来设置 spot 的默认价格，也可以为 kubecost 提供权限使它动态获取这两项资源的价格。</p>
<p>kubecost 根据每个容器的资源请求 requests 以及资源用量监控进行成本分配，对于未配置 requests 的资源将仅按实际用量监控进行成本分配。</p>
<p>kubecost 的成本统计粒度为 container，而 deployment/service/namespace/label 只是按不同的维度进行成本聚合而已。</p>
<h4 id="2-网络成本的分析" class="headerLink">
    <a href="#2-%e7%bd%91%e7%bb%9c%e6%88%90%e6%9c%ac%e7%9a%84%e5%88%86%e6%9e%90" class="header-mark"></a>2. 网络成本的分析</h4><blockquote>
<p><a href="https://github.com/kubecost/docs/blob/b7e9d25994ce3df6b3936a06023588f2249554e5/network-allocation.md" target="_blank" rel="noopener noreferrer">https://github.com/kubecost/docs/blob/b7e9d25994ce3df6b3936a06023588f2249554e5/network-allocation.md</a></p>
</blockquote>
<p>对提供线上服务的云上 Kubernetes 集群而言，网络成本很可能等于甚至超过计算成本。这里面最贵的，是跨区/跨域传输的流量成本，以及 NAT 网关成本。NAT 网关成本可以通过自建 NAT 实例来部分缩减（这里仅考察了 AWS 云服务，其他云服务商的收费模式可能存在区别）。
使用单个可用区风险比较高，资源池也可能不够用，因此我们通常会使用多个可用区，这就导致跨区流量成本激增。</p>
<p>kubecost 也支持使用 Pod network 监控指标对整个集群的流量成本进行拆分，kubecost 会部署一个绑定 hostNetwork 的 daemonset 来采集需要的网络指标，提供给 prometheus 拉取，再进行进一步的分析。</p>
<p>kubecost 将网络流量分成如下几类：</p>
<ul>
<li>in-zone: 免费流量</li>
<li>in-region: 跨区流量，国外的云服务商基本都会对跨区流量收费</li>
<li>cross-region: 跨域流量</li>
</ul>
<p>更多的待研究，看 kubecost 官方文档吧。</p>
<blockquote>
<p>另外还看到 kubecost 有忽略 s3 流量（因为不收费）的 issue: <a href="https://github.com/kubecost/cost-model/issues/517" target="_blank" rel="noopener noreferrer">https://github.com/kubecost/cost-model/issues/517</a></p>
</blockquote>
<h3 id="kubecost-api" class="headerLink">
    <a href="#kubecost-api" class="header-mark"></a>kubecost API</h3><blockquote>
<p><a href="https://github.com/kubecost/docs/blob/b7e9d25994ce3df6b3936a06023588f2249554e5/apis.md" target="_blank" rel="noopener noreferrer">https://github.com/kubecost/docs/blob/b7e9d25994ce3df6b3936a06023588f2249554e5/apis.md</a></p>
</blockquote>
<ul>
<li>成本拆分文档：https://github.com/kubecost/docs/blob/b7e9d25994ce3df6b3936a06023588f2249554e5/cost-allocation.md</li>
<li>成本拆分 API 文档：https://github.com/kubecost/docs/blob/b7e9d25994ce3df6b3936a06023588f2249554e5/allocation.md</li>
</ul>
<p>查询成本拆分结果的 API 示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">requests</span>
</span></span><span class="line"><span class="cl"><span class="n">resp</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;http://localhost:9090/model/allocation&#34;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;window&#34;</span><span class="p">:</span> <span class="s2">&#34;2022-05-05T00:00:00Z,2022-05-06T00:00:00Z&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;aggregate&#34;</span><span class="p">:</span> <span class="s2">&#34;namespace,label:app&#34;</span><span class="p">,</span>  <span class="c1"># 以这几个纬度进行成本聚合</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;external&#34;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>     <span class="c1"># 拆分集群外部的成本（比如 s3/rds/es 等），需要通过其他手段提供外部资源的成本</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;accumulate&#34;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>   <span class="c1"># 累加指定 window 的所有成本</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;shareIdle&#34;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>   <span class="c1"># 将空闲成本拆分到所有资源上</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;idleByNode&#34;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>  <span class="c1"># 基于节点进行空闲资源的统计</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;shareTenancyCosts&#34;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>  <span class="c1"># 在集群的多个租户之间共享集群管理成本、节点数据卷成本。这部分成本将被添加到 `sharedCost` 字段中</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;shareNamespaces&#34;</span><span class="p">:</span> <span class="s2">&#34;kube-system,kubecost,istio-system,monitoring&#34;</span><span class="p">,</span>  <span class="c1"># 将这些名字空间的成本设为共享成本</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;shareLabels&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;shareCost&#34;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;shareSplit&#34;</span><span class="p">:</span> <span class="s2">&#34;weighted&#34;</span><span class="p">,</span>  <span class="c1"># 共享成本的拆分方法，weight 加权拆分，even 均分</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">resp_json</span> <span class="o">=</span> <span class="n">resp</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">resp_json</span><span class="p">[</span><span class="s1">&#39;code&#39;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">result</span> <span class="o">=</span> <span class="n">resp_json</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>查询结果中有这几种特殊成本类别：</p>
<ul>
<li><code>__idle__</code>: 未被占用的空闲资源消耗的成本</li>
<li><code>__unallocated_</code>: 不含有 <code>aggregate</code> 对应维度的成本，比如按 <code>label:app</code> 进行聚合，不含有 <code>app</code> 这个 label 的 pod 成本就会被分类到此标签</li>
<li><code>__unmounted__</code>: 未挂载 PV 的成本</li>
</ul>
<p>此外如果使用 kubecost 可视化面板，可能还会看到一个 <code>other</code> 类别，这是为了方便可视化，把成本太低的一些指标聚合展示了。</p>
<h3 id="kubecost-与-aws-集成" class="headerLink">
    <a href="#kubecost-%e4%b8%8e-aws-%e9%9b%86%e6%88%90" class="header-mark"></a>Kubecost 与 AWS 集成</h3><blockquote>
<p><a href="https://github.com/kubecost/docs/blob/b7e9d25994ce3df6b3936a06023588f2249554e5/aws-cloud-integrations.md" target="_blank" rel="noopener noreferrer">https://github.com/kubecost/docs/blob/b7e9d25994ce3df6b3936a06023588f2249554e5/aws-cloud-integrations.md</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/kubecost/docs/blob/main/aws-node-price-reconcilitation-methodology.md" target="_blank" rel="noopener noreferrer">https://github.com/kubecost/docs/blob/main/aws-node-price-reconcilitation-methodology.md</a></p>
</blockquote>
<p>TBD</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li><a href="https://github.com/kubecost/cost-model" target="_blank" rel="noopener noreferrer">kubecost</a>: kubecost 应该是目前最优秀的开源成本分析工具了，self-hosted 是免费的，也提供收费的云上版本，值得研究。
<ul>
<li>文档：https://github.com/kubecost/docs</li>
</ul>
</li>
<li><a href="https://github.com/gocrane/crane" target="_blank" rel="noopener noreferrer">crane</a>: 腾讯开源的一款 Kubernetes 成本优化工具，支持成本报表以及 EHPA 两个功能，才刚开源几个月，目前还比较简陋。</li>
<li><a href="https://www.finops.org/projects/calculating-container-costs/" target="_blank" rel="noopener noreferrer">Calculating Container Costs - FinOps</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/523045177" target="_blank" rel="noopener noreferrer">CPU利用率从10%提升至60%：中型企业云原生成本优化实战指南 - 星汉未来(Galaxy-Future)</a></li>
<li><a href="https://cloud.tencent.com/document/product/457/57732" target="_blank" rel="noopener noreferrer">资源利用率分析和优化建议 - 腾讯云容器服务</a></li>
</ul>
]]></content></entry><entry><title type="html">变革与创新</title><link href="https://thiscute.world/posts/revolution-and-innovation/"/><id>https://thiscute.world/posts/revolution-and-innovation/</id><author><name>ryan4yin</name></author><published>2022-03-28T00:40:00+08:00</published><updated>2022-03-28T00:40:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">写给开发人员的实用密码学（八）—— 数字证书与 TLS 协议</title><link href="https://thiscute.world/posts/about-tls-cert/"/><id>https://thiscute.world/posts/about-tls-cert/</id><author><name>ryan4yin</name></author><published>2022-03-14T00:00:00+08:00</published><updated>2022-03-14T00:00:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">写给开发人员的实用密码学（七）—— 非对称密钥加密算法 RSA/ECC</title><link href="https://thiscute.world/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/"/><id>https://thiscute.world/posts/practical-cryptography-basics-7-asymmetric-key-ciphers/</id><author><name>ryan4yin</name></author><published>2022-03-09T20:50:00+08:00</published><updated>2022-03-13T15:26:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">写给开发人员的实用密码学（六）—— 对称密钥加密算法</title><link href="https://thiscute.world/posts/practical-cryptography-basics-6-symmetric-key-ciphers/"/><id>https://thiscute.world/posts/practical-cryptography-basics-6-symmetric-key-ciphers/</id><author><name>ryan4yin</name></author><published>2022-03-06T18:44:00+08:00</published><updated>2022-03-06T18:44:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">「转」且看有思想的年轻人</title><link href="https://thiscute.world/posts/the-thoughtful-youth/"/><id>https://thiscute.world/posts/the-thoughtful-youth/</id><author><name>ryan4yin</name></author><published>2022-03-04T22:58:00+08:00</published><updated>2022-03-04T22:58:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">写给开发人员的实用密码学（五）—— 密钥交换 DHKE 与完美前向保密 PFS</title><link href="https://thiscute.world/posts/practical-cryptography-basics-5-key-exchange/"/><id>https://thiscute.world/posts/practical-cryptography-basics-5-key-exchange/</id><author><name>ryan4yin</name></author><published>2022-03-01T17:15:05+08:00</published><updated>2022-03-13T15:26:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">写给开发人员的实用密码学（四）—— 安全随机数生成器 CSPRNG</title><link href="https://thiscute.world/posts/practical-cryptography-basics-4-secure-random-generators/"/><id>https://thiscute.world/posts/practical-cryptography-basics-4-secure-random-generators/</id><author><name>ryan4yin</name></author><published>2022-03-01T17:15:04+08:00</published><updated>2022-03-01T17:15:04+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">写给开发人员的实用密码学（三）—— MAC 与密钥派生函数 KDF</title><link href="https://thiscute.world/posts/practical-cryptography-basics-3-key-derivation-function/"/><id>https://thiscute.world/posts/practical-cryptography-basics-3-key-derivation-function/</id><author><name>ryan4yin</name></author><published>2022-03-01T17:15:03+08:00</published><updated>2022-03-01T17:15:03+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">写给开发人员的实用密码学（二）—— 哈希函数</title><link href="https://thiscute.world/posts/practical-cryptography-basics-2-hash/"/><id>https://thiscute.world/posts/practical-cryptography-basics-2-hash/</id><author><name>ryan4yin</name></author><published>2022-03-01T17:15:01+08:00</published><updated>2022-03-01T17:15:01+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">写给开发人员的实用密码学（一）—— 概览</title><link href="https://thiscute.world/posts/practical-cryptography-basics-1/"/><id>https://thiscute.world/posts/practical-cryptography-basics-1/</id><author><name>ryan4yin</name></author><published>2022-03-01T17:15:00+08:00</published><updated>2022-03-01T17:15:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">「转」仙马赛记——我又 PB 了</title><link href="https://thiscute.world/posts/likenttt-2021-04-11-xianlin-half-marathon-1_33_12/"/><id>https://thiscute.world/posts/likenttt-2021-04-11-xianlin-half-marathon-1_33_12/</id><author><name>ryan4yin</name></author><published>2022-02-26T17:44:00+08:00</published><updated>2022-02-26T17:44:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">「转」MIRT出征广马——首次摸到330的边儿</title><link href="https://thiscute.world/posts/likenttt-2020-12-13-guangzhou-marathon-3_30_15/"/><id>https://thiscute.world/posts/likenttt-2020-12-13-guangzhou-marathon-3_30_15/</id><author><name>ryan4yin</name></author><published>2022-02-26T16:59:00+08:00</published><updated>2022-02-26T16:59:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">Linux/Windows/MacOSX 系统常用命令集锦</title><link href="https://thiscute.world/posts/common-commands-for-various-operating-systems/"/><id>https://thiscute.world/posts/common-commands-for-various-operating-systems/</id><author><name>ryan4yin</name></author><published>2022-02-13T16:09:00+08:00</published><updated>2022-02-13T16:09:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">Python 实用技巧与常见错误集锦</title><link href="https://thiscute.world/posts/python-tips-and-tricks/"/><id>https://thiscute.world/posts/python-tips-and-tricks/</id><author><name>ryan4yin</name></author><published>2022-02-13T01:17:00+08:00</published><updated>2022-02-13T01:17:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">部署一个 Kubernetes 集群</title><link href="https://thiscute.world/posts/kubernetes-deployment-using-kubeadm/"/><id>https://thiscute.world/posts/kubernetes-deployment-using-kubeadm/</id><author><name>ryan4yin</name></author><published>2022-01-25T01:37:00+08:00</published><updated>2022-01-25T01:37:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">Kubernetes 微服务最佳实践</title><link href="https://thiscute.world/posts/kubernetes-best-practices/"/><id>https://thiscute.world/posts/kubernetes-best-practices/</id><author><name>ryan4yin</name></author><published>2022-01-25T00:13:00+08:00</published><updated>2022-01-25T00:13:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">2021 年年终总结</title><link href="https://thiscute.world/posts/2021-summary/"/><id>https://thiscute.world/posts/2021-summary/</id><author><name>ryan4yin</name></author><published>2022-01-03T14:50:00+08:00</published><updated>2022-01-03T14:50:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">月宫</title><link href="https://thiscute.world/posts/moon-palace/"/><id>https://thiscute.world/posts/moon-palace/</id><author><name>ryan4yin</name></author><published>2021-12-27T17:23:00+08:00</published><updated>2021-12-27T17:23:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">浮生若梦，为欢几何？</title><link href="https://thiscute.world/posts/life-is-just-like-a-dream/"/><id>https://thiscute.world/posts/life-is-just-like-a-dream/</id><author><name>ryan4yin</name></author><published>2021-11-16T02:07:39+08:00</published><updated>2021-11-16T02:14:37+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">此岸弃草，彼岸繁花</title><link href="https://thiscute.world/posts/weeds-on-this-side-flowers-on-the-other/"/><id>https://thiscute.world/posts/weeds-on-this-side-flowers-on-the-other/</id><author><name>ryan4yin</name></author><published>2021-08-28T12:24:20+08:00</published><updated>2021-08-28T12:24:20+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">iptables 及 docker 容器网络分析</title><link href="https://thiscute.world/posts/iptables-and-container-networks/"/><id>https://thiscute.world/posts/iptables-and-container-networks/</id><author><name>ryan4yin</name></author><published>2021-08-15T19:11:29+08:00</published><updated>2021-08-15T19:11:29+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">Linux 中的虚拟网络接口</title><link href="https://thiscute.world/posts/linux-virtual-network-interfaces/"/><id>https://thiscute.world/posts/linux-virtual-network-interfaces/</id><author><name>ryan4yin</name></author><published>2021-08-14T11:13:03+08:00</published><updated>2021-08-14T11:13:03+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">Linux 网络工具中的瑞士军刀 - socat &amp;amp; netcat</title><link href="https://thiscute.world/posts/socat-netcat/"/><id>https://thiscute.world/posts/socat-netcat/</id><author><name>ryan4yin</name></author><published>2021-04-11T16:38:13+08:00</published><updated>2021-04-11T16:38:13+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">脚踏实地，仰望星空</title><link href="https://thiscute.world/posts/no-more-dreams/"/><id>https://thiscute.world/posts/no-more-dreams/</id><author><name>ryan4yin</name></author><published>2021-02-13T10:32:56+08:00</published><updated>2021-02-13T10:32:56+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">我在创业公司做技术一年多的一点体会</title><link href="https://thiscute.world/posts/end-of-the-first-round/"/><id>https://thiscute.world/posts/end-of-the-first-round/</id><author><name>ryan4yin</name></author><published>2021-02-06T08:46:46+08:00</published><updated>2021-02-06T08:46:46+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">云原生流水线 Argo Workflows 的安装、使用以及个人体验</title><link href="https://thiscute.world/posts/experience-of-argo-workflows/"/><id>https://thiscute.world/posts/experience-of-argo-workflows/</id><author><name>ryan4yin</name></author><published>2021-01-27T15:37:27+08:00</published><updated>2021-01-27T15:37:27+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">secrets 管理工具 Vault 的介绍、安装及使用</title><link href="https://thiscute.world/posts/experience-of-vault/"/><id>https://thiscute.world/posts/experience-of-vault/</id><author><name>ryan4yin</name></author><published>2021-01-24T09:31:41+08:00</published><updated>2021-01-24T09:31:41+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">QEMU/KVM 虚拟化环境的搭建与使用</title><link href="https://thiscute.world/posts/qemu-kvm-usage/"/><id>https://thiscute.world/posts/qemu-kvm-usage/</id><author><name>ryan4yin</name></author><published>2021-01-17T21:34:04+08:00</published><updated>2021-01-17T21:34:04+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">Pulumi 使用体验 - 基础设施代码化</title><link href="https://thiscute.world/posts/experience-of-pulumi/"/><id>https://thiscute.world/posts/experience-of-pulumi/</id><author><name>ryan4yin</name></author><published>2021-01-08T18:51:30+08:00</published><updated>2021-01-08T18:51:30+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">openSUSE 使用指南</title><link href="https://thiscute.world/posts/opensuse-instruction/"/><id>https://thiscute.world/posts/opensuse-instruction/</id><author><name>ryan4yin</name></author><published>2021-01-04T08:42:21+08:00</published><updated>2021-01-04T08:42:21+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">2020 年年终总结</title><link href="https://thiscute.world/posts/2020-summary/"/><id>https://thiscute.world/posts/2020-summary/</id><author><name>ryan4yin</name></author><published>2020-12-12T23:45:00+08:00</published><updated>2020-12-12T23:45:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">「小歌行」-景德镇文艺复兴-2020巡演-深圳</title><link href="https://thiscute.world/posts/jingdezhen-renaissance-band-2020-shenzhen/"/><id>https://thiscute.world/posts/jingdezhen-renaissance-band-2020-shenzhen/</id><author><name>ryan4yin</name></author><published>2020-11-28T11:49:00+08:00</published><updated>2020-11-28T11:49:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">Base64 编码并不唯一</title><link href="https://thiscute.world/posts/base64-encoding-is-not-unique/"/><id>https://thiscute.world/posts/base64-encoding-is-not-unique/</id><author><name>ryan4yin</name></author><published>2020-05-31T00:13:00+08:00</published><updated>2020-05-31T00:13:00+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">使用 tcpdump 和 Wireshark 进行远程实时抓包分析</title><link href="https://thiscute.world/posts/tcpdump-and-wireshark/"/><id>https://thiscute.world/posts/tcpdump-and-wireshark/</id><author><name>ryan4yin</name></author><published>2020-05-28T16:20:26+08:00</published><updated>2020-05-28T16:20:26+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry><entry><title type="html">使用 Istio 进行 JWT 身份验证（充当 API 网关）</title><link href="https://thiscute.world/posts/use-istio-for-jwt-auth/"/><id>https://thiscute.world/posts/use-istio-for-jwt-auth/</id><author><name>ryan4yin</name></author><published>2020-04-06T21:48:26+08:00</published><updated>2020-04-06T21:48:26+08:00</updated><content type="html">&lt;p>文章比较老就不放 RSS 里啦，请点击阅读原文吧。&lt;/p>
&lt;p>This post is too old, please click the original URL to read it.&lt;/p></content></entry></feed>