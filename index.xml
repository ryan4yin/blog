<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>This Cute World</title><link>https://thiscute.world/</link><description>This Cute World</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaoyin_c@qq.com (ryan4yin)</managingEditor><webMaster>xiaoyin_c@qq.com (ryan4yin)</webMaster><lastBuildDate>Sun, 13 Feb 2022 16:09:00 +0800</lastBuildDate><atom:link href="https://thiscute.world/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux/Windows/MacOSX 系统常用命令集锦</title><link>https://thiscute.world/posts/common-commands-for-various-operating-systems/</link><pubDate>Sun, 13 Feb 2022 16:09:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/common-commands-for-various-operating-systems/</guid><description><![CDATA[<blockquote>
<p>个人笔记，只会列出我自己容易忘掉的命令，方便查阅。</p>
</blockquote>
<blockquote>
<p>内容比较多，适合当参考手册用。可能不太适合从头读到尾&hellip;</p>
</blockquote>
<blockquote>
<p>本文主要介绍 Linux 命令，顺带介绍下 Windows/MacOSX.</p>
</blockquote>
<h2 id="一linux">一、Linux</h2>
<h3 id="1-后台运行">1. 后台运行</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 1. 后台运行命令</span>
nohup python xxx.py <span class="p">&amp;</span>
</code></pre></td></tr></table>
</div>
</div><p>也可以使用 tmux，tmux 提供的 session 功能比 nohup 更好用，后面会介绍 tmux</p>
<h3 id="2-查找替换-sedawk">2. 查找替换 sed/awk</h3>
<p>sed 常用命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1">## 只在目录中所有的 .py 和 .dart 文件中递归搜索字符&#34;main()&#34;</span>
grep <span class="s2">&#34;main()&#34;</span> . -r --include *.<span class="o">{</span>py, dart<span class="o">}</span>

<span class="c1">## 1） 全文搜索并替换</span>
<span class="c1">### -i --in-place 原地替换（修改原文件）</span>
<span class="c1">### -i=SUFFIX  替换后的文件添加 SUFFIX 这个后缀</span>
<span class="c1">### -r  使用拓展的正则表达式，注意此正则不支持 \d\w\s 等语法，必须使用 [0-9] [a-zA-Z] 等来替换！！！</span>
sed -ri <span class="s2">&#34;s/pattern_str/replace_str/g&#34;</span> <span class="sb">`</span>grep <span class="s2">&#34;key_pattern&#34;</span> <span class="s1">&#39;path_pattern&#39;</span> -rl<span class="sb">`</span>

<span class="c1">## 2）文件名搜索，替换文件内容</span>
sed -ri <span class="s2">&#34;s/pattern_str/replace_str/g&#34;</span> <span class="sb">`</span>find . -name <span class="s2">&#34;pattern&#34;</span><span class="sb">`</span>

<span class="c1">## 3）批量转换大小写</span>
<span class="c1"># 将当前文件夹内，所有的 gitlab URL 都转换成小写</span>
<span class="c1"># \L 转小写  \U 转大写</span>
sed -ri <span class="s1">&#39;s@http://GITLAB.*.git@\L&amp;@g&#39;</span> <span class="sb">`</span>find . -name pubspec*<span class="sb">`</span>


<span class="c1">## 4) 拷贝文件，并且保持文件夹结构（--parents 表示保持文件夹结构）</span>
cp --parents <span class="sb">`</span>find &lt;src-dir&gt; -name *.py<span class="sb">`</span> &lt;dst-dir&gt;
</code></pre></td></tr></table>
</div>
</div><p>awk 用于按列处理文本，它比 sed 更强大更复杂，常用命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1">## 1. 单独选出第 1 列的文本</span>
cat xxx.txt <span class="p">|</span> awk -F <span class="s1">&#39;{print $1}&#39;</span> <span class="p">|</span> head

<span class="c1">## 2. 可以使用 -F 指定分隔符，打印出多列</span>
awk -F <span class="s1">&#39;,&#39;</span> <span class="s1">&#39;{print $1,$2}&#39;</span><span class="p">|</span> head 

<span class="c1">## 3. 打印出行数</span>
cat log_test <span class="p">|</span> awk <span class="s1">&#39;{print NR,$1}&#39;</span> <span class="p">|</span> more

<span class="c1">## 4. if 判断语句</span>
cat log_test <span class="p">|</span> awk <span class="s1">&#39;{if($11&gt;300) print($1,$11)}&#39;</span>

cat log_test <span class="p">|</span> awk <span class="s1">&#39;{print $11}&#39;</span> <span class="p">|</span> sort -n <span class="p">|</span> uniq -c  

<span class="c1"># 求和</span>
cat data<span class="p">|</span>awk <span class="s1">&#39;{sum+=$1} END {print &#34;Sum = &#34;, sum}&#39;</span>

<span class="c1"># 求平均</span>
cat data<span class="p">|</span>awk <span class="s1">&#39;{sum+=$1} END {print &#34;Average = &#34;, sum/NR}&#39;</span>

<span class="c1"># 求最大值</span>
cat data<span class="p">|</span>awk <span class="s1">&#39;BEGIN {max = 0} {if ($1&gt;max) max=$1 fi} END {print &#34;Max=&#34;, max}&#39;</span>

<span class="c1"># 求最小值（min的初始值设置一个超大数即可）</span>
awk <span class="s1">&#39;BEGIN {min = 1999999} {if ($1&lt;min) min=$1 fi} END {print &#34;Min=&#34;, min}&#39;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="3-压缩相关">3. 压缩相关</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 直接 cat 压缩文件的内容</span>
zcat xxx.gz <span class="p">|</span> more  <span class="c1"># gzip</span>
xzcat xxx.xz <span class="p">|</span> more  <span class="c1"># xz</span>

tar -axvf xxx.tar.*  <span class="c1"># 通过后缀识别压缩格式，智能解压</span>
</code></pre></td></tr></table>
</div>
</div><p>更多命令参见 <a href="https://thiscute.world/posts/compression-related-instructions-under-linux/" target="_blank" rel="noopener noreferrer">常见压缩格式的区别，及 Linux 下的压缩相关指令</a></p>
<h3 id="4-文件拷贝与同步">4. 文件拷贝与同步</h3>
<p>各种 Linux 发行版都自带 scp/ssh，这两个工具功能简单，一般够用。</p>
<p>另外就是更强大也更复杂的 rsync，部分发行版会自带 rsync。</p>
<p>下面分别介绍下。</p>
<h4 id="1-sshscp">1. ssh/scp</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 如果使用 ssh 命令进行文件传输，可安装 pv 命令查看传输速度（pipeviewer）</span>
<span class="c1">## ubuntu</span>
sudo apt-get install pv
<span class="c1">##  centos</span>
sudo yum install epel-release
sudo yum install pv

<span class="c1">## 1)从本地上传到服务器</span>

<span class="c1">### 使用 ssh 的好处是流式传输不会占用目标机器的存储空间，适合传输可能引起空间不足的大文件，并在目标机器上实时处理该文件。</span>
cat &lt;filename&gt; <span class="p">|</span> pv <span class="p">|</span> ssh &lt;user&gt;@&lt;host&gt; -p <span class="m">22</span> <span class="s2">&#34;cat - &gt; &lt;new-filename&gt;&#34;</span>
tar cz &lt;filename or foldername or glob&gt; <span class="p">|</span> pv <span class="p">|</span> ssh &lt;user&gt;@&lt;host&gt; -p <span class="m">22</span> <span class="s2">&#34;tar xz&#34;</span>  <span class="c1"># 压缩传输</span>

<span class="c1">## scp 命令比 ssh 命令更简洁（但是不适合用于传文件夹，它会破坏文件的权限设置，把文件夹弄得一团糟）</span>
scp -P <span class="m">22</span> &lt;filename&gt; &lt;user&gt;@&lt;host&gt;:&lt;folder-name or filename&gt;  <span class="c1"># 通过 scp 传输，传文件夹时记得添加 -r 参数（recursive）</span>

<span class="c1">## 2) 从服务器下载到本地</span>
ssh &lt;user&gt;@&lt;host&gt; -p <span class="m">22</span> <span class="s2">&#34;tar cz &lt;filename or foldername or glob&gt;&#34;</span> <span class="p">|</span> pv <span class="p">|</span> tar xz  <span class="c1"># 压缩传输</span>
scp -P <span class="m">22</span> &lt;user&gt;@&lt;host&gt;:&lt;folder-name or filename&gt; &lt;filename&gt;  <span class="c1"># 通过 scp 传输，传文件夹时记得添加 -r 参数（recursive）</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="2-rsync">2. rsync</h4>
<p>rsync 的功能其实和前面的 scp/(tar+ssh) 是一样的，将文件从一个地方拷贝到另一个地方。
区别在于它只做增量同步，在多次拷贝文件时，只拷贝（同步）修改过的部分，很多场景下可以大大加快拷贝/备份速度。</p>
<p>rsync 的常用命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 将一个文件夹归档、压缩，并通过 ssh 协议（默认）同步到另一个地方</span>
<span class="c1"># -a, --archive   # 归档模式，保留文件的所有元信息，等同于 `-rlptgoD`</span>
<span class="c1"># -r, --recursive # 递归复制文件夹，`-a` 隐含了这个参数，通常都用 -a。</span>
<span class="c1"># -v, --verbose   # 输出详细信息</span>
<span class="c1"># --progress      # 显示传输进度</span>
<span class="c1"># -z, --compress  # 传输文件时进行压缩</span>
rsync -avz --progress src host:dest
rsync -avz --progress -e <span class="s2">&#34;ssh -p225&#34;</span> /path/src user@host:dest  <span class="c1"># 使用非默认的 ssh 端口进行传输</span>
rsync -avz --progress -e <span class="s2">&#34;ssh -i id_xxx&#34;</span> /path/src user@host:dest  <span class="c1"># 使用指定的私钥连接 ssh 服务端，其他各种 ssh 参数都可以在这里指定</span>

<span class="c1"># --exclude 排除掉某些不需要的文件(夹)</span>
rsync -avz --progress --exclude <span class="s2">&#34;foor/bar&#34;</span> src user@host:dest

<span class="c1"># 有时我们希望在同步数据时修改文件的 user/group</span>
<span class="c1"># --chown    # 设置文件的 user:group，必须与 `-og`/`--owner --group` 同时使用！（`-a` 隐含了 `-og`） </span>
rsync -avz --progress --chown<span class="o">=</span>root:root src user@host:dest  <span class="c1"># 传输时修改 user/group 为 root</span>

<span class="c1"># 详细说明 src 和 dest 的位置</span>
rsync -avz --progress path/src user@host:/tmp  <span class="c1"># 将 src 拷贝到远程主机的 /tmp 中（得到 /tmp/src）</span>
<span class="c1">## 注意 src 结尾有 /</span>
rsync -avz --progress path/src/ user@host:/tmp/src  <span class="c1"># 将 src 目录中的文件拷贝到远程主机的 /tmp/src 目录中（同样得到 /tmp/src）</span>

<span class="c1"># 有时候我们在传输文件时不希望保留文件的元信息</span>

<span class="c1"># rsync 默认不会删除 dest 中多余的文件，使用 --delete 可让 rsync 删除这部分无关的文件</span>
<span class="c1"># 对 src 文件夹进行完全镜像，保证两个文件夹的内容一模一样，不多不少</span>
rsync -avz --progress --delete src user@host:dest

<span class="c1"># 也可以使用 --ignore-existing 让 rsync 忽略掉 dest 已经存在的文件。就是只同步新增的文件。</span>
rsync -avz --progress --ignore-existing src user@host:dest
</code></pre></td></tr></table>
</div>
</div><p>另外也有使用双冒号 <code>::</code> 分隔的传输命令，这种命令使用 <code>rsync</code> 协议进行传输，要求目标主机启用 rsync-daemon。用得会比 ssh 少一些，暂时不做介绍。</p>
<p>rsync 详细文档参见 <a href="https://rsync.samba.org/documentation.html" target="_blank" rel="noopener noreferrer">https://rsync.samba.org/documentation.html</a>，或者 <code>man rsync</code>.</p>
<h3 id="5-tmux">5. Tmux</h3>
<ol>
<li>输入 <code>tmux</code> 启动一个 tmux 会话。（或者用 <code>tmux new -s &lt;session-name&gt;</code> 启动一个命名会话）</li>
<li>输入 <code>python xxx.py</code>，python 进程开始运行。</li>
<li>按快捷键 <code>ctrl+b</code>，然后再按一下 <code>d</code> 脱离(detatch)当前会话。此时 python 进程进入后台运行，关闭当前终端对 python 进程没有影响。</li>
<li>输入 <code>tmux ls</code> 可以查看当前正在后台运行的会话。（命名会话会显示名称，否则只显示 id）</li>
<li>通过 <code>tmux attach -t &lt;session-name/id&gt;</code> 重新接入后台会话。
<ol>
<li>缩写 <code>tmux a -t &lt;session&gt;</code></li>
</ol>
</li>
<li>或者通过 <code>tmux kill-session -t &lt;session-name/id&gt;</code> 杀死一个后台会话。</li>
</ol>
<p>常用快捷键：</p>
<pre><code>  # prefix 表示 `ctrl`+`b`

  # pane 的切分与选择
  prefix &quot;  # 在下方新建一个 pane
  prefix %  # 在右侧新建一个 pane
  prefix `方向键`  # 光标移动到指定方向的 pane 中

  # 使用方向键滚动窗口内容
  prefix [  # 进入翻页模式，可使用 page up/down，或者方向键来浏览 pane 的内容
  # 使用鼠标滚轮来滚动窗口内容（也可以把此命令添加到 `~/.tmux.conf` 中使它永久生效）
  prefix `:` 然后输入 `set-window-option -g mode-mouse on`

  # （调整 pane 大小）将当前的 pane 向给定的方向扩容 5 行或者 5 列
  # 按住 ALT 时快速重复敲击「方向键」，能快速调整，否则就得从 prefix 开始重新输入
  prefix `Alt` + `方向键`
  # 将当前窗格全屏显示，第二次使用此命令，会将窗格还原
  prefix z

  # 交换 pane 的位置
  prefix {  # 当前窗格与上一个窗格交换位置
  prefix }  # 当前窗格与下一个窗格交换位置

  # session 相关操作
  prefix s  # 查看 session 列表，并通过方向键选择 session
  prefix `number`  # 通过数字标签选择 session

  # window 相关操作（关系：每个 session 可以包含多个 window，每个 window 里面又可以有多个 pane）
  prefix c # 新建 window
  prefix w # 通过数字标签选择 window
</code></pre>
<p>参考文档：</p>
<ul>
<li><a href="https://github.com/tmux/tmux/wiki/Getting-Started" target="_blank" rel="noopener noreferrer">https://github.com/tmux/tmux/wiki/Getting-Started</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html" target="_blank" rel="noopener noreferrer">https://www.ruanyifeng.com/blog/2019/10/tmux.html</a></li>
</ul>
<h3 id="6-bash-shell-基础">6. Bash Shell 基础</h3>
<p>目标：能使用 shell 编写 10 行以内的脚本。更长的脚本可以使用 Python 编写，就没必要折腾 Shell 了。</p>
<h4 id="1-for-循环">1. For 循环</h4>
<p>单行 for 循环，有时候很有用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 数字枚举</span>
<span class="k">for</span> i in <span class="k">$(</span>seq <span class="m">1</span> 5<span class="k">)</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done</span>  <span class="c1"># sh/bash 都支持</span>
<span class="k">for</span> i in <span class="o">{</span>1..5<span class="o">}</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done</span>  <span class="c1"># sh 不支持此语法</span>


<span class="c1"># 文件枚举，可使用 glob 语法进行文件匹配</span>
<span class="k">for</span> f in *<span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="nv">$f</span><span class="p">;</span> <span class="k">done</span>
<span class="k">for</span> f in /etc/*.py<span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="nv">$f</span><span class="p">;</span> <span class="k">done</span>

<span class="c1"># 使用 find 进行文件枚举</span>
<span class="k">for</span> f in <span class="k">$(</span>find . -name *.py<span class="k">)</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="nv">$f</span><span class="p">;</span> <span class="k">done</span>
</code></pre></td></tr></table>
</div>
</div><p>单行 for 循环加几个换行就得到多行 for 循环，格式如下：写脚本用得到，不过更建议用 python:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="k">for</span> i in <span class="k">$(</span>seq <span class="m">1</span> 5<span class="k">)</span>
<span class="k">do</span> 
  <span class="nb">echo</span> <span class="nv">$i</span>
<span class="k">done</span>  <span class="c1"># sh/bash 都支持</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="2-if-语句">2. if 语句</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 单行 if 语句</span>
<span class="k">if</span> <span class="o">[</span> <span class="nb">true</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span> &lt;command&gt;<span class="p">;</span> <span class="k">fi</span>

<span class="c1">#  if else</span>
<span class="k">if</span> <span class="o">[</span> expression <span class="o">]</span>
<span class="k">then</span>
   Statement<span class="o">(</span>s<span class="o">)</span> to be executed <span class="k">if</span> expression is <span class="nb">true</span>
<span class="k">else</span>
   Statement<span class="o">(</span>s<span class="o">)</span> to be executed <span class="k">if</span> expression is not <span class="nb">true</span>
<span class="k">fi</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="3-shell脚本中的set指令比如set--x-和-set--e">3. Shell脚本中的set指令，比如set -x 和 set -e</h4>
<p>参见：<a href="https://www.cnblogs.com/robinunix/p/11635560.html" target="_blank" rel="noopener noreferrer">Shell脚本中的set指令，比如set -x 和 set -e</a></p>
<h4 id="4-其他资料">4. 其他资料</h4>
<ul>
<li><a href="https://github.com/mritd/shell_scripts" target="_blank" rel="noopener noreferrer">shell_scripts</a>: 实用 shell 小脚本</li>
</ul>
<h3 id="socket-commands">7. socket 连接查询 - ss/netcat/lsof</h3>
<p>查看 socket 信息可以帮我们回答下列问题：</p>
<ol>
<li>我的程序是不是真的在监听我指定的端口？</li>
<li>我的程序是在监听 127.0.0.1（本机），还是在监听 0.0.0.0（整个网络）</li>
<li>进程们分别在使用哪些端口？</li>
<li>我的连接数是否达到了上限？</li>
</ol>
<blockquote>
<p>现在较新版本的 Ubuntu 和 CentOS 都已经使用 <code>iproute2</code> 替换掉了 <code>net-tools</code>，
如果你还需要使用陈旧的 <code>route</code> <code>netstat</code> 等命令，需要手动安装 <code>net-tools</code>。</p>
</blockquote>
<p>我们可以使用 ss(socket statistics) 或者 netstat 命令来查看 socket 信息:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 查看 socket 连接的统计信息</span>
<span class="c1"># 主要统计处于各种状态的 tcp sockets 数量，以及其他 sockets 的统计信息</span>
ss --summary
ss -s  <span class="c1"># 缩写</span>

<span class="c1"># 查看哪个进程在监听 80 端口</span>
<span class="c1"># --listening 列出所有正在被监听的 socket</span>
<span class="c1"># --processes 显示出每个 socket 对应的 process 名称和 pid</span>
<span class="c1"># --numeric 直接打印数字端口号（不解析协议名称）</span>
ss --listening --processes --numeric <span class="p">|</span> grep <span class="m">80</span>
ss -nlp <span class="p">|</span> grep <span class="m">80</span>  <span class="c1"># 缩写</span>
ss -lp <span class="p">|</span> grep http  <span class="c1"># 解析协议名称，然后通过协议名搜索监听</span>

<span class="c1">## 使用过时的 netstat</span>
<span class="c1">### -t tcp</span>
<span class="c1">### -u udp</span>
netstat -tunlp <span class="p">|</span> grep <span class="s2">&#34;:80&#34;</span>

<span class="c1"># 查看 sshd 当前使用的端口号</span>
ss --listening --processes <span class="p">|</span> grep sshd
<span class="c1">## 使用过时的 netstat</span>
netstat -tunlp <span class="p">|</span> grep &lt;pid&gt;  <span class="c1"># pid 通过 ps 命令获得</span>

<span class="c1"># 列出所有的 tcp sockets，包括所有的 socket 状态</span>
ss --tcp --all

<span class="c1"># 只列出正在 listen 的 socket</span>
ss --listening

<span class="c1"># 列出所有 ESTABLISHED 的 socket（默认行为）</span>
ss

<span class="c1"># 统计 TCP 连接数</span>
ss <span class="p">|</span> grep ESTAB <span class="p">|</span> wc -l

<span class="c1"># 列出所有 ESTABLISHED 的 socket，并且给出连接的计时器</span>
ss --options

<span class="c1"># 查看所有来自 192.168.5 的 sockets</span>
ss dst 192.168.1.5

<span class="c1"># 查看本机与服务器 192.168.1.100 建立的 sockets</span>
ss src 192.168.1.5
</code></pre></td></tr></table>
</div>
</div><p>TCP 连接数受 Linux 文件描述符上限控制，可以通过如下方法查看已用文件句柄的数量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 已用文件描述符数量</span>
lsof <span class="p">|</span> wc -l
<span class="c1"># 文件描述符上限</span>
<span class="nb">ulimit</span> -n 
</code></pre></td></tr></table>
</div>
</div><h3 id="8-其他网络相关命令">8. 其他网络相关命令</h3>
<p>主要是 iproute2 dhclient lsof 等</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 查看路由表</span>
routel       <span class="c1"># 旧的 net-tools 包中的命令</span>
ip route ls  <span class="c1"># iproute2 提供的新命令</span>

<span class="c1"># DHCP，先释放旧租约，再建立新租约</span>
sudo dhclient -r eth0 <span class="o">&amp;&amp;</span> sudo dhclient eth0
<span class="c1"># 查看 DHCP 租期</span>
cat /var/lib/dhcp/dhcpd.leases

<span class="c1"># 清理 DNS 缓存</span>
<span class="c1">## 1. 如果你使用的是 systemd-resolve，使用此命令</span>
sudo systemd-resolve --flush-caches
sudo systemd-resolve --statistics  <span class="c1"># 查看缓存状态</span>
<span class="c1">## 2. 如果使用的是 dnsmasq，使用此命令</span>
sudo systemctl restart dnsmasq
sudo killall -HUP dnsmasq  <span class="c1"># 直接发送 HUP 信号也可以</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="9-容器网络诊断---nsenter">9. 容器网络诊断 - nsenter</h3>
<p>Docker 容器有自己的 namespace，直接通过宿主机的 ss 命令是查看不到容器的 socket 信息的。</p>
<p>比较直观的方法是直接通过 <code>docker exec</code> 在容器中通过 ss 命令。但是这要求容器中必须自带 ss 等程序，有的精简镜像可能不会自带它。</p>
<p>通过 <code>nsenter</code> 可以直接进入到容器的指定 namespace 中，这样就能直接查询容器网络相关的信息了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">docker ps <span class="p">|</span> grep xxx

<span class="nb">echo</span> <span class="nv">CONTAINER</span><span class="o">=</span>xxx  <span class="c1"># 容器名称或 ID</span>

<span class="c1"># 1. 查询到容器对应的 pid</span>
<span class="nv">PID</span><span class="o">=</span><span class="k">$(</span>docker inspect --format <span class="o">{{</span>.State.Pid<span class="o">}}</span> <span class="nv">$CONTAINER</span><span class="k">)</span>

<span class="c1"># 2. nsenter 通过 pid 进入容器的 network namespace，执行 ss 查看 socket 信息</span>
nsenter --target <span class="nv">$PID</span> --net ss -s
</code></pre></td></tr></table>
</div>
</div><p><code>nsenter</code> 这个工具貌似是 docker 自带的或者是系统内置命令，只要装了 docker，ubuntu/centos 都可以直接使用这个命令。</p>
<blockquote>
<p>nsenter 是一个进入名字空间的工具，功能不仅仅局限在「网络诊断」，还有更多用法。</p>
</blockquote>
<h3 id="10-用户与群组">10. 用户与群组</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1">## 查看用户属于哪些群组</span>
groups &lt;user-name&gt;  <span class="c1"># 方法一</span>
id &lt;username&gt;       <span class="c1"># 方法二，它会额外列出 gid/uid</span>
cat /etc/group <span class="p">|</span> grep &lt;user-name&gt;  <span class="c1"># 方法三，直接查看配置</span>
<span class="c1">## 查看群组中有哪些用户，第一列是群组，最后一列是用户名</span>
cat /etc/group <span class="p">|</span> grep &lt;group-name&gt;
</code></pre></td></tr></table>
</div>
</div><h2 id="二powershell">二、Powershell</h2>
<p>Powershell 是微软推出的一款新一代 shell，它的特点之一是，命令都有一致的命名规则：<strong>谓词-名词</strong>，
谓词表示动作：Get/Set/Stop/Start 等，名词指示操作对象：Service/Member/ChildItem/Command 等。</p>
<p>这样的命名格式使我们可以很容易地猜测到自己需要的命令的名称。</p>
<p>为了使用方便，powershell 还提供了一些常用命令的缩写，并且添加了大量类似 Linux 命令的别名。</p>
<p>还有就是，Windows 默认不区分字母大小写，日常使用可以全部小写。</p>
<h3 id="1-实用命令">1. 实用命令</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="c"># 删除文件/文件夹</span>
<span class="nb">remove-item</span> <span class="n">xxx</span>  <span class="n">-confirm</span>
<span class="nb">ri </span><span class="n">xxx</span>  <span class="c"># 别名1</span>
<span class="nb">rm </span><span class="n">xxx</span>  <span class="c"># 别名2</span>
<span class="nb">rmdir </span><span class="n">xxx</span>  <span class="c"># etc...</span>

<span class="c"># 复制</span>
<span class="nb">copy-item</span> <span class="n">xxx</span> <span class="n">xx</span> <span class="n">-r</span>
<span class="nb">cp </span><span class="n">-r</span> <span class="n">xxx</span> <span class="n">xx</span>

<span class="c"># 显示工作目录</span>
<span class="nb">get-location</span>
<span class="nb">gl
</span><span class="nb">pwd
</span><span class="nb"></span>
<span class="c"># 切换工作目录</span>
<span class="nb">set-location</span> <span class="n">xxx</span>
<span class="nb">sl </span><span class="n">xxx</span>
<span class="nb">cd </span><span class="n">xxx</span>

<span class="c"># 查看环境变量</span>
<span class="nb">get-childitem</span> <span class="n">env</span><span class="err">:</span>
<span class="nb">gci </span><span class="n">env</span><span class="err">:</span>
<span class="nb">gci </span><span class="n">env</span><span class="err">:</span><span class="n">PATH</span>  <span class="c"># 查看 PATH 变量</span>

<span class="nv">$env:XXX</span><span class="p">=</span><span class="s2">&#34;value&#34;</span>   <span class="c"># 临时设置环境变量</span>
<span class="nv">$env:Path</span> <span class="p">+=</span> <span class="s2">&#34;;SomeRandomPath&#34;</span>  <span class="c"># 临时在 Path 末尾添加新路径</span>
<span class="c">## 以下三行命令只对 windows 有效，linux 下无效</span>
<span class="no">[Environment]</span><span class="p">::</span><span class="n">SetEnvironmentVariable</span><span class="p">(</span><span class="s2">&#34;XXX&#34;</span><span class="p">,</span> <span class="nv">$env:XXX</span> <span class="p">+</span> <span class="s2">&#34;;value&#34;</span><span class="p">,</span> <span class="no">[EnvironmentVariableTarget]</span><span class="p">::</span><span class="n">User</span><span class="p">)</span>  <span class="c"># 修改当前用户的环境变量（永久），只对新进程有效</span>
<span class="no">[Environment]</span><span class="p">::</span><span class="n">SetEnvironmentVariable</span><span class="p">(</span><span class="s2">&#34;XXX&#34;</span><span class="p">,</span> <span class="s2">&#34;value&#34;</span><span class="p">,</span> <span class="no">[EnvironmentVariableTarget]</span><span class="p">::</span><span class="n">Machine</span><span class="p">)</span>  <span class="c"># 给这台电脑设置环境变量（永久），只对新进程有效，需要管理员权限</span>
<span class="no">[Environment]</span><span class="p">::</span><span class="n">SetEnvironmentVariable</span><span class="p">(</span><span class="s2">&#34;XXX&#34;</span><span class="p">,</span> <span class="nv">$env:XXX</span> <span class="p">+</span> <span class="s2">&#34;;value&#34;</span><span class="p">,</span> <span class="s2">&#34;User&#34;</span><span class="p">)</span>  <span class="c"># target 也可用字符串指定</span>

<span class="c"># 删除文件/文件夹</span>
<span class="nb">rm </span><span class="n">xxx</span>  <span class="c"># 删除文件夹时会进入交互界面，按提示输入就行。</span>

<span class="c"># 查看命名位置（类似 Linux Shell 的 which）</span>
<span class="nb">get-command</span> <span class="n">xxx</span>
<span class="nb">gcm </span><span class="n">xxx</span>

<span class="c"># 通过关键字查找 powershell 命令</span>
<span class="nb">gcm </span><span class="p">|</span> <span class="nb">select-string</span> <span class="p">&lt;</span><span class="n">keyword</span><span class="p">&gt;</span>

<span class="c"># 通过关键字查找 powershell 命令和环境变量中的程序，比较慢</span>
<span class="nb">gcm </span><span class="p">*</span> <span class="p">|</span> <span class="nb">select-string</span> <span class="p">&lt;</span><span class="n">keyword</span><span class="p">&gt;</span>

<span class="c"># 查看别名对应的真实命令</span>
<span class="nb">get-alias</span>

<span class="c"># 类似 linux 的 find/ls 命令</span>
<span class="nb">get-childitem</span> <span class="n">-Recurse</span> <span class="n">-Include</span> <span class="p">*.</span><span class="n">py</span>
<span class="nb">gci </span><span class="n">-r</span> <span class="n">-i</span> <span class="p">*.</span><span class="n">py</span>

<span class="c"># 清空终端的输出</span>
<span class="nb">clear-host</span>
<span class="nb">clear
</span><span class="nb"></span>
<span class="c"># 查看文件内容</span>
<span class="nb">get-content</span> <span class="n">xx</span><span class="p">.</span><span class="n">py</span> <span class="p">|</span> <span class="n">more</span>
<span class="nb">get-content</span> <span class="n">xx</span><span class="p">.</span><span class="n">py</span> <span class="p">|</span> <span class="nb">out-host</span> <span class="n">-paging</span>
<span class="nb">cat </span><span class="n">xx</span><span class="p">.</span><span class="n">py</span>
<span class="nb">gc </span><span class="n">xx</span><span class="p">.</span><span class="n">py</span>

<span class="c"># 字符串搜索，不能对对象使用</span>
<span class="c"># 类似 linux 的 grep 命令</span>
<span class="nb">cat </span><span class="n">xxx</span><span class="p">.</span><span class="n">log</span> <span class="p">|</span> <span class="nb">select-string</span> <span class="p">&lt;</span><span class="n">pattern</span><span class="p">&gt;</span>
<span class="nb">gci </span><span class="n">env</span><span class="err">:</span> <span class="p">|</span> <span class="nb">out-string</span>  <span class="n">-stream</span> <span class="p">|</span> <span class="nb">select-string</span> <span class="p">&lt;</span><span class="n">pattern</span><span class="p">&gt;</span>  <span class="c"># 需要先使用 out-string 将对象转换成 string</span>
<span class="nb">gci </span><span class="n">env</span><span class="err">:</span> <span class="p">|</span> <span class="nb">where-object</span> <span class="p">{</span><span class="nv">$_</span><span class="p">.</span><span class="n">Name</span> <span class="o">-like</span> <span class="p">&lt;</span><span class="n">pattern</span><span class="p">&gt;}</span>

<span class="c"># 计算输出的行数/对象个数</span>
<span class="nb">gci </span><span class="n">env</span><span class="err">:</span> <span class="p">|</span> <span class="nb">measure-object</span>
<span class="nb">gci </span><span class="n">env</span><span class="err">:</span> <span class="p">|</span> <span class="nb">measure </span> <span class="c"># 这是缩写</span>

<span class="c"># 关机/重启</span>
<span class="nb">stop-computer</span>
<span class="nb">restart-computer</span>

<span class="c"># windows 计算 hash 值</span>
<span class="c"># 功能等同于 linux 下的 sha256sum/sha1sum/sha512sum/md5sum</span>
<span class="nb">Get-FileHash</span> <span class="n">-Path</span> <span class="p">/</span><span class="n">path</span><span class="p">/</span><span class="n">to</span><span class="p">/</span><span class="n">file</span> <span class="n">-Algorithm</span> <span class="n">SHA256</span>
<span class="nb">Get-FileHash</span> <span class="n">-Path</span> <span class="p">/</span><span class="n">path</span><span class="p">/</span><span class="n">to</span><span class="p">/</span><span class="n">file</span> <span class="n">-Algorithm</span> <span class="n">SHA256</span>  <span class="p">|</span> <span class="nb">Format-List</span>  <span class="c"># 用 format 修改格式化效果</span>

<span class="c"># base64 编解码</span>
<span class="no">[Convert]</span><span class="p">::</span><span class="n">ToBase64String</span><span class="p">(</span><span class="no">[Text.Encoding]</span><span class="p">::</span><span class="n">UTF8</span><span class="p">.</span><span class="n">GetBytes</span><span class="p">(</span><span class="s2">&#34;xxx&#34;</span><span class="p">))</span>  <span class="c"># base64 编码</span>
<span class="no">[Text.Encoding]</span><span class="p">::</span><span class="n">UTF8</span><span class="p">.</span><span class="n">GetString</span><span class="p">(</span><span class="no">[Convert]</span><span class="p">::</span><span class="n">FromBase64String</span><span class="p">(</span><span class="s2">&#34;eHh4&#34;</span><span class="p">))</span>  <span class="c"># 解码</span>

</code></pre></td></tr></table>
</div>
</div><p>另外 windows 同样自带 ssh/scp 命令，参数也和 linux 一致</p>
<h3 id="2-进程相关命令">2. 进程相关命令</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="c"># 查看所有进程</span>
<span class="nb">get-process</span> <span class="p">|</span> <span class="n">more</span>
<span class="nb">ps </span><span class="p">|</span> <span class="n">more</span>  <span class="c"># 别名</span>

<span class="c"># 查找某进程（替代掉 tasklist）</span>
<span class="nb">get-process</span> <span class="n">-name</span> <span class="n">exp</span><span class="p">*,</span><span class="n">power</span><span class="p">*</span>  <span class="c"># 使用正则查找进程</span>
<span class="nb">get-process</span> <span class="p">|</span> <span class="nb">select-string</span> <span class="p">&lt;</span><span class="n">pattern</span><span class="p">&gt;</span>  <span class="c"># 效果同上</span>

<span class="c"># 通过 id 杀掉某进程（替代掉 taskkill）</span>
<span class="c"># 也可以通过 -Name 用正则匹配进程</span>
<span class="nb">stop-process</span> <span class="p">&lt;</span><span class="n">pid</span><span class="p">&gt;</span>
<span class="nb">kill </span><span class="p">&lt;</span><span class="n">pid</span><span class="p">&gt;</span>  <span class="c"># 别名</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="3-网络相关命令">3. 网络相关命令</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="c">## 1. dns 相关(dns-client)</span>
<span class="nb">Clear-DnsClientCache</span>  <span class="c"># 清除 dns 缓存（替换掉 `ipconfig /flushdns`）</span>
<span class="nb">Get-DnsClientCache</span>  <span class="c"># 查看 dns 缓存</span>
<span class="nb">Resolve-DnsName</span> <span class="n">baidu</span><span class="p">.</span><span class="n">com</span>  <span class="c"># 解析域名</span>

<span class="c"># 更新 DHCP 租约</span>
<span class="n">ipconfig</span> <span class="p">/</span><span class="n">renew</span>

<span class="c">## 2. TCP/IP 相关命令</span>
<span class="nb">Get-Command</span> <span class="nb">Get-Net</span><span class="p">*</span>  <span class="c"># 查看所有 TCP/IP 相关的命令</span>

<span class="nb">Get-NetIPAddress</span>  <span class="c"># 查看 IP 地址</span>
<span class="nb">Get-NetIPInterface</span>  <span class="c"># 查看 IP 接口</span>
<span class="nb">Get-NetRoute</span>        <span class="c"># 查看路由表</span>
<span class="nb">Get-NetNeighbor</span>     <span class="c"># 获取链路层 MAC 地址缓存</span>
<span class="nb">Get-NetTCPConnection</span>   <span class="c"># 查看 TCP 连接</span>
<span class="c">### 也可以对 TCP/IP 的 IP 地址、接口、路由表进行增删改</span>
<span class="nb">New-NetRoute</span>
<span class="nb">Remove-NetNeighbor</span>  <span class="c"># 清除 MAC 地址缓存</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="4-socket-信息查询---netstat">4. socket 信息查询 - netstat</h3>
<p>Windows 系统和 macOS 一样，也没有 <code>ss</code>，但是自带 <code>netstat</code>，该命令和 Linux 下的 <code>netstat</code> 有一定差别，具体使用方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="n">netstat</span> <span class="p">-?</span>  <span class="c"># 查看使用帮助，很清晰易懂</span>

<span class="c"># 查看那个进程在监听 80 端口，最后一列是进程的 Pid</span>
<span class="n">netstat</span> <span class="n">-ano</span> <span class="p">|</span> <span class="n">findstr</span> <span class="n">80</span>        <span class="c"># windows 命令</span>
<span class="n">netstat</span> <span class="n">-ano</span> <span class="p">|</span> <span class="nb">select-string</span> <span class="n">80</span>  <span class="c"># powershell 命令，就是把 findstr 替换成 select-string</span>

<span class="c"># 不仅列出 Pid，还给出 Pid 对应的可执行文件名称（需要管理员权限）</span>
<span class="n">netstat</span> <span class="n">-ano</span> <span class="n">-b</span> <span class="p">|</span> <span class="nb">select-string</span> <span class="n">80</span>  <span class="c"># powershell 命令</span>

<span class="c"># 列出所有 ESTABLISHED 的 socket（默认行为）</span>
<span class="n">netstat</span>

<span class="c"># 列出所有正在监听的端口</span>
<span class="n">netstat</span> <span class="n">-ano</span> <span class="p">|</span> <span class="n">findstr</span> <span class="n">LISTENING</span>

<span class="c"># 只列出 TCP 连接</span>
<span class="n">netstat</span> <span class="n">-ano</span> <span class="n">-p</span> <span class="n">TCP</span>


<span class="c"># 查看路由表</span>
<span class="n">route</span> <span class="p">-?</span>  <span class="c"># 查看使用帮助，很清晰易懂</span>
<span class="n">route</span> <span class="n">print</span>    <span class="c"># 查看所有路由信息</span>
<span class="n">route</span> <span class="n">print</span> <span class="p">-</span><span class="n">4</span>  <span class="c"># 仅 ipv4</span>
</code></pre></td></tr></table>
</div>
</div><p>比如我们遇到端口占用问题时，就可以通过上述命令查找到端口对应的 Pid，然后使用 <code>kill &lt;Pid&gt;</code> 命令（powershell <code>stop-process</code> 的别名）杀死对应的进程。</p>
<h2 id="三mac-os-x">三、Mac OS X</h2>
<p>Mac OS X 系统也是 unix-like 系统，也使用 zsh/bash，因此大部分命令基本都跟 Linux 没啥区别，可以直接参考前面 Linux 一节的内容。</p>
<p>但是要注意一些坑：</p>
<ul>
<li>macos 自带的 tar 并不是 gnutar，命令使用方式不一样！
<ul>
<li>解决：<code>brew install gnu-tar</code>，安装好后通过 <code>gtar</code> 调用，参数就跟 linux 一致了。</li>
</ul>
</li>
<li>网络相关的命令区别较大，后面会详细介绍。</li>
<li>MacOSX 使用 launchpad 作为系统服务管理器，跟 systemd 区别很大。</li>
</ul>
<h3 id="1-查看-socket-信息">1. 查看 socket 信息</h3>
<p>Mac OS X 系统目前没有 <code>ss</code>，但是自带 <code>netstat</code>，该命令和 Linux 下的 <code>netstat</code> 有一定差别，而且还很慢，还不能显示 pid.</p>
<p>所以 stackoverflow 上更推荐使用 <code>lsof</code>，几条常用命令记录如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># -n 表示不显示主机名</span>
<span class="c1"># -P 表示不显示端口俗称</span>
<span class="c1"># 不加 sudo 只能查看以当前用户运行的程序</span>
<span class="c1"># 通用格式：</span>
sudo lsof -nP -iTCP:端口号 -sTCP:LISTEN

<span class="c1"># 查看所有 tcp 连接</span>
lsof -nP -iTCP

<span class="c1"># 查看所有监听端口相关的信息（command/pid）</span>
lsof -nP -iTCP -sTCP:LISTEN
</code></pre></td></tr></table>
</div>
</div><h3 id="2-其他网络相关命令">2. 其他网络相关命令</h3>
<p>清理 DNS 缓存：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># macos 10.10+</span>
sudo dscacheutil -flushcache
sudo killall -HUP mDNSResponder

<span class="c1"># 其他版本请自己网上搜...</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 查看所有网络接口及相关参数（ip/mac/type...）</span>
ifconfig

<span class="c1"># 查看路由表</span>
netstat -nr
</code></pre></td></tr></table>
</div>
</div><h2 id="四跨平台程序">四、跨平台程序</h2>
<h3 id="1-vim">1. vim</h3>
<h4 id="常用技巧">常用技巧</h4>
<p>移动：</p>
<ul>
<li><code>0</code>/<code>^</code> 回到行首，<code>$</code> 去到行末</li>
<li>w 跳到下个单词的首部，e 跳到下个单词末尾
<ul>
<li>也能使用 2w 2e 这种命令按单词数量跳转</li>
</ul>
</li>
</ul>
<p>删除 <code>d</code> 或修改 <code>c</code>:</p>
<ul>
<li>dw 删除单词，d2w 删除两个单词</li>
<li>d$ 删除到行末，<code>d0</code>/<code>d^</code> 删除到行首</li>
<li><code>d(</code>/<code>d{</code>/<code>d[[</code> 删除到文件首部，<code>d)</code>/<code>d}</code>/<code>d]]</code> 删除到文件末尾</li>
<li><code>r</code> 替换一个字符，<code>R</code> 持续往后替换</li>
</ul>
<h4 id="多行修改">多行修改</h4>
<p>多行插入，主要用于加注释之类的：</p>
<ul>
<li>光标停留在你需要插入文本的地方</li>
<li><code>ctrl</code>+<code>v</code> 进入 visual block 模式，选中多行</li>
<li>输入 <code>I</code>，进入编辑模式</li>
<li>输入 <code>#</code> 注释或者其他字符，但是注意不能输入换行符！也不能删除？</li>
<li>按两下 <code>Esc</code>，依次退出 Insert 和 visual block 模式，就插入成功了</li>
</ul>
<p>多行删除：</p>
<ul>
<li><code>v</code> 进入 visual 模式，在第一行，选中你想要删除的文本块
<ul>
<li>或者也可以先进入 visual block 模式，再通过左右方向键选择文本。</li>
</ul>
</li>
<li><code>ctrl</code>+<code>v</code> 进入 visual block 模式，选中多行
<ul>
<li>visual block 的特点是它是垂直选择，而 visual 模式是段落选择</li>
</ul>
</li>
<li>按 <code>d</code> 键就能删除被选中的所有内容。</li>
</ul>
<h4 id="多行替换基本和-sed-一致">多行替换（基本和 sed 一致）</h4>
<p>多行行首插入注释符号 <code>#</code></p>
<pre><code>  :1,6 s/^/#/g
  :2,$ s/^/#/g   注：此为2行至尾行
  :% s/^/#/g     注：此为所有行
</code></pre>
<p>这里使用了正则表达式 <code>^</code> 匹配行首，改成 <code>$</code> 就可在行尾进行批量修改。</p>
<p>此外，它的分隔符也不仅限于 <code>\</code>，也可以用 <code>@</code> 等符号，方便阅读。比如：</p>
<pre><code>  :1,6 s@^@#@g
  :2,$ s@^@#@g   注：此为2行至尾行
  :% s@^@#@g     注：此为所有行
</code></pre>
<p>使用 vim 的这个正则匹配功能，不仅能进行插入，也能完成删除、替换的功能。</p>
<h4 id="将选中部分写入到文件">将选中部分写入到文件</h4>
<ul>
<li>首先按 <code>v</code> 进入 visual 模式，选中需要的内容</li>
<li>按 <code>:</code>，应该会显示 <code>:'&lt;,'&gt;</code>，表示对选中部分进行操作</li>
<li>输入内容 <code>w new.txt</code>，此时显示效果应该是 <code>:'&lt;,'&gt;w new.txt</code></li>
<li>回车就能完成文件写入</li>
</ul>
<h4 id="问题在-vim-中粘贴-yaml-时缩进会变得一团糟">问题：在 vim 中粘贴 yaml 时缩进会变得一团糟</h4>
<p>解决方法：在命令模式下输入 <code>:set paste</code> 进入粘贴模式，然后再粘贴 yaml 内容。</p>
<p>注意行首可能会丢失几个字符，需要手动补上。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/45920111" target="_blank" rel="noopener noreferrer">如何在 Linux 中查看进程占用的端口号</a></li>
<li><a href="https://github.com/jpetazzo/nsenter#how-do-i-use-nsenter" target="_blank" rel="noopener noreferrer">github - nsenter</a></li>
<li><a href="https://tonydeng.github.io/2016/07/07/use-lsof-to-replace-netstat/" target="_blank" rel="noopener noreferrer">使用 lsof 代替 Mac OS X 中的 netstat 查看占用端口的程序</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/81123584" target="_blank" rel="noopener noreferrer">aws 常用命令</a></li>
</ul>
]]></description></item><item><title>Python 实用技巧与常见错误集锦</title><link>https://thiscute.world/posts/python-tips-and-tricks/</link><pubDate>Sun, 13 Feb 2022 01:17:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/python-tips-and-tricks/</guid><description><![CDATA[<blockquote>
<p>个人笔记，不保证正确。</p>
</blockquote>
<blockquote>
<p>内容比较多，建议参照目录浏览。</p>
</blockquote>
<h2 id="一标准库">一、标准库</h2>
<h3 id="1-文件路径---pathlib">1. 文件路径 - pathlib</h3>
<p>提供了 OS 无关的文件路径抽象，可以完全替代旧的 <code>os.path</code> 和 <code>glob</code>.</p>
<p>学会了 <code>pathlib.Path</code>，你就会了 Python 处理文件路径的所有功能。</p>
<h4 id="1-路径解析与拼接">1. 路径解析与拼接</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">data_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&#34;./source_data/text_files/&#34;</span><span class="p">)</span>
<span class="n">data_file</span> <span class="o">=</span> <span class="n">data_folder</span> <span class="o">/</span> <span class="s2">&#34;raw_data.txt&#34;</span>  <span class="c1"># Path 重载了 / 操作符，路径拼接超级方便</span>

<span class="c1"># 路径的解析</span>
<span class="n">data_file</span><span class="o">.</span><span class="n">parent</span>  <span class="c1"># 获取父路径，这里的结果就是 data_folder</span>
<span class="n">data_foler</span><span class="o">.</span><span class="n">parent</span> <span class="c1"># 会返回 Path(&#34;source_data&#34;)</span>
<span class="n">data_file</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># 即获取到 data_file 的上上层目录，结果和上面一样是 Path(&#34;source_data&#34;)</span>
<span class="n">data_file</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># 上上上层目录，Path(&#34;.&#34;)</span>

<span class="n">dara_file</span><span class="o">.</span><span class="n">name</span> <span class="c1"># 文件名 &#34;raw_data.txt&#34;</span>
<span class="n">dara_file</span><span class="o">.</span><span class="n">suffix</span>  <span class="c1"># 文件的后缀（最末尾的）&#34;.txt&#34;，还可用 suffixes 获取所有后缀</span>

<span class="n">data_file</span><span class="o">.</span><span class="n">stem</span>  <span class="c1"># 去除掉最末尾的后缀后（只去除一个），剩下的文件名：raw_data</span>

<span class="c1"># 替换文件名或者文件后缀</span>
<span class="n">data_file</span><span class="o">.</span><span class="n">with_name</span><span class="p">(</span><span class="s2">&#34;test.txt&#34;</span><span class="p">)</span>  <span class="c1"># 变成 .../test.txt</span>
<span class="n">data_file</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&#34;.pdf&#34;</span><span class="p">)</span>  <span class="c1"># 变成 .../raw_data.pdf</span>

<span class="c1"># 当前路径与另一路径 的相对路径</span>
<span class="n">data_file</span><span class="o">.</span><span class="n">relative_to</span><span class="p">(</span><span class="n">data_folder</span><span class="p">)</span>  <span class="c1"># PosixPath(&#39;raw_data.txt&#39;)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="2-pathlib-常用函数">2. pathlib 常用函数</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">if</span> <span class="ow">not</span> <span class="n">data_folder</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="n">data_folder</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># 直接创建文件夹，如果父文件夹不存在，也自动创建</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>  <span class="c1"># 文件是否存在</span>
    <span class="n">filename</span><span class="o">.</span><span class="n">touch</span><span class="p">()</span>  <span class="c1"># 直接创建空文件，或者用 filename.open() 直接获取文件句柄</span>

<span class="c1"># 路径类型判断</span>
<span class="k">if</span> <span class="n">data_file</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>  <span class="c1"># 是文件</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">data_file</span><span class="p">,</span> <span class="s2">&#34;is a file&#34;</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">data_file</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>  <span class="c1"># 是文件夹</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">iterdir</span><span class="p">():</span>  <span class="c1"># 通过 Path.iterdir() 迭代文件夹中的内容</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

<span class="c1"># 路径解析</span>
<span class="c1"># 获取文件的绝对路径（符号链接也会被解析到真正的文件）</span>
<span class="n">filename</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>  <span class="c1"># 在不区分大小写的系统上（Windows），这个函数也会将大小写转换成实际的形式。</span>

<span class="c1"># 可以直接获取 Home 路径或者当前路径</span>
<span class="n">Path</span><span class="o">.</span><span class="n">home</span><span class="p">()</span> <span class="o">/</span> <span class="s2">&#34;file.txt&#34;</span> <span class="c1"># 有时需要以 home 为 base path 来构建文件路径</span>
<span class="n">Path</span><span class="o">.</span><span class="n">cwd</span><span class="p">()</span>  <span class="o">/</span> <span class="s2">&#34;file.txt&#34;</span> <span class="c1"># 或者基于当前路径构建</span>
</code></pre></td></tr></table>
</div>
</div><p>还有很多其它的实用函数，可在使用中慢慢探索。</p>
<h4 id="3-glob-通配符">3. glob 通配符</h4>
<p>pathlib 也提供了 glob 支持，也就是广泛用在路径匹配上的一种简化正则表达式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">data_file</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">glob_pattern</span><span class="p">)</span>  <span class="c1"># 返回 True 或 False，表示文件路径与给出的 glob pattern 是否匹配</span>

<span class="k">for</span> <span class="n">py_file</span> <span class="ow">in</span> <span class="n">data_folder</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&#34;*/*.py&#34;</span><span class="p">):</span>  <span class="c1"># 匹配当前路径下的子文件夹中的 py 文件，会返回一个可迭代对象</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">py_file</span><span class="p">)</span>

<span class="c1"># 反向匹配，相当于 glob 模式开头添加 &#34;**/&#34;</span>
<span class="k">for</span> <span class="n">py_file</span> <span class="ow">in</span> <span class="n">data_folder</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&#34;**/*.py&#34;</span><span class="p">):</span>  <span class="c1"># 匹配当前路径下的所有 py 文件（所有子文件夹也会被搜索），返回一个可迭代对象</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">py_file</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>glob 中的 * 表示任意字符，而 ** 则表示任意层目录。（在大型文件树上使用 ** 速度会很慢！）</p>
<h3 id="2-时间日期处理">2. 时间日期处理</h3>
<p>python3 在时间日期处理方面，有标准库 <code>datetime</code> 跟 <code>calender</code>，也有流行的第三方库 <code>arrow</code> 跟 <code>maya</code>.</p>
<p>标准库 datetime 有时候不太方便，比如没有提供解析 iso 格式的函数。
另外就是用标准库时，经常需要自定义格式化串。
相比之下，<code>maya</code> 和 <code>arrow</code> 这两个第三方库会方便很多。</p>
<p>不过第三方库并不是任何时候都可用，这里只介绍标准库 <code>datetime</code> 的用法，<code>maya</code>/<code>arrow</code> 请自行查找官方文档学习。</p>
<h4 id="1-获取当前时间">1. 获取当前时间</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>

<span class="c1"># 1. 获取当前时间的时间戳</span>
<span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>  <span class="c1"># 直接调用 c api，因此速度很快:  1582315203.537061</span>
<span class="n">utcnow</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">utcnow</span><span class="p">()</span>  <span class="c1"># 当前的世界标准时间: datetime.datetime(2020, 2, 22, 4, 0, 3, 537061)</span>
<span class="n">utcnow</span><span class="o">.</span><span class="n">timestamp</span><span class="p">()</span>   <span class="c1"># 将标准时转换成时间戳：datetime =&gt;  1582315203.537061</span>

<span class="c1"># 2. UTC 世界标准时间</span>
<span class="n">time</span><span class="o">.</span><span class="n">gmtime</span><span class="p">()</span>
<span class="c1">#输出为： time.struct_time(tm_year=2019, tm_mon=6, tm_mday=23, </span>
<span class="c1">#                         tm_hour=3, tm_min=49, tm_sec=17,</span>
<span class="c1">#                         tm_wday=6, tm_yday=174, tm_isdst=0)</span>
<span class="c1"># 这实际上是一个命名元组</span>

<span class="c1"># 3. 构建一个指定的 datetime 实例</span>
<span class="n">time_1997</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="mi">1997</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># =&gt; datetime.datetime(1997, 1, 1, 0, 0)</span>
<span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="mi">1997</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">minute</span><span class="o">=</span><span class="mi">11</span><span class="p">)</span>  <span class="c1"># =&gt; datetime.datetime(1997, 1, 1, 0, 11)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="2-时间日期的修改与运算">2. 时间日期的修改与运算</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="c1"># 0. 日期的修改（修改年月时分秒）</span>
<span class="n">utcnow</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">day</span><span class="o">=</span><span class="mi">11</span><span class="p">)</span>  <span class="c1"># =&gt;  datetime.datetime(2020, 2, 11, 4, 0, 3, 537061)  修改 day</span>
<span class="n">utcnow</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">hour</span><span class="o">=</span><span class="mi">11</span><span class="p">)</span>  <span class="c1"># =&gt; datetime.datetime(2020, 2, 22, 11, 0, 3, 537061)  修改 hour</span>

<span class="c1"># 1. 日期与时间</span>
<span class="n">date_utcnow</span> <span class="o">=</span> <span class="n">utcnow</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>  <span class="c1"># =&gt; datetime.date(2020, 2, 22)  年月日</span>
<span class="n">time_utcnow</span> <span class="o">=</span> <span class="n">utcnow</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>  <span class="c1"># =&gt; datetime.time(4, 0, 3, 537061)  时分秒</span>

<span class="c1"># 2. 联结时间和日期（date 和 time 不能用加法联结）</span>
<span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">date_utcnow</span><span class="p">,</span> <span class="n">time_utcnow</span><span class="p">)</span>  <span class="c1"># =&gt;  datetime.datetime(2020, 2, 22, 4, 0, 3, 537061)</span>

<span class="c1"># 3. 日期的运算</span>

<span class="c1"># 3.1 datetime 之间只能计算时间差（减法），不能进行其他运算</span>
<span class="n">utcnow</span> <span class="o">-</span> <span class="n">time_1997</span>  <span class="c1"># =&gt; datetime.timedelta(days=8452, seconds=14403, microseconds=537061)</span>

<span class="c1"># 3.2 使用 timedelta 进行时间的增减</span>
<span class="n">days_step</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># 注意参数是复数形式</span>
<span class="n">time_1997</span> <span class="o">+</span> <span class="n">days_step</span>  <span class="c1"># =&gt; datetime.datetime(1997, 1, 2, 0, 0)</span>
<span class="n">time_1997</span> <span class="o">-</span> <span class="n">days_step</span>  <span class="c1"># =&gt; datetime.datetime(1996, 12, 31, 0, 0)</span>

<span class="c1"># 3.3 timedelta 之间也可以进行加减法</span>
<span class="n">hours_step</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># =&gt; datetime.timedelta(seconds=3600)</span>
<span class="n">days_step</span> <span class="o">+</span> <span class="n">hours_step</span>  <span class="c1"># =&gt; datetime.timedelta(days=1, seconds=3600)</span>
<span class="n">days_step</span> <span class="o">-</span> <span class="n">hours_step</span>  <span class="c1"># =&gt; datetime.timedelta(seconds=82800)</span>
<span class="n">hours_step</span> <span class="o">-</span> <span class="n">days_step</span>  <span class="c1"># =&gt; datetime.timedelta(days=-1, seconds=3600)</span>

<span class="c1"># 3.4 timedelta 还可以按比例增减（与数字进行乘除法）</span>
<span class="n">hours_step</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># =&gt; datetime.timedelta(seconds=7200)</span>
<span class="n">days_step</span> <span class="o">*</span> <span class="o">-</span><span class="mi">2</span>  <span class="c1"># =&gt; datetime.timedelta(days=-2)</span>
<span class="n">hours_step</span> <span class="o">*</span> <span class="mf">1.1</span>  <span class="c1"># =&gt;  datetime.timedelta(seconds=3960)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="3-时间日期的格式化与解析">3. 时间日期的格式化与解析</h4>
<p>先介绍下常用的格式化字符串：</p>
<ol>
<li>普通格式 - &lsquo;%Y-%m-%d %H:%M:%S&rsquo; =&gt; &lsquo;2020-02-22 04:00:03&rsquo;</li>
<li>ISO 格式 - &lsquo;%Y-%m-%dT%H:%M:%S.%fZ&rsquo; =&gt; &lsquo;2020-02-22T04:00:03.537061Z&rsquo;</li>
<li>带时区的格式 - &lsquo;%Y-%m-%dT%H:%M:%S%Z&rsquo; =&gt; 2022-02-10T00:48:52UTC+08:00
<ul>
<li>需要时间对象自身有时区属性才行！否则格式化时会忽略 <code>%Z</code></li>
</ul>
</li>
</ol>
<p>另外再介绍下 Python 两个时间格式化与解析函数的命名：</p>
<ul>
<li><code>strftime</code>: 即 <code>string formate time</code></li>
<li><code>strptime</code>: 即 <code>string parse time</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="c1"># 1. 将时间格式化成字符串</span>

<span class="c1"># 1.1 将 datetime 格式化为 iso 标准格式</span>
<span class="n">utcnow</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>  <span class="c1"># =&gt;  &#39;2020-02-22T04:00:03.537061&#39;</span>
<span class="n">utcnow</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">T%H:%M:%S.</span><span class="si">%f</span><span class="s1">Z&#39;</span><span class="p">)</span>   <span class="c1"># =&gt; &#39;2020-02-22T04:00:03.537061Z&#39;</span>
<span class="n">utcnow</span><span class="o">.</span><span class="n">date</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">T%H:%M:%S.</span><span class="si">%f</span><span class="s1">Z&#39;</span><span class="p">)</span>  <span class="c1"># =&gt; &#39;2020-02-22T00:00:00.000000Z&#39;</span>

<span class="c1"># 1.2 将 time.struct_time 格式化为日期字符串（貌似不支持 iso，可能是精度不够）</span>
<span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">T%H:%M:%S&#39;</span><span class="p">,</span> <span class="n">gm</span><span class="p">)</span>  <span class="c1"># =&gt; &#39;2020-02-22T04:00:03&#39;</span>

<span class="c1"># 1.3 将 datetime 格式化成指定格式</span>
<span class="n">utcnow</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>  <span class="c1"># =&gt; &#39;2020-02-22 04:00:03&#39;</span>

<span class="c1"># 2. 解析时间字符串</span>

<span class="c1"># 2.1 解析 iso 格式的时间字符串，手动指定格式（注意 %f 只对应六位小数，对9位小数它无能为力。。）</span>
<span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">&#39;2020-02-22T04:00:03.537061Z&#39;</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">T%H:%M:%S.</span><span class="si">%f</span><span class="s1">Z&#39;</span><span class="p">)</span>  <span class="c1"># =&gt; datetime.datetime(2020, 2, 22, 4, 0, 3, 537061)</span>

<span class="c1"># 2.2 解析 iso 格式的时间字符串(需要 python 3.7+)</span>
<span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">fromisoformat</span><span class="p">(</span><span class="s1">&#39;2020-02-22T04:00:03.537061&#39;</span><span class="p">)</span>  <span class="c1"># =&gt; datetime.datetime(2020, 2, 22, 4, 0, 3, 537061)</span>
<span class="n">dt</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">fromisoformat</span><span class="p">(</span><span class="s1">&#39;2020-02-22&#39;</span><span class="p">)</span>  <span class="c1"># =&gt; datetime.date(2020, 2, 22)</span>
<span class="n">dt</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">fromisoformat</span><span class="p">(</span><span class="s2">&#34;04:00:03.537061&#34;</span><span class="p">)</span>  <span class="c1"># =&gt;  datetime.time(4, 0, 3, 537061)</span>

<span class="c1"># 2.3 解析指定格式的字符串</span>
<span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">&#39;2020-02-22 04:00:03&#39;</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>  <span class="c1"># =&gt; datetime.datetime(2020, 2, 22, 4, 0, 3)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="4-时区转换与日期格式化">4. 时区转换与日期格式化</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="c1"># 上海时区：东八区 utc+8</span>
<span class="n">tz_shanghai</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">timezone</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="mi">8</span><span class="p">))</span>

<span class="n">now_shanghai</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz_shanghai</span><span class="p">)</span>

<span class="n">now_shanghai</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">T%H:%M:%S%Z&#39;</span><span class="p">)</span>  <span class="c1"># =&gt; 2022-02-10T00:48:52UTC+08:00</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="3-排序常用库---operator">3. 排序常用库 - operator</h3>
<p>operator 模块包含四种类型的方法：</p>
<h4 id="1-operatoritemgetter">1. <strong>operator.itemgetter</strong></h4>
<p>经常被用于 sorted/max/mix/itertools.groupby 等</p>
<p>使用方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="c1"># itemgetter</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">f</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="c1"># return r[2]</span>

<span class="c1"># 还能一次获取多个值，像 numpy 那样索引</span>
<span class="n">f2</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="n">f2</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="c1"># return (r[2], r[4], r[5])</span>

<span class="c1"># 或者使用 slice 切片</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
<span class="n">s</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>  <span class="c1"># return r[2:]</span>

<span class="c1"># dict 索引也能用</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="s1">&#39;rank&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">)</span>
<span class="n">d</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>  <span class="c1"># return d[&#39;rank&#39;], d[&#39;name&#39;]</span>
</code></pre></td></tr></table>
</div>
</div><p>用途：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="c1"># 用于指定用于比较大小的属性</span>
<span class="n">key</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">sorted</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>  <span class="c1"># 使用 iterable[1] 对 iterable 进行排序</span>
<span class="nb">max</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>  <span class="c1"># 找出最大的元素，使用 iterable[1] 做比较</span>

<span class="c1"># 用于高级切片（比如像 numpy 那样的，指定只获取某几列）</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
<span class="nb">map</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>  <span class="c1"># list 后得到 [(1, 3, 4), (2,4,5)]</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="2-operatorattrgetter">2. <code>operator.attrgetter</code></h4>
<p>可用于动态获取对象的属性，与直接用 <code>getattr()</code> 不同的是，它可以嵌套访问属性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Python3" data-lang="Python3"><span class="c1"># 嵌套访问属性</span>
<span class="n">att</span> <span class="o">=</span> <span class="n">attrgetter</span><span class="p">(</span><span class="s2">&#34;a.b.c&#34;</span><span class="p">)</span>
<span class="n">att</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>  <span class="c1"># return obj.a.b.c</span>

<span class="c1"># 和 itemgetter 一样，也可以一次获取多个属性</span>
<span class="n">att</span> <span class="o">=</span> <span class="n">attrgetter</span><span class="p">(</span><span class="s2">&#34;a.b.c&#34;</span><span class="p">,</span> <span class="s2">&#34;x.y&#34;</span><span class="p">)</span>
<span class="n">att</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>  <span class="c1"># return (obj.a.b.c, obj.x.y)</span>

<span class="c1"># 不嵌套的话，用 getattr 就行</span>
<span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&#34;a&#34;</span><span class="p">)</span>  <span class="c1"># return obj.a</span>
</code></pre></td></tr></table>
</div>
</div><p>这里可以回顾一下类的两个魔法函数：</p>
<ol>
<li><code>__getattr__</code>: 当被访问的属性不存在时，这个方法会被调用，它的返回值会成为对象的该属性。
<ul>
<li>用于动态生成实例的属性/函数</li>
</ul>
</li>
<li><code>__getattribute__</code>: 与 <code>__getattr__</code> 唯一的差别在于，访问对象的任何属性，都会直接调用这个方法，<strong>不管属性存不存在</strong>。</li>
</ol>
<h4 id="3-operatormethodcaller">3. operator.methodcaller</h4>
<p>可用于调用函数，它和 attrgetter 很像，差别在于 attrgetter 只是返回指定的属性，而 methodcaller 会直接把指定的属性当成函数调用，然后返回结果。</p>
<p>举例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="n">f</span> <span class="o">=</span> <span class="n">methodcaller</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># returns b.name(&#39;foo&#39;, bar=1)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="4-各种操作符对应的函数">4. 各种操作符对应的函数</h4>
<p>operator.add、operator.sub、operator.mul、operator.div 等等，函数式编程有时需要用到。</p>
<h3 id="4-itertools">4. itertools</h3>
<p><a href="https://docs.python.org/3/library/itertools.html" target="_blank" rel="noopener noreferrer">itertools</a> 提供了许多针对可迭代对象的实用函数</p>
<p>方法很多，基本不可能一次全记住。还是要用到时多查吧。大致记住有提供哪些功能，需要用到时能想起可以查这个模块就行。</p>
<h4 id="1-无限迭代器">1. 无限迭代器</h4>
<ol>
<li>count(start=0, step=1): 从 start 开始，每次迭代时，返回值都加一个 step
<ul>
<li>默认返回序列为 0 1 2 3&hellip;</li>
</ul>
</li>
<li>cycle(iterable): 不断循环迭代 iterable</li>
<li>repeat(element, times=None): 默认永远返回 element。（如果 times 不为 None，就迭代 times 后结束）</li>
</ol>
<h4 id="2-排列组合迭代器">2. 排列组合迭代器</h4>
<ol>
<li>product(p1, p2, &hellip;, repeat=1)：p1, p2&hellip; 的元素的笛卡尔积，相当于多层 for 循环
<ul>
<li>repeat 指参数重复次数，比如</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">&gt;&gt;&gt; from itertools import product
&gt;&gt;&gt; <span class="nv">r</span> <span class="o">=</span> product<span class="o">([</span>1, 2<span class="o">]</span>, <span class="o">[</span>3, 4<span class="o">]</span>, <span class="o">[</span>5, 6<span class="o">])</span>  <span class="c1"># 重复一次，也就是 (p1, p2, p3) 的笛卡尔积</span>
&gt;&gt;&gt; pprint<span class="o">(</span>list<span class="o">(</span>r<span class="o">))</span>       
<span class="o">[(</span>1, 3, 5<span class="o">)</span>,
 <span class="o">(</span>1, 3, 6<span class="o">)</span>,
 <span class="o">(</span>1, 4, 5<span class="o">)</span>,
 <span class="o">(</span>1, 4, 6<span class="o">)</span>,
 <span class="o">(</span>2, 3, 5<span class="o">)</span>,
 <span class="o">(</span>2, 3, 6<span class="o">)</span>,
 <span class="o">(</span>2, 4, 5<span class="o">)</span>,
 <span class="o">(</span>2, 4, 6<span class="o">)]</span>
&gt;&gt;&gt; <span class="nv">r2</span> <span class="o">=</span> product<span class="o">([</span>1, 2<span class="o">]</span>, <span class="o">[</span>3, 4<span class="o">]</span>, <span class="o">[</span>5, 6<span class="o">]</span>, <span class="nv">repeat</span><span class="o">=</span>2<span class="o">)</span>  <span class="c1"># 重复两次，即 (p1, p2, p3, p1, p2, p3) 的笛卡尔积</span>
&gt;&gt;&gt; pprint<span class="o">(</span>list<span class="o">(</span>r2<span class="o">))</span>
<span class="o">[(</span>1, 3, 5, 1, 3, 5<span class="o">)</span>,
 <span class="o">(</span>1, 3, 5, 1, 3, 6<span class="o">)</span>,
 <span class="o">(</span>1, 3, 5, 1, 4, 5<span class="o">)</span>,
 <span class="o">(</span>1, 3, 5, 1, 4, 6<span class="o">)</span>,
 <span class="o">(</span>1, 3, 5, 2, 3, 5<span class="o">)</span>,
...
</code></pre></td></tr></table>
</div>
</div><ol>
<li>permutations(p[, r])：p 中元素，长度为 r 的所有可能的排列。相当于 product 去重后的结果。</li>
<li>combinations(p, r)：既然有排列，当然就有组合了。</li>
</ol>
<h4 id="3-其他">3. 其他</h4>
<ol>
<li><code>zip_longest(*iterables, fillvalue=None)</code>：和 zip 的差别在于，缺失的元素它会用 fillvalue 补全，而不是直接结束。</li>
<li><code>takewhile()</code></li>
<li><code>dropwhile()</code></li>
<li><code>groupby()</code></li>
</ol>
<p>等等等，用得到的时候再查了。。。</p>
<h3 id="5-collections">5. collections</h3>
<p>提供了一些实用的高级数据结构（容器）</p>
<ol>
<li><strong><code>defaultdict</code></strong>：这个感觉是最常用的，可以给定 key 的默认值</li>
<li><strong><code>Counter</code></strong>：方便、快速的计数器。常用于分类统计</li>
<li><code>deque</code>：一个线程安全的双端队列</li>
<li><code>OrderedDict</code>：有时候会需要有序字典</li>
<li><code>namedtuple</code>：命名元组，有时用于参数传递。与 tuple 的差别是它提供了关键字参数和通过名字访问属性的功能</li>
<li><code>ChainMap</code>：将多个 map 连接（chain）在一起，提供一个统一的视图。因为是视图，所以原来的 map 不会被影响。</li>
</ol>
<h3 id="6-常用函数装饰器-functools">6. 常用函数装饰器 functools</h3>
<p>functools 提供了几个有时很有用的函数和装饰器</p>
<h4 id="1-functoolswraps">1. @functools.wraps</h4>
<p>这个装饰器用于使装饰器 copy 被装饰的对象的 <code>__module__</code>, <code>__name__</code>, <code>__qualname__</code>, <code>__annotations__</code> and <code>__doc__</code> 属性，这样装饰器就显得更加透明。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="k">def</span> <span class="nf">my_decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
     <span class="nd">@wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
     <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
         <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calling decorated function&#39;</span><span class="p">)</span>
         <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
     <span class="k">return</span> <span class="n">wrapper</span>  <span class="c1"># 用了 wraps，wrapper 会复制 f 的各种文档属性</span>

<span class="nd">@my_decorator</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">xx</span><span class="p">):</span>
    <span class="s2">&#34;&#34;&#34; this is func&#39;s docstring&#34;&#34;&#34;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;this is func~&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果不用 wraps 的话，因为实际上返回的是 wrapper，被装饰对象的这些文档属性都会丢失。（比如 docstring）
<strong>因此在使用 wrapper 装饰器时，添加 @wraps() 装饰器是个好习惯。</strong></p>
<h4 id="2-functoolspartial">2. functools.partial</h4>
<p>这个感觉和高等数学的偏函数很像：比如函数 z = f(x, y) 有 x 和 y 两个变量，现在把 x 看作常数，就可以对 y 进行求导运算。
而 python 的 partial 也差不多，不过它不是把 x 看作常数，而是先给定 x 的值。用法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="n">basetwo</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># 先给定 int 函数的 base 参数为 2</span>
<span class="n">basetwo</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s1">&#39;Convert base 2 string to an int.&#39;</span>  <span class="c1"># 如果需要文档，可以添加 __doc__ 属性</span>
<span class="n">basetwo</span><span class="p">(</span><span class="s1">&#39;10010&#39;</span><span class="p">)</span>  <span class="c1"># return 18</span>
</code></pre></td></tr></table>
</div>
</div><p>此外，还有个 partialmethod 函数，待了解</p>
<h4 id="3-functoolslru_cachemaxsize128-typedfalse">3. @functools.lru_cache(maxsize=128, typed=False)</h4>
<p>如果某方法可能被频繁调用（使用相同的参数），而且它的结果在一定时间内不会改变。可以用 lru_cache 装饰它，减少运算量或 IO 操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>

<span class="c1"># 缓存最近的（least recently used，lru） 64 次参数不同的调用结果。</span>
<span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_sum</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>  <span class="c1"># 后续的调用中，如果参数能匹配到缓存，就直接返回缓存结果</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>比如用递归计算斐波那契数列，数值较低的参数会被频繁使用，于是可以用 lru_cache 来缓存它们。
或者爬取网页，可能会需要频繁爬取一个变化不快的网页，这时完全可以用 cache 缓存。</p>
<p>但是它不能控制缓存失效时间，因此不能用于 Web 系统的缓存。还是得自己写个简单的装饰器，把缓存存到 redis 里并设置 expires。或者直接用 Flask 或 Django 的 caching 插件。</p>
<h4 id="4-functoolssingledispatch">4. @functools.singledispatch</h4>
<p>单重派发，即根据函数的第一个参数的类型，来决定调用哪一个同名函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="nd">@singledispatch</span>
<span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>  <span class="c1"># 首先定义一个默认函数</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;没有合适的类型被调用&#39;</span><span class="p">)</span>  <span class="c1"># 如果参数类型没有匹配上，就调用这个默认函数</span>

<span class="nd">@parse</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>  <span class="c1"># 第一个参数为 None</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;出现 None 了&#39;</span><span class="p">)</span>

<span class="nd">@parse</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># 第一个参数为整数</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;这次输入的是整数&#39;</span><span class="p">)</span>

<span class="nd">@parse</span><span class="o">.</span><span class="n">register</span>
<span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>  <span class="c1"># python3.7 开始，可以直接用类型注解来标注第一个参数的类型</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;这次输入的是列表&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>画外：有单重派发，自然就有多重派发，Julia 语言就支持多重派发，即根据函数所有参数的类型，来决定调用哪一个同名函数。
Julia 语言根本没有类这个定义，类型的所有方法都是通过多重派发来定义的。</p>
<h4 id="其他">其他</h4>
<ol>
<li>@functools.total_ordering：用于自动生成比较函数。</li>
<li>functools.cmp_to_key(func)：用于将老式的比较函数，转换成新式的 key 函数。</li>
</ol>
<h3 id="7-上下文管理---contextlib">7. 上下文管理 - contextlib</h3>
<p>即实现使用 <code>with</code> 语句进行自定义的上下文管理。</p>
<h4 id="1-使用-__enter__-和-__exit__">1. 使用 <code>__enter__</code> 和 <code>__exit__</code></h4>
<p>Java 使用 try 来自动管理资源，只要实现了 AutoCloseable 接口，就可以部分摆脱手动 colse 的地狱了。</p>
<p>而 Python，则是定义了两个 Protocol：<code>__enter__</code> 和 <code>__exit__</code>. 下面是一个 open 的模拟实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">OpenContext</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>  <span class="c1"># 调用 open(filename, mode) 返回一个实例</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># 用 with 管理 __init__ 返回的实例时，with 会自动调用这个方法</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fp</span>

    <span class="c1"># 退出 with 代码块时，会自动调用这个方法。</span>
    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1"># 这里先构造了 OpenContext 实例，然后用 with 管理该实例</span>
<span class="k">with</span> <span class="n">OpenContext</span><span class="p">(</span><span class="s1">&#39;/tmp/a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这里唯一有点复杂的，就是 <code>__exit__</code> 方法。和 Java 一样，<code>__exit__</code> 相当于 <code>try - catch - finally</code> 的 <code>finally</code> 代码块，在发生异常时，它也会被调用。</p>
<p>当没有异常发生时，<code>__exit__</code> 的三个参数 <code>exc_type, exc_value, traceback</code> 都为 None，而当发生异常时，它们就对应异常的详细信息。
发生异常时， <code>__exit__</code> <strong>的返回值将被用于决定是否向外层抛出该异常</strong>，返回 True 则抛出，返回 False 则抑制（swallow it）。</p>
<p>Note 1：Python 3.6 提供了 async with 异步上下文管理器，它的 Protocol 和同步的 with 完全类似，是 <code>__aenter__</code> 和 <code>__aexit__</code> 两个方法。
Note 2：与 Java 相同，with 支持同时管理多个资源，因此可以直接写 <code>with open(x) as a, open(y) as b:</code> 这样的形式。</p>
<h4 id="2-推荐contextlib">2. 推荐：contextlib</h4>
<h5 id="21-contextlibcontextmanager">2.1 @contextlib.contextmanager</h5>
<p>对于简单的 with 资源管理，编写一个类可能会显得比较繁琐，为此 contextlib 提供了一个方便的装饰器 <code>@contextlib.contextmanager</code> 用来简化代码。</p>
<p>使用它，上面的 OpenContext 可以改写成这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">make_open_context</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">fp</span>  <span class="c1"># 没错，这是一个生成器函数</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">with</span> <span class="n">make_open_context</span><span class="p">(</span><span class="s1">&#39;/tmp/a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 <code>contextmanager</code> 装饰一个生成器函数，yield 之前的代码对应 <code>__enter__</code>，finally 代码块就对应 <code>__exit__</code>.</p>
<p>Note：同样，也有异步版本的装饰器 <code>@contextlib.asynccontextmanager</code></p>
<h5 id="22-contextlibclosingthing">2.2 contextlib.closing(thing)</h5>
<p>用于将原本不支持 with 管理的资源，包装成一个 Context 对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">closing</span>
<span class="kn">from</span> <span class="nn">urllib.request</span> <span class="kn">import</span> <span class="n">urlopen</span>

<span class="k">with</span> <span class="n">closing</span><span class="p">(</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">page</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">page</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

<span class="c1"># closing 等同于</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">closing</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">thing</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">thing</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># 就是添加了一个自动 close 的功能</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="23-contextlibsuppressexceptions">2.3 contextlib.suppress(*exceptions)</h5>
<p>使 with 管理器抑制代码块内任何被指定的异常：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">suppress</span>

<span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">FileNotFoundError</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;somefile.tmp&#39;</span><span class="p">)</span>

<span class="c1"># 等同于</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;somefile.tmp&#39;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
    <span class="k">pass</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="24-contextlibredirect_stdoutnew_target">2.4 contextlib.redirect_stdout(new_target)</h5>
<p>将 with 代码块内的 stdout 重定向到指定的 target（可用于收集 stdout 的输出）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
<span class="k">with</span> <span class="n">redirect_stdout</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>  <span class="c1"># 将输出直接写入到 StringIO</span>
    <span class="n">help</span><span class="p">(</span><span class="nb">pow</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

<span class="c1"># 或者直接写入到文件</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;help.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">redirect_stdout</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">help</span><span class="p">(</span><span class="nb">pow</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>redirect_stdout 函数返回的 Context 是可重入的（ reentrant），可以重复使用。</p>
<h2 id="二实用代码片段">二、实用代码片段</h2>
<h3 id="group_size">1. 元素分组/group</h3>
<p>数据处理中一个常见的操作，是将列表中的元素，依次每 k 个分作一组。</p>
<p>下面的函数使用非常简洁的代码实现了元素分组的功能：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">zip_longest</span>

<span class="k">def</span> <span class="nf">group_each</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">longest</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="s2">&#34;&#34;&#34;
</span><span class="s2">        将一个可迭代对象 a 内的元素, 每 size 个分为一组
</span><span class="s2">        group_each([1,2,3,4], 2) -&gt; [(1,2), (3,4)]
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="n">iterators</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span> <span class="o">*</span> <span class="n">size</span>  <span class="c1"># 将新构造的 iterator 复制 size 次（浅复制）</span>

    <span class="n">func_zip</span> <span class="o">=</span> <span class="n">zip_longest</span> <span class="k">if</span> <span class="n">longest</span> <span class="k">else</span> <span class="nb">zip</span>
    <span class="k">return</span> <span class="n">func_zip</span><span class="p">(</span><span class="o">*</span><span class="n">iterators</span><span class="p">)</span>  <span class="c1"># 然后 zip</span>

<span class="n">a</span> <span class="o">=</span> <span class="s2">&#34;abcdefghijk&#34;</span>

<span class="nb">list</span><span class="p">(</span><span class="n">group_each</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1"># =&gt; [(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), (&#39;d&#39;, &#39;e&#39;, &#39;f&#39;), (&#39;g&#39;, &#39;h&#39;, &#39;i&#39;)]</span>

<span class="nb">list</span><span class="p">(</span><span class="n">group_each</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">longest</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="c1"># =&gt; [(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), (&#39;d&#39;, &#39;e&#39;, &#39;f&#39;), (&#39;g&#39;, &#39;h&#39;, &#39;i&#39;), (&#39;j&#39;, &#39;k&#39;, None)]</span>
</code></pre></td></tr></table>
</div>
</div><p>这个函数还可以进一步简化为 <code>zip(*[iter(a)] * 3)</code>，如果没想到浅复制（Shallow Copy）特性的话，会很难理解它的逻辑。</p>
<p>此外，如果某个 size 比较常用（比如 2），还可以用 <code>partial</code> 封装一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

 <span class="c1"># 每两个分一组</span>
<span class="n">group_each_2</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">group_each</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># 等同于 group_each_2 = lambda a: group_each(a, 2)</span>

<span class="n">a</span> <span class="o">=</span> <span class="s2">&#34;abcde&#34;</span>

<span class="nb">list</span><span class="p">(</span><span class="n">group_each_2</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="c1"># =&gt; [(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;)]</span>

<span class="nb">list</span><span class="p">(</span><span class="n">group_each_2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">longest</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="c1"># =&gt; [(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;e&#39;, None)]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="2-扁平版本的-map">2. 扁平版本的 map</h3>
<p>稍微接触过函数式应该都知道 flat_map，可 Python 标准库却没有提供。下面是我在 stackoverflow 上找到的实现，其实很简单</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>

<span class="k">def</span> <span class="nf">flat_map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">items</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>它和 map 的差别在于是不是扁平(flat) 的（废话。。），举个例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">&gt;&gt;&gt; list(map(list, [&#39;123&#39;, &#39;456&#39;]))
[[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;], [&#39;4&#39;, &#39;5&#39;, &#39;6&#39;]]
&gt;&gt;&gt; list(flat_map(list, [&#39;123&#39;, &#39;456&#39;]))
[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;]
</code></pre></td></tr></table>
</div>
</div><h3 id="3-轮流迭代多个迭代器">3. 轮流迭代多个迭代器</h3>
<p>假设我有多个可迭代对象（迭代器、列表等），现在我需要每次从每个对象中取一个值，直到某个对象为空。如果用循环写会比较繁琐，但是用 itertools 可以这样写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>

<span class="k">def</span> <span class="nf">iter_one_by_one</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">items</span><span class="p">))</span>

<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>

<span class="nb">list</span><span class="p">(</span><span class="n">iter_one_by_one</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]))</span>  <span class="c1"># =&gt;  [1, 4, 7, 2, 5, 8, 3, 6, 9]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="4-多-dict-的去重">4. 多 dict 的去重</h3>
<p>假设我们有一个 dict 的列表，里面可能有内容一模一样的 dict，我们需要对它做去重。
容易想到的方法就是使用 set，可是 set 中的元素必须是 hashable 的，而 dict 是 unhashable 的，因此不能直接放进 set 里。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">&gt;&gt;&gt; a = [{&#39;a&#39;: 1}, {&#39;a&#39;: 1}, {&#39;b&#39;: 2}]
&gt;&gt;&gt; set(a)
Traceback (most recent call last):
  File &#34;/usr/local/lib/python3.7/site-packages/IPython/core/interactiveshell.py&#34;, line 2961, in run_code
    exec(code_obj, self.user_global_ns, self.user_ns)
  File &#34;&lt;ipython-input-5-5b4c643a6feb&gt;&#34;, line 1, in &lt;module&gt;
    set(a)
TypeError: unhashable type: &#39;dict&#39;
</code></pre></td></tr></table>
</div>
</div><p>难道就必须手写递归了么？未必，我在 stackoverflow 看到这样一个小技巧</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="kn">import</span> <span class="nn">json</span>

<span class="k">def</span> <span class="nf">unique_dicts</span><span class="p">(</span><span class="n">data_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
    <span class="s2">&#34;&#34;&#34;unique a list of dict
</span><span class="s2">        dict 是 unhashable 的，不能放入 set 中，所以先转换成 str
</span><span class="s2">        
</span><span class="s2">        unique_dicts([{&#39;a&#39;: 1}, {&#39;a&#39;: 1}, {&#39;b&#39;: 2}])  -&gt;  [{&#39;a&#39;: 1}, {&#39;b&#39;: 2}]
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="n">data_json_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data_json_set</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="5-str-的-startswith-和-endswith-的参数可以是元组">5. str 的 startswith 和 endswith 的参数可以是元组</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">In[7]: a = &#34;bb.gif&#34;
In[8]: b = &#39;a.jpg&#39;
In[9]: a.endswith((&#39;.jpg&#39;, &#39;.gif&#39;))
Out[9]: True
In[10]: b.startswith((&#39;bb&#39;, &#39;a&#39;))
Out[10]: True
</code></pre></td></tr></table>
</div>
</div><h3 id="6-判断两个对象的所有属性都相同">6. 判断两个对象的所有属性都相同</h3>
<p>python 和 java 一样，直接用 == 做判断，默认是比较的引用，相当于 is。对自定义的类，你需要重写 <code>__eq__</code> 函数。
判断值相等的方法很简单，一行代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">==</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span>  <span class="c1"># 转成 __dict__ 再比较</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="7-案例">7. 案例</h3>
<h4 id="71-html-table-元素的处理">7.1 html table 元素的处理</h4>
<p>在做爬虫工作时，有时会遇到这样的 table 元素：</p>
<figure>
</figure>

<p>对这种 html 元素，我一般会直接把它转换成 list，结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="n">table</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;label1&#39;</span><span class="p">,</span> <span class="s1">&#39;value1&#39;</span><span class="p">,</span> <span class="s1">&#39;label2&#39;</span><span class="p">,</span> <span class="s1">&#39;value2&#39;</span><span class="p">],</span>
         <span class="p">[</span><span class="s1">&#39;label3&#39;</span><span class="p">,</span> <span class="s1">&#39;value3&#39;</span><span class="p">],</span>
         <span class="p">[</span><span class="s1">&#39;label4&#39;</span><span class="p">,</span> <span class="s1">&#39;value4&#39;</span><span class="p">,</span> <span class="s1">&#39;label5&#39;</span><span class="p">,</span> <span class="s1">&#39;value5&#39;</span><span class="p">],</span>
         <span class="o">...</span>
         <span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>为了方便索引，现在我需要把上面的数据转换成下面这个样子的 dict</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="p">{</span>
    <span class="s1">&#39;label1&#39;</span><span class="p">:</span> <span class="s1">&#39;value1&#39;</span><span class="p">,</span>
    <span class="s1">&#39;label2&#39;</span><span class="p">:</span> <span class="s1">&#39;value2&#39;</span><span class="p">,</span>
    <span class="s1">&#39;label3&#39;</span><span class="p">:</span> <span class="s1">&#39;value3&#39;</span><span class="p">,</span>
    <span class="s1">&#39;label4&#39;</span><span class="p">:</span> <span class="s1">&#39;value4&#39;</span><span class="p">,</span>
    <span class="s1">&#39;label5&#39;</span><span class="p">:</span> <span class="s1">&#39;value5&#39;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果是平常，大概需要写循环了。不过如果用刚刚说到的几个函数的话，会变得异常简单</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"> # 1. 分组
groups = flat_map(group_each_2, table)

# 1.1 flat_map 返回的是迭代器，list 后内容如下：
# [(&#39;label1&#39;, &#39;value1&#39;),
#  (&#39;label2&#39;, &#39;value2&#39;),
#  (&#39;label3&#39;, &#39;value3&#39;),
#  (&#39;label4&#39;, &#39;value4&#39;),
#  (&#39;label5&#39;, &#39;value5&#39;)]

# 2. 转换成 dict
key_values = dict(groups)   # 得到的 key_values 与上面需要的 dict 别无二致。
</code></pre></td></tr></table>
</div>
</div><h2 id="三常见错误">三、常见错误</h2>
<h3 id="1-浅复制导致错误">1. 浅复制导致错误</h3>
<p>利用好浅复制，可以非常简洁的实现前面提到的<a href="##group_size" rel="">元素分组/group</a>功能，但是如果不注意，也会导致非常隐晦的错误！</p>
<p>比如在使用 * 作为重复运算符时，如果目标是一个嵌套的可变对象，就会产生令人费解的问题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>  <span class="c1"># nested</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
</code></pre></td></tr></table>
</div>
</div><p>因为 * 并不是深拷贝，它只是简单地复制了 [a] 这个列表，里面的 [1,2,3] 都是同一个对象，所以改了一个，所有的都会改变。
<strong>解决方法是不要使用 * 号，改用<code>[a.copy() for i in range(3)]</code> 执行深拷贝。如果不需要修改，请直接使用不可变对象。</strong></p>
<h3 id="2-变量作用域">2. 变量作用域</h3>
<ol>
<li>Python 中<strong>只有模块，类以及函数才会引入新的作用域</strong>，其它的代码块是不会引入新的作用域的。（而在 C/Java 中，任何一个 <code>{}</code> 块就构成一个局部作用域。另外 Julia 中 for/while/try-catch 都是局部作用域，但 if-else 又不是局部作用域。总之这些小差别要注意。）</li>
<li>局部变量可以与外部变量同名，并且在其作用域中，局部变量会覆盖掉外部变量。
不知是出于实现简单或是性能，还是其他的原因，好像所有的语言都是这样的。其实我更希望变量的作用域覆盖会报错。</li>
<li>如果有函数与其他函数或变量（甚至某些保留字）同名，后定义的会覆盖掉先定义的。（这是因为 Python 中函数也是对象。而在 C/Java 中这是会报错的）</li>
</ol>
<p>此外，还有一个小问题，先看一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="o">&gt;&gt;&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">f</span><span class="p">():</span>     <span class="c1"># 单纯的从函数作用域访问外部作用域是没问题的</span>
<span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="o">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">()</span>
<span class="mi">4</span>
</code></pre></td></tr></table>
</div>
</div><p>再看一个问题举例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="o">&gt;&gt;&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
<span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="c1"># 这里应该是访问外部作用域</span>
<span class="o">...</span>     <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span>     <span class="c1"># 可这里又定义了一个同名局部变量 i</span>
<span class="o">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">()</span>   <span class="c1"># 于是就出错了</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&#34;&lt;stdin&gt;&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s2">&#34;&lt;stdin&gt;&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="ow">in</span> <span class="n">f</span>
<span class="ne">UnboundLocalError</span><span class="p">:</span> <span class="n">local</span> <span class="n">variable</span> <span class="s1">&#39;i&#39;</span> <span class="n">referenced</span> <span class="n">before</span> <span class="n">assignment</span>
</code></pre></td></tr></table>
</div>
</div><p>如果在内部作用域先访问外部作用域，再定义一个同名的局部变量，解释器就懵逼了。
如果你其实想做的是改变全局变量 i 的值，就应该在开头声明 <code>global i</code>. 而如果 外部变量 i 不是存在于全局作用域，而是在某个闭合作用域内的话，就该用 <code>nonlocal i</code></p>
<h2 id="四自定义装饰器">四、自定义装饰器</h2>
<p>装饰器有两种：用函数定义的装饰器，还有用类定义的装饰器。函数装饰器最常用。</p>
<p>装饰器可用于装饰函数，修改函数/类的某些行为，或者将函数注册到别的地方。</p>
<h3 id="1-函数定义装饰器">1. 函数定义装饰器</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="nd">@decc</span>
<span class="k">def</span> <span class="nf">gg</span><span class="p">(</span><span class="n">xx</span><span class="p">):</span>
    <span class="o">...</span>

<span class="c1"># 等同于</span>
<span class="k">def</span> <span class="nf">gg</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span>
<span class="n">gg</span> <span class="o">=</span> <span class="n">decc</span><span class="p">(</span><span class="n">gg</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="带参的装饰器">带参的装饰器</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="nd">@decorator</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>

<span class="n">F</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>

<span class="c1"># 等同于</span>
<span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>

<span class="n">F</span> <span class="o">=</span> <span class="n">decorator</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)(</span><span class="n">F</span><span class="p">)</span>      <span class="c1"># Rebind F to result of decorator&#39;s return value</span>
<span class="n">F</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>                                <span class="c1"># Essentially calls decorator(A, B)(F)(99)</span>
</code></pre></td></tr></table>
</div>
</div><p>上面演示的是用函数定义的装饰器，也是最常用的装饰器。
装饰器接收的参数可以是各种各样的，下面是一个带参的装饰器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="nd">@on_command</span><span class="p">(</span><span class="s2">&#34;info&#34;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_info</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&#34;这就是你需要的 info&#34;</span>

<span class="k">def</span> <span class="nf">on_command</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># 调用此函数获得装饰器，这样就实现了带参装饰器</span>
    <span class="k">def</span> <span class="nf">deco</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>  <span class="c1"># 这个才是真正的装饰器</span>
        <span class="c1"># 将命令处理器注册到命令列表内</span>
        <span class="k">return</span> <span class="n">func</span>  <span class="c1"># 直接返回原函数，这样的话，多个装饰器就不会相互影响了。</span>
    <span class="k">return</span> <span class="n">deco</span>

<span class="c1"># 上面的等同于：</span>
<span class="n">get_info</span> <span class="o">=</span> <span class="n">on_command</span><span class="p">(</span><span class="s2">&#34;info&#34;</span><span class="p">)(</span><span class="n">get_info</span><span class="p">)</span>  <span class="c1"># on_command(&#34;info&#34;) 返回真正的装饰器</span>
</code></pre></td></tr></table>
</div>
</div><p>如果你的 <code>on_command</code> 有通用的部分，还可以将通用的部分抽离出来复用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">_deco_maker</span><span class="p">(</span><span class="n">event_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>  <span class="c1"># 调用这个，获取 on_xxx 的 deco_deco，</span>
    <span class="k">def</span> <span class="nf">deco_deco</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>   <span class="c1"># 这个对应 on_xxx</span>
        <span class="k">def</span> <span class="nf">deco</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span> <span class="c1"># 这个才是真正的装饰器</span>
            <span class="c1"># do something </span>
            <span class="k">return</span> <span class="n">func</span>  <span class="c1"># 返回原函数</span>

        <span class="k">return</span> <span class="n">deco</span>

    <span class="k">return</span> <span class="n">deco_deco</span>
</code></pre></td></tr></table>
</div>
</div><p>我们知道 Python 的类实际上是可以很方便的修改的，因此函数装饰器也能用于装饰类，修改类的某些行为。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">log_getattribute</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="c1"># Get the original implementation</span>
    <span class="n">orig_getattribute</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__getattribute__</span>

    <span class="c1"># Make a new definition</span>
    <span class="k">def</span> <span class="nf">new_getattribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;getting:&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">orig_getattribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="c1"># Attach to the class and return</span>
    <span class="bp">cls</span><span class="o">.</span><span class="fm">__getattribute__</span> <span class="o">=</span> <span class="n">new_getattribute</span>  <span class="c1"># 修改了被装饰类 cls 的 __getattribute__</span>
    <span class="k">return</span> <span class="bp">cls</span>

<span class="c1"># Example use</span>
<span class="nd">@log_getattribute</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">def</span> <span class="nf">spam</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="2-类定义装饰器">2. 类定义装饰器</h3>
<p>类定义装饰器和函数定义装饰器的使用方式完全一致。它也可以用于装饰函数或者类。</p>
<p>那么为啥还需要类定义装饰器呢？它的优势在于类是可以继承的，这样的话，就能用继承的方式定义装饰器，将通用部分定义成超类。</p>
<p>类定义装饰器的定义方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># PythonDecorators/entry_exit_class.py</span>
<span class="k">class</span> <span class="nc">entry_exit</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1">#关键在于这个函数，它使此类的对象变成 Callable</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Entering&#34;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Exited&#34;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

<span class="nd">@entry_exit</span>
<span class="k">def</span> <span class="nf">func1</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;inside func1()&#34;</span><span class="p">)</span>

<span class="c1"># 上面的装饰器相当于</span>
<span class="n">func1</span> <span class="o">=</span> <span class="n">entry_exit</span><span class="p">(</span><span class="n">func1</span><span class="p">)</span>  <span class="c1"># 从这里看的话，装饰器的行为完全一致</span>

<span class="c1"># 接下来调用该函数（实际上是调用了 entry_exit 对象的 call 函数）</span>
<span class="n">func1</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>输出结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Entering func1
inside func1()
Exited func1
</code></pre></td></tr></table>
</div>
</div><h2 id="五oop">五、OOP</h2>
<ol>
<li>
<p>调用超类方法：</p>
<ul>
<li>直接通过<code>超类名.__init__(self,xx)</code>调用</li>
<li>通过<code>super(__class__, self).__init__()</code>调用。
（Python3 可直接用 <code>super().__init__()</code>
但是要搞清楚，<strong><a href="https://docs.python.org/3/library/functions.html#super" target="_blank" rel="noopener noreferrer">super() 方法</a>返回的是一个代理类。另外被代理的类也不一定是其超类。如果不清楚这些差别，最好还是显式用方法一最好。</strong>）</li>
</ul>
</li>
<li>
<p>抽象超类：@abstractmethod</p>
</li>
<li>
<p><code>@staticmethod</code> <code>@classmethod</code> 与 Java 的 static 方法对比
python的类方法、静态方法，与java的静态方法：</p>
<ol>
<li>
<p>java 中 constants、utils 这样的静态类，对应的是python的一个模块（文件），类属性对应模块的全局属性，静态方法对应模块的函数</p>
</li>
<li>
<p>对于 java 中需要访问类属性的静态方法，如果它不属于第一类，应该用 <code>@classmethod</code> 实现它。classmethod最大的特点就是一定有一个 cls 传入。这种方法的主要用途是实现工厂函数。</p>
</li>
<li>
<p>对于不需要访问任何类属性，也不属于第一类的方法，应该用 <code>@staticmathod</code> 实现。这种方法其实完全不需要放到类里面，它就是一个独立的函数。（仍然放里面，是为了把功能类似的函数组织到一起而已。）</p>
</li>
</ol>
</li>
<li>
<p><code>__slots__</code>: 属性导出，不在该列表内的属性，若存在则为只读。不存在的话，就不存在。。
6.<code> __getattr__</code>: 拦截对不存在的属性的访问，可用于实现动态分配属性。</p>
</li>
<li>
<p><code>__getattribute__</code>: 和上面相同，但是它拦截对所有属性的访问，包括对已存在的属性的访问。</p>
</li>
<li>
<p>@property: 提供对属性访问的安全检查</p>
</li>
<li>
<p>descriptor: <strong>get</strong> <strong>set</strong> <strong>delete</strong> 控制对类的访问。（上面的 <strong>getattr</strong> 等是控制对类的属性的访问）</p>
</li>
<li>
<p>类构造器 <code>__new__</code>：在 <code>__init__</code> 之前运行，它接收一个 <code>cls</code> 参数，然后使用它构造并返回类实例 <code>self</code>。</p>
</li>
<li>
<p>类方法的 <code>cls</code> 即是当前类，是 type 的实例，<code>cls.xxx</code> 和 <code>&lt;类名&gt;.xxx</code> 调用结果是一致的。而 self 由 <code>__new__</code> 构造，是 cls 的实例。</p>
</li>
</ol>
<h3 id="元类-metaclasses">元类 metaclasses</h3>
<p>元类，也就是用于创建class 的 class，算是很高级的话题了（If you wonder whether you need metaclasses, you don’t ）
元类的工作流程：</p>
<ol>
<li>拦截类的创建</li>
<li>修改类</li>
<li>返回修改之后的类</li>
</ol>
<p>详细直接看 <a href="http://blog.jobbole.com/21351/" target="_blank" rel="noopener noreferrer">http://blog.jobbole.com/21351/</a> 吧。</p>
<h2 id="六查看-python-源码">六、查看 Python 源码</h2>
<p>对一般的标准库的模块，要查看其具体的 Python 实现是很简单的：直接通过 <code>__file__</code> 属性就能看到 <code>.py</code> 文件的位置。</p>
<p>但是 Python 很多功能是 C 写的，对于这类函数/类，<code>__file__</code> 就没啥用了。</p>
<p>如果是需要查看 <a href="https://stackoverflow.com/questions/8608587/finding-the-source-code-for-built-in-python-functions" target="_blank" rel="noopener noreferrer">builtins 模块</a> 的具体实现，直接查看 <a href="https://github.com/python/cpython/blob/master/Python/bltinmodule.c" target="_blank" rel="noopener noreferrer">Python/bltinmodule.c</a> 就行。</p>
<p>其他 C 模块的源码，待补充具体的查看方法。</p>
<h2 id="七参考文档">七、参考文档</h2>
<ul>
<li><a href="https://www.jb51.net/article/140443.htm" target="_blank" rel="noopener noreferrer">Python中一些不为人知的基础技巧总结</a></li>
<li><a href="https://docs.python.org/3/" target="_blank" rel="noopener noreferrer">Python3 官方文档</a></li>
</ul>
]]></description></item><item><title>部署一个 Kubernetes 集群</title><link>https://thiscute.world/posts/kubernetes-deployemnt-using-kubeadm/</link><pubDate>Tue, 25 Jan 2022 01:37:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/kubernetes-deployemnt-using-kubeadm/</guid><description><![CDATA[<blockquote>
<p>本文由个人笔记 <a href="https://github.com/ryan4yin/knowledge/tree/master/kubernetes" target="_blank" rel="noopener noreferrer">ryan4yin/knowledge</a> 整理而来，不保证正确</p>
</blockquote>
<h2 id="本地-kubernetes-集群安装工具">本地 Kubernetes 集群安装工具</h2>
<blockquote>
<p>云上的 Kubernetes 集群，基本上各云厂商都支持一键部署。这里主要关注本地部署，或者叫做裸机(baremetal)部署</p>
</blockquote>
<blockquote>
<p>本文介绍的方法适合开发测试使用，安全性、稳定性、长期可用性等方案都可能还有问题。</p>
</blockquote>
<blockquote>
<p>本文未考虑国内网络环境，建议在路由器上整个科学代理，或者自行调整文中的部分命令。</p>
</blockquote>
<p>kubernetes 是一个组件化的系统，安装过程有很大的灵活性，很多组件都有多种实现，这些实现各有特点，让初学者眼花缭乱。</p>
<p>而且要把这些组件一个个安装配置好并且能协同工作，也是很不容易的。</p>
<p>因此社区出现了各种各样的安装方案，下面介绍下几种支持裸机（Baremetal）部署的工具：</p>
<ol>
<li><a href="https://kuboard.cn/install/install-k8s.html" target="_blank" rel="noopener noreferrer">kubeadm</a>: 社区的集群安装工具，目前已经很成熟了。
<ol>
<li>使用难度：简单</li>
</ol>
</li>
<li><a href="https://github.com/k3s-io/k3s" target="_blank" rel="noopener noreferrer">k3s</a>: 轻量级 kubernetes，资源需求小，部署非常简单，适合开发测试用或者边缘环境
<ol>
<li>支持 airgap 离线部署</li>
<li>使用难度：超级简单</li>
</ol>
</li>
<li><a href="https://github.com/alibaba/sealer" target="_blank" rel="noopener noreferrer">alibaba/sealer</a>: 支持将整个 kubernetes 打包成一个镜像进行交付，而且部署也非常简单。
<ol>
<li>使用难度：超级简单</li>
<li>这个项目目前还在发展中，不过貌似已经有很多 toB 的公司在使用它进行 k8s 应用的交付了。</li>
</ol>
</li>
<li><a href="https://github.com/kubernetes-sigs/kubespray" target="_blank" rel="noopener noreferrer">kubespray</a>: 适合自建生产级别的集群，是一个大而全的 kubernetes 安装方案，自动安装容器运行时、k8s、网络插件等组件，而且各组件都有很多方案可选，但是感觉有点复杂。
<ol>
<li>使用难度：中等</li>
<li>支持 airgap 离线部署，但是以前我试用过是有坑，现在不知道咋样了</li>
<li>底层使用了 kubeadm 部署集群</li>
</ol>
</li>
</ol>
<p>笔者为了学习 Kubernetes，下面采用官方的 kubeadm 进行部署（不要问为啥不二进制部署，问就是懒），容器运行时使用 containerd，网络插件则使用目前最潮的基于 eBPF 的 Cilium.</p>
<p>kubernetes 官方介绍了两种高可用集群的拓扑结构：「Stacked etcd topology」和「External etcd topology」，简单起见，本文使用第一种「堆叠 Etcd 拓扑」结构，创建一个三 master 的高可用集群。</p>
<p>参考：</p>
<ul>
<li><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noopener noreferrer">Kubernetes Docs - Installing kubeadm</a></li>
<li><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/" target="_blank" rel="noopener noreferrer">Kubernetes Docs - Creating Highly Available clusters with kubeadm</a></li>
</ul>
<h2 id="1-节点的环境准备">1. 节点的环境准备</h2>
<p>首先准备三台 Linux 虚拟机，系统按需选择，然后调整这三台机器的设置：</p>
<ul>
<li>节点配置：
<ul>
<li>master：不低于 2c/3g，硬盘 20G
<ul>
<li>主节点性能也受集群 Pods 个数的影响，上述配置应该可以支撑到每个 Worker 节点跑 100 个 Pod.</li>
</ul>
</li>
<li>worker：看需求，建议不低于 2c/4g，硬盘不小于 20G，资源充分的话建议 40G.</li>
</ul>
</li>
<li>处于同一网络内并可互通（通常是同一局域网）</li>
<li>各主机的 hostname 和 mac/ip 地址以及 <code>/sys/class/dmi/id/product_uuid</code>，都必须唯一
<ul>
<li>这里最容易出问题的，通常是 hostname 冲突！</li>
</ul>
</li>
<li><strong>必须</strong>关闭 swap，kubelet 才能正常工作！</li>
</ul>
<p>方便起见，我直接使用 <a href="https://github.com/ryan4yin/pulumi-libvirt#examples" target="_blank" rel="noopener noreferrer">ryan4yin/pulumi-libvirt</a> 自动创建了五个虚拟机，并设置好了 ip/hostname.</p>
<p>本文使用了 opensuse leap 15.3 的 KVM cloud image 进行安装测试。</p>
<h3 id="11-iptables-设置">1.1 iptables 设置</h3>
<p>目前 kubernetes 的容器网络，默认使用的是 bridge 模式，这种模式下，需要使 <code>iptables</code> 能够接管 bridge 上的流量。</p>
<p>配置如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">sudo modprobe br_netfilter
cat <span class="s">&lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf
</span><span class="s">br_netfilter
</span><span class="s">EOF</span>

cat <span class="s">&lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf
</span><span class="s">net.bridge.bridge-nf-call-ip6tables = 1
</span><span class="s">net.bridge.bridge-nf-call-iptables = 1
</span><span class="s">EOF</span>
sudo sysctl --system
</code></pre></td></tr></table>
</div>
</div><h3 id="12-开放节点端口">1.2 开放节点端口</h3>
<blockquote>
<p>局域网环境的话，建议直接关闭防火墙。这样所有端口都可用，方便快捷。</p>
</blockquote>
<blockquote>
<p>通常我们的云上集群，也是关闭防火墙的，只是会通过云服务提供的「安全组」来限制客户端 ip</p>
</blockquote>
<p>Control-plane 节点，也就是 master，需要开放如下端口：</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Direction</th>
<th>Port Range</th>
<th>Purpose</th>
<th>Used By</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>6443*</td>
<td>Kubernetes API server</td>
<td>All</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>2379-2380</td>
<td>etcd server client API</td>
<td>kube-apiserver, etcd</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>10250</td>
<td>kubelet API</td>
<td>Self, Control plane</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>10251</td>
<td>kube-scheduler</td>
<td>Self</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>10252</td>
<td>kube-controller-manager</td>
<td>Self</td>
</tr>
</tbody>
</table>
<p>Worker 节点需要开发如下端口：</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Direction</th>
<th>Port Range</th>
<th>Purpose</th>
<th>Used By</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>10250</td>
<td>kubelet API</td>
<td>Self, Control plane</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>30000-32767</td>
<td>NodePort Services†</td>
<td>All</td>
</tr>
</tbody>
</table>
<p>另外通常我们本地测试的时候，可能更想直接在 <code>80</code> <code>443</code> <code>8080</code> 等端口上使用 <code>NodePort</code>，
就需要修改 kube-apiserver 的 <code>--service-node-port-range</code> 参数来自定义 NodePort 的端口范围，相应的 Worker 节点也得开放这些端口。</p>
<h2 id="2-安装-containerd">2. 安装 containerd</h2>
<p>首先是环境配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">cat <span class="s">&lt;&lt;EOF | sudo tee /etc/modules-load.d/containerd.conf
</span><span class="s">overlay
</span><span class="s">br_netfilter
</span><span class="s">nf_conntrack
</span><span class="s">EOF</span>

sudo modprobe overlay
sudo modprobe br_netfilter
sudo modprobe nf_conntrack

<span class="c1"># Setup required sysctl params, these persist across reboots.</span>
cat <span class="s">&lt;&lt;EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf
</span><span class="s">net.bridge.bridge-nf-call-iptables  = 1
</span><span class="s">net.ipv4.ip_forward                 = 1
</span><span class="s">net.bridge.bridge-nf-call-ip6tables = 1
</span><span class="s">EOF</span>

<span class="c1"># Apply sysctl params without reboot</span>
sudo sysctl --system
</code></pre></td></tr></table>
</div>
</div><p>安装 containerd+nerdctl:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">wget https://github.com/containerd/nerdctl/releases/download/v0.11.1/nerdctl-full-0.11.1-linux-amd64.tar.gz
tar -axvf nerdctl-full-0.11.1-linux-amd64.tar.gz
<span class="c1"># 这里简单起见，rootless 相关的东西也一起装进去了，测试嘛就无所谓了...</span>
mv bin/* /usr/local/bin/
mv lib/systemd/system/containerd.service /usr/lib/systemd/system/

systemctl <span class="nb">enable</span> containerd
systemctl start containerd
</code></pre></td></tr></table>
</div>
</div><p><code>nerdctl</code> 是一个 containerd 的命令行工具，但是它的容器、镜像与 Kubernetes 的容器、镜像是完全隔离的，不能互通！</p>
<p>目前只能通过 <code>crictl</code> 来查看、拉取 Kubernetes 的容器、镜像，下一节会介绍 crictl 的安装。</p>
<h2 id="3-安装-kubeletkubeadmkubectl">3. 安装 kubelet/kubeadm/kubectl</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 一些全局都需要用的变量</span>
<span class="nv">CNI_VERSION</span><span class="o">=</span><span class="s2">&#34;v0.8.2&#34;</span>
<span class="nv">CRICTL_VERSION</span><span class="o">=</span><span class="s2">&#34;v1.17.0&#34;</span>
<span class="c1"># kubernetes 的版本号</span>
<span class="c1"># RELEASE=&#34;$(curl -sSL https://dl.k8s.io/release/stable.txt)&#34;</span>
<span class="nv">RELEASE</span><span class="o">=</span><span class="s2">&#34;1.22.1&#34;</span>
<span class="c1"># kubelet 配置文件的版本号</span>
<span class="nv">RELEASE_VERSION</span><span class="o">=</span><span class="s2">&#34;v0.4.0&#34;</span>
<span class="c1"># 架构</span>
<span class="nv">ARCH</span><span class="o">=</span><span class="s2">&#34;amd64&#34;</span>
<span class="c1">#　安装目录</span>
<span class="nv">DOWNLOAD_DIR</span><span class="o">=</span>/usr/local/bin


<span class="c1"># CNI 插件</span>
sudo mkdir -p /opt/cni/bin
curl -L <span class="s2">&#34;https://github.com/containernetworking/plugins/releases/download/</span><span class="si">${</span><span class="nv">CNI_VERSION</span><span class="si">}</span><span class="s2">/cni-plugins-linux-</span><span class="si">${</span><span class="nv">ARCH</span><span class="si">}</span><span class="s2">-</span><span class="si">${</span><span class="nv">CNI_VERSION</span><span class="si">}</span><span class="s2">.tgz&#34;</span> <span class="p">|</span> sudo tar -C /opt/cni/bin -xz

<span class="c1"># crictl 相关工具</span>
curl -L <span class="s2">&#34;https://github.com/kubernetes-sigs/cri-tools/releases/download/</span><span class="si">${</span><span class="nv">CRICTL_VERSION</span><span class="si">}</span><span class="s2">/crictl-</span><span class="si">${</span><span class="nv">CRICTL_VERSION</span><span class="si">}</span><span class="s2">-linux-</span><span class="si">${</span><span class="nv">ARCH</span><span class="si">}</span><span class="s2">.tar.gz&#34;</span> <span class="p">|</span> sudo tar -C <span class="nv">$DOWNLOAD_DIR</span> -xz

<span class="c1"># kubelet/kubeadm/kubectl</span>
<span class="nb">cd</span> <span class="nv">$DOWNLOAD_DIR</span>
sudo curl -L --remote-name-all https://storage.googleapis.com/kubernetes-release/release/<span class="si">${</span><span class="nv">RELEASE</span><span class="si">}</span>/bin/linux/<span class="si">${</span><span class="nv">ARCH</span><span class="si">}</span>/<span class="o">{</span>kubeadm,kubelet,kubectl<span class="o">}</span>
sudo chmod +x <span class="o">{</span>kubeadm,kubelet,kubectl<span class="o">}</span>

<span class="c1"># kubelet/kubeadm 配置</span>
curl -sSL <span class="s2">&#34;https://raw.githubusercontent.com/kubernetes/release/</span><span class="si">${</span><span class="nv">RELEASE_VERSION</span><span class="si">}</span><span class="s2">/cmd/kubepkg/templates/latest/deb/kubelet/lib/systemd/system/kubelet.service&#34;</span> <span class="p">|</span> sed <span class="s2">&#34;s:/usr/bin:</span><span class="si">${</span><span class="nv">DOWNLOAD_DIR</span><span class="si">}</span><span class="s2">:g&#34;</span> <span class="p">|</span> sudo tee /etc/systemd/system/kubelet.service
sudo mkdir -p /etc/systemd/system/kubelet.service.d
curl -sSL <span class="s2">&#34;https://raw.githubusercontent.com/kubernetes/release/</span><span class="si">${</span><span class="nv">RELEASE_VERSION</span><span class="si">}</span><span class="s2">/cmd/kubepkg/templates/latest/deb/kubeadm/10-kubeadm.conf&#34;</span> <span class="p">|</span> sed <span class="s2">&#34;s:/usr/bin:</span><span class="si">${</span><span class="nv">DOWNLOAD_DIR</span><span class="si">}</span><span class="s2">:g&#34;</span> <span class="p">|</span> sudo tee /etc/systemd/system/kubelet.service.d/10-kubeadm.conf

systemctl <span class="nb">enable</span> --now kubelet
<span class="c1"># 验证 kubelet 启动起来了，但是目前还没有初始化配置，过一阵就会重启一次</span>
systemctl status kubelet
</code></pre></td></tr></table>
</div>
</div><p>试用 crictl:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">export</span> <span class="nv">CONTAINER_RUNTIME_ENDPOINT</span><span class="o">=</span><span class="s1">&#39;unix:///var/run/containerd/containerd.sock&#39;</span>
<span class="c1"># 列出所有 pods，现在应该啥也没</span>
crictl  pods

<span class="c1"># 列出所有镜像</span>
crictl images
</code></pre></td></tr></table>
</div>
</div><h2 id="4-为-master-的-kube-apiserver-创建负载均衡实现高可用">4. 为 master 的 kube-apiserver 创建负载均衡实现高可用</h2>
<p>根据 kubeadm 官方文档 <a href="https://github.com/kubernetes/kubeadm/blob/master/docs/ha-considerations.md#kube-vip" target="_blank" rel="noopener noreferrer">Kubeadm Docs - High Availability Considerations</a> 介绍，要实现 kube-apiserver 的高可用，目前最知名的负载均衡方式是 keepalived+haproxy，另外也可以考虑使用 kube-vip 等更简单的工具。</p>
<p>简单起见，我们直接用 kube-vip 吧，参考了 kube-vip 的官方文档：<a href="https://kube-vip.io/install_static/" target="_blank" rel="noopener noreferrer">Kube-vip as a Static Pod with Kubelet</a>.</p>
<blockquote>
<p>P.S. 我也见过有的安装工具会直接抛弃 keepalived，直接在每个节点上跑一个 nginx 做负载均衡，配置里写死了所有 master 的地址&hellip;</p>
</blockquote>
<p>首先使用如下命令生成 kube-vip 的配置文件，以 ARP 为例（生产环境建议换成 BGP）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">cat <span class="s">&lt;&lt;EOF | sudo tee add-kube-vip.sh
</span><span class="s"># 你的虚拟机网卡，opensuse/centos 等都是 eth0，但是 ubuntu 可能是 ens3
</span><span class="s">export INTERFACE=eth0
</span><span class="s">
</span><span class="s"># 用于实现高可用的 vip，需要和前面的网络接口在同一网段内，否则就无法路由了。
</span><span class="s">export VIP=192.168.122.200
</span><span class="s">
</span><span class="s"># 生成 static-pod 的配置文件
</span><span class="s">mkdir -p /etc/kubernetes/manifests
</span><span class="s">nerdctl run --rm --network=host --entrypoint=/kube-vip ghcr.io/kube-vip/kube-vip:v0.3.8 \
</span><span class="s">  manifest pod \
</span><span class="s">  --interface $INTERFACE \
</span><span class="s">  --vip $VIP \
</span><span class="s">  --controlplane \
</span><span class="s">  --services \
</span><span class="s">  --arp \
</span><span class="s">  --leaderElection | tee  /etc/kubernetes/manifests/kube-vip.yaml
</span><span class="s">EOF</span>

bash add-kube-vip.sh
</code></pre></td></tr></table>
</div>
</div><p>三个 master 节点都需要跑下上面的命令（worker 不需要），创建好 kube-vip 的 static-pod 配置文件。
在完成 kubeadm 初始化后，kubelet 会自动把它们拉起为 static pod.</p>
<h2 id="5-使用-kubeadm-创建集群">5. 使用 kubeadm 创建集群</h2>
<p>其实需要运行的就是这条命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 极简配置：</span>
cat <span class="s">&lt;&lt;EOF | sudo tee kubeadm-config.yaml
</span><span class="s">apiVersion: kubeadm.k8s.io/v1beta3
</span><span class="s">kind: InitConfiguration
</span><span class="s">nodeRegistration:
</span><span class="s">  criSocket: &#34;/var/run/containerd/containerd.sock&#34;
</span><span class="s">  imagePullPolicy: IfNotPresent
</span><span class="s">---
</span><span class="s">kind: ClusterConfiguration
</span><span class="s">apiVersion: kubeadm.k8s.io/v1beta3
</span><span class="s">kubernetesVersion: v1.22.1
</span><span class="s">clusterName: kubernetes
</span><span class="s">certificatesDir: /etc/kubernetes/pki
</span><span class="s">imageRepository: k8s.gcr.io
</span><span class="s">controlPlaneEndpoint: &#34;192.168.122.200:6443&#34;  # 填 apiserver 的 vip 地址，或者整个域名也行，但是就得加 /etc/hosts 或者内网 DNS 解析
</span><span class="s">networking:
</span><span class="s">  serviceSubnet: &#34;10.96.0.0/16&#34;
</span><span class="s">  podSubnet: &#34;10.244.0.0/16&#34;
</span><span class="s">etcd:
</span><span class="s">  local:
</span><span class="s">    dataDir: /var/lib/etcd
</span><span class="s">---
</span><span class="s">apiVersion: kubelet.config.k8s.io/v1beta1
</span><span class="s">kind: KubeletConfiguration
</span><span class="s">cgroupDriver: systemd
</span><span class="s"># 让 kubelet 从 certificates.k8s.io 申请由集群 CA Root 签名的 tls 证书，而非直接使用自签名证书
</span><span class="s"># 如果不启用这个， 安装 metrics-server 时就会遇到证书报错，后面会详细介绍。
</span><span class="s">serverTLSBootstrap: true
</span><span class="s">EOF</span>

<span class="c1"># 查看 kubeadm 默认的完整配置，供参考</span>
kubeadm config print init-defaults &gt; init.default.yaml

<span class="c1"># 执行集群的初始化，这会直接将当前节点创建为 master</span>
<span class="c1"># 成功运行的前提：前面该装的东西都装好了，而且 kubelet 已经在后台运行了</span>
<span class="c1"># `--upload-certs` 会将生成的集群证书上传到 kubeadm 服务器，在两小时内加入集群的 master 节点会自动拉证书，主要是方便集群创建。</span>
kubeadm init --config kubeadm-config.yaml --upload-certs
</code></pre></td></tr></table>
</div>
</div><p>kubeadm 应该会报错，提示你有些依赖不存在，下面先安装好依赖项。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">sudo zypper in -y socat ebtables conntrack-tools
</code></pre></td></tr></table>
</div>
</div><p>再重新运行前面的 kubeadm 命令，应该就能正常执行了，它做的操作有：</p>
<ul>
<li>拉取控制面的容器镜像</li>
<li>生成 ca 根证书</li>
<li>使用根证书为 etcd/apiserver 等一票工具生成 tls 证书</li>
<li>为控制面的各个组件生成 kubeconfig 配置</li>
<li>生成 static pod 配置，kubelet 会根据这些配置自动拉起 kube-proxy 以及其他所有的 k8s master 组件</li>
</ul>
<p>运行完会给出三部分命令：</p>
<ul>
<li>将 <code>kubeconfig</code> 放到 <code>$HOME/.kube/config</code> 下，<code>kubectl</code> 需要使用该配置文件连接 kube-apiserver</li>
<li>control-plane 节点加入集群的命令:
<ul>
<li>这里由于我们提前添加了 kube-vip 的 static-pod 配置，这里的 preflight-check 会报错，需要添加此参数忽略该报错 - <code>--ignore-preflight-errors=DirAvailable--etc-kubernetes-manifests</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">kubeadm join 192.168.122.200:6443 --token &lt;token&gt; <span class="se">\
</span><span class="se"></span>  --discovery-token-ca-cert-hash sha256:&lt;hash&gt; <span class="se">\
</span><span class="se"></span>  --control-plane --certificate-key &lt;key&gt; <span class="se">\
</span><span class="se"></span>  --ignore-preflight-errors<span class="o">=</span>DirAvailable--etc-kubernetes-manifests
</code></pre></td></tr></table>
</div>
</div></li>
<li>worker 节点加入集群的命令:
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">kubeadm join 192.168.122.200:6443 --token &lt;token&gt; <span class="se">\
</span><span class="se"></span>      --discovery-token-ca-cert-hash sha256:&lt;hash&gt; 
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>跑完第一部分 <code>kubeconfig</code> 的处理命令后，就可以使用 kubectl 查看集群状况了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">k8s-master-0:~/kubeadm <span class="c1"># kubectl get no</span>
NAME           STATUS     ROLES                  AGE   VERSION
k8s-master-0   NotReady   control-plane,master   79s   v1.22.1
k8s-master-0:~/kubeadm <span class="c1"># kubectl get po --all-namespaces</span>
NAMESPACE     NAME                                   READY   STATUS    RESTARTS   AGE
kube-system   coredns-78fcd69978-6tlnw               0/1     Pending   <span class="m">0</span>          83s
kube-system   coredns-78fcd69978-hxtvs               0/1     Pending   <span class="m">0</span>          83s
kube-system   etcd-k8s-master-0                      1/1     Running   <span class="m">6</span>          90s
kube-system   kube-apiserver-k8s-master-0            1/1     Running   <span class="m">4</span>          90s
kube-system   kube-controller-manager-k8s-master-0   1/1     Running   <span class="m">4</span>          90s
kube-system   kube-proxy-6w2bx                       1/1     Running   <span class="m">0</span>          83s
kube-system   kube-scheduler-k8s-master-0            1/1     Running   <span class="m">7</span>          97s
</code></pre></td></tr></table>
</div>
</div><p>现在在其他节点运行前面打印出的加入集群的命令，就可以搭建好一个高可用的集群了。</p>
<p>所有节点都加入集群后，通过 kubectl 查看，应该是三个控制面 master，两个 worker：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">k8s-master-0:~/kubeadm <span class="c1"># kubectl get node</span>
NAME           STATUS     ROLES                  AGE     VERSION
k8s-master-0   NotReady   control-plane,master   26m     v1.22.1
k8s-master-1   NotReady   control-plane,master   7m2s    v1.22.1
k8s-master-2   NotReady   control-plane,master   2m10s   v1.22.1
k8s-worker-0   NotReady   &lt;none&gt;                 97s     v1.22.1
k8s-worker-1   NotReady   &lt;none&gt;                 86s     v1.22.1
</code></pre></td></tr></table>
</div>
</div><p>现在它们都还处于 NotReady 状态，需要等到我们把网络插件安装好，才会 Ready.</p>
<p>现在再看下集群的证书签发状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">❯ kubectl get csr --sort-by<span class="o">=</span><span class="s1">&#39;{.spec.username}&#39;</span>
NAME        AGE     SIGNERNAME                                    REQUESTOR                  REQUESTEDDURATION   CONDITION
csr-95hll   6m58s   kubernetes.io/kube-apiserver-client-kubelet   system:bootstrap:q8ivnz    &lt;none&gt;              Approved,Issued
csr-tklnr   7m5s    kubernetes.io/kube-apiserver-client-kubelet   system:bootstrap:q8ivnz    &lt;none&gt;              Approved,Issued
csr-w92jv   9m15s   kubernetes.io/kube-apiserver-client-kubelet   system:bootstrap:q8ivnz    &lt;none&gt;              Approved,Issued
csr-rv7sj   8m11s   kubernetes.io/kube-apiserver-client-kubelet   system:bootstrap:q8ivnz    &lt;none&gt;              Approved,Issued
csr-nxkgx   10m     kubernetes.io/kube-apiserver-client-kubelet   system:node:k8s-master-0   &lt;none&gt;              Approved,Issued
csr-cd22c   10m     kubernetes.io/kubelet-serving                 system:node:k8s-master-0   &lt;none&gt;              Pending
csr-wjrnr   9m53s   kubernetes.io/kubelet-serving                 system:node:k8s-master-0   &lt;none&gt;              Pending
csr-sjq42   9m8s    kubernetes.io/kubelet-serving                 system:node:k8s-master-1   &lt;none&gt;              Pending
csr-xtv8f   8m56s   kubernetes.io/kubelet-serving                 system:node:k8s-master-1   &lt;none&gt;              Pending
csr-f2dsf   8m3s    kubernetes.io/kubelet-serving                 system:node:k8s-master-2   &lt;none&gt;              Pending
csr-xl8dg   6m58s   kubernetes.io/kubelet-serving                 system:node:k8s-worker-0   &lt;none&gt;              Pending
csr-p9g24   6m52s   kubernetes.io/kubelet-serving                 system:node:k8s-worker-1   &lt;none&gt;              Pending
</code></pre></td></tr></table>
</div>
</div><p>能看到有好几个 <code>kubernetes.io/kubelet-serving</code> 的证书还处于 pending 状态，
这是因为我们在 kubeadm 配置文件中，设置了 <code>serverTLSBootstrap: true</code>，让 Kubelet 从集群中申请 CA 签名证书，而不是自签名导致的。</p>
<p>设置这个参数的主要目的，是为了让 metrics-server 等组件能使用 https 协议与 kubelet 通信，避免为 metrics-server 添加参数 <code>--kubelet-insecure-tls</code>.</p>
<p>目前 kubeadm 不支持自动批准 kubelet 申请的证书，需要我们手动批准一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 批准 Kubelet 申请的所有证书</span>
kubectl certificate approve csr-cd22c csr-wjrnr csr-sjq42 csr-xtv8f csr-f2dsf csr-xl8dg csr-p9g24
</code></pre></td></tr></table>
</div>
</div><p>在未批准这些证书之前，所有需要调用 kubelet api 的功能都将无法使用，比如：</p>
<ul>
<li>查看 pod 日志</li>
<li>获取节点 metrics</li>
<li>等等</li>
</ul>
<h3 id="51-常见问题">5.1 常见问题</h3>
<h4 id="511-使用国内镜像源">5.1.1 使用国内镜像源</h4>
<p>如果你没有科学环境，kubeadm 默认的镜像仓库在国内是拉不了的。
如果对可靠性要求高，最好是自建私有镜像仓库，把镜像推送到私有仓库。</p>
<p>可以通过如下命令列出所有需要用到的镜像地址：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">❯ kubeadm config images list --kubernetes-version v1.22.1
k8s.gcr.io/kube-apiserver:v1.22.1
k8s.gcr.io/kube-controller-manager:v1.22.1
k8s.gcr.io/kube-scheduler:v1.22.1
k8s.gcr.io/kube-proxy:v1.22.1
k8s.gcr.io/pause:3.5
k8s.gcr.io/etcd:3.5.0-0
k8s.gcr.io/coredns/coredns:v1.8.4
</code></pre></td></tr></table>
</div>
</div><p>使用 <code>skopeo</code> 等工具或脚本将上述镜像拷贝到你的私有仓库，或者图方便（测试环境）也可以考虑网上找找别人同步好的镜像地址。将镜像地址添加到 <code>kubeadm-config.yaml</code> 中再部署。</p>
<h4 id="512-重置集群配置">5.1.2 重置集群配置</h4>
<p>创建集群的过程中出现任何问题，都可以通过在所有节点上运行 <code>kubeadm reset</code> 来还原配置，然后重新走 kubeadm 的集群创建流程。</p>
<p>但是要注意几点：</p>
<ul>
<li><code>kubeadm reset</code> 会清除包含 kube-vip 配置在内的所有 static-pod 配置文件，所以 master 节点需要重新跑下前面给的 kube-vip 命令，生成下 kube-vip 配置。</li>
<li><code>kubeadm reset</code> 不会重置网络接口的配置，master 节点需要手动清理下 kube-vip 添加的 vip: <code>ip addr del 192.168.122.200/32 dev eth0</code>.</li>
<li>如果你在安装了网络插件之后希望重装集群，顺序如下：
<ul>
<li>通过 <code>kubectl delete -f xxx.yaml</code>/<code>helm uninstall</code> 删除所有除网络之外的其他应用配置</li>
<li>删除网络插件</li>
<li>先重启一遍所有节点，或者手动重置所有节点的网络配置
<ul>
<li>建议重启，因为我不知道该怎么手动重置&hellip; 试了 <code>systemctl restart network</code> 并不会清理所有虚拟网络接口。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如此操作后，再重新执行集群安装，应该就没啥毛病了。</p>
<h2 id="6-验证集群的高可用性">6. 验证集群的高可用性</h2>
<p>虽然网络插件还没装导致集群所有节点都还没 ready，但是我们已经可以通过 kubectl 命令来简单验证集群的高可用性了。</p>
<p>首先，我们将前面放置在 k8s-master-0 的认证文件 <code>$HOME/.kube/config</code> 以及 kunbectl 安装在另一台机器上，比如我直接放我的宿主机。</p>
<p>然后在宿主机上跑 <code>kubectl get node</code> 命令验证集群的高可用性：</p>
<ul>
<li>三个主节点都正常运行时，kubectl 命令也正常</li>
<li>pause 或者 stop 其中一个 master，kubectl 命令仍然能正常运行</li>
<li>再 pause 第二个 master，kubectl 命令应该就会卡住，并且超时，无法使用了</li>
<li>resume 恢复停掉的两个 master 之一，会发现 kubectl 命令又能正常运行了</li>
</ul>
<p>到这里 kubeadm 的工作就完成了，接下来再安装网络插件，集群就可用了。</p>
<h2 id="7-安装网络插件">7. 安装网络插件</h2>
<p>社区有很多种网络插件可选，比较知名且性能也不错的，应该是 Calico 和 Cilium，其中 Cilium 主打基于 eBPF 的高性能与高可观测性。</p>
<p>下面分别介绍这两个插件的安装方法。（注意只能安装其中一个网络插件，不能重复安装。）</p>
<p>需要提前在本机安装好 helm，我这里使用宿主机，因此只需要在宿主机安装:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 一行命令安装，也可以自己手动下载安装包，都行</span>
curl https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 <span class="p">|</span> bash

<span class="c1"># 或者 opensuse 直接用包管理器安装</span>
sudo zypper in helm
</code></pre></td></tr></table>
</div>
</div><h3 id="71-安装-cilium">7.1 安装 Cilium</h3>
<blockquote>
<p>官方文档：https://docs.cilium.io/en/v1.10/gettingstarted/k8s-install-kubeadm/</p>
</blockquote>
<p>cilium 通过 eBPF 提供了高性能与高可观测的 k8s 集群网络，
另外 cilium 还提供了比 kube-proxy 更高效的实现，可以完全替代 kube-proxy.</p>
<p>这里我们还是先使用 kube-proxy 模式，先熟悉下 cilium 的使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">helm repo add cilium https://helm.cilium.io/
helm search repo cilium/cilium -l <span class="p">|</span> head

helm install cilium cilium/cilium --version 1.10.4 --namespace kube-system
</code></pre></td></tr></table>
</div>
</div><p>可以通过 <code>kubectl get pod -A</code> 查看 cilium 的安装进度，当所有 pod 都 ready 后，集群就 ready 了~</p>
<p>cilium 也提供了专用的客户端：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">curl -L --remote-name-all https://github.com/cilium/cilium-cli/releases/latest/download/cilium-linux-amd64.tar.gz<span class="o">{</span>,.sha256sum<span class="o">}</span>
sha256sum --check cilium-linux-amd64.tar.gz.sha256sum
sudo tar xzvfC cilium-linux-amd64.tar.gz /usr/local/bin
rm cilium-linux-amd64.tar.gz<span class="o">{</span>,.sha256sum<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后使用 cilium 客户端检查网络插件的状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"> $ cilium status --wait
    /¯¯<span class="se">\
</span><span class="se"></span> /¯¯<span class="se">\_</span>_/¯¯<span class="se">\ </span>   Cilium:         OK
 <span class="se">\_</span>_/¯¯<span class="se">\_</span>_/    Operator:       OK
 /¯¯<span class="se">\_</span>_/¯¯<span class="se">\ </span>   Hubble:         disabled
 <span class="se">\_</span>_/¯¯<span class="se">\_</span>_/    ClusterMesh:    disabled
    <span class="se">\_</span>_/

DaemonSet         cilium             Desired: 5, Ready: 5/5, Available: 5/5
Deployment        cilium-operator    Desired: 2, Ready: 2/2, Available: 2/2
Containers:       cilium             Running: <span class="m">5</span>
                  cilium-operator    Running: <span class="m">2</span>
Cluster Pods:     2/2 managed by Cilium
Image versions    cilium             quay.io/cilium/cilium:v1.10.4@sha256:7d354052ccf2a7445101d78cebd14444c7c40129ce7889f2f04b89374dbf8a1d: <span class="m">5</span>
                  cilium-operator    quay.io/cilium/operator-generic:v1.10.4@sha256:c49a14e34634ff1a494c84b718641f27267fb3a0291ce3d74352b44f8a8d2f93: <span class="m">2</span>
</code></pre></td></tr></table>
</div>
</div><p>cilium 还提供了命令，自动创建 pod 进行集群网络的连接性测试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">❯ cilium connectivity <span class="nb">test</span>
ℹ️  Monitor aggregation detected, will skip some flow validation steps
✨ <span class="o">[</span>kubernetes<span class="o">]</span> Creating namespace <span class="k">for</span> connectivity check...
✨ <span class="o">[</span>kubernetes<span class="o">]</span> Deploying echo-same-node service...
✨ <span class="o">[</span>kubernetes<span class="o">]</span> Deploying same-node deployment...
✨ <span class="o">[</span>kubernetes<span class="o">]</span> Deploying client deployment...
✨ <span class="o">[</span>kubernetes<span class="o">]</span> Deploying client2 deployment...
✨ <span class="o">[</span>kubernetes<span class="o">]</span> Deploying echo-other-node service...
✨ <span class="o">[</span>kubernetes<span class="o">]</span> Deploying other-node deployment...
...
ℹ️  Expose Relay locally with:
   cilium hubble <span class="nb">enable</span>
   cilium status --wait
   cilium hubble port-forward<span class="p">&amp;</span>
🏃 Running tests...
...
---------------------------------------------------------------------------------------------------------------------
✅ All <span class="m">11</span> tests <span class="o">(</span><span class="m">134</span> actions<span class="o">)</span> successful, <span class="m">0</span> tests skipped, <span class="m">0</span> scenarios skipped.
</code></pre></td></tr></table>
</div>
</div><p>通过 <code>kubectl get po -A</code> 能观察到，这个测试命令会自动创建一个 <code>cilium-test</code> 名字空间，并在启动创建若干 pod 进行详细的测试。</p>
<p>整个测试流程大概会持续 5 分多钟，测试完成后，相关 Pod 不会自动删除，使用如下命令手动删除：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">kubectl delete namespace cilium-test
</code></pre></td></tr></table>
</div>
</div><h3 id="72-安装-calico">7.2 安装 Calico</h3>
<blockquote>
<p>官方文档：https://docs.projectcalico.org/getting-started/kubernetes/self-managed-onprem/onpremises</p>
</blockquote>
<p>也就两三行命令。安装确实特别简单，懒得介绍了，看官方文档吧。</p>
<p>但是实际上 calico 的细节还蛮多的，建议通读下它的官方文档，了解下 calico 的架构。</p>
<h2 id="8-查看集群状态">8. 查看集群状态</h2>
<p>官方的 dashboard 个人感觉不太好用，建议直接在本地装个 k9s 用，特别爽。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">sudo zypper in k9s
</code></pre></td></tr></table>
</div>
</div><p>然后就可以愉快地玩耍了。</p>
<h2 id="9-安装-metrics-server">9. 安装 metrics-server</h2>
<blockquote>
<p>这一步可能遇到的问题：<a href="https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#kubelet-serving-certs" target="_blank" rel="noopener noreferrer">Enabling signed kubelet serving certificates</a></p>
</blockquote>
<p>如果需要使用 HPA 以及简单的集群监控，那么 metrics-server 是必须安装的，现在我们安装一下它。</p>
<p>首先，跑 kubectl 的监控命令应该会报错：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">❯ kubectl top node
error: Metrics API not available
</code></pre></td></tr></table>
</div>
</div><p>k9s 里面应该也看不到任何监控指标。</p>
<p>现在通过 helm 安装它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">helm repo add metrics-server https://kubernetes-sigs.github.io/metrics-server/
helm search repo metrics-server/metrics-server -l <span class="p">|</span> head

helm upgrade --install metrics-server metrics-server/metrics-server --version 3.5.0 --namespace kube-system
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>metrics-server 默认只会部署一个实例，如果希望高可用，请参考官方配置：<a href="https://github.com/kubernetes-sigs/metrics-server/tree/master/manifests/high-availability" target="_blank" rel="noopener noreferrer">metrics-server - high-availability manifests</a></p>
</blockquote>
<p>等 metrics-server 启动好后，就可以使用 <code>kubectl top</code> 命令啦：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">❯ kubectl top node
NAME           CPU<span class="o">(</span>cores<span class="o">)</span>   CPU%   MEMORY<span class="o">(</span>bytes<span class="o">)</span>   MEMORY%   
k8s-master-0   327m         16%    1465Mi          50%       
k8s-master-1   263m         13%    1279Mi          44%       
k8s-master-2   289m         14%    1282Mi          44%       
k8s-worker-0   62m          3%     518Mi           13%       
k8s-worker-1   115m         2%     659Mi           8%        

❯ kubectl top pod
No resources found in default namespace.

❯ kubectl top pod -A
NAMESPACE     NAME                                   CPU<span class="o">(</span>cores<span class="o">)</span>   MEMORY<span class="o">(</span>bytes<span class="o">)</span>   
kube-system   cilium-45nw4                           9m           135Mi           
kube-system   cilium-5x7jf                           6m           154Mi           
kube-system   cilium-84sr2                           7m           160Mi           
kube-system   cilium-operator-78f45675-dp4b6         2m           30Mi            
kube-system   cilium-operator-78f45675-fpm5g         1m           30Mi            
kube-system   cilium-tkhl4                           6m           141Mi           
kube-system   cilium-zxbvm                           5m           138Mi           
kube-system   coredns-78fcd69978-dpxxk               3m           16Mi            
kube-system   coredns-78fcd69978-ptd9p               1m           18Mi            
kube-system   etcd-k8s-master-0                      61m          88Mi            
kube-system   etcd-k8s-master-1                      50m          85Mi            
kube-system   etcd-k8s-master-2                      55m          83Mi            
kube-system   kube-apiserver-k8s-master-0            98m          462Mi           
kube-system   kube-apiserver-k8s-master-1            85m          468Mi           
kube-system   kube-apiserver-k8s-master-2            85m          423Mi           
kube-system   kube-controller-manager-k8s-master-0   22m          57Mi            
kube-system   kube-controller-manager-k8s-master-1   2m           23Mi            
kube-system   kube-controller-manager-k8s-master-2   2m           23Mi            
kube-system   kube-proxy-j2s76                       1m           24Mi            
kube-system   kube-proxy-k6d6z                       1m           18Mi            
kube-system   kube-proxy-k85rx                       1m           23Mi            
kube-system   kube-proxy-pknsc                       1m           20Mi            
kube-system   kube-proxy-xsq4m                       1m           15Mi            
kube-system   kube-scheduler-k8s-master-0            3m           25Mi            
kube-system   kube-scheduler-k8s-master-1            4m           21Mi            
kube-system   kube-scheduler-k8s-master-2            5m           21Mi            
kube-system   kube-vip-k8s-master-0                  4m           17Mi            
kube-system   kube-vip-k8s-master-1                  2m           16Mi            
kube-system   kube-vip-k8s-master-2                  2m           17Mi            
kube-system   metrics-server-559f85484-5b6xf         7m           27Mi    
</code></pre></td></tr></table>
</div>
</div><h2 id="10-为-etcd-添加定期备份能力">10. 为 etcd 添加定期备份能力</h2>
<p>请移步 <a href="https://github.com/ryan4yin/knowledge/blob/master/datastore/etcd/etcd%20%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D.md" target="_blank" rel="noopener noreferrer">etcd 的备份与恢复</a></p>
<h2 id="11-安装-volume-provisioner">11. 安装 Volume Provisioner</h2>
<p>在我们学习使用 Prometheus/MinIO/Tekton 等有状态应用时，它们默认情况下会通过 PVC 声明需要的数据卷。</p>
<p>为了支持这个能力，我们需要在集群中部署一个 Volume Provisioner.</p>
<p>对于云上环境，直接接入云服务商提供的 Volume Provisioner 就 OK 了，方便省事而且足够可靠。</p>
<p>而对于 bare-metal 环境，比较有名的应该是 rook-ceph，但是这个玩意部署复杂，维护难度又高，不适合用来测试学习，也不适合生产环境。</p>
<p>对于开发、测试环境，或者个人集群，建议使用：</p>
<ul>
<li>local 数据卷，适合数据可丢失，且不要求分布式的场景，如开发测试环境
<ul>
<li><a href="https://github.com/kubernetes-sigs/sig-storage-local-static-provisioner" target="_blank" rel="noopener noreferrer">https://github.com/kubernetes-sigs/sig-storage-local-static-provisioner</a></li>
<li><a href="https://github.com/rancher/local-path-provisioner" target="_blank" rel="noopener noreferrer">https://github.com/rancher/local-path-provisioner</a></li>
</ul>
</li>
<li>NFS 数据卷，适合数据可丢失，对性能要求不高，并且要求分布式的场景。比如开发测试环境、或者线上没啥压力的应用
<ul>
<li><a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner" target="_blank" rel="noopener noreferrer">https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner</a></li>
<li><a href="https://github.com/kubernetes-csi/csi-driver-nfs" target="_blank" rel="noopener noreferrer">https://github.com/kubernetes-csi/csi-driver-nfs</a></li>
<li>NFS 数据的可靠性依赖于外部 NFS 服务器，企业通常使用群晖等 NAS 来做 NFS 服务器</li>
<li>如果外部 NFS 服务器出问题，应用就会崩。</li>
</ul>
</li>
<li>直接使用云上的对象存储，适合希望数据不丢失、对性能要求不高的场景。
<ul>
<li>直接使用 <a href="https://github.com/rclone/rclone" target="_blank" rel="noopener noreferrer">https://github.com/rclone/rclone</a> mount 模式来保存数据，或者直接同步文件夹数据到云端（可能会有一定数据丢失）。</li>
</ul>
</li>
</ul>
]]></description></item><item><title>Kubernetes 微服务最佳实践</title><link>https://thiscute.world/posts/kubernetes-best-practices/</link><pubDate>Tue, 25 Jan 2022 00:13:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/kubernetes-best-practices/</guid><description><![CDATA[<blockquote>
<p>本文由个人笔记 <a href="https://github.com/ryan4yin/knowledge/tree/master/kubernetes" target="_blank" rel="noopener noreferrer">ryan4yin/knowledge</a> 整理而来</p>
</blockquote>
<p>本文主要介绍我个人在使用 Kubernetes 的过程中，总结出的一套「Kubernetes 配置」，是我个人的「最佳实践」。
其中大部分内容都经历过线上环境的考验，但是也有少部分还只在我脑子里模拟过，请谨慎参考。</p>
<p>阅读前的几个注意事项：</p>
<ul>
<li>这份文档比较长，囊括了很多内容，建议当成参考手册使用，先参照目录简单读一读，有需要再细读相关内容。</li>
<li>这份文档需要一定的 Kubernetes 基础才能理解，而且如果没有过实践经验的话，看上去可能会比较枯燥。
<ul>
<li>而有过实践经验的大佬，可能会跟我有不同的见解，欢迎各路大佬评论~</li>
</ul>
</li>
</ul>
<p>我会视情况不定期更新这份文档。</p>
<h2 id="零示例">零、示例</h2>
<p>首先，这里给出一些本文遵守的前提，这些前提只是契合我遇到的场景，可灵活变通：</p>
<ul>
<li>这里只讨论无状态服务，有状态服务不在讨论范围内</li>
<li>我们不使用 Deployment 的滚动更新能力，而是为每个服务的每个版本，都创建不同的 Deployment + HPA + PodDisruptionBudget，这是为了方便做金丝雀/灰度发布</li>
<li>我们的服务可能会使用 IngressController / Service Mesh 来进行服务的负载均衡、流量切分</li>
</ul>
<p>下面先给出一个 Deployment + HPA + PodDisruptionBudget 的 demo，后面再拆开详细说下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Deployment</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">my-app-v3</span><span class="w">
</span><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">prod</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">my-app</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span><span class="w">  </span><span class="nt">strategy</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">RollingUpdate</span><span class="w">
</span><span class="w">    </span><span class="c"># 因为服务的每个版本都使用各自的 Deployment，服务更新时其实是用不上这里的滚动更新策略的</span><span class="w">
</span><span class="w">    </span><span class="c"># 这个配置应该只在 SRE 手动修改 Deployment 配置时才会生效（通常不应该发生这种事）</span><span class="w">
</span><span class="w">    </span><span class="nt">rollingUpdate</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">maxSurge</span><span class="p">:</span><span class="w"> </span><span class="m">10</span><span class="l">% </span><span class="w"> </span><span class="c"># 滚动更新时，每次最多更新 10% 的 Pods</span><span class="w">
</span><span class="w">      </span><span class="nt">maxUnavailable</span><span class="p">:</span><span class="w"> </span><span class="m">0</span><span class="w">  </span><span class="c"># 滚动更新时，不允许出现不可用的 Pods，也就是说始终要维持 3 个可用副本</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">my-app</span><span class="w">
</span><span class="w">      </span><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="l">v3</span><span class="w">
</span><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">my-app</span><span class="w">
</span><span class="w">        </span><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="l">v3</span><span class="w">
</span><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">affinity</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">podAffinity</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">preferredDuringSchedulingIgnoredDuringExecution</span><span class="p">:</span><span class="w"> </span><span class="c"># 非强制性条件</span><span class="w">
</span><span class="w">          </span>- <span class="nt">weight</span><span class="p">:</span><span class="w"> </span><span class="m">100</span><span class="w">  </span><span class="c"># weight 用于为节点评分，会优先选择评分最高的节点（只有一条规则的情况下，这个值没啥意义）</span><span class="w">
</span><span class="w">            </span><span class="nt">podAffinityTerm</span><span class="p">:</span><span class="w">
</span><span class="w">              </span><span class="nt">labelSelector</span><span class="p">:</span><span class="w">
</span><span class="w">                </span><span class="nt">matchExpressions</span><span class="p">:</span><span class="w">
</span><span class="w">                </span>- <span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">app</span><span class="w">
</span><span class="w">                  </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="l">In</span><span class="w">
</span><span class="w">                  </span><span class="nt">values</span><span class="p">:</span><span class="w">
</span><span class="w">                  </span>- <span class="l">my-app</span><span class="w">
</span><span class="w">                </span>- <span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">version</span><span class="w">
</span><span class="w">                  </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="l">In</span><span class="w">
</span><span class="w">                  </span><span class="nt">values</span><span class="p">:</span><span class="w">
</span><span class="w">                  </span>- <span class="l">v3</span><span class="w">
</span><span class="w">              </span><span class="c"># pod 尽量使用同一种节点类型，也就是尽量保证节点的性能一致</span><span class="w">
</span><span class="w">              </span><span class="nt">topologyKey</span><span class="p">:</span><span class="w"> </span><span class="l">node.kubernetes.io/instance-type</span><span class="w">
</span><span class="w">        </span><span class="nt">podAntiAffinity</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">preferredDuringSchedulingIgnoredDuringExecution</span><span class="p">:</span><span class="w"> </span><span class="c"># 非强制性条件</span><span class="w">
</span><span class="w">          </span>- <span class="nt">weight</span><span class="p">:</span><span class="w"> </span><span class="m">100</span><span class="w">  </span><span class="c"># weight 用于为节点评分，会优先选择评分最高的节点（只有一条规则的情况下，这个值没啥意义）</span><span class="w">
</span><span class="w">            </span><span class="nt">podAffinityTerm</span><span class="p">:</span><span class="w">
</span><span class="w">              </span><span class="nt">labelSelector</span><span class="p">:</span><span class="w">
</span><span class="w">                </span><span class="nt">matchExpressions</span><span class="p">:</span><span class="w">
</span><span class="w">                </span>- <span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">app</span><span class="w">
</span><span class="w">                  </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="l">In</span><span class="w">
</span><span class="w">                  </span><span class="nt">values</span><span class="p">:</span><span class="w">
</span><span class="w">                  </span>- <span class="l">my-app</span><span class="w">
</span><span class="w">                </span>- <span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">version</span><span class="w">
</span><span class="w">                  </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="l">In</span><span class="w">
</span><span class="w">                  </span><span class="nt">values</span><span class="p">:</span><span class="w">
</span><span class="w">                  </span>- <span class="l">v3</span><span class="w">
</span><span class="w">              </span><span class="c"># 将 pod 尽量打散在多个可用区</span><span class="w">
</span><span class="w">              </span><span class="nt">topologyKey</span><span class="p">:</span><span class="w"> </span><span class="l">topology.kubernetes.io/zone</span><span class="w">
</span><span class="w">          </span><span class="nt">requiredDuringSchedulingIgnoredDuringExecution</span><span class="p">:</span><span class="w">  </span><span class="c"># 强制性要求（这个建议按需添加）</span><span class="w">
</span><span class="w">          </span><span class="c"># 注意这个没有 weights，必须满足列表中的所有条件</span><span class="w">
</span><span class="w">          </span>- <span class="nt">labelSelector</span><span class="p">:</span><span class="w">
</span><span class="w">              </span><span class="nt">matchExpressions</span><span class="p">:</span><span class="w">
</span><span class="w">              </span>- <span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">app</span><span class="w">
</span><span class="w">                </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="l">In</span><span class="w">
</span><span class="w">                </span><span class="nt">values</span><span class="p">:</span><span class="w">
</span><span class="w">                </span>- <span class="l">my-app</span><span class="w">
</span><span class="w">              </span>- <span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">version</span><span class="w">
</span><span class="w">                </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="l">In</span><span class="w">
</span><span class="w">                </span><span class="nt">values</span><span class="p">:</span><span class="w">
</span><span class="w">                </span>- <span class="l">v3</span><span class="w">
</span><span class="w">            </span><span class="c"># Pod 必须运行在不同的节点上</span><span class="w">
</span><span class="w">            </span><span class="nt">topologyKey</span><span class="p">:</span><span class="w"> </span><span class="l">kubernetes.io/hostname</span><span class="w">
</span><span class="w">      </span><span class="nt">securityContext</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="c"># runAsUser: 1000  # 设定用户</span><span class="w">
</span><span class="w">        </span><span class="c"># runAsGroup: 1000  # 设定用户组</span><span class="w">
</span><span class="w">        </span><span class="nt">runAsNonRoot</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">  </span><span class="c"># Pod 必须以非 root 用户运行</span><span class="w">
</span><span class="w">        </span><span class="nt">seccompProfile</span><span class="p">:</span><span class="w">  </span><span class="c"># security compute mode</span><span class="w">
</span><span class="w">          </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">RuntimeDefault</span><span class="w">
</span><span class="w">      </span><span class="nt">nodeSelector</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">eks.amazonaws.com/nodegroup</span><span class="p">:</span><span class="w"> </span><span class="l">common </span><span class="w"> </span><span class="c"># 使用专用节点组，如果希望使用多个节点组，可改用节点亲和性</span><span class="w">
</span><span class="w">      </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">tmp-dir</span><span class="w">
</span><span class="w">        </span><span class="nt">emptyDir</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">my-app-v3</span><span class="w">
</span><span class="w">        </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">my-app:v3 </span><span class="w"> </span><span class="c"># 建议使用私有镜像仓库，规避 docker.io 的镜像拉取限制</span><span class="w">
</span><span class="w">        </span><span class="nt">imagePullPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">IfNotPresent</span><span class="w">
</span><span class="w">        </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span><span class="w">        </span>- <span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="l">/tmp</span><span class="w">
</span><span class="w">          </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">tmp-dir</span><span class="w">
</span><span class="w">        </span><span class="nt">lifecycle</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">preStop</span><span class="p">:</span><span class="w">
</span><span class="w">            </span><span class="nt">exec</span><span class="p">:</span><span class="w">
</span><span class="w">              </span><span class="nt">command</span><span class="p">:</span><span class="w">
</span><span class="w">              </span>- <span class="l">/bin/sh</span><span class="w">
</span><span class="w">              </span>- -<span class="l">c</span><span class="w">
</span><span class="w">              </span>- <span class="s2">&#34;while [ $(netstat -plunt | grep tcp | wc -l | xargs) -ne 0 ]; do sleep 1; done&#34;</span><span class="w">
</span><span class="w">        </span><span class="nt">resources</span><span class="p">:</span><span class="w">  </span><span class="c"># 资源请求与限制</span><span class="w">
</span><span class="w">          </span><span class="c"># 对于核心服务，建议设置 requests = limits，避免资源竞争</span><span class="w">
</span><span class="w">          </span><span class="nt">requests</span><span class="p">:</span><span class="w">
</span><span class="w">            </span><span class="c"># HPA 会使用 requests 计算资源利用率</span><span class="w">
</span><span class="w">            </span><span class="c"># 建议将 requests 设为服务正常状态下的 CPU 使用率，HPA 的目前指标设为 80%</span><span class="w">
</span><span class="w">            </span><span class="c"># 所有容器的 requests 总量不建议为 2c/4G 4c/8G 等常见值，因为节点通常也是这个配置，这会导致 Pod 只能调度到更大的节点上，适当调小 requests 等扩充可用的节点类型，从而扩充节点池。 </span><span class="w">
</span><span class="w">            </span><span class="nt">cpu</span><span class="p">:</span><span class="w"> </span><span class="l">1000m</span><span class="w">
</span><span class="w">            </span><span class="nt">memory</span><span class="p">:</span><span class="w"> </span><span class="l">1Gi</span><span class="w">
</span><span class="w">          </span><span class="nt">limits</span><span class="p">:</span><span class="w">
</span><span class="w">            </span><span class="c"># limits - requests 为允许超卖的资源量，建议为 requests 的 1 到 2 倍，酌情配置。</span><span class="w">
</span><span class="w">            </span><span class="nt">cpu</span><span class="p">:</span><span class="w"> </span><span class="l">1000m</span><span class="w">
</span><span class="w">            </span><span class="nt">memory</span><span class="p">:</span><span class="w"> </span><span class="l">1Gi</span><span class="w">
</span><span class="w">        </span><span class="nt">securityContext</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="c"># 将容器层设为只读，防止容器文件被篡改</span><span class="w">
</span><span class="w">          </span><span class="c">## 如果需要写入临时文件，建议额外挂载 emptyDir 来提供可读写的数据卷</span><span class="w">
</span><span class="w">          </span><span class="nt">readOnlyRootFilesystem</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="w">          </span><span class="c"># 禁止 Pod 做任何权限提升</span><span class="w">
</span><span class="w">          </span><span class="nt">allowPrivilegeEscalation</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span><span class="w">          </span><span class="nt">capabilities</span><span class="p">:</span><span class="w">
</span><span class="w">            </span><span class="c"># drop ALL 的权限比较严格，可按需修改</span><span class="w">
</span><span class="w">            </span><span class="nt">drop</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="l">ALL</span><span class="w">
</span><span class="w">        </span><span class="nt">startupProbe</span><span class="p">:</span><span class="w">  </span><span class="c"># 要求 kubernetes 1.18+</span><span class="w">
</span><span class="w">          </span><span class="nt">httpGet</span><span class="p">:</span><span class="w">
</span><span class="w">            </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/actuator/health </span><span class="w"> </span><span class="c"># 直接使用健康检查接口即可</span><span class="w">
</span><span class="w">            </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span><span class="w">          </span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="w">          </span><span class="nt">timeoutSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w">          </span><span class="nt">failureThreshold</span><span class="p">:</span><span class="w"> </span><span class="m">20</span><span class="w">  </span><span class="c"># 最多提供给服务 5s * 20 的启动时间</span><span class="w">
</span><span class="w">          </span><span class="nt">successThreshold</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w">        </span><span class="nt">livenessProbe</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">httpGet</span><span class="p">:</span><span class="w">
</span><span class="w">            </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/actuator/health </span><span class="w"> </span><span class="c"># spring 的通用健康检查路径</span><span class="w">
</span><span class="w">            </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span><span class="w">          </span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="w">          </span><span class="nt">timeoutSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w">          </span><span class="nt">failureThreshold</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="w">          </span><span class="nt">successThreshold</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w">        </span><span class="c"># Readiness probes are very important for a RollingUpdate to work properly,</span><span class="w">
</span><span class="w">        </span><span class="nt">readinessProbe</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">httpGet</span><span class="p">:</span><span class="w">
</span><span class="w">            </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/actuator/health </span><span class="w"> </span><span class="c"># 简单起见可直接使用 livenessProbe 相同的接口，当然也可额外定义</span><span class="w">
</span><span class="w">            </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span><span class="w">          </span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="w">          </span><span class="nt">timeoutSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w">          </span><span class="nt">failureThreshold</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="w">          </span><span class="nt">successThreshold</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w"></span><span class="nn">---</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">autoscaling/v2beta2</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">HorizontalPodAutoscaler</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">my-app</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">my-app-v3</span><span class="w">
</span><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">prod</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">scaleTargetRef</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span><span class="w">    </span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Deployment</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">my-app-v3</span><span class="w">
</span><span class="w">  </span><span class="nt">maxReplicas</span><span class="p">:</span><span class="w"> </span><span class="m">50</span><span class="w">
</span><span class="w">  </span><span class="nt">minReplicas</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span><span class="w">  </span><span class="nt">metrics</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">Resource</span><span class="w">
</span><span class="w">    </span><span class="nt">resource</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">cpu</span><span class="w">
</span><span class="w">      </span><span class="nt">target</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">Utilization</span><span class="w">
</span><span class="w">        </span><span class="nt">averageUtilization</span><span class="p">:</span><span class="w"> </span><span class="m">70</span><span class="w">
</span><span class="w"></span><span class="nn">---</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">policy/v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">PodDisruptionBudget</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">my-app-v3</span><span class="w">
</span><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">prod</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">my-app</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">minAvailable</span><span class="p">:</span><span class="w"> </span><span class="m">75</span><span class="l">%</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">my-app</span><span class="w">
</span><span class="w">      </span><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="l">v3</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="一优雅停止gracful-shutdown与-502504-报错">一、优雅停止（Gracful Shutdown）与 502/504 报错</h2>
<p>如果 Pod 正在处理大量请求（比如 1000 QPS+）时，因为节点故障或「竞价节点」被回收等原因被重新调度，
你可能会观察到在容器被 terminate 的一段时间内出现少量 502/504。</p>
<p>为了搞清楚这个问题，需要先理解清楚 terminate 一个 Pod 的流程：</p>
<ol>
<li>Pod 的状态被设为「Terminating」，（几乎）同时该 Pod 被从所有关联的 Service Endpoints 中移除</li>
<li><code>preStop</code> 钩子被执行，它可以是一个命令，或者一个对 Pod 中容器的 http 调用
<ol>
<li>如果你的程序在收到 SIGTERM 信号时，无法优雅退出，就可以考虑使用 <code>preStop</code></li>
<li>如果让程序本身支持优雅退出比较麻烦的话，用 <code>preStop</code> 实现优雅退出是一个非常好的方式</li>
</ol>
</li>
<li>将 SIGTERM 发送给 Pod 中的所有容器</li>
<li>继续等待，直到超过 <code>spec.terminationGracePeriodSeconds</code> 设定好的时间，这个值默认为 30s
<ol>
<li>需要注意的是，这个优雅退出的等待计时是与 <code>preStop</code> 同步开始的！而且它也不会等待 <code>preStop</code> 结束！</li>
</ol>
</li>
<li>如果超过了 <code>spec.terminationGracePeriodSeconds</code> 容器仍然没有停止，k8s 将会发送 SIGKILL 信号给容器</li>
<li>进程全部终止后，整个 Pod 完全被清理掉</li>
</ol>
<p><strong>注意</strong>：1 和 2 两个工作是异步发生的，所以可能会出现「Pod 还在 Service Endpoints 中，但是 <code>preStop</code> 已经执行了」的情况，我们需要考虑到这种状况的发生。</p>
<p>了解了上面的流程后，我们就能分析出两种错误码出现的原因：</p>
<ul>
<li>502：应用程序在收到 SIGTERM 信号后直接终止了运行，导致部分还没有被处理完的请求直接中断，代理层返回 502 表示这种情况</li>
<li>504：Service Endpoints 移除不够及时，在 Pod 已经被终止后，仍然有个别请求被路由到了该 Pod，得不到响应导致 504</li>
</ul>
<p>通常的解决方案是，在 Pod 的 <code>preStop</code> 步骤加一个 15s 的等待时间。
其原理是：在 Pod 处理 terminating 状态的时候，就会被从 Service Endpoints 中移除，也就不会再有新的请求过来了。
在 <code>preStop</code> 等待 15s，基本就能保证所有的请求都在容器死掉之前被处理完成（一般来说，绝大部分请求的处理时间都在 300ms 以内吧）。</p>
<p>一个简单的示例如下，它使 Pod 被终止时，总是先等待 15s，再发送 SIGTERM 信号给容器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="w">    </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">my-app</span><span class="w">
</span><span class="w">      </span><span class="c"># 添加下面这部分</span><span class="w">
</span><span class="w">      </span><span class="nt">lifecycle</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">preStop</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">exec</span><span class="p">:</span><span class="w">
</span><span class="w">            </span><span class="nt">command</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="l">/bin/sleep</span><span class="w">
</span><span class="w">            </span>- <span class="s2">&#34;15&#34;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>更好的解决办法，是直接等待所有 tcp 连接都关闭（需要镜像中有 netstat）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="w">    </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">my-app</span><span class="w">
</span><span class="w">      </span><span class="c"># 添加下面这部分</span><span class="w">
</span><span class="w">      </span><span class="nt">lifecycle</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">preStop</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">exec</span><span class="p">:</span><span class="w">
</span><span class="w">            </span><span class="nt">command</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="l">/bin/sh</span><span class="w">
</span><span class="w">            </span>- -<span class="l">c</span><span class="w">
</span><span class="w">            </span>- <span class="s2">&#34;while [ $(netstat -plunt | grep tcp | wc -l | xargs) -ne 0 ]; do sleep 1; done&#34;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="k8s-istio-pod-prestop">如果我的服务还使用了 Sidecar 代理网络请求，该怎么处理？</h3>
<p>以服务网格 Istio 为例，在 Envoy 代理了 Pod 流量的情况下，502/504 的问题会变得更复杂一点——还需要考虑 Sidecar 与主容器的关闭顺序：</p>
<ul>
<li>如果在 Envoy 已关闭后，有新的请求再进来，将会导致 504（没人响应这个请求了）
<ul>
<li>所以 Envoy 最好在 Terminating 至少 3s 后才能关，确保 Istio 网格配置已完全更新</li>
</ul>
</li>
<li>如果在 Envoy 还没停止时，主容器先关闭，然后又有新的请求再进来，Envoy 将因为无法连接到 upstream 导致 503
<ul>
<li>所以主容器也最好在 Terminating 至少 3s 后，才能关闭。</li>
</ul>
</li>
<li>如果主容器处理还未处理完遗留请求时，Envoy 或者主容器的其中一个停止了，会因为 tcp 连接直接断开连接导致 502
<ul>
<li>因此 Envoy 必须在主容器处理完遗留请求后（即没有 tcp 连接时），才能关闭</li>
</ul>
</li>
</ul>
<p>所以总结下：Envoy 及主容器的 <code>preStop</code> 都至少得设成 3s，并且在「没有 tcp 连接」时，才能关闭，避免出现 502/503/504.</p>
<p>主容器的修改方法在前文中已经写过了，下面介绍下 Envoy 的修改方法。</p>
<p>和主容器一样，Envoy 也能直接加 <code>preStop</code>，修改 <code>istio-sidecar-injector</code> 这个 <code>configmap</code>，在 sidecar 里添加 preStop sleep 命令:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="w">    </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">istio-proxy</span><span class="w">
</span><span class="w">      </span><span class="c"># 添加下面这部分</span><span class="w">
</span><span class="w">      </span><span class="nt">lifecycle</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">preStop</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">exec</span><span class="p">:</span><span class="w">
</span><span class="w">            </span><span class="nt">command</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="l">/bin/sh</span><span class="w">
</span><span class="w">            </span>- -<span class="l">c</span><span class="w">
</span><span class="w">            </span>- <span class="s2">&#34;while [ $(netstat -plunt | grep tcp | grep -v envoy | wc -l | xargs) -ne 0 ]; do sleep 1; done&#34;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="参考">参考</h3>
<ul>
<li><a href="https://cloud.google.com/blog/products/containers-kubernetes/kubernetes-best-practices-terminating-with-grace" target="_blank" rel="noopener noreferrer">Kubernetes best practices: terminating with grace</a></li>
<li><a href="https://medium.com/flant-com/kubernetes-graceful-shutdown-nginx-php-fpm-d5ab266963c2" target="_blank" rel="noopener noreferrer">Graceful shutdown in Kubernetes is not always trivial</a></li>
</ul>
<h2 id="k8s-hpa">二、服务的伸缩配置 - HPA</h2>
<p>Kubernetes 官方主要支持基于 Pod CPU 的伸缩，这是应用最为广泛的伸缩指标，需要部署 <a href="https://github.com/kubernetes-sigs/metrics-server" target="_blank" rel="noopener noreferrer">metrics-server</a> 才可使用。</p>
<p>先回顾下前面给出的，基于 Pod CPU 使用率进行伸缩的示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">autoscaling/v2beta2 </span><span class="w"> </span><span class="c"># k8s 1.23+ 此 API 已经 GA</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">HorizontalPodAutoscaler</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">my-app</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">my-app-v3</span><span class="w">
</span><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">prod</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">scaleTargetRef</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span><span class="w">    </span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Deployment</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">my-app-v3</span><span class="w">
</span><span class="w">  </span><span class="nt">maxReplicas</span><span class="p">:</span><span class="w"> </span><span class="m">50</span><span class="w">
</span><span class="w">  </span><span class="nt">minReplicas</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span><span class="w">  </span><span class="nt">metrics</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">Resource</span><span class="w">
</span><span class="w">    </span><span class="nt">resource</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">cpu</span><span class="w">
</span><span class="w">      </span><span class="nt">target</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">Utilization</span><span class="w">
</span><span class="w">        </span><span class="nt">averageUtilization</span><span class="p">:</span><span class="w"> </span><span class="m">70</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="1-当前指标值的计算方式">1. 当前指标值的计算方式</h3>
<p>提前总结：每个 <strong>Pod 的指标是其中所有容器指标之和</strong>，如果计算百分比，就再除以 Pod 的 requests.</p>
<p>HPA 默认使用 Pod 的当前指标进行计算，以 CPU 使用率为例，其计算公式为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">「Pod 的 CPU 使用率」= 100% * 「所有 Container 的 CPU 用量之和」/「所有 Container 的 CPU requests 之和」
</code></pre></td></tr></table>
</div>
</div><p>注意分母是总的 requests 量，而不是 limits.</p>
<h4 id="11-存在的问题与解决方法">1.1 存在的问题与解决方法</h4>
<p>在 Pod 只有一个容器时这没啥问题，但是当 Pod 注入了 envoy 等 sidecar 时，这就会有问题了。</p>
<p>因为 Istio 的 Sidecar requests 默认为 <code>100m</code> 也就是 0.1 核。
在未 tuning 的情况下，服务负载一高，sidecar 的实际用量很容易就能涨到 0.2-0.4 核。
把这两个值代入前面的公式，会发现 <strong>对于 QPS 较高的服务，添加 Sidecar 后，「Pod 的 CPU 利用率」可能会高于「应用容器的 CPU 利用率」</strong>，造成不必要的扩容。</p>
<p>即使改用「Pod 的 CPU 用量」而非百分比来进行扩缩容，也解决不了这个问题。</p>
<p>解决方法：</p>
<ul>
<li>方法一：针对每个服务的 CPU 使用情况，为每个服务的 sidecar 设置不同的 requests/limits.
<ul>
<li>感觉这个方案太麻烦了</li>
</ul>
</li>
<li>方法二：使用 KEDA 等第三方组件，获取到应用程序的 CPU 利用率（排除掉 Sidecar），使用它进行扩缩容</li>
<li>方法三：使用 k8s 1.20 提供的 alpha 特性：<a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#container-resource-metrics" target="_blank" rel="noopener noreferrer">Container Resourse Metrics</a>.</li>
</ul>
<h3 id="2-hpa-的扩缩容算法">2. HPA 的扩缩容算法</h3>
<p>HPA 什么时候会扩容，这一点是很好理解的。但是 HPA 的缩容策略，会有些迷惑，下面简单分析下。</p>
<ol>
<li>HPA 的「目标指标」可以使用两种形式：绝对度量指标和资源利用率。
<ul>
<li>绝对度量指标：比如 CPU，就是指 CPU 的使用量</li>
<li>资源利用率（资源使用量/资源请求 * 100%）：在 Pod 设置了资源请求时，可以使用资源利用率进行 Pod 伸缩</li>
</ul>
</li>
<li>HPA 的「当前指标」是一段时间内所有 Pods 的平均值，不是峰值。</li>
</ol>
<p>HPA 的扩缩容算法为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">期望副本数 = ceil[当前副本数 * ( 当前指标 / 目标指标 )]
</code></pre></td></tr></table>
</div>
</div><p>从上面的参数可以看到：</p>
<ol>
<li>只要「当前指标」超过了目标指标，就一定会发生扩容。</li>
<li><code>当前指标 / 目标指标</code>要小到一定的程度，才会触发缩容。
<ol>
<li>比如双副本的情况下，上述比值要小于等于 1/2，才会缩容到单副本。</li>
<li>三副本的情况下，上述比值的临界点是 2/3。</li>
<li>五副本时临界值是 4/5，100副本时临界值是 99/100，依此类推。</li>
<li>如果 <code>当前指标 / 目标指标</code> 从 1 降到 0.5，副本的数量将会减半。（虽然说副本数越多，发生这么大变化的可能性就越小。）</li>
</ol>
</li>
<li><code>当前副本数 / 目标指标</code>的值越大，「当前指标」的波动对「期望副本数」的影响就越大。</li>
</ol>
<p>为了防止扩缩容过于敏感，HPA 有几个相关参数：</p>
<ol>
<li>Hardcoded 参数
<ol>
<li>HPA Loop 延时：默认 15 秒，每 15 秒钟进行一次 HPA 扫描。</li>
<li>缩容冷却时间：默认 5 分钟。</li>
</ol>
</li>
<li>对于 K8s 1.18+，HPA 通过 <code>spec.behavior</code> 提供了多种控制扩缩容行为的参数，后面会具体介绍。</li>
</ol>
<h3 id="3-hpa-的期望值设成多少合适">3. HPA 的期望值设成多少合适</h3>
<p>这个需要针对每个服务的具体情况，具体分析。</p>
<p>以最常用的按 CPU 值伸缩为例，</p>
<ul>
<li>核心服务
<ul>
<li>requests/limits 值: 建议设成相等的，保证<a href="https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/" target="_blank" rel="noopener noreferrer">服务质量等级</a>为 Guaranteed
<ul>
<li>需要注意 CPU 跟 Memory 的 limits 限制策略是不同的，CPU 是真正地限制了上限，而 Memory 是用超了就干掉容器（OOMKilled）</li>
<li>k8s 一直使用 cgroups v1 (<code>cpu_shares</code>/<code>memory.limit_in_bytes</code>)来限制 cpu/memory，但是对于 <code>Guaranteed</code> 的 Pods 而言，内存并不能完全预留，资源竞争总是有可能发生的。1.22 有 alpha 特性改用 cgroups v2，可以关注下。</li>
</ul>
</li>
<li>HPA: 一般来说，期望值设为 60% 到 70% 可能是比较合适的，最小副本数建议设为 2 - 5. （仅供参考）</li>
<li>PodDisruptionBudget: 建议按服务的健壮性与 HPA 期望值，来设置 PDB，后面会详细介绍，这里就先略过了</li>
</ul>
</li>
<li>非核心服务
<ul>
<li>requests/limits 值: 建议 requests 设为 limits 的 0.6 - 0.9 倍（仅供参考），对应的服务质量等级为 Burstable
<ul>
<li>也就是超卖了资源，这样做主要的考量点是，很多非核心服务负载都很低，根本跑不到 limits 这么高，降低 requests 可以提高集群资源利用率，也不会损害服务稳定性。</li>
</ul>
</li>
<li>HPA: 因为 requests 降低了，而 HPA 是以 requests 为 100% 计算使用率的，我们可以提高 HPA 的期望值（如果使用百分比为期望值的话），比如 80% ~ 90%，最小副本数建议设为 1 - 3. （仅供参考）</li>
<li>PodDisruptionBudget: 非核心服务嘛，保证最少副本数为 1 就行了。</li>
</ul>
</li>
</ul>
<h3 id="4-hpa-的常见问题">4. HPA 的常见问题</h3>
<h4 id="41-pod-扩容---预热陷阱">4.1. Pod 扩容 - 预热陷阱</h4>
<blockquote>
<p>预热：Java/C# 这类运行在虚拟机上的语言，第一次使用到某些功能时，往往需要初始化一些资源，例如「JIT 即时编译」。
如果代码里还应用了动态类加载之类的功能，就很可能导致微服务某些 API 第一次被调用时，响应特别慢（要动态编译 class）。
因此 Pod 在提供服务前，需要提前「预热（slow_start）」一次这些接口，将需要用到的资源提前初始化好。</p>
</blockquote>
<p>在负载很高的情况下，HPA 会自动扩容。
但是如果扩容的 Pod 需要预热，就可能会遇到「预热陷阱」。</p>
<p>在有大量用户访问的时候，不论使用何种负载均衡策略，只要请求被转发到新建的 Pod 上，这个请求就会「卡住」。
如果请求速度太快，Pod 启动的瞬间「卡住」的请求就越多，这将会导致新建 Pod 因为压力过大而垮掉。
然后 Pod 一重启就被压垮，进入 CrashLoopBackoff 循环。</p>
<p>如果是在使用多线程做负载测试时，效果更明显：50 个线程在不间断地请求，
别的 Pod 响应时间是「毫秒级」，而新建的 Pod 的首次响应是「秒级」。几乎是一瞬间，50 个线程就会全部陷在新建的 Pod 这里。
而新建的 Pod 在启动的瞬间可能特别脆弱，瞬间的 50 个并发请求就可以将它压垮。
然后 Pod 一重启就被压垮，进入 CrashLoopBackoff 循环。</p>
<p><strong>解决方法</strong>：</p>
<p>可以在「应用层面」解决：</p>
<ol>
<li>在启动探针 API 的后端控制器里面，依次调用所有需要预热的接口或者其他方式，提前初始化好所有资源。
<ol>
<li>启动探针的控制器中，可以通过 <code>localhost</code> 回环地址调用它自身的接口。</li>
</ol>
</li>
<li>使用「AOT 预编译」技术：预热，通常都是因为「JIT 即时编译」导致的问题，在需要用到时它才编译。而 AOT 是预先编译，在使用前完成编译，因此 AOT 能解决预热的问题。</li>
</ol>
<p>也可以在「基础设施层面」解决：</p>
<ol>
<li>像 AWS ALB TargetGroup 以及其他云服务商的 ALB 服务，通常都可以设置 <code>slow_start</code> 时长，即对新加入的实例，使用一定时间慢慢地把流量切过去，最终达到预期的负载均衡状态。这个可以解决服务预热问题。</li>
<li>Envoy 也已经支持 <code>slow_start</code> 模式，支持在一个设置好的时间窗口内，把流量慢慢负载到新加入的实例上，达成预热效果。</li>
</ol>
<h4 id="42-hpa-扩缩容过于敏感导致-pod-数量震荡">4.2. HPA 扩缩容过于敏感，导致 Pod 数量震荡</h4>
<p>通常来讲，EKS 上绝大部分负载都应该选择使用 CPU 进行扩缩容。因为 CPU 通常能很好的反映服务的负载情况</p>
<p>但是有些服务会存在其他影响 CPU 使用率的因素，导致使用 CPU 扩缩容变得不那么可靠，比如：</p>
<ul>
<li>有些 Java 服务堆内存设得很大，GC pause 也设得比较长，因此内存 GC 会造成 CPU 间歇性飙升，CPU 监控会有大量的尖峰。</li>
<li>有些服务有定时任务，定时任务一运行 CPU 就涨，但是这跟服务的 QPS 是无关的</li>
<li>有些服务可能一运行 CPU 就会立即处于一个高位状态，它可能希望使用别的业务侧指标来进行扩容，而不是 CPU.</li>
</ul>
<p>因为上述问题存在，使用 CPU 扩缩容，就可能会造成服务频繁的扩容然后缩容，或者无限扩容。
而有些服务（如我们的「推荐服务」），对「扩容」和「缩容」都是比较敏感的，每次扩缩都会造成服务可用率抖动。</p>
<p>对这类服务而言，HPA 有这几种调整策略：</p>
<ul>
<li>选择使用 <strong>QPS</strong> 等相对比较平滑，没有 GC 这类干扰的指标来进行扩缩容，这需要借助 KEDA 等社区组件。</li>
<li>对 kubernetes 1.18+，可以直接使用 HPA 的 <code>behavior.scaleDown</code> 和 <code>behavior.scaleUp</code> 两个参数，控制每次扩缩容的最多 pod 数量或者比例。 示例如下：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nn">---</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">autoscaling/v2beta2</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">HorizontalPodAutoscaler</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">podinfo</span><span class="w">
</span><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">scaleTargetRef</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span><span class="w">    </span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Deployment</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">podinfo</span><span class="w">
</span><span class="w">  </span><span class="nt">minReplicas</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span><span class="w">  </span><span class="nt">maxReplicas</span><span class="p">:</span><span class="w"> </span><span class="m">50</span><span class="w">
</span><span class="w">  </span><span class="nt">metrics</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">Resource</span><span class="w">
</span><span class="w">    </span><span class="nt">resource</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">cpu</span><span class="w">
</span><span class="w">      </span><span class="nt">target</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">Utilization</span><span class="w">
</span><span class="w">        </span><span class="nt">averageUtilization</span><span class="p">:</span><span class="w"> </span><span class="m">50</span><span class="w">  </span><span class="c"># 期望的 CPU 平均值</span><span class="w">
</span><span class="w">  </span><span class="nt">behavior</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">scaleUp</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">stabilizationWindowSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">0</span><span class="w">  </span><span class="c"># 默认为 0，只使用当前值进行扩缩容</span><span class="w">
</span><span class="w">      </span><span class="nt">policies</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">180</span><span class="w">  </span><span class="c"># 每 3 分钟最多扩容 5% 的 Pods</span><span class="w">
</span><span class="w">        </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">Percent</span><span class="w">
</span><span class="w">        </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="w">      </span>- <span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">60</span><span class="w">  </span><span class="c"># 每分钟最多扩容 1 个 Pod，扩的慢一点主要是为了一个个地预热，避免一次扩容太多未预热的 Pods 导致服务可用率剧烈抖动</span><span class="w">
</span><span class="w">        </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">Pods</span><span class="w">
</span><span class="w">        </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w">      </span><span class="nt">selectPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">Min </span><span class="w"> </span><span class="c"># 选择最小的策略</span><span class="w">
</span><span class="w">    </span><span class="c"># 以下的一切配置，都是为了更平滑地缩容</span><span class="w">
</span><span class="w">    </span><span class="nt">scaleDown</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">stabilizationWindowSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">600</span><span class="w">  </span><span class="c"># 使用过去 10 mins 的最大 cpu 值进行缩容计算，避免过快缩容</span><span class="w">
</span><span class="w">      </span><span class="nt">policies</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">Percent </span><span class="w"> </span><span class="c"># 每 3 mins 最多缩容 `ceil[当前副本数 * 5%]` 个 pod（20 个 pod 以内，一次只缩容 1 个 pod）</span><span class="w">
</span><span class="w">        </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="w">        </span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">180</span><span class="w">
</span><span class="w">      </span>- <span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">Pods </span><span class="w"> </span><span class="c"># 每 1 mins 最多缩容 1 个 pod</span><span class="w">
</span><span class="w">        </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w">        </span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">60</span><span class="w">
</span><span class="w">      </span><span class="nt">selectPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">Min </span><span class="w"> </span><span class="c"># 上面的 policies 列表，只生效其中最小的值作为缩容限制（保证平滑缩容）</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>而对于扩容不够平滑这个问题，可以考虑提供类似 AWS ALB TargetGroup <code>slow_start</code> 的功能，在扩容时缓慢将流量切到新 Pod 上，以实现预热服务（JVM 预热以及本地缓存预热），这样就能达到比较好的平滑扩容效果。</p>
<h3 id="5-hpa-注意事项">5. HPA 注意事项</h3>
<p>注意 kubectl 1.23 以下的版本，默认使用 <code>hpa.v1.autoscaling</code> 来查询 HPA 配置，<code>v2beta2</code> 相关的参数会被编码到 <code>metadata.annotations</code> 中。</p>
<p>比如 <code>behavior</code> 就会被编码到 <code>autoscaling.alpha.kubernetes.io/behavior</code> 这个 key 所对应的值中。</p>
<p>因此如果使用了 v2beta2 的 HPA，一定要明确指定使用 <code>v2beta2</code> 版本的 HPA：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">kubectl get hpa.v2beta2.autoscaling
</code></pre></td></tr></table>
</div>
</div><p>否则不小心动到 <code>annotations</code> 中编码的某些参数，可能会产生意料之外的效果，甚至直接把控制面搞崩&hellip;
比如这个 issue: <a href="https://github.com/kubernetes/kubernetes/issues/107038" target="_blank" rel="noopener noreferrer">Nil pointer dereference in KCM after v1 HPA patch request</a></p>
<h3 id="6-参考">6. 参考</h3>
<ul>
<li><a href="https://kubernetes.io/zh/docs/tasks/run-application/horizontal-pod-autoscale/" target="_blank" rel="noopener noreferrer">Pod 水平自动伸缩 - Kubernetes Docs</a></li>
<li><a href="https://kubernetes.io/zh/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/" target="_blank" rel="noopener noreferrer">Horizontal Pod Autoscaler演练 - Kubernetes Docs</a></li>
</ul>
<h2 id="k8s-PodDistruptionBuget">三、<a href="https://kubernetes.io/zh/docs/tasks/run-application/configure-pdb/" target="_blank" rel="noopener noreferrer">节点维护与Pod干扰预算</a></h2>
<p>在我们通过 <code>kubectl drain</code> 将某个节点上的容器驱逐走的时候，
kubernetes 会依据 Pod 的「PodDistruptionBuget」来进行 Pod 的驱逐。</p>
<p>如果不设置任何明确的 PodDistruptionBuget，Pod 将会被直接杀死，然后在别的节点重新调度，<strong>这可能导致服务中断！</strong></p>
<p>PDB 是一个单独的 CR 自定义资源，示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">policy/v1beta1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">PodDisruptionBudget</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">podinfo-pdb</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="c"># 如果不满足 PDB，Pod 驱逐将会失败！</span><span class="w">
</span><span class="w">  </span><span class="nt">minAvailable</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">      </span><span class="c"># 最少也要维持一个 Pod 可用</span><span class="w">
</span><span class="w"></span><span class="c">#   maxUnavailable: 1  # 最大不可用的 Pod 数，与 minAvailable 不能同时配置！二选一</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">podinfo</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>如果在进行节点维护时(kubectl drain)，Pod 不满足 PDB，drain 将会失败，示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">&gt; kubectl drain node-205 --ignore-daemonsets --delete-local-data
node/node-205 cordoned
WARNING: ignoring DaemonSet-managed Pods: kube-system/calico-node-nfhj7, kube-system/kube-proxy-94dz5
evicting pod default/podinfo-7c84d8c94d-h9brq
evicting pod default/podinfo-7c84d8c94d-gw6qf
error when evicting pod <span class="s2">&#34;podinfo-7c84d8c94d-h9brq&#34;</span> <span class="o">(</span>will retry after 5s<span class="o">)</span>: Cannot evict pod as it would violate the pod<span class="s1">&#39;s disruption budget.
</span><span class="s1">evicting pod default/podinfo-7c84d8c94d-h9brq
</span><span class="s1">error when evicting pod &#34;podinfo-7c84d8c94d-h9brq&#34; (will retry after 5s): Cannot evict pod as it would violate the pod&#39;</span>s disruption budget.
evicting pod default/podinfo-7c84d8c94d-h9brq
error when evicting pod <span class="s2">&#34;podinfo-7c84d8c94d-h9brq&#34;</span> <span class="o">(</span>will retry after 5s<span class="o">)</span>: Cannot evict pod as it would violate the pod<span class="err">&#39;</span>s disruption budget.
evicting pod default/podinfo-7c84d8c94d-h9brq
pod/podinfo-7c84d8c94d-gw6qf evicted
pod/podinfo-7c84d8c94d-h9brq evicted
node/node-205 evicted
</code></pre></td></tr></table>
</div>
</div><p>上面的示例中，podinfo 一共有两个副本，都运行在 node-205 上面。我给它设置了干扰预算 PDB <code>minAvailable: 1</code>。</p>
<p>然后使用 <code>kubectl drain</code> 驱逐 Pod 时，其中一个 Pod 被立即驱逐走了，而另一个 Pod 大概在 15 秒内一直驱逐失败。
因为第一个 Pod 还没有在新的节点上启动完成，它不满足干扰预算 PDB <code>minAvailable: 1</code> 这个条件。</p>
<p>大约 15 秒后，最先被驱逐走的 Pod 在新节点上启动完成了，另一个 Pod 满足了 PDB 所以终于也被驱逐了。这才完成了一个节点的 drain 操作。</p>
<blockquote>
<p>ClusterAutoscaler 等集群节点伸缩组件，在缩容节点时也会考虑 PodDisruptionBudget. 如果你的集群使用了 ClusterAutoscaler 等动态扩缩容节点的组件，强烈建议设置为所有服务设置 PodDisruptionBudget.</p>
</blockquote>
<h4 id="在-pdb-中使用百分比的注意事项">在 PDB 中使用百分比的注意事项</h4>
<p>在使用百分比时，计算出的实例数都会被向上取整，这会造成两个现象：</p>
<ul>
<li>如果使用 <code>minAvailable</code>，实例数较少的情况下，可能会导致 ALLOWED DISRUPTIONS 为 0，所有实例都无法被驱逐了。</li>
<li>如果使用 <code>maxUnavailable</code>，因为是向上取整，ALLOWED DISRUPTIONS 的值一定不会低于 1，至少有 1 个实例可以被驱逐。</li>
</ul>
<p>因此从「便于驱逐」的角度看，如果你的服务至少有 2-3 个实例，建议在 PDB 中使用百分比配置 <code>maxUnavailable</code>，而不是 <code>minAvailable</code>.
相对的从「确保服务稳定性」的角度看，我们则应该使用 <code>minAvailable</code>，确保至少有 1 个实例可用。</p>
<h3 id="最佳实践-deployment--hpa--poddisruptionbudget">最佳实践 Deployment + HPA + PodDisruptionBudget</h3>
<p>一般而言，一个服务的每个版本，都应该包含如下三个资源：</p>
<ul>
<li>Deployment: 管理服务自身的 Pods 嘛</li>
<li>HPA: 负责 Pods 的扩缩容，通常使用 CPU 指标进行扩缩容</li>
<li>PodDisruptionBudget(PDB): 建议按照 HPA 的目标值，来设置 PDB.
<ul>
<li>比如 HPA CPU 目标值为 60%，就可以考虑设置 PDB <code>minAvailable=65%</code>，保证至少有 65% 的 Pod 可用。这样理论上极限情况下 QPS 均摊到剩下 65% 的 Pods 上也不会造成雪崩（这里假设 QPS 和 CPU 是完全的线性关系）</li>
</ul>
</li>
</ul>
<h2 id="k8s-affinity">四、节点亲和性与节点组</h2>
<p>我们一个集群，通常会使用不同的标签为节点组进行分类，比如 kubernetes 自动生成的一些节点标签：</p>
<ul>
<li><code>kubernetes.io/os</code>: 通常都用 <code>linux</code></li>
<li><code>kubernetes.io/arch</code>: <code>amd64</code>, <code>arm64</code></li>
<li><code>topology.kubernetes.io/region</code> 和 <code>topology.kubernetes.io/zone</code>: 云服务的区域及可用区</li>
</ul>
<p>我们使用得比较多的，是「节点亲和性」以及「Pod 反亲和性」，另外两个策略视情况使用。</p>
<h3 id="1-节点亲和性">1. 节点亲和性</h3>
<p>如果你使用的是 aws，那 aws 有一些自定义的节点标签：</p>
<ul>
<li><code>eks.amazonaws.com/nodegroup</code>: aws eks 节点组的名称，同一个节点组使用同样的 aws ec2 实例模板
<ul>
<li>比如 arm64 节点组、amd64/x64 节点组</li>
<li>内存比例高的节点组如 m 系实例，计算性能高的节点组如 c 系列</li>
<li>竞价实例节点组：这个省钱啊，但是动态性很高，随时可能被回收</li>
<li>按量付费节点组：这类实例贵，但是稳定。</li>
</ul>
</li>
</ul>
<p>假设你希望优先选择竞价实例跑你的 Pod，如果竞价实例暂时跑满了，就选择按量付费实例。
那 <code>nodeSelector</code> 就满足不了你的需求了，你需要使用 <code>nodeAffinity</code>，示例如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Deployment</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">xxx</span><span class="w">
</span><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">xxx</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="c"># ...</span><span class="w">
</span><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="c"># ...</span><span class="w">
</span><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">affinity</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">nodeAffinity</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="c"># 优先选择 spot-group-c 的节点</span><span class="w">
</span><span class="w">          </span><span class="nt">preferredDuringSchedulingIgnoredDuringExecution</span><span class="p">:</span><span class="w">
</span><span class="w">          </span>- <span class="nt">preference</span><span class="p">:</span><span class="w">
</span><span class="w">              </span><span class="nt">matchExpressions</span><span class="p">:</span><span class="w">
</span><span class="w">              </span>- <span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">eks.amazonaws.com/nodegroup</span><span class="w">
</span><span class="w">                </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="l">In</span><span class="w">
</span><span class="w">                </span><span class="nt">values</span><span class="p">:</span><span class="w">
</span><span class="w">                </span>- <span class="l">spot-group-c</span><span class="w">
</span><span class="w">            </span><span class="nt">weight</span><span class="p">:</span><span class="w"> </span><span class="m">80</span><span class="w">  </span><span class="c"># weight 用于为节点评分，会优先选择评分最高的节点</span><span class="w">
</span><span class="w">          </span>- <span class="nt">preference</span><span class="p">:</span><span class="w">
</span><span class="w">              </span><span class="nt">matchExpressions</span><span class="p">:</span><span class="w">
</span><span class="w">              </span><span class="c"># 优先选择 aws c6i 的机器</span><span class="w">
</span><span class="w">              </span>- <span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">node.kubernetes.io/instance-type</span><span class="w">
</span><span class="w">                </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="l">In</span><span class="w">
</span><span class="w">                </span><span class="nt">values</span><span class="p">:</span><span class="w">
</span><span class="w">                </span>- <span class="s2">&#34;c6i.xlarge&#34;</span><span class="w">
</span><span class="w">                </span>- <span class="s2">&#34;c6i.2xlarge&#34;</span><span class="w">
</span><span class="w">                </span>- <span class="s2">&#34;c6i.4xlarge&#34;</span><span class="w">
</span><span class="w">                </span>- <span class="s2">&#34;c6i.8xlarge&#34;</span><span class="w">
</span><span class="w">            </span><span class="nt">weight</span><span class="p">:</span><span class="w"> </span><span class="m">70</span><span class="w">
</span><span class="w">          </span>- <span class="nt">preference</span><span class="p">:</span><span class="w">
</span><span class="w">              </span><span class="nt">matchExpressions</span><span class="p">:</span><span class="w">
</span><span class="w">              </span><span class="c"># 其次选择 aws c5 的机器</span><span class="w">
</span><span class="w">              </span>- <span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">node.kubernetes.io/instance-type</span><span class="w">
</span><span class="w">                </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="l">In</span><span class="w">
</span><span class="w">                </span><span class="nt">values</span><span class="p">:</span><span class="w">
</span><span class="w">                </span>- <span class="s2">&#34;c5.xlarge&#34;</span><span class="w">
</span><span class="w">                </span>- <span class="s2">&#34;c5.2xlarge&#34;</span><span class="w">
</span><span class="w">                </span>- <span class="s2">&#34;c5.4xlarge&#34;</span><span class="w">
</span><span class="w">                </span>- <span class="s2">&#34;c5.9xlarge&#34;</span><span class="w">
</span><span class="w">            </span><span class="nt">weight</span><span class="p">:</span><span class="w"> </span><span class="m">60</span><span class="w">
</span><span class="w">         </span><span class="c"># 如果没 spot-group-c 可用，也可选择 ondemand-group-c 的节点跑</span><span class="w">
</span><span class="w">          </span><span class="nt">requiredDuringSchedulingIgnoredDuringExecution</span><span class="p">:</span><span class="w">
</span><span class="w">            </span><span class="nt">nodeSelectorTerms</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="nt">matchExpressions</span><span class="p">:</span><span class="w">
</span><span class="w">              </span>- <span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">eks.amazonaws.com/nodegroup</span><span class="w">
</span><span class="w">                </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="l">In</span><span class="w">
</span><span class="w">                </span><span class="nt">values</span><span class="p">:</span><span class="w">
</span><span class="w">                </span>- <span class="l">spot-group-c</span><span class="w">
</span><span class="w">                </span>- <span class="l">ondemand-group-c</span><span class="w">
</span><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="c"># ...</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="2-pod-反亲和性">2. Pod 反亲和性</h3>
<p>通常建议为每个 Deployment 的 template 配置 Pod 反亲和性，把 Pods 打散在所有节点上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Deployment</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">xxx</span><span class="w">
</span><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">xxx</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="c"># ...</span><span class="w">
</span><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="c"># ...</span><span class="w">
</span><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span><span class="w">      </span><span class="nt">affinity</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">podAntiAffinity</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">preferredDuringSchedulingIgnoredDuringExecution</span><span class="p">:</span><span class="w"> </span><span class="c"># 非强制性条件</span><span class="w">
</span><span class="w">          </span>- <span class="nt">weight</span><span class="p">:</span><span class="w"> </span><span class="m">100</span><span class="w">  </span><span class="c"># weight 用于为节点评分，会优先选择评分最高的节点</span><span class="w">
</span><span class="w">            </span><span class="nt">podAffinityTerm</span><span class="p">:</span><span class="w">
</span><span class="w">              </span><span class="nt">labelSelector</span><span class="p">:</span><span class="w">
</span><span class="w">                </span><span class="nt">matchExpressions</span><span class="p">:</span><span class="w">
</span><span class="w">                </span>- <span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">app</span><span class="w">
</span><span class="w">                  </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="l">In</span><span class="w">
</span><span class="w">                  </span><span class="nt">values</span><span class="p">:</span><span class="w">
</span><span class="w">                  </span>- <span class="l">xxx</span><span class="w">
</span><span class="w">                </span>- <span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">version</span><span class="w">
</span><span class="w">                  </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="l">In</span><span class="w">
</span><span class="w">                  </span><span class="nt">values</span><span class="p">:</span><span class="w">
</span><span class="w">                  </span>- <span class="l">v12</span><span class="w">
</span><span class="w">              </span><span class="c"># 将 pod 尽量打散在多个可用区</span><span class="w">
</span><span class="w">              </span><span class="nt">topologyKey</span><span class="p">:</span><span class="w"> </span><span class="l">topology.kubernetes.io/zone</span><span class="w">
</span><span class="w">          </span><span class="nt">requiredDuringSchedulingIgnoredDuringExecution</span><span class="p">:</span><span class="w">  </span><span class="c"># 强制性要求</span><span class="w">
</span><span class="w">          </span><span class="c"># 注意这个没有 weights，必须满足列表中的所有条件</span><span class="w">
</span><span class="w">          </span>- <span class="nt">labelSelector</span><span class="p">:</span><span class="w">
</span><span class="w">              </span><span class="nt">matchExpressions</span><span class="p">:</span><span class="w">
</span><span class="w">              </span>- <span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">app</span><span class="w">
</span><span class="w">                </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="l">In</span><span class="w">
</span><span class="w">                </span><span class="nt">values</span><span class="p">:</span><span class="w">
</span><span class="w">                </span>- <span class="l">xxx</span><span class="w">
</span><span class="w">              </span>- <span class="nt">key</span><span class="p">:</span><span class="w"> </span><span class="l">version</span><span class="w">
</span><span class="w">                </span><span class="nt">operator</span><span class="p">:</span><span class="w"> </span><span class="l">In</span><span class="w">
</span><span class="w">                </span><span class="nt">values</span><span class="p">:</span><span class="w">
</span><span class="w">                </span>- <span class="l">v12</span><span class="w">
</span><span class="w">            </span><span class="c"># Pod 必须运行在不同的节点上</span><span class="w">
</span><span class="w">            </span><span class="nt">topologyKey</span><span class="p">:</span><span class="w"> </span><span class="l">kubernetes.io/hostname</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="k8s-container-probe">五、Pod 的就绪探针、存活探针与启动探针</h2>
<p>Pod 提供如下三种探针，均支持使用 Command、HTTP API、TCP Socket 这三种手段来进行服务可用性探测。</p>
<ul>
<li><code>startupProbe</code> 启动探针（Kubernetes v1.18 [beta]）: 此探针通过后，「就绪探针」与「存活探针」才会进行存活性与就绪检查
<ul>
<li>用于对慢启动容器进行存活性检测，避免它们在启动运行之前就被杀掉
<ul>
<li>startupProbe 显然比 livenessProbe 的 initialDelaySeconds 参数更灵活。</li>
<li>同时它也能延迟 readinessProbe 的生效时间，这主要是为了避免无意义的探测。容器都还没 startUp，显然是不可能就绪的。</li>
</ul>
</li>
<li>程序将最多有 <code>failureThreshold * periodSeconds</code> 的时间用于启动，比如设置 <code>failureThreshold=20</code>、<code>periodSeconds=5</code>，程序启动时间最长就为 100s，如果超过 100s 仍然未通过「启动探测」，容器会被杀死。</li>
</ul>
</li>
<li><code>readinessProbe</code> 就绪探针:
<ul>
<li>就绪探针失败次数超过 <code>failureThreshold</code> 限制（默认三次），服务将被暂时从 Service 的 Endpoints 中踢出，直到服务再次满足 <code>successThreshold</code>.</li>
</ul>
</li>
<li><code>livenessProbe</code> 存活探针: 检测服务是否存活，它可以捕捉到死锁等情况，及时杀死这种容器。
<ul>
<li>存活探针失败可能的原因：
<ul>
<li>服务发生死锁，对所有请求均无响应</li>
<li>服务线程全部卡在对外部 redis/mysql 等外部依赖的等待中，导致请求无响应</li>
</ul>
</li>
<li>存活探针失败次数超过 <code>failureThreshold</code> 限制（默认三次），容器将被杀死，随后根据重启策略执行重启。
<ul>
<li><code>kubectl describe pod</code> 会显示重启原因为 <code>State.Last State.Reason = Error, Exit Code=137</code>，同时 Events 中会有 <code>Liveness probe failed: ...</code> 这样的描述。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>上述三类探测器的参数都是通用的，五个时间相关的参数列举如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="c"># 下面的值就是 k8s 的默认值</span><span class="w">
</span><span class="w"></span><span class="nt">initialDelaySeconds</span><span class="p">:</span><span class="w"> </span><span class="m">0</span><span class="w">  </span><span class="c"># 默认没有 delay 时间</span><span class="w">
</span><span class="w"></span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">10</span><span class="w">
</span><span class="w"></span><span class="nt">timeoutSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w"></span><span class="nt">failureThreshold</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span><span class="w"></span><span class="nt">successThreshold</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Deployment</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">my-app-v3</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="c"># ...</span><span class="w">
</span><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="c">#  ...</span><span class="w">
</span><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">my-app-v3</span><span class="w">
</span><span class="w">        </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">xxx.com/app/my-app:v3</span><span class="w">
</span><span class="w">        </span><span class="nt">imagePullPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">IfNotPresent </span><span class="w">
</span><span class="w">        </span><span class="c"># ... 省略若干配置</span><span class="w">
</span><span class="w">        </span><span class="nt">startupProbe</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">httpGet</span><span class="p">:</span><span class="w">
</span><span class="w">            </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/actuator/health </span><span class="w"> </span><span class="c"># 直接使用健康检查接口即可</span><span class="w">
</span><span class="w">            </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span><span class="w">          </span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="w">          </span><span class="nt">timeoutSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w">          </span><span class="nt">failureThreshold</span><span class="p">:</span><span class="w"> </span><span class="m">20</span><span class="w">  </span><span class="c"># 最多提供给服务 5s * 20 的启动时间</span><span class="w">
</span><span class="w">          </span><span class="nt">successThreshold</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w">        </span><span class="nt">livenessProbe</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">httpGet</span><span class="p">:</span><span class="w">
</span><span class="w">            </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/actuator/health </span><span class="w"> </span><span class="c"># spring 的通用健康检查路径</span><span class="w">
</span><span class="w">            </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span><span class="w">          </span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="w">          </span><span class="nt">timeoutSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w">          </span><span class="nt">failureThreshold</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="w">          </span><span class="nt">successThreshold</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w">        </span><span class="c"># Readiness probes are very important for a RollingUpdate to work properly,</span><span class="w">
</span><span class="w">        </span><span class="nt">readinessProbe</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">httpGet</span><span class="p">:</span><span class="w">
</span><span class="w">            </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/actuator/health </span><span class="w"> </span><span class="c"># 简单起见可直接使用 livenessProbe 相同的接口，当然也可额外定义</span><span class="w">
</span><span class="w">            </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span><span class="w">          </span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="w">          </span><span class="nt">timeoutSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w">          </span><span class="nt">failureThreshold</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="w">          </span><span class="nt">successThreshold</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在 Kubernetes 1.18 之前，通用的手段是为「就绪探针」添加较长的 <code>initialDelaySeconds</code> 来实现类似「启动探针」的功能动，避免容器因为启动太慢，存活探针失败导致容器被重启。示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Deployment</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">my-app-v3</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="c"># ...</span><span class="w">
</span><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="c">#  ...</span><span class="w">
</span><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">my-app-v3</span><span class="w">
</span><span class="w">        </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">xxx.com/app/my-app:v3</span><span class="w">
</span><span class="w">        </span><span class="nt">imagePullPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">IfNotPresent </span><span class="w">
</span><span class="w">        </span><span class="c"># ... 省略若干配置</span><span class="w">
</span><span class="w">        </span><span class="nt">livenessProbe</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">httpGet</span><span class="p">:</span><span class="w">
</span><span class="w">            </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/actuator/health </span><span class="w"> </span><span class="c"># spring 的通用健康检查路径</span><span class="w">
</span><span class="w">            </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span><span class="w">          </span><span class="nt">initialDelaySeconds</span><span class="p">:</span><span class="w"> </span><span class="m">120</span><span class="w">  </span><span class="c"># 前两分钟，都假设服务健康，避免 livenessProbe 失败导致服务重启</span><span class="w">
</span><span class="w">          </span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="w">          </span><span class="nt">timeoutSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w">          </span><span class="nt">failureThreshold</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="w">          </span><span class="nt">successThreshold</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w">        </span><span class="c"># 容器一启动，Readiness probes 就会不断进行检测</span><span class="w">
</span><span class="w">        </span><span class="nt">readinessProbe</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">httpGet</span><span class="p">:</span><span class="w">
</span><span class="w">            </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/actuator/health</span><span class="w">
</span><span class="w">            </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span><span class="w">          </span><span class="nt">initialDelaySeconds</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">  </span><span class="c"># readiness probe 不需要设太长时间，使 Pod 尽快加入到 Endpoints.</span><span class="w">
</span><span class="w">          </span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="w">          </span><span class="nt">timeoutSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w">          </span><span class="nt">failureThreshold</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="w">          </span><span class="nt">successThreshold</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h2 id="k8s-pod-security">六、Pod 安全</h2>
<p>这里只介绍 Pod 中安全相关的参数，其他诸如集群全局的安全策略，不在这里讨论。</p>
<h3 id="1-pod-securitycontexthttpskubernetesiodocstasksconfigure-pod-containersecurity-context">1. <a href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/" target="_blank" rel="noopener noreferrer">Pod SecurityContext</a></h3>
<p>通过设置 Pod 的 SecurityContext，可以为每个 Pod 设置特定的安全策略。</p>
<p>SecurityContext 有两种类型：</p>
<ol>
<li><code>spec.securityContext</code>: 这是一个 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#podsecuritycontext-v1-core" target="_blank" rel="noopener noreferrer">PodSecurityContext</a> 对象
<ul>
<li>顾名思义，它对 Pod 中的所有 contaienrs 都有效。</li>
</ul>
</li>
<li><code>spec.containers[*].securityContext</code>: 这是一个 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#securitycontext-v1-core" target="_blank" rel="noopener noreferrer">SecurityContext</a> 对象
<ul>
<li>container 私有的 SecurityContext</li>
</ul>
</li>
</ol>
<p>这两个 SecurityContext 的参数只有部分重叠，重叠的部分 <code>spec.containers[*].securityContext</code> 优先级更高。</p>
<p>我们比较常遇到的一些<strong>提升权限</strong>的安全策略：</p>
<ol>
<li>特权容器：<code>spec.containers[*].securityContext.privileged</code></li>
<li>添加（Capabilities）可选的系统级能力: <code>spec.containers[*].securityContext.capabilities.add</code>
<ol>
<li>只有 ntp 同步服务等少数容器，可以开启这项功能。请注意这非常危险。</li>
</ol>
</li>
<li>Sysctls: 系统参数: <code>spec.securityContext.sysctls</code></li>
</ol>
<p><strong>权限限制</strong>相关的安全策略有（<strong>强烈建议在所有 Pod 上按需配置如下安全策略！</strong>）：</p>
<ol>
<li><code>spec.volumes</code>: 所有的数据卷都可以设定读写权限</li>
<li><code>spec.securityContext.runAsNonRoot: true</code> Pod 必须以非 root 用户运行</li>
<li><code>spec.containers[*].securityContext.readOnlyRootFileSystem:true</code> <strong>将容器层设为只读，防止容器文件被篡改。</strong>
<ol>
<li>如果微服务需要读写文件，建议额外挂载 <code>emptydir</code> 类型的数据卷。</li>
</ol>
</li>
<li><code>spec.containers[*].securityContext.allowPrivilegeEscalation: false</code> 不允许 Pod 做任何权限提升！</li>
<li><code>spec.containers[*].securityContext.capabilities.drop</code>: 移除（Capabilities）可选的系统级能力</li>
</ol>
<p>还有其他诸如指定容器的运行用户(user)/用户组(group)等功能未列出，请自行查阅 Kubernetes 相关文档。</p>
<p>一个无状态的微服务 Pod 配置举例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">&lt;Pod name&gt;</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">- name</span><span class="p">:</span><span class="w"> </span><span class="l">&lt;container name&gt;</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">&lt;image&gt;</span><span class="w">
</span><span class="w">    </span><span class="nt">imagePullPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">IfNotPresent </span><span class="w">
</span><span class="w">    </span><span class="c"># ......此处省略 500 字</span><span class="w">
</span><span class="w">    </span><span class="nt">securityContext</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">readOnlyRootFilesystem</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">  </span><span class="c"># 将容器层设为只读，防止容器文件被篡改。</span><span class="w">
</span><span class="w">      </span><span class="nt">allowPrivilegeEscalation</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">  </span><span class="c"># 禁止 Pod 做任何权限提升</span><span class="w">
</span><span class="w">      </span><span class="nt">capabilities</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">drop</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="c"># 禁止容器使用 raw 套接字，通常只有 hacker 才会用到 raw 套接字。</span><span class="w">
</span><span class="w">        </span><span class="c"># raw_socket 可自定义网络层数据，避开 tcp/udp 协议栈，直接操作底层的 ip/icmp 数据包。可实现 ip 伪装、自定义协议等功能。</span><span class="w">
</span><span class="w">        </span><span class="c"># 去掉 net_raw 会导致 tcpdump 无法使用，无法进行容器内抓包。需要抓包时可临时去除这项配置</span><span class="w">
</span><span class="w">        </span>- <span class="l">NET_RAW</span><span class="w">
</span><span class="w">        </span><span class="c"># 更好的选择：直接禁用所有 capabilities</span><span class="w">
</span><span class="w">        </span><span class="c"># - ALL</span><span class="w">
</span><span class="w">  </span><span class="nt">securityContext</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="c"># runAsUser: 1000  # 设定用户</span><span class="w">
</span><span class="w">    </span><span class="c"># runAsGroup: 1000  # 设定用户组</span><span class="w">
</span><span class="w">    </span><span class="nt">runAsNonRoot</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">  </span><span class="c"># Pod 必须以非 root 用户运行</span><span class="w">
</span><span class="w">    </span><span class="nt">seccompProfile</span><span class="p">:</span><span class="w">  </span><span class="c"># security compute mode</span><span class="w">
</span><span class="w">      </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">RuntimeDefault</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="2-seccomp-security-compute-mode">2. seccomp: security compute mode</h3>
<p>seccomp 和 seccomp-bpf 允许对系统调用进行过滤，可以防止用户的二进制文对主机操作系统件执行通常情况下并不需要的危险操作。它和 Falco 有些类似，不过 Seccomp 没有为容器提供特别的支持。</p>
<p>视频:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=Ro4QRx7VPsY&amp;list=PLj6h78yzYM2Pn8RxfLh2qrXBDftr6Qjut$index=22" target="_blank" rel="noopener noreferrer">Seccomp: What Can It Do For You? - Justin Cormack, Docker</a></li>
</ul>
<h2 id="其他问题">其他问题</h2>
<ul>
<li>不同节点类型的性能有差距，导致 QPS 均衡的情况下，CPU 负载不均衡
<ul>
<li>解决办法（未验证）：
<ul>
<li>尽量使用性能相同的实例类型：通过 <code>podAffinity</code> 及 <code>nodeAffinity</code> 添加节点类型的亲和性</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></description></item><item><title>2021 年年终总结</title><link>https://thiscute.world/posts/2021-summary/</link><pubDate>Mon, 03 Jan 2022 14:50:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/2021-summary/</guid><description><![CDATA[<blockquote>
<p>更新：2022/1/22</p>
</blockquote>
<h2 id="闲言碎语">闲言碎语</h2>
<p>一晃一年又是过去了，这个新年，全球疫情再创新高，圣诞节后美国单日新增更是直接突破 <del>50 万直逼 60 万大关❌</del> <strong>100 万✅</strong>，国内也有西安管理不力导致民众忍饥挨饿。</p>
<p>新冠已经两年多了啊。</p>
<p>言归正传，我今年年初从 W 公司离职后，非常幸运地进了现在的公司——大宇无限，在融入大宇的过程中也是五味杂陈。
不过总体结果还是挺满意的，目前工作已经步入正轨，也发现了非常多的机会，大宇的基础设施领域仍然大有可为。</p>
<p>一些重要事情还是没怎么想通，不过毕竟风口上的猪都能飞，今年小小努力了一把，大部分时间仍然随波逐流，却也渐入佳境。</p>
<h2 id="生活">生活</h2>
<ul>
<li>1 月的时候从博客园迁移到这个独立博客，还认识了 <a href="https://chee5e.space/" target="_blank" rel="noopener noreferrer">@芝士</a>，芝士帮我调整好了博客「友链」页面的样式，超级感谢~</li>
<li>2 月的时候从 W 公司离职，然后怎么说呢，瞬间感觉海阔天空，心态 180 度转变，好得不得了，但是其实也很担心自己各方面的不足。总之心里有好多的想法，跟 <a href="https://sanshiliuxiao.top/" target="_blank" rel="noopener noreferrer">@是格子啊</a>、<a href="https://chee5e.space/" target="_blank" rel="noopener noreferrer">@芝士</a> 以及前同事聊了好多，非常感谢这几位朋友跟同事帮我梳理思路，给我肯定。也是这个时间点，我被 <a href="https://chee5e.space/" target="_blank" rel="noopener noreferrer">@芝士</a> 拉进了中文 twitter 的圈子。</li>
<li>过年响应号召没回家（其实是嫌核酸检测麻烦，家里也建议先别回），每天爬爬山看看风景，买了个吊床去公园午睡，练习口琴竹笛，就这样玩了一个月。
<ul>
<li><figure>
</figure>
</li>
</ul>
</li>
<li>到了 3 月份的时候我开始找工作，面了几家公司后，非常幸运地进入了大宇无限，成为了一名 SRE 萌新。在大宇一年的感受，就放在后面的「工作」部分写了，这里先略过。
<ul>
<li>加入大宇后，全年都有定期的团建，跟 SRE 小伙伴公款吃喝，我 2021 年下馆子次数估计是上一年的七八倍</li>
</ul>
</li>
<li>3 月底，看了电影——《寻龙传说》（2021 年看的唯一一部电影），片尾曲超好听。</li>
<li>4 月份，各种巧合下，意外发现初中同学住得离我 1km 不到，在他家吃了顿家乡菜，还有杨梅酒，味道非常棒！还有回甘强烈的城步青钱柳茶，让我念念不忘。</li>
<li>8 月份，堂弟来深圳暑期实习，跟两个堂弟一起穿越深圳东西冲海岸线，风景非常棒，不过路上也是又热又渴</li>
<li>10 月份
<ul>
<li>加入了大宇的冲浪小分队，第一次冲浪、海边烧烤</li>
<li>买了双轮滑鞋，学会了倒滑、压步转向，复习了大学时学过的若干基础技巧</li>
</ul>
</li>
<li>12 月，买了台云米泉先净饮机后，有了随时随地的矿物质热水，就想起了 4 月份在初中同学家喝过的青钱柳，然后就喝茶上瘾了，一桌子的滇红、祁门红茶、安吉白茶、黄山毛峰、青钱柳、莓茶、梅子菁&hellip;目前感觉滇红跟祁门红茶最好喝，安吉白茶跟黄山毛峰都非常清香，青钱柳回甘最强烈，莓茶怎么说呢味道感觉不太好（也可能是泡的手法不对？）
<ul>
<li><figure><a class="lightgallery" href="/images/2021-summary/yunmi-ro-filterred-water-dispenser.jpg" title="/images/2021-summary/yunmi-ro-filterred-water-dispenser.jpg" data-thumbnail="/images/2021-summary/yunmi-ro-filterred-water-dispenser.jpg" data-sub-html="<h2>我的云米净饮机</h2>">
        
    </a><figcaption class="image-caption">我的云米净饮机</figcaption>
    </figure></li>
<li><figure><a class="lightgallery" href="/images/2021-summary/my-tea.jpg" title="/images/2021-summary/my-tea.jpg" data-thumbnail="/images/2021-summary/my-tea.jpg" data-sub-html="<h2>桌面上的各种茶叶</h2>">
        
    </a><figcaption class="image-caption">桌面上的各种茶叶</figcaption>
    </figure></li>
</ul>
</li>
<li>2022 年 1 月，第一次买动漫手办，妆点后感觉房间都增色不少~
<ul>
<li><figure><a class="lightgallery" href="/images/2021-summary/Posts-and-Garage-Kit.jpg" title="/images/2021-summary/Posts-and-Garage-Kit.jpg" data-thumbnail="/images/2021-summary/Posts-and-Garage-Kit.jpg" data-sub-html="<h2>我的房间-挂画-手办</h2>">
        
    </a><figcaption class="image-caption">我的房间-挂画-手办</figcaption>
    </figure></li>
</ul>
</li>
</ul>
<h2 id="读书">读书</h2>
<ul>
<li>年初辞职后游山玩水，心思稍微安定了些，看了大半本《走出荒野》。</li>
<li>6 月份社区组织打新冠疫苗时，在等候室看了本《青春驿站——深圳打工妹写真》，讲述八九十年代打工妹的生活。很真实，感情很细腻。</li>
<li>年末二爷爷去世，参加完葬礼后，心态有些变化，看完了大一时买下的《月宫 Moon Palace》，讲述主角的悲剧人生。</li>
<li>其余大部分业余时间，无聊，又不想学点东西，也不想运动，于是看了非常多的网络小说打发时间。</li>
</ul>
<h2 id="音乐">音乐</h2>
<p>年初辞职后，练了一段时间的竹笛跟蓝调口琴，但后来找到工作后就基本沉寂了。</p>
<p>总的来说还是原地踏步吧。</p>
<figure>
</figure>

<h2 id="工作---我在大宇无限的这一年">工作 - 我在大宇无限的这一年</h2>
<p>3 月份刚进大宇的我充满好奇，但也小心谨慎，甚至有点不敢相信自己能进到一家这么棒的公司，感觉自己运气爆棚。
毕竟大宇无论是同事水平还是工作氛围，亦或是用户体量，相比我上家公司都是质的差别。</p>
<p><figure><a class="lightgallery" href="/images/2021-summary/workstation-1.jpg" title="/images/2021-summary/workstation-1.jpg" data-thumbnail="/images/2021-summary/workstation-1.jpg" data-sub-html="<h2>我在大宇的第一个工位</h2>">
        
    </a><figcaption class="image-caption">我在大宇的第一个工位</figcaption>
    </figure></p>
<p>之后慢慢熟悉工作的内容与方法，leader 尽力把最匹配我兴趣的工作安排给我，帮我排疑解难，同时又给我极大的自主性，真的是棒极了。</p>
<p>然而自主性高带来的也是更高的工作难度，遇到困难时也曾手忙脚乱、迷茫、甚至自我怀疑，很担心是不是隔天就得跑路了&hellip;（是的我抗压能力有点弱）
但好在我终究还是能调节好心态，负起责任，一步步把工作完成。
中间有几次工作有延误时，leader 还陪我加班，事情干完后又带我去吃大餐犒劳自己，真的超级感谢他的帮助与支持。</p>
<p><figure><a class="lightgallery" href="/images/2021-summary/workstation-2.jpg" title="/images/2021-summary/workstation-2.jpg" data-thumbnail="/images/2021-summary/workstation-2.jpg" data-sub-html="<h2>换座位后的新工位，落地窗风景很棒</h2>">
        
    </a><figcaption class="image-caption">换座位后的新工位，落地窗风景很棒</figcaption>
    </figure></p>
<p>这样经历了几个项目的洗礼后，现在我终于能说自己是脚踏实地了，心态从「明天是不是得提桶跑路」转变成了「哇还有这个可以搞，那个 ROI 也很高，有好多有趣的事可以做啊」，我终于能说自己真正融入了大宇无限这家公司，成为了它的一员。</p>
<p>回看下了 2020 年的总结与展望，今年实际的进步，跟去年期望的差别很大。最初的目标大概只实现了 10%，但是接触到了许多意料之外的东西，总体还是满意的：</p>
<ul>
<li>熟悉了新公司的文化与工作方式，这感觉是个很大的收获，我的工作方式有了很大的改善</li>
<li>接触并且熟悉了新公司的 AWS 线上环境
<ul>
<li>负责维护线上 Kubernetes 管理平台，第一次接触到的线上集群峰值 QPS 就有好几万。从一开始的小心翼翼，到现在也转变成了老手，这算是意义重大吧</li>
<li>使用 python 写了几个 Kubernetes 管理平台的服务，这也是我第一次写线上服务，很有些成就感</li>
<li>下半年在 AWS 成本的分析与管控上花了很多精力，也有了一些不错的成果，受益匪浅</li>
<li>学会了 Nginx 的简单使用，刚好够用于维护公司先有的 Nginx 代理配置</li>
</ul>
</li>
<li>主导完成了「新建 K8s 集群，将服务迁移到新集群」。虽然并不是一件很难的事，但这应该算是我 2021 年最大的成就了。
<ul>
<li>升级过程中也是遇到了各种问题，第一次升级迁移时我准备了好久，慌的不行，结果升级时部分服务还是出了问题，当时脑子真的是个懵的，跟 leader 搞到半夜 1 点多后还是没解决，回退到了旧集群，升级失败。之后通过测试确认到是某个服务扩缩容震荡导致可用率无法恢复，尝试通过 HPA 的 behavior 来控制扩缩容速率，又意外触发了 K8s HPA 的 bug 把集群控制面搞崩了&hellip; 再之后把问题都确认了，第二次尝试升级，又是有个别服务可用率抖动，调试了好几天。那几天神经一直紧绷，每天早上都是被服务可用率的告警吵醒的。跨年的那天晚上业务量上涨，我就在观察服务可用率的过程中跨年了。这样才终于完成了 K8s 集群的升级，期间各位同事也有参与帮忙分析排查各种问题，非常感谢他们，还有努力的我自己。</li>
</ul>
</li>
<li>随便写了几个 go 的 demo，基本没啥进步</li>
<li>学了一个星期的 rust 语言，快速看完了 the book，用 rust 重写了个 video2chars</li>
<li>学习了 Linux 容器的底层原理：cgroups/namespace 技术，并且用 go/rust 实现了个 demo</li>
<li>学习了 Linux 的各种网络接口、Iptables</li>
<li>熟悉了 PromQL/Grafana，现在也能拷贝些 PromQL 查各种数据了</li>
</ul>
<p>如果要给自己打分的话，那就是「良好」吧。因为并没有很强的进取心，所以出来的结果也并不能称之为「优秀」。</p>
<p>顺便公司的新办公区真的超赞，详情见我的 twitter：</p>
<blockquote class="twitter-tweet"><p lang="zh" dir="ltr">新办公区真好呐～<br><br>值此良辰美景，好想整个榻榻米坐垫，坐在角落的落地窗边工作🤣<br>那种使用公共设施工（mo）作（yu）的乐趣，以及平常工位见不到的景色交相辉映，是不太好表述的奇妙体验 <a href="https://t.co/FASffzw8N3">pic.twitter.com/FASffzw8N3</a></p>&mdash; ryan4yin | 於清樂 (@ryan4yin) <a href="https://twitter.com/ryan4yin/status/1482891448731070466?ref_src=twsrc%5Etfw">January 17, 2022</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 
<h2 id="技术方面的感受">技术方面的感受</h2>
<ul>
<li>Istio 服务网格：体会到了它有点重，而且它的发展跟我们的需求不一定匹配
<ul>
<li>Sidecar 模式的成本比较高，在未调优的情况下，它会给服务带来 1/3 到 1/4 的成本提升，以及延迟上升</li>
<li>比如切量权重固定为 100（新版本将会放宽限制），不支持 pod 的 warm up（社区已经有 PR，持续观望吧）</li>
<li>而它重点发展的虚拟机支持我们却完全不需要</li>
<li>一直在思考是持续往 Istio 投入，还是换其他的方案</li>
</ul>
</li>
<li>服务网格仍然在快速发展，未来的趋势应该是 eBPF + Envoy + WASM
<ul>
<li>Cilium 推出的基于 eBPF 的 Service Mesh 是一个新趋势（它使用高级特性时会退化成 Per Node Proxy 模式），成本、延迟方面都有望吊打 Sidecar 模式的其他服务网格，是今年服务网格领域的大新闻。</li>
<li>我们曾尝试使用中心化网关来替代 Sidecar 以降低成本。但是跨区流量成本、HTTP/gRPC 多协议共存，这些都是挑战。而且这也并不是社区的最佳实践，现在我觉得维持 Sidecar 其实反而能提升资源利用率，我们的集群资源利用率目前很低。如果能把控好，这部分成本或许是可以接受的。</li>
</ul>
</li>
<li>K8s 集群的日志方面，我们目前是使用自研的基于 gelf 协议的系统，但是问题挺多的
<ul>
<li>从提升系统的可维护性、易用性等角度来说，loki 是值得探索下的</li>
</ul>
</li>
<li>K8s 集群管理方面，觉得集群的升级迭代，可以做得更自动化、更可靠。明年可以在多集群管理这个方向上多探索下。</li>
<li><a href="https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/" target="_blank" rel="noopener noreferrer">Pod 服务质量</a>：对非核心服务，可以适当调低 requests 的资源量，而不是完全预留(<code>Guaranteed</code>)，以提升资源利用率。</li>
<li>官方的 HPA 能力是不够用的，业务侧可能会需要基于 QPS/Queue 或者业务侧的其他参数来进行扩缩容，需要持续关注 <a href="https://github.com/kedacore/keda" target="_blank" rel="noopener noreferrer">KEDA</a> 这个项目。</li>
<li>成本控制方面，体会到了 ARM 架构以及 Spot 竞价实例的好处</li>
<li>跨区流量成本有很大的潜在优化空间
<ul>
<li>跨区流量成本是在两边都会收费，而且不仅涉及 Kubernetes 集群内服务间的调用，还会涉及对 RDS/ES/ElastiCache/EC2 等其他资源的调用。</li>
</ul>
</li>
<li>今年各云厂商故障频发，没有<strong>跨 region 的服务迁移</strong>就会很难受，需要持续关注下 <a href="https://github.com/karmada-io/karmada" target="_blank" rel="noopener noreferrer">karmada</a> 这类多集群管理方案。
<ul>
<li>Google 账号系统宕机</li>
<li>Fastly CDN 故障</li>
<li>Facebook 故障</li>
<li>AWS 更是各种可用区故障，12/7 的故障导致 AWS 大部分服务都崩了。因此我们 SRE 今年经常是救各种大火小火&hellip;</li>
</ul>
</li>
<li>Rust/Go/WASM 蓬勃发展，未来可期。</li>
<li>AI 落地到各个领域，影响到了我们日常使用的语音导航、歌声合成、语音合成等多个领域，当然也包括与 SRE 工作相关的场景：AIOps</li>
</ul>
<h2 id="2022-年的展望">2022 年的展望</h2>
<h3 id="技术侧">技术侧</h3>
<p>今年的展望写得更聚焦一些，争取能实现 50%，就是很大的突破了。</p>
<ol>
<li>熟练掌握 Go 语言，并分别用于至少两个项目中
<ol>
<li>打铁还需自身硬，编码能力是基础中的基础</li>
</ol>
</li>
<li>Kubernetes 相关
<ol>
<li>以 kubebuilder 为代表的 k8s 开发、拓展技术</li>
<li>阅读 k8s 及相关生态的源码，了解其实现逻辑</li>
</ol>
</li>
<li>网络技术
<ol>
<li>服务网格 Istio</li>
<li>代理工具 Envoy/APISIX</li>
<li>网络插件 Cilium + eBPF</li>
</ol>
</li>
<li>AWS K8s 成本与服务稳定性优化
<ol>
<li>节约跨可用区/跨域的流量成本</li>
<li>K8s 新特性：<a href="https://kubernetes.io/docs/concepts/services-networking/topology-aware-hints/" target="_blank" rel="noopener noreferrer">Topology Aware Hints</a></li>
<li>Istio: <a href="https://istio.io/latest/docs/tasks/traffic-management/locality-load-balancing/" target="_blank" rel="noopener noreferrer">Locality Load Balancing</a></li>
<li>实例类型优化：
<ol>
<li>使用更合适的实例类型</li>
<li>使用 ARM 架构机型，降本增效</li>
</ol>
</li>
<li>推广 gRPC 协议</li>
</ol>
</li>
<li>提升本地开发效率：
<ol>
<li><a href="https://github.com/nocalhost/nocalhost" target="_blank" rel="noopener noreferrer">nocalhost</a></li>
</ol>
</li>
<li>多集群的应用部署、容灾
<ol>
<li>karmada</li>
</ol>
</li>
<li>探索新技术与可能性（优先级低）
<ol>
<li>基于 Kubernetes 的服务平台，未来的发展方向
<ol>
<li>kubevela</li>
<li>buildpack</li>
<li>是否应该推进 gitops</li>
<li>openkruise</li>
</ol>
</li>
<li>Serverless 平台的进展
<ol>
<li>Knative</li>
<li>OpenFunction</li>
</ol>
</li>
<li>机器学习、深度学习技术：想尝试下将 AI 应用在音乐、语音、SRE 等我感兴趣的领域，即使是调包也行啊，总之想出点成果&hellip;</li>
</ol>
</li>
</ol>
<p>可以预料到明年 SRE 团队有超多的机会，这其中我具体能负责哪些部分，又能做出怎样的成果，真的相当期待~</p>
<h3 id="生活侧">生活侧</h3>
<ul>
<li>运动：
<ul>
<li>把轮滑练好，学会点花样吧，每个月至少两次。</li>
<li>进行三次以上的次短途旅行，东西冲穿越可以再来一次。</li>
</ul>
</li>
<li>音乐：
<ul>
<li>再一次学习乐理&hellip;</li>
<li>midi 键盘买了一直吃灰，多多练习吧</li>
<li>买了个 Synthesizer V  Stduio Pro + 「青溯 AI」，新的一年想学下调教，翻唱些自己喜欢的歌。</li>
</ul>
</li>
<li>阅读：清单如下，一个月至少读完其中一本。
<ul>
<li>文学类：
<ul>
<li><i class="far fa-check-square fa-fw"></i> 《人间失格》：久仰大名的一本书，曾经有同学力荐，但是一直没看。</li>
<li><i class="far fa-square fa-fw"></i> 《生命最后的读书会》：或许曾经看过，但是一点印象都没了</li>
<li><i class="far fa-square fa-fw"></i> 《百年孤独》：高中的时候读过一遍，但是都忘差不多了</li>
<li><i class="far fa-square fa-fw"></i> 《霍乱时期的爱情》</li>
<li><i class="far fa-square fa-fw"></i> 《苏菲的世界》：据说是哲学启蒙读物，曾经看过，但是对内容完全没印象了。</li>
<li><i class="far fa-square fa-fw"></i> 《你一生的故事》：我也曾是个科幻迷</li>
<li><i class="far fa-square fa-fw"></i> 《沈从文的后半生》</li>
<li><i class="far fa-square fa-fw"></i> 《我与地坛》</li>
<li><i class="far fa-square fa-fw"></i> 《将饮茶》</li>
<li><i class="far fa-square fa-fw"></i> 《吾国与吾民 - 林语堂》</li>
<li><i class="far fa-square fa-fw"></i> 《房思琪的初恋乐园》</li>
</ul>
</li>
<li>人文社科
<ul>
<li><i class="far fa-square fa-fw"></i> 《在生命的尽头拥抱你-临终关怀医生手记》：今年想更多地了解下「死亡」</li>
<li><i class="far fa-square fa-fw"></i> 《怎样征服美丽少女》：哈哈</li>
<li><i class="far fa-square fa-fw"></i> 《爱的艺术》</li>
<li><i class="far fa-square fa-fw"></i> 《社会心理学》</li>
<li><i class="far fa-square fa-fw"></i> 《被讨厌的勇气》</li>
<li><i class="far fa-square fa-fw"></i> 《人体简史》</li>
<li><i class="far fa-square fa-fw"></i> 《科学革命的结构》</li>
<li><i class="far fa-square fa-fw"></i> 《邓小平时代》</li>
<li><i class="far fa-square fa-fw"></i> 《论中国》</li>
<li><i class="far fa-square fa-fw"></i> 《刘擎西方现代思想讲义》</li>
<li><i class="far fa-square fa-fw"></i> 《时间的秩序》</li>
<li><i class="far fa-square fa-fw"></i> 《极简宇宙史》</li>
<li><i class="far fa-square fa-fw"></i> 《圆圈正义-作为自由前提的信念》</li>
<li><i class="far fa-square fa-fw"></i> 《人生脚本》</li>
</ul>
</li>
<li>技术类
<ul>
<li><i class="far fa-square fa-fw"></i> 《复杂》</li>
<li><i class="far fa-square fa-fw"></i> 《SRE - Google 运维解密》</li>
<li><i class="far fa-square fa-fw"></i> 《凤凰项目：一个 IT 运维的传奇故事》</li>
<li><i class="far fa-square fa-fw"></i> 《人月神话》</li>
<li><i class="far fa-square fa-fw"></i> 《绩效使能：超越 OKR》</li>
<li><i class="far fa-square fa-fw"></i> 《奈飞文化手册》</li>
<li><i class="far fa-square fa-fw"></i> 《幕后产品-打造突破式思维》</li>
<li><i class="far fa-square fa-fw"></i> 《深入 Linux 内核架构》</li>
<li><i class="far fa-square fa-fw"></i> 《Linux/UNIX 系统编程手册》</li>
<li><i class="far fa-square fa-fw"></i> 《重构 - 改善既有代码的设计》</li>
<li><i class="far fa-square fa-fw"></i> 《网络是怎样连接的》：曾经学习过《计算机网络：自顶向下方法》，不过只学到网络层。就从这本书开始重新学习吧。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="结语">结语</h2>
<p>2021 年初朋友与我给自己的期许是「拆破玉笼飞彩凤，顿开金锁走蛟龙」，感觉确实应验了。</p>
<p>今年我希望不论是在生活上还是在工作上，都能「更上一层楼」~</p>
<blockquote>
<p>更多有趣的、有深度的 2021 年度总结：<a href="https://github.com/saveweb/review-2021" target="_blank" rel="noopener noreferrer">https://github.com/saveweb/review-2021</a></p>
</blockquote>
]]></description></item><item><title>月宫</title><link>https://thiscute.world/posts/moon-palace/</link><pubDate>Mon, 27 Dec 2021 17:23:00 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/moon-palace/</guid><description><![CDATA[<p>大雪，沙雪。</p>
<p>到晴岚桥等送葬队伍时，非常冷。</p>
<p>转头一望，发现抬棺的几位师傅在渠渡庙门口就地取材生起了火堆取暖，这样寒冷的天气下，很有种惊喜的感觉。</p>
<p>送葬路上又是风又是雪，像是老天也在哀伤。辉辉说这还是他第一次在风雪天里送葬，我也有同感。</p>
<p>到了山上，雨伞上已经结了薄薄一层冰，老爸跟老妈衣服也冻上了冰晶，辉辉更是头发都冻上了。</p>
<p>风雪之中，二爷爷被葬在我家后山。我们就这样送走了二爷爷。</p>
<p>这次的送葬，对我而言也像是一个仪式，我在弥补曾经缺席奶奶、外婆过世的遗憾。</p>
<p>事情都办完后，我到洞口赶高铁，结果不论是高铁还是火车都晚点，就连只隔一个站的 K809 都晚点 99 分钟。</p>
<p>等车的时间，我又看起了《月宫》这本小说。这是大一时买的书，因为看到说主角想把自己逼到极限，这引起了当时苦行僧般的我的共鸣。
但是我始终没有看完它，读不下去。</p>
<p>今天很奇怪的，居然又能读的下去了。</p>
<p>在记起是 Kitty 救了自我放逐中的 Fogg，并且重新获得希望之后，我发觉自己目前的状态可能有些问题。
业余时间沉迷在自我中心的网络小说中，其他时间只关注技术，人就渐渐变得跟人脱节。</p>
<p>高铁上我同样用《月宫》打发时间，在晚点两个半小时后，一点半，到达了深圳北。这时候我刚好看到 Kitty 对 Fogg 说：「已经太晚了，我不能再一次冒险。再见，请你好好对自己。」
心里突然就空落落的，我意识到这是一个彻头彻尾的悲剧，我居然想在悲剧中期许一个美好的转折，真的是有些妄想了。</p>
<p>下了车，站在站台上，眼泪就涌了出来。为书中的悲剧哭泣，也再一次意识到，那些记忆中满脸皱纹的身影，是真的永别了。</p>
<p>从 2015 年 11 月到 2021 年 12 月 27 日的凌晨，二爷爷下葬的翌日，我借着火车站路边昏黄的灯光，看完了保罗·奥斯特的《月宫》。</p>
]]></description></item><item><title>此岸弃草，彼岸繁花</title><link>https://thiscute.world/posts/weeds-on-this-side-flowers-on-the-other/</link><pubDate>Sat, 28 Aug 2021 12:24:20 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/weeds-on-this-side-flowers-on-the-other/</guid><description><![CDATA[<blockquote>
<p>「此岸弃草，彼岸繁花。」取自前永动机主唱「河津樱/白金」的个人简介</p>
</blockquote>
<p>今天想推几首歌 emmmm</p>
<!-- 庭前鹤高歌 - 河津樱 -->
<meting-js server="netease" type="song" id="1466346187" theme="#448aff"></meting-js>
<!-- 明日见黄花 - 永动机 -->
<meting-js server="netease" type="song" id="519225198" theme="#448aff"></meting-js>
<!-- 1400424646 - She Her Her Hers -->
<meting-js server="netease" type="song" id="1400424646" theme="#448aff"></meting-js>
]]></description></item><item><title>iptables 及 docker 容器网络分析</title><link>https://thiscute.world/posts/iptables-and-container-networks/</link><pubDate>Sun, 15 Aug 2021 19:11:29 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/iptables-and-container-networks/</guid><description><![CDATA[<blockquote>
<p>本文仅针对 ipv4 网络</p>
</blockquote>
<p>本文先介绍 iptables 的基本概念及常用命令，然后分析 docker/podman 是如何利用 iptables 和 Linux 虚拟网络接口实现的单机容器网络。</p>
<h1 id="一iptables">一、iptables</h1>
<p><a href="https://www.netfilter.org/projects/iptables/index.html" target="_blank" rel="noopener noreferrer">iptables</a> 提供了包过滤、NAT 以及其他的包处理能力，iptables 应用最多的两个场景是 firewall 和 NAT</p>
<p>iptables 及新的 nftables 都是基于 netfilter 开发的，是 netfilter 的子项目。</p>
<p>但是 eBPF 社区目前正在开发旨在取代 netfilter 的新项目 bpfilter，他们的目标之一是兼容 iptables/nftables 规则，让我们拭目以待吧。</p>
<h2 id="iptables-基础概念---四表五链">iptables 基础概念 - 四表五链</h2>
<blockquote>
<p>实际上还有张 SELinux 相关的 security 表（应该是较新的内核新增的，但是不清楚是哪个版本加的），但是我基本没接触过，就略过了。</p>
</blockquote>
<p>详细的说明参见 <a href="https://www.zsythink.net/archives/1199" target="_blank" rel="noopener noreferrer">iptables详解（1）：iptables概念 - 朱双印</a>，这篇文章写得非常棒！把 iptables 讲清楚了。</p>
<p>默认情况下，iptables 提供了四张表（不考虑 security 的话）和五条链，数据在这四表五链中的处理流程如下图所示：</p>
<blockquote>
<p>在这里的介绍中，可以先忽略掉图中 link layer 层的链路，它属于 ebtables 的范畴。另外 <code>conntrack</code> 也暂时忽略，在下一小节会详细介绍 conntrack 的功能。</p>
</blockquote>
<p><figure><a class="lightgallery" href="/images/netfilter/netfilter-packet-flow.png" title="/images/netfilter/netfilter-packet-flow.png" data-thumbnail="/images/netfilter/netfilter-packet-flow.png" data-sub-html="<h2>netfilter 数据包处理流程，来自 wikipedia</h2>">
        
    </a><figcaption class="image-caption">netfilter 数据包处理流程，来自 wikipedia</figcaption>
    </figure></p>
<p>对照上图，对于发送到某个用户层程序的数据而言，流量顺序如下：</p>
<ul>
<li>首先进入 PREROUTING 链，依次经过这三个表： raw -&gt; mangle -&gt; nat</li>
<li>然后进入 INPUT 链，这个链上也有三个表，处理顺序是：mangle -&gt; nat -&gt; filter</li>
<li>过了 INPUT 链后，数据才会进入内核协议栈，最终到达用户层程序。</li>
</ul>
<p>用户层程序发出的报文，则依次经过这几个表：OUTPUT -&gt; POSTROUTING</p>
<p>从图中也很容易看出，如果数据 dst ip 不是本机任一接口的 ip，那它通过的几个链依次是：PREROUTEING -&gt; FORWARD -&gt; POSTROUTING</p>
<p>五链的功能和名称完全一致，应该很容易理解。下面按优先级分别介绍下链中的四个表：</p>
<ul>
<li>raw: 对收到的数据包在连接跟踪前进行处理。一般用不到，可以忽略
<ul>
<li>一旦用户使用了 raw raw 表处理完后，将跳过 nat 表和 ip_conntrack 处理，即不再做地址转换和数据包的链接跟踪处理了</li>
</ul>
</li>
<li>mangle: 用于修改报文、给报文打标签</li>
<li>nat: 主要用于做网络地址转换，SNAT 或者 DNAT</li>
<li>filter: 主要用于过滤数据包</li>
</ul>
<p>数据在按优先级经过四个表的处理时，一旦在某个表中匹配到一条规则 A,下一条处理规则就由规则 A 的 target 参数指定，<strong>后续的所有表</strong>都会被忽略。target 有如下几种类型：</p>
<ul>
<li>ACCEPT: 直接允许数据包通过</li>
<li>DROP: 直接丢弃数据包，对程序而言就是 100% 丢包</li>
<li>REJECT: 丢弃数据包，但是会给程序返回  RESET。这个对程序更友好，但是存在安全隐患，通常不使用。</li>
<li>MASQUERADE: （伪装）将 src ip 改写为网卡 ip，和 SNAT 的区别是它会自动读取网卡 ip。路由设备必备。</li>
<li>SNAT/DNAT: 顾名思义，做网络地址转换</li>
<li>REDIRECT: 在本机做端口映射</li>
<li>LOG: 在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。
<ul>
<li>只有这个 target 特殊一些，匹配它的数据仍然可以匹配后续规则，不会直接跳过。</li>
</ul>
</li>
<li>其他类型，可以用到的时候再查</li>
</ul>
<p>理解了上面这张图，以及四个表的用途，就很容易理解 iptables 的命令了。</p>
<h2 id="常用命令">常用命令</h2>
<blockquote>
<p><strong>注意</strong>: 下面提供的 iptables 命令做的修改是未持久化的，重启就会丢失！在下一节会简单介绍持久化配置的方法。</p>
</blockquote>
<p>命令格式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">iptables <span class="o">[</span>-t table<span class="o">]</span> <span class="o">{</span>-A<span class="p">|</span>-C<span class="p">|</span>-D<span class="o">}</span> chain <span class="o">[</span>-m matchname <span class="o">[</span>per-match-options<span class="o">]]</span> -j targetname <span class="o">[</span>per-target-options<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>其中 table 默认为 <code>filter</code> 表，其中系统管理员实际使用最多的是 INPUT 链，用于设置防火墙。</p>
<p>以下简单介绍在 INPUT 链上添加、修改规则，来设置防火墙：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># --add 允许 80 端口通过</span>
iptables -A INPUT -p tcp --dport <span class="m">80</span> -j ACCEPT

<span class="c1"># --list-rules 查看所有规则</span>
iptables -S

<span class="c1"># --list-rules 查看 INPUT 表中的所有规则</span>
iptables -S INPUT
<span class="c1"># 查看 iptables 中的所有规则（比 -L 更详细）</span>

<span class="c1"># ---delete 通过编号删除规则</span>
iptables -D <span class="m">1</span>
<span class="c1"># 或者通过完整的规则参数来删除规则</span>
iptables -D INPUT -p tcp --dport <span class="m">80</span> -j ACCEPT

<span class="c1"># --replace 通过编号来替换规则内容</span>
iptables -R INPUT <span class="m">1</span> -s 192.168.0.1 -j DROP

<span class="c1"># --insert 在指定的位置插入规则，可类比链表的插入</span>
iptables -I INPUT <span class="m">1</span> -p tcp --dport <span class="m">80</span> -j ACCEPT

<span class="c1"># 在匹配条件前面使用感叹号表示取反</span>
<span class="c1"># 如下规则表示接受所有来自 docker0，但是目标接口不是 docker0 的流量</span>
iptables -A FORWARD -i docker0 ! -o docker0 -j ACCEPT

<span class="c1"># --policy 设置某个链的默认规则</span>
<span class="c1"># 很多系统管理员会习惯将连接公网的服务器，默认规则设为 DROP，提升安全性，避免错误地开放了端口。</span>
<span class="c1"># 但是也要注意，默认规则设为 DROP 前，一定要先把允许 ssh 端口的规则加上，否则就尴尬了。</span>
iptables -P INPUT DROP

<span class="c1"># --flush 清空 INPUT 表上的所有规则</span>
iptables -F INPUT
</code></pre></td></tr></table>
</div>
</div><hr>
<blockquote>
<p>本文后续分析时，假设用户已经清楚 linux bridge、veth 等虚拟网络接口相关知识。
如果你还缺少这些前置知识，请先阅读文章 <a href="https://thiscute.world/posts/linux-virtual-network-interfaces/" target="_blank" rel="noopener noreferrer">Linux 中的虚拟网络接口</a>。</p>
</blockquote>
<h2 id="conntrack-连接跟踪与-nat">conntrack 连接跟踪与 NAT</h2>
<p>在讲 conntrack 之间，我们再回顾下前面给出过的 netfilter 数据处理流程图：</p>
<p><figure><a class="lightgallery" href="/images/netfilter/netfilter-packet-flow.png" title="/images/netfilter/netfilter-packet-flow.png" data-thumbnail="/images/netfilter/netfilter-packet-flow.png" data-sub-html="<h2>netfilter 数据包处理流程，来自 wikipedia</h2>">
        
    </a><figcaption class="image-caption">netfilter 数据包处理流程，来自 wikipedia</figcaption>
    </figure></p>
<p>上一节中我们忽略了图中的 conntrack，它就是本节的主角——netfilter 的连接跟踪（connection tracking）模块。</p>
<p>netfilter/conntrack 是 iptables 实现 SNAT/DNAT/MASQUERADE 的前提条件，上面的流程图显示， conntrack 在 PREROUTEING 和 OUTPUT 链的 raw 表之后生效。</p>
<p>下面以 docker 默认的 bridge 网络为例详细介绍下 conntrack 的功能。</p>
<p>首先，这是我在「Linux 的虚拟网络接口」文中给出过的 docker0 网络架构图:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">+-----------------------------------------------+-----------------------------------+-----------------------------------+
|                      Host                     |           Container A             |           Container B             |
|                                               |                                   |                                   |
|   +---------------------------------------+   |    +-------------------------+    |    +-------------------------+    |
|   |       Network Protocol Stack          |   |    |  Network Protocol Stack |    |    |  Network Protocol Stack |    |
|   +----+-------------+--------------------+   |    +-----------+-------------+    |    +------------+------------+    |
|        ^             ^                        |                ^                  |                 ^                 |
|........|.............|........................|................|..................|.................|.................|
|        v             v  ↓                     |                v                  |                 v                 |
|   +----+----+  +-----+------+                 |          +-----+-------+          |           +-----+-------+         |
|   | .31.101 |  | 172.17.0.1 |      +------+   |          | 172.17.0.2  |          |           |  172.17.0.3 |         |
|   +---------+  +-------------&lt;----&gt;+ veth |   |          +-------------+          |           +-------------+         |
|   |  eth0   |  |   docker0  |      +--+---+   |          | eth0(veth)  |          |           | eth0(veth)  |         |
|   +----+----+  +-----+------+         ^       |          +-----+-------+          |           +-----+-------+         |
|        ^             ^                |       |                ^                  |                 ^                 |
|        |             |                +------------------------+                  |                 |                 |
|        |             v                        |                                   |                 |                 |
|        |          +--+---+                    |                                   |                 |                 |
|        |          | veth |                    |                                   |                 |                 |
|        |          +--+---+                    |                                   |                 |                 |
|        |             ^                        |                                   |                 |                 |
|        |             +------------------------------------------------------------------------------+                 |
|        |                                      |                                   |                                   |
|        |                                      |                                   |                                   |
+-----------------------------------------------+-----------------------------------+-----------------------------------+
         v
    Physical Network  (192.168.31.0/24)
</code></pre></td></tr></table>
</div>
</div><p>docker 会在 iptables 中为 docker0 网桥添加如下规则：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">-t nat -A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE

-t filter -P DROP
-t filter -A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
</code></pre></td></tr></table>
</div>
</div><p>这几行规则使 docker 容器能正常访问外部网络。<code>MASQUERADE</code> 在请求出网时，会自动做 <code>SNAT</code>，将 src ip 替换成出口网卡的 ip.
这样数据包能正常出网，而且对端返回的数据包现在也能正常回到出口网卡。</p>
<p>现在问题就来了：<strong>出口网卡收到返回的数据包后，还能否将数据包转发到数据的初始来源端——某个 docker 容器</strong>？难道 docker 还额外添加了与 MASQUERADE 对应的 dst ip 反向转换规则？</p>
<p>实际上这一步依赖的是本节的主角——iptables 提供的 conntrack 连接跟踪功能（在「参考」中有一篇文章详细介绍了此功能）。</p>
<p>连接跟踪对 NAT 的贡献是：在做 NAT 转换时，无需手动添加额外的规则来执行<strong>反向转换</strong>以实现数据的双向传输。netfilter/conntrack 系统会记录 NAT 的连接状态，NAT 地址的反向转换是根据这个状态自动完成的。</p>
<p>比如上图中的 <code>Container A</code> 通过 bridge 网络向 baidu.com 发起了 N 个连接，这时数据的处理流程如下：</p>
<ul>
<li>首先 <code>Container A</code> 发出的数据包被 MASQUERADE 规则处理，将 src ip 替换成 eth0 的 ip，然后发送到物理网络 <code>192..168.31.0/24</code>。
<ul>
<li>conntrack 系统记录此连接被 NAT 处理前后的状态信息，并将其状态设置为 NEW，表示这是新发起的一个连接</li>
</ul>
</li>
<li>对端 baidu.com 返回数据包后，会首先到达 eth0 网卡</li>
<li>conntrack 查表，发现返回数据包的连接已经记录在表中并且状态为 NEW，于是它将连接的状态修改为 ESTABLISHED，并且将 dst_ip 改为 <code>172.17.0.2</code> 然后发送出去
<ul>
<li>注意，这个和 tcp 的 ESTABLISHED 没任何关系</li>
</ul>
</li>
<li>经过路由匹配，数据包会进入到 docker0，然后匹配上 iptables 规则：<code>-t filter -A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</code>，数据直接被放行</li>
<li>数据经过 veth 后，最终进入到 <code>Container A</code> 中，交由容器的内核协议栈处理。</li>
<li>数据被 <code>Container A</code> 的内核协议栈发送到「发起连接的应用程序」。</li>
</ul>
<h3 id="实际测试-conntrack">实际测试 conntrack</h3>
<p>现在我们来实际测试一下，看看是不是这么回事：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 使用 tcpdump 分别在出口网卡 wlp4s0 （相当于 eth0）和 dcoker0 网桥上抓包，后面会用来分析</span>
❯ sudo tcpdump -i wlp4s0 -n &gt; wlp4s0.dump   <span class="c1"># 窗口一，抓 wlp4s0 的包</span>
❯ sudo tcpdump -i docker0 -n &gt; docker0.dump  <span class="c1"># 窗口二，抓 docker0 的包</span>
</code></pre></td></tr></table>
</div>
</div><p>现在新建窗口三，启动一个容器，通过 curl 命令低速下载一个视频文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">❯ docker run --rm --name curl -it curlimages/curl &#34;https://media.w3.org/2010/05/sintel/trailer.mp4&#34; -o /tmp/video.mp4 --limit-rate 100k
</code></pre></td></tr></table>
</div>
</div><p>然后新建窗口四，在宿主机查看 conntrack 状态</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">❯ sudo zypper in conntrack-tools  <span class="c1"># 这个记得先提前安装好</span>
❯ sudo conntrack -L <span class="p">|</span> grep 172.17
<span class="c1"># curl 通过 NAT 网络发起了一个 dns 查询请求，DNS 服务器是网关上的 192.168.31.1</span>
udp      <span class="m">17</span> <span class="m">22</span> <span class="nv">src</span><span class="o">=</span>172.17.0.4 <span class="nv">dst</span><span class="o">=</span>192.168.31.1 <span class="nv">sport</span><span class="o">=</span><span class="m">59423</span> <span class="nv">dport</span><span class="o">=</span><span class="m">53</span> <span class="nv">src</span><span class="o">=</span>192.168.31.1 <span class="nv">dst</span><span class="o">=</span>192.168.31.228 <span class="nv">sport</span><span class="o">=</span><span class="m">53</span> <span class="nv">dport</span><span class="o">=</span><span class="m">59423</span> <span class="o">[</span>ASSURED<span class="o">]</span> <span class="nv">mark</span><span class="o">=</span><span class="m">0</span> <span class="nv">use</span><span class="o">=</span><span class="m">1</span>
<span class="c1"># curl 通过 NAT 网络向 media.w3.org 发起了 tcp 连接</span>
tcp      <span class="m">6</span> <span class="m">298</span> ESTABLISHED <span class="nv">src</span><span class="o">=</span>172.17.0.4 <span class="nv">dst</span><span class="o">=</span>198.18.5.130 <span class="nv">sport</span><span class="o">=</span><span class="m">54636</span> <span class="nv">dport</span><span class="o">=</span><span class="m">443</span> <span class="nv">src</span><span class="o">=</span>198.18.5.130 <span class="nv">dst</span><span class="o">=</span>192.168.31.228 <span class="nv">sport</span><span class="o">=</span><span class="m">443</span> <span class="nv">dport</span><span class="o">=</span><span class="m">54636</span> <span class="o">[</span>ASSURED<span class="o">]</span> <span class="nv">mark</span><span class="o">=</span><span class="m">0</span> <span class="nv">use</span><span class="o">=</span><span class="m">1</span>
</code></pre></td></tr></table>
</div>
</div><p>等 curl 命令跑个十来秒，然后关闭所有窗口及应用程序，接下来进行数据分析：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 前面查到的，本地发起请求的端口是 54636，下面以此为过滤条件查询数据</span>

<span class="c1"># 首先查询 wlp4s0/eth0 进来的数据，可以看到本机的 dst_ip 为 192.168.31.228.54636</span>
❯ cat wlp4s0.dump <span class="p">|</span> grep <span class="m">54636</span> <span class="p">|</span> head -n <span class="m">15</span>
18:28:28.349321 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>S<span class="o">]</span>, seq 750859357, win 64240, options <span class="o">[</span>mss 1460,sackOK,TS val <span class="m">3365688110</span> ecr 0,nop,wscale 7<span class="o">]</span>, length <span class="m">0</span>
18:28:28.350757 IP 198.18.5.130.443 &gt; 192.168.31.228.54636: Flags <span class="o">[</span>S.<span class="o">]</span>, seq 2381759932, ack 750859358, win 28960, options <span class="o">[</span>mss 1460,sackOK,TS val <span class="m">22099541</span> ecr 3365688110,nop,wscale 5<span class="o">]</span>, length <span class="m">0</span>
18:28:28.350814 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>.<span class="o">]</span>, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688111</span> ecr 22099541<span class="o">]</span>, length <span class="m">0</span>
18:28:28.357345 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 1:518, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688118</span> ecr 22099541<span class="o">]</span>, length <span class="m">517</span>
18:28:28.359253 IP 198.18.5.130.443 &gt; 192.168.31.228.54636: Flags <span class="o">[</span>.<span class="o">]</span>, ack 518, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099542</span> ecr 3365688118<span class="o">]</span>, length <span class="m">0</span>
18:28:28.726544 IP 198.18.5.130.443 &gt; 192.168.31.228.54636: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 1:2622, ack 518, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099579</span> ecr 3365688118<span class="o">]</span>, length <span class="m">2621</span>
18:28:28.726616 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>.<span class="o">]</span>, ack 2622, win 482, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688487</span> ecr 22099579<span class="o">]</span>, length <span class="m">0</span>
18:28:28.727652 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 518:598, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">80</span>
18:28:28.727803 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 598:644, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">46</span>
18:28:28.727828 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 644:693, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">49</span>
18:28:28.727850 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 693:728, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">35</span>
18:28:28.727875 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 728:812, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">84</span>
18:28:28.729241 IP 198.18.5.130.443 &gt; 192.168.31.228.54636: Flags <span class="o">[</span>.<span class="o">]</span>, ack 598, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099579</span> ecr 3365688488<span class="o">]</span>, length <span class="m">0</span>
18:28:28.729245 IP 198.18.5.130.443 &gt; 192.168.31.228.54636: Flags <span class="o">[</span>.<span class="o">]</span>, ack 644, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099579</span> ecr 3365688488<span class="o">]</span>, length <span class="m">0</span>
18:28:28.729247 IP 198.18.5.130.443 &gt; 192.168.31.228.54636: Flags <span class="o">[</span>.<span class="o">]</span>, ack 693, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099579</span> ecr 3365688488<span class="o">]</span>, length <span class="m">0</span>


<span class="c1"># 然后再查询 docker0 上的数据，能发现本地的地址为 172.17.0.4.54636</span>
❯ cat docker0.dump <span class="p">|</span> grep <span class="m">54636</span> <span class="p">|</span> head -n <span class="m">20</span>
18:28:28.349299 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>S<span class="o">]</span>, seq 750859357, win 64240, options <span class="o">[</span>mss 1460,sackOK,TS val <span class="m">3365688110</span> ecr 0,nop,wscale 7<span class="o">]</span>, length <span class="m">0</span>
18:28:28.350780 IP 198.18.5.130.443 &gt; 172.17.0.4.54636: Flags <span class="o">[</span>S.<span class="o">]</span>, seq 2381759932, ack 750859358, win 28960, options <span class="o">[</span>mss 1460,sackOK,TS val <span class="m">22099541</span> ecr 3365688110,nop,wscale 5<span class="o">]</span>, length <span class="m">0</span>
18:28:28.350812 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>.<span class="o">]</span>, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688111</span> ecr 22099541<span class="o">]</span>, length <span class="m">0</span>
18:28:28.357328 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 1:518, ack 1, win 502, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688118</span> ecr 22099541<span class="o">]</span>, length <span class="m">517</span>
18:28:28.359281 IP 198.18.5.130.443 &gt; 172.17.0.4.54636: Flags <span class="o">[</span>.<span class="o">]</span>, ack 518, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099542</span> ecr 3365688118<span class="o">]</span>, length <span class="m">0</span>
18:28:28.726578 IP 198.18.5.130.443 &gt; 172.17.0.4.54636: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 1:2622, ack 518, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099579</span> ecr 3365688118<span class="o">]</span>, length <span class="m">2621</span>
18:28:28.726610 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>.<span class="o">]</span>, ack 2622, win 482, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688487</span> ecr 22099579<span class="o">]</span>, length <span class="m">0</span>
18:28:28.727633 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 518:598, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">80</span>
18:28:28.727798 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 598:644, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">46</span>
18:28:28.727825 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 644:693, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">49</span>
18:28:28.727847 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 693:728, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">35</span>
18:28:28.727871 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 728:812, ack 2622, win 501, options <span class="o">[</span>nop,nop,TS val <span class="m">3365688488</span> ecr 22099579<span class="o">]</span>, length <span class="m">84</span>
18:28:28.729308 IP 198.18.5.130.443 &gt; 172.17.0.4.54636: Flags <span class="o">[</span>.<span class="o">]</span>, ack 598, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099579</span> ecr 3365688488<span class="o">]</span>, length <span class="m">0</span>
18:28:28.729324 IP 198.18.5.130.443 &gt; 172.17.0.4.54636: Flags <span class="o">[</span>.<span class="o">]</span>, ack 644, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099579</span> ecr 3365688488<span class="o">]</span>, length <span class="m">0</span>
18:28:28.729328 IP 198.18.5.130.443 &gt; 172.17.0.4.54636: Flags <span class="o">[</span>.<span class="o">]</span>, ack 693, win 939, options <span class="o">[</span>nop,nop,TS val <span class="m">22099579</span> ecr 3365688488<span class="o">]</span>, length <span class="m">0</span>
</code></pre></td></tr></table>
</div>
</div><p>能看到数据确实在进入 docker0 网桥前，dst_ip 确实被从 <code>192.168.31.228</code>（wlp4s0 的 ip）被修改为了 <code>172.17.0.4</code>（<code>Container A</code> 的 ip）.</p>
<h3 id="nat-如何分配端口">NAT 如何分配端口？</h3>
<p>上一节我们实际测试发现，docker 容器的流量在经过 iptables 的 MASQUERADE 规则处理后，只有 src ip 被修改了，而 port 仍然是一致的。</p>
<p>但是如果 NAT 不修改连接的端口，实际上是会有问题的。如果有两个容器同时向 <code>ip: 198.18.5.130, port: 443</code> 发起请求，又恰好使用了同一个 src port，在宿主机上就会出现端口冲突！
因为这两个请求被 SNAT 时，如果只修改 src ip，那它们映射到的将是主机上的同一个连接！</p>
<p>这个问题 NAT 是如何解决的呢？我想如果遇到这种情况，NAT 应该会通过一定的规则选用一个不同的端口。</p>
<p>有空可以翻一波源码看看这个，待续&hellip;</p>
<h2 id="如何持久化-iptables-配置">如何持久化 iptables 配置</h2>
<p>首先需要注意的是，centos7/opensuse 15 都已经切换到了 firewalld 作为防火墙配置软件，
而 ubuntu18.04 lts 也换成了 ufw 来配置防火墙。</p>
<p>包括 docker 应该也是在启动的时候动态添加 iptables 配置。</p>
<p>对于上述新系统，还是建议直接使用 firewalld/ufw 配置防火墙吧，或者网上搜下关闭 ufw/firewalld、启用 iptables 持久化的解决方案。</p>
<p>本文主要目的在于理解 docker 容器网络的原理，以及为后面理解 kubernetes 网络插件 calico/flannel 打好基础，因此就不多介绍持久化了。</p>
<h2 id="如何使用-iptables--bridge--veth-实现容器网络">如何使用 iptables + bridge + veth 实现容器网络</h2>
<p>Docker/Podman 默认使用的都是 bridge 网络，它们的底层实现完全类似。下面以 docker 为例进行分析（Podman 的分析流程也基本一样）。</p>
<h3 id="通过-docker-run-运行容器">通过 docker run 运行容器</h3>
<p>首先，使用 <code>docker run</code> 运行几个容器，检查下网络状况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 运行一个 debian 容器和一个 nginx</span>
❯ docker run -dit --name debian --rm debian:buster sleep <span class="m">1000000</span>
❯ docker run -dit --name nginx --rm nginx:1.19-alpine 

<span class="c1">#　查看网络接口，有两个 veth 接口（而且都没设 ip 地址），分别连接到两个容器的 eth0（dcoker0 网络架构图前面给过了，可以往前面翻翻对照下）</span>
❯ ip addr ls
...
5: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default 
    link/ether 02:42:42:c7:12:ba brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:42ff:fec7:12ba/64 scope link 
       valid_lft forever preferred_lft forever
100: veth16b37ea@if99: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master docker0 state UP group default 
    link/ether 42:af:34:ae:74:ae brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">0</span>
    inet6 fe80::40af:34ff:feae:74ae/64 scope link 
       valid_lft forever preferred_lft forever
102: veth4b4dada@if101: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master docker0 state UP group default 
    link/ether 9e:f1:58:1a:cf:ae brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">1</span>
    inet6 fe80::9cf1:58ff:fe1a:cfae/64 scope link 
       valid_lft forever preferred_lft forever

<span class="c1"># 两个 veth 接口都连接到了 docker0 上面，说明两个容器都使用了 docker 默认的 bridge 网络</span>
❯ sudo brctl show
bridge name     bridge id               STP enabled     interfaces
docker0         8000.024242c712ba       no              veth16b37ea
                                                        veth4b4dada

<span class="c1"># 查看路由规则</span>
❯ ip route ls
default via 192.168.31.1 dev wlp4s0 proto dhcp metric <span class="m">600</span>
<span class="c1">#下列路由规则将 `172.17.0.0/16` 网段的所有流量转发到 docker0</span>
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown 
192.168.31.0/24 dev wlp4s0 proto kernel scope link src 192.168.31.228 metric <span class="m">600</span> 

<span class="c1"># 查看　iptables 规则</span>
<span class="c1"># NAT 表</span>
❯ sudo iptables -t nat -S
-P PREROUTING ACCEPT
-P INPUT ACCEPT
-P OUTPUT ACCEPT
-P POSTROUTING ACCEPT
-N DOCKER
<span class="c1"># 所有目的地址在本机的，都先交给 DOCKER 链处理一波</span>
-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER
<span class="c1"># （容器访问外部网络）所有出口不为 docker0 的流量，都做下 SNAT，把 src ip 换成出口接口的 ip 地址</span>
-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE
-A DOCKER -i docker0 -j RETURN

<span class="c1"># filter 表</span>
❯ sudo iptables -t filter -S
-P INPUT ACCEPT
-P FORWARD DROP
-P OUTPUT ACCEPT
-N DOCKER
-N DOCKER-ISOLATION-STAGE-1
-N DOCKER-ISOLATION-STAGE-2
-N DOCKER-USER
<span class="c1"># 所有流量都必须先经过如下两个链的处理，没问题才能继续往下走</span>
-A FORWARD -j DOCKER-ISOLATION-STAGE-1
-A FORWARD -j DOCKER-USER
<span class="c1"># （容器访问外部网络）出去的流量走了 MASQUERADE，回来的流量会被 conntrack 识别并转发回来，这里允许返回的数据包通过。</span>
<span class="c1"># 这里直接 ACCEPT 被 conntrack 识别到的流量</span>
-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
<span class="c1"># 将所有访问 docker0 的流量都转给自定义链 DOCKER 处理</span>
-A FORWARD -o docker0 -j DOCKER
<span class="c1"># 允许所有来自 docker0 的流量通过，不论下一跳是否是 docker0</span>
-A FORWARD -i docker0 ! -o docker0 -j ACCEPT
-A FORWARD -i docker0 -o docker0 -j ACCEPT
<span class="c1"># 下面三个链目前啥规则也没有，就是简单的 RETURN，交给后面的表继续处理</span>
-A DOCKER-ISOLATION-STAGE-1 -j RETURN
-A DOCKER-ISOLATION-STAGE-2 -j RETURN
-A DOCKER-USER -j RETURN
</code></pre></td></tr></table>
</div>
</div><p>接下来使用如下 docker-compose 配置启动一个 caddy　容器，添加自定义 network 和端口映射，待会就能验证 docker 是如何实现这两种网络的了。</p>
<p><code>docker-compose.yml</code> 内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;3.3&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">caddy</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;caddy:2.2.1-alpine&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;caddy&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">always</span><span class="w">
</span><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l">caddy file-server --browse --root /data/static</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;8081:80&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;/home/ryan/Downloads:/data/static&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="l">caddy-1</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">caddy-1</span><span class="p">:</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>现在先用上面的配置启动 caddy 容器，然后再查看网络状况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 启动 caddy</span>
❯ docker-compose up -d
<span class="c1"># 查下 caddy 容器的 ip</span>
&gt; docker inspect caddy <span class="p">|</span> grep IPAddress
...
    <span class="s2">&#34;IPAddress&#34;</span>: <span class="s2">&#34;172.18.0.2&#34;</span>,

<span class="c1"># 查看网络接口，可以看到多了一个网桥，它就是上一行命令创建的 caddy-1 网络</span>
<span class="c1"># 还多了一个 veth，它连接到了 caddy 容器的 eth0(veth) 接口</span>
❯ ip addr ls
...
5: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default 
    link/ether 02:42:42:c7:12:ba brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:42ff:fec7:12ba/64 scope link 
       valid_lft forever preferred_lft forever
100: veth16b37ea@if99: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master docker0 state UP group default 
    link/ether 42:af:34:ae:74:ae brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">0</span>
    inet6 fe80::40af:34ff:feae:74ae/64 scope link 
       valid_lft forever preferred_lft forever
102: veth4b4dada@if101: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master docker0 state UP group default 
    link/ether 9e:f1:58:1a:cf:ae brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">1</span>
    inet6 fe80::9cf1:58ff:fe1a:cfae/64 scope link 
       valid_lft forever preferred_lft forever
103: br-ac3e0514d837: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default 
    link/ether 02:42:7d:95:ba:7e brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.1/16 brd 172.18.255.255 scope global br-ac3e0514d837
       valid_lft forever preferred_lft forever
    inet6 fe80::42:7dff:fe95:ba7e/64 scope link 
       valid_lft forever preferred_lft forever
105: veth0c25c6f@if104: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master br-ac3e0514d837 state UP group default 
    link/ether 9a:03:e1:f0:26:ea brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">2</span>
    inet6 fe80::9803:e1ff:fef0:26ea/64 scope link 
       valid_lft forever preferred_lft forever


<span class="c1"># 查看网桥，能看到 caddy 容器的 veth 接口连在了 caddy-1 这个网桥上，没有加入到 docker0 网络</span>
❯ sudo brctl show
bridge name     bridge id               STP enabled     interfaces
br-ac3e0514d837         8000.02427d95ba7e       no              veth0c25c6f
docker0         8000.024242c712ba       no              veth16b37ea
                                                        veth4b4dada

<span class="c1"># 查看路由，能看到新网桥使用的地址段是 172.18.0.0/16，是 docker0 递增上来的 </span>
❯ ip route ls
default via 192.168.31.1 dev wlp4s0 proto dhcp metric <span class="m">600</span> 
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 
<span class="c1"># 多了一个网桥的</span>
172.18.0.0/16 dev br-ac3e0514d837 proto kernel scope link src 172.18.0.1 
192.168.31.0/24 dev wlp4s0 proto kernel scope link src 192.168.31.228 metric <span class="m">600</span> 

<span class="c1"># iptables 中也多了 caddy-1 网桥的 MASQUERADE 规则，以及端口映射的规则</span>
❯ sudo iptables -t nat -S
-P PREROUTING ACCEPT
-P INPUT ACCEPT
-P OUTPUT ACCEPT
-P POSTROUTING ACCEPT
-N DOCKER
-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER
-A POSTROUTING -s 172.18.0.0/16 ! -o br-ac3e0514d837 -j MASQUERADE
-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE
<span class="c1"># 端口映射过来的入网流量，都做下 SNAT，把 src ip 换成出口 docker0 的 ip 地址</span>
-A POSTROUTING -s 172.18.0.2/32 -d 172.18.0.2/32 -p tcp -m tcp --dport <span class="m">80</span> -j MASQUERADE
-A DOCKER -i br-ac3e0514d837 -j RETURN
-A DOCKER -i docker0 -j RETURN
<span class="c1"># 主机上所有其他接口进来的 tcp 流量，只要目标端口是 8081，就转发到 caddy 容器去（端口映射）</span>
<span class="c1"># DOCKER 是被 PREROUTEING 链的 target，因此这会导致流量直接走了 FORWARD 链，直接绕过了通常设置在 INPUT 链的主机防火墙规则！</span>
-A DOCKER ! -i br-ac3e0514d837 -p tcp -m tcp --dport <span class="m">8081</span> -j DNAT --to-destination 172.18.0.2:80

❯ sudo iptables -t filter -S
-P INPUT ACCEPT
-P FORWARD DROP
-P OUTPUT ACCEPT
-N DOCKER
-N DOCKER-ISOLATION-STAGE-1
-N DOCKER-ISOLATION-STAGE-2
-N DOCKER-USER
-A FORWARD -j DOCKER-USER
-A FORWARD -j DOCKER-ISOLATION-STAGE-1
<span class="c1"># 给 caddy-1 bridge 网络添加的转发规则，与 docker0 的规则完全一一对应，就不多介绍了。</span>
-A FORWARD -o br-ac3e0514d837 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -o br-ac3e0514d837 -j DOCKER
-A FORWARD -i br-ac3e0514d837 ! -o br-ac3e0514d837 -j ACCEPT
-A FORWARD -i br-ac3e0514d837 -o br-ac3e0514d837 -j ACCEPT
-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -o docker0 -j DOCKER
-A FORWARD -i docker0 ! -o docker0 -j ACCEPT
-A FORWARD -i docker0 -o docker0 -j ACCEPT
<span class="c1"># 这一条仍然是端口映射相关的规则，接受所有从其他接口过来的，请求 80 端口且出口是 caddy-1 网桥的流量</span>
-A DOCKER -d 172.18.0.2/32 ! -i br-ac3e0514d837 -o br-ac3e0514d837 -p tcp -m tcp --dport <span class="m">80</span> -j ACCEPT
<span class="c1"># 当存在多个 bridge 网络的时候，docker 就会在下面两个 STAGE 链中处理将它们隔离开，禁止互相访问</span>
-A DOCKER-ISOLATION-STAGE-1 -i br-ac3e0514d837 ! -o br-ac3e0514d837 -j DOCKER-ISOLATION-STAGE-2
-A DOCKER-ISOLATION-STAGE-1 -i docker0 ! -o docker0 -j DOCKER-ISOLATION-STAGE-2
-A DOCKER-ISOLATION-STAGE-1 -j RETURN
<span class="c1"># 这里延续上面 STAGE-1 的处理，彻底隔离两个网桥的流量</span>
-A DOCKER-ISOLATION-STAGE-2 -o br-ac3e0514d837 -j DROP
-A DOCKER-ISOLATION-STAGE-2 -o docker0 -j DROP
-A DOCKER-ISOLATION-STAGE-2 -j RETURN
-A DOCKER-USER -j RETURN
</code></pre></td></tr></table>
</div>
</div><p>到这里，我们简单地分析了下 docker 如何通过 iptables 实现 bridge 网络和端口映射。
有了这个基础，后面就可以尝试深入分析 kubernetes 网络插件 flannel/calico/cilium 了哈哈。</p>
<h2 id="dockerpodman-的-macvlanipvlan-模式">Docker/Podman 的 macvlan/ipvlan 模式</h2>
<blockquote>
<p>注意：macvlan 和 wifi 好像不兼容，测试时不要使用无线网络的接口！</p>
</blockquote>
<p>我在前面介绍 Linux 虚拟网络接口的文章中，有介绍过 macvlan 和 ipvlan 两种新的虚拟接口。</p>
<p>目前 Podman/Docker 都支持使用 macvlan 来构建容器网络，这种模式下创建的容器直连外部网络，容器可以拥有独立的外部 IP，不需要端口映射，也不需要借助 iptables.</p>
<p>这和虚拟机的 Bridge 模式就很类似，主要适用于希望容器拥有独立外部 IP 的情况。</p>
<p>下面详细分析下 Docker 的 macvlan 网络（Podman 应该也完全类似）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 首先创建一个 macvlan 网络</span>
<span class="c1"># subnet/gateway 的参数需要和物理网络一致</span>
<span class="c1"># 通过 -o parent 设定父接口，我本机的以太网口名称为 eno1</span>
$ docker network create -d macvlan <span class="se">\
</span><span class="se"></span>  --subnet<span class="o">=</span>192.168.31.0/24 <span class="se">\
</span><span class="se"></span>  --gateway<span class="o">=</span>192.168.31.1 <span class="se">\
</span><span class="se"></span>  -o <span class="nv">parent</span><span class="o">=</span>eno1 <span class="se">\
</span><span class="se"></span>  macnet0

<span class="c1"># 现在使用 macvlan 启动一个容器试试</span>
<span class="c1"># 建议和我一样，通过 --ip 手动配置静态 ip 地址，当然不配也可以，DHCP 会自动分配 IP</span>
$ docker run --network macnet0 --ip<span class="o">=</span>192.168.31.233 --rm -it buildpack-deps:buster-curl /bin/bash
<span class="c1"># 在容器中查看网络接口状况，能看到 eth0 是一个 macvlan 接口</span>
root@4319488cb5e7:/# ip -d addr ls
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="m">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity <span class="m">0</span> minmtu <span class="m">0</span> maxmtu <span class="m">0</span> numtxqueues <span class="m">1</span> numrxqueues <span class="m">1</span> gso_max_size <span class="m">65536</span> gso_max_segs <span class="m">65535</span> 
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
8: eth0@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default 
    link/ether 02:42:c0:a8:1f:e9 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">0</span> promiscuity <span class="m">0</span> minmtu <span class="m">68</span> maxmtu <span class="m">9194</span> 
    macvlan mode bridge numtxqueues <span class="m">1</span> numrxqueues <span class="m">1</span> gso_max_size <span class="m">64000</span> gso_max_segs <span class="m">64</span> 
    inet 192.168.31.233/24 brd 192.168.31.255 scope global eth0
       valid_lft forever preferred_lft forever
<span class="c1"># 路由表，默认 gateway 被自动配置进来了</span>
root@4319488cb5e7:/# ip route ls
default via 192.168.31.1 dev eth0 
192.168.31.0/24 dev eth0 proto kernel scope link src 192.168.31.233 

<span class="c1"># 可以正常访问 baidu</span>
root@4319488cb5e7:/# curl baidu.com
&lt;html&gt;
&lt;meta http-equiv<span class="o">=</span><span class="s2">&#34;refresh&#34;</span> <span class="nv">content</span><span class="o">=</span><span class="s2">&#34;0;url=http://www.baidu.com/&#34;</span>&gt;
&lt;/html&gt;
</code></pre></td></tr></table>
</div>
</div><p>Docker 支持的另一种网络模式是 ipvlan（ipvlan 和 macvlan 的区别我在前一篇文章中已经介绍过，不再赘言），创建命令和 macvlan 几乎一样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 首先创建一个 macvlan 网络</span>
<span class="c1"># subnet/gateway 的参数需要和物理网络一致</span>
<span class="c1"># 通过 -o parent 设定父接口，我本机的以太网口名称为 eno1</span>
<span class="c1"># ipvlan_mode 默认为 l2，表示工作在数据链路层。</span>
$ docker network create -d ipvlan <span class="se">\
</span><span class="se"></span>  --subnet<span class="o">=</span>192.168.31.0/24 <span class="se">\
</span><span class="se"></span>  --gateway<span class="o">=</span>192.168.31.1 <span class="se">\
</span><span class="se"></span>  -o <span class="nv">parent</span><span class="o">=</span>eno1 <span class="se">\
</span><span class="se"></span>  -o <span class="nv">ipvlan_mode</span><span class="o">=</span>l2 <span class="se">\
</span><span class="se"></span>  ipvnet0

<span class="c1"># 现在使用 macvlan 启动一个容器试试</span>
<span class="c1"># 建议和我一样，通过 --ip 手动配置静态 ip 地址，当然不配也可以，DHCP 会自动分配 IP</span>
$ docker run --network ipvnet0 --ip<span class="o">=</span>192.168.31.234 --rm -it buildpack-deps:buster-curl /bin/bash
<span class="c1"># 在容器中查看网络接口状况，能看到 eth0 是一个 ipvlan 接口</span>
root@d0764ebbbf42:/# ip -d addr ls
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="m">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity <span class="m">0</span> minmtu <span class="m">0</span> maxmtu <span class="m">0</span> numtxqueues <span class="m">1</span> numrxqueues <span class="m">1</span> gso_max_size <span class="m">65536</span> gso_max_segs <span class="m">65535</span> 
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
12: eth0@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UNKNOWN group default 
    link/ether 38:f3:ab:a3:e6:71 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">0</span> promiscuity <span class="m">0</span> minmtu <span class="m">68</span> maxmtu <span class="m">65535</span> 
    ipvlan  mode l2 bridge numtxqueues <span class="m">1</span> numrxqueues <span class="m">1</span> gso_max_size <span class="m">64000</span> gso_max_segs <span class="m">64</span> 
    inet 192.168.31.234/24 brd 192.168.31.255 scope global eth0
       valid_lft forever preferred_lft forever
<span class="c1"># 路由表，默认 gateway 被自动配置进来了</span>
root@d0764ebbbf42:/# ip route ls
default via 192.168.31.1 dev eth0 
192.168.31.0/24 dev eth0 proto kernel scope link src 192.168.31.234 

<span class="c1"># 可以正常访问 baidu</span>
root@d0764ebbbf42:/# curl baidu.com
&lt;html&gt;
&lt;meta http-equiv<span class="o">=</span><span class="s2">&#34;refresh&#34;</span> <span class="nv">content</span><span class="o">=</span><span class="s2">&#34;0;url=http://www.baidu.com/&#34;</span>&gt;
&lt;/html&gt;
</code></pre></td></tr></table>
</div>
</div><h2 id="rootless-容器的网络实现">Rootless 容器的网络实现</h2>
<p>如果容器运行时也在 Rootless 模式下运行，那它就没有权限在宿主机添加 bridge/veth 等虚拟网络接口，这种情况下，我们前面描述的容器网络就无法设置了。</p>
<p>那么 podman/containerd(nerdctl) 目前是如何在 Rootless 模式下构建容器网络的呢？</p>
<p>查看文档，发现它们都用到了 rootlesskit 相关的东西，而 rootlesskit 提供了 rootless 网络的几个实现，文档参见 <a href="https://github.com/rootless-containers/rootlesskit/blob/master/docs/network.md" target="_blank" rel="noopener noreferrer">rootlesskit/docs/network.md</a></p>
<p>其中目前推荐使用，而且 podman/containerd(nerdctl) 都默认使用的方案，是 <a href="https://github.com/rootless-containers/slirp4netns" target="_blank" rel="noopener noreferrer">rootless-containers/slirp4netns</a></p>
<p>以 containerd(nerdctl) 为例，按官方文档安装好后，随便启动几个容器，然后在宿主机查 <code>iptables</code>/<code>ip addr ls</code>，会发现啥也没有。
这显然是因为 rootless 模式下 containerd 改不了宿主机的 iptables 配置和虚拟网络接口。但是可以查看到宿主机 slirp4netns 在后台运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">❯ ps aux <span class="p">|</span> grep tap
ryan     <span class="m">11644</span>  0.0  0.0   <span class="m">5288</span>  <span class="m">3312</span> ?        S    00:01   0:02 slirp4netns --mtu <span class="m">65520</span> -r <span class="m">3</span> --disable-host-loopback --enable-sandbox --enable-seccomp <span class="m">11625</span> tap0
</code></pre></td></tr></table>
</div>
</div><p>但是我看半天文档，只看到怎么使用 <code>rootlesskit</code>/<code>slirp4netns</code> 创建新的名字空间，没看到有介绍如何进入一个已存在的 <code>slirp4netns</code> 名字空间&hellip;</p>
<p>使用 <code>nsenter -a -t 11644</code> 也一直报错，任何程序都是 <code>no such binary</code>&hellip;</p>
<p>以后有空再重新研究一波&hellip;</p>
<p>总之能确定的是，它通过在虚拟的名字空间中创建了一个 <code>tap</code> 虚拟接口来实现容器网络，性能相比前面介绍的网络多少是要差一点的。</p>
<h2 id="nftables">nftables</h2>
<p>前面介绍了 iptables 以及其在 docker 和防火墙上的应用。但是实际上目前各大 Linux 发行版都已经不建议使用 iptables 了，甚至把 iptables 重命名为了 <code>iptables-leagacy</code>.</p>
<p>目前 opensuse/debian/opensuse 都已经预装了并且推荐使用 nftables，<strong>而且 firewalld 已经默认使用 nftables 作为它的后端了</strong>。</p>
<p>我在 opensuse tumbleweed 上实测，firewalld 添加的是 nftables 配置，而 docker 仍然在用旧的 iptables，也就是说我现在的机器上有两套 netfilter 工具并存：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># 查看 iptables 数据
&gt; iptables -S
-P INPUT ACCEPT
-P FORWARD DROP
-P OUTPUT ACCEPT
-N DOCKER
-N DOCKER-ISOLATION-STAGE-1
-N DOCKER-ISOLATION-STAGE-2
-N DOCKER-USER
-A FORWARD -j DOCKER-ISOLATION-STAGE-1
-A FORWARD -o br-e3fbbb7a1b3a -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -o br-e3fbbb7a1b3a -j DOCKER
...

# 确认下是否使用了 nftables 的兼容层，结果提示请我使用 iptables-legacy
&gt; iptables-nft -S
# Warning: iptables-legacy tables present, use iptables-legacy to see them
-P INPUT ACCEPT
-P FORWARD ACCEPT
-P OUTPUT ACCEPT

# 查看 nftables 规则，能看到三张 firewalld 生成的 table
&gt; nft list ruleset
table inet firewalld {
    ...
}
table ip firewalld {
    ...
}
table ip6 firewalld {
    ...
}
</code></pre></td></tr></table>
</div>
</div><p>但是现在 kubernetes/docker 都还是用的 iptables，nftables 我学了用处不大，以后有空再补充。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.zsythink.net/archives/1199" target="_blank" rel="noopener noreferrer">iptables详解（1）：iptables概念</a></li>
<li><a href="https://linux.cn/article-13364-1.html" target="_blank" rel="noopener noreferrer">网络地址转换（NAT）之报文跟踪</a></li>
<li><a href="https://developer.aliyun.com/article/700923" target="_blank" rel="noopener noreferrer">容器安全拾遗 - Rootless Container初探</a></li>
<li><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener noreferrer">netfilter - wikipedia</a></li>
</ul>
]]></description></item><item><title>Linux 中的虚拟网络接口</title><link>https://thiscute.world/posts/linux-virtual-network-interfaces/</link><pubDate>Sat, 14 Aug 2021 11:13:03 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/linux-virtual-network-interfaces/</guid><description><![CDATA[<blockquote>
<p>本文用到的字符画工具：<a href="https://github.com/zenghongtu/vscode-asciiflow2" target="_blank" rel="noopener noreferrer">vscode-asciiflow2</a></p>
</blockquote>
<blockquote>
<p>注意: 本文中使用 <code>ip</code> 命令创建或修改的任何网络配置，都是未持久化的，主机重启即消失。</p>
</blockquote>
<p>Linux 具有强大的虚拟网络能力，这也是 openstack 网络、docker 容器网络以及 kubernetes 网络等虚拟网络的基础。</p>
<p>这里介绍 Linux 常用的虚拟网络接口类型：TUN/TAP、bridge、veth、ipvlan/macvlan、vlan 以及 vxlan/geneve.</p>
<h2 id="一tuntap-虚拟网络接口">一、tun/tap 虚拟网络接口</h2>
<p>tun/tap 是操作系统内核中的虚拟网络设备，他们为用户层程序提供数据的接收与传输。</p>
<p>普通的物理网络接口如 eth0，它的两端分别是内核协议栈和外面的物理网络。</p>
<p>而对于 TUN/TAP 虚拟接口如 tun0，它的一端一定是连接的用户层程序，另一端则视配置方式的不同而变化，可以直连内核协议栈，也可以是某个 bridge（后面会介绍）。
Linux 通过内核模块 TUN 提供 tun/tap 功能，该模块提供了一个设备接口 <code>/dev/net/tun</code> 供用户层程序读写，用户层程序通过 <code>/dev/net/tun</code> 读写主机内核协议栈的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">&gt; modinfo tun
filename:       /lib/modules/5.13.6-1-default/kernel/drivers/net/tun.ko.xz
alias:          devname:net/tun
alias:          char-major-10-200
license:        GPL
author:         (C) 1999-2004 Max Krasnyansky &lt;maxk@qualcomm.com&gt;
description:    Universal TUN/TAP device driver
...

&gt; ls /dev/net/tun
/dev/net/tun
</code></pre></td></tr></table>
</div>
</div><p>一个 TUN 设备的示例图如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">             
+----------------------------------------------------------------------+
|                                                                      |
|  +--------------------+      +--------------------+                  |
|  | User Application A |      | User Application B +&lt;-----+           |
|  +------------+-------+      +-------+------------+      |           |
|               | 1                    | 5                 |           |
|...............+......................+...................|...........|
|               ↓                      ↓                   |           |
|         +----------+           +----------+              |           |
|         | socket A |           | socket B |              |           |
|         +-------+--+           +--+-------+              |           |
|                 | 2               | 6                    |           |
|.................+.................+......................|...........|
|                 ↓                 ↓                      |           |
|             +------------------------+          +--------+-------+   |
|             | Network Protocol Stack |          |  /dev/net/tun  |   |
|             +--+-------------------+-+          +--------+-------+   |
|                | 7                 | 3                   ^           |
|................+...................+.....................|...........|
|                ↓                   ↓                     |           |
|        +----------------+    +----------------+        4 |           |
|        |      eth0      |    |      tun0      |          |           |
|        +-------+--------+    +-----+----------+          |           |
|    10.32.0.11  |                   |   192.168.3.11      |           |
|                | 8                 +---------------------+           |
|                |                                                     |
+----------------+-----------------------------------------------------+
                 ↓
         Physical Network
</code></pre></td></tr></table>
</div>
</div><p>因为 TUN/TAP 设备的一端是内核协议栈，显然流入 tun0 的数据包是先经过本地的路由规则匹配的。</p>
<p>路由匹配成功，数据包被发送到 tun0 后，tun0 发现另一端是通过 <code>/dev/net/tun</code> 连接到应用程序 B，就会将数据丢给应用程序 B。</p>
<p>应用程序对数据包进行处理后，可能会构造新的数据包，通过物理网卡发送出去。比如常见的 VPN 程序就是把原来的数据包封装/加密一遍，再发送给 VPN 服务器。</p>
<h3 id="c-语言编程测试-tun-设备">C 语言编程测试 TUN 设备</h3>
<p>为了使用 tun/tap 设备，用户层程序需要通过系统调用打开 <code>/dev/net/tun</code> 获得一个读写该设备的文件描述符(FD)，并且调用 <code>ioctl()</code> 向内核注册一个 TUN 或 TAP 类型的虚拟网卡(实例化一个 tun/tap 设备)，其名称可能是 <code>tun0/tap0</code> 等。</p>
<p>此后，用户程序可以通过该 TUN/TAP 虚拟网卡与主机内核协议栈（或者其他网络设备）交互。当用户层程序关闭后，其注册的 TUN/TAP 虚拟网卡以及自动生成的路由表相关条目都会被内核释放。</p>
<p>可以把用户层程序看做是网络上另一台主机，他们通过 tun/tap 虚拟网卡相连。</p>
<p>一个简单的 C 程序示例如下，它每次收到数据后，都只单纯地打印一下收到的字节数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;linux/if.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;linux/if_tun.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/ioctl.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">tun_alloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>

    <span class="k">struct</span> <span class="n">ifreq</span> <span class="n">ifr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">clonedev</span> <span class="o">=</span> <span class="s">&#34;/dev/net/tun&#34;</span><span class="p">;</span>

    <span class="c1">// 打开 tun 文件，获得 fd
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">clonedev</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ifr</span><span class="p">));</span>
    <span class="n">ifr</span><span class="p">.</span><span class="n">ifr_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

    <span class="c1">// 向内核注册一个 TUN 网卡，并与前面拿到的 fd 关联起来
</span><span class="c1"></span>    <span class="c1">// 程序关闭时，注册的 tun 网卡及自动生成的相关路由策略，会被自动释放
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">TUNSETIFF</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Open tun/tap device: %s for reading...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>

    <span class="kt">int</span> <span class="n">tun_fd</span><span class="p">,</span> <span class="n">nread</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1500</span><span class="p">];</span>

    <span class="cm">/* Flags: IFF_TUN   - TUN device (no Ethernet headers)
</span><span class="cm">     *        IFF_TAP   - TAP device
</span><span class="cm">     *        IFF_NO_PI - Do not provide packet information
</span><span class="cm">     */</span>
    <span class="n">tun_fd</span> <span class="o">=</span> <span class="n">tun_alloc</span><span class="p">(</span><span class="n">IFF_TUN</span> <span class="o">|</span> <span class="n">IFF_NO_PI</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tun_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;Allocating interface&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">tun_fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">perror</span><span class="p">(</span><span class="s">&#34;Reading from interface&#34;</span><span class="p">);</span>
            <span class="n">close</span><span class="p">(</span><span class="n">tun_fd</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Read %d bytes from tun/tap device</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">nread</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>接下来开启三个终端窗口来测试上述程序，分别运行上面的 tun 程序、tcpdump 和 iproute2 指令。</p>
<p>首先通过编译运行上述 c 程序，程序会阻塞住，等待数据到达：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># 编译，请忽略部分 warning
&gt; gcc mytun.c -o mytun

# 创建并监听 tun 设备需要 root 权限
&gt; sudo mytun 
Open tun/tap device: tun0 for reading...
</code></pre></td></tr></table>
</div>
</div><p>现在使用 iproute2 查看下链路层设备：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># 能发现最后面有列出名为 tun0 的接口，但是状态为 down
❯ ip addr ls
......
3: wlp4s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000
    link/ether c0:3c:59:36:a4:16 brd ff:ff:ff:ff:ff:ff
    inet 192.168.31.228/24 brd 192.168.31.255 scope global dynamic noprefixroute wlp4s0
       valid_lft 41010sec preferred_lft 41010sec
    inet6 fe80::4ab0:130f:423b:5d37/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
7: tun0: &lt;POINTOPOINT,MULTICAST,NOARP&gt; mtu 1500 qdisc noop state DOWN group default qlen 500
    link/none 

# 为 tun0 设置 ip 地址，注意不要和其他接口在同一网段，会导致路由冲突
&gt; sudo ip addr add 172.21.22.23/24 dev tun0
# 启动 tun0 这个接口，这一步会自动向路由表中添加将 172.21.22.23/24 路由到 tun0 的策略
&gt; sudo ip link set tun0 up
#确认上一步添加的路由策略是否存在
❯ ip route ls
default via 192.168.31.1 dev wlp4s0 proto dhcp metric 600 
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown 
172.21.22.0/24 dev tun0 proto kernel scope link src 172.21.22.23 
192.168.31.0/24 dev wlp4s0 proto kernel scope link src 192.168.31.228 metric 600 

# 此时再查看接口，发现 tun0 状态为 unknown
&gt; ip addr ls
......
8: tun0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN group default qlen 500
    link/none 
    inet 172.21.22.23/24 scope global tun0
       valid_lft forever preferred_lft forever
    inet6 fe80::3d52:49b5:1cf3:38fd/64 scope link stable-privacy 
       valid_lft forever preferred_lft forever

# 使用 tcpdump 尝试抓下 tun0 的数据，会阻塞在这里，等待数据到达
&gt; tcpdump -i tun0
</code></pre></td></tr></table>
</div>
</div><p>现在再启动第三个窗口发点数据给 tun0，持续观察前面 <code>tcpdump</code> 和 <code>mytun</code> 的日志:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># 直接 ping tun0 的地址，貌似有问题，数据没进 mytun 程序，而且还有响应
❯ ping -c 4 172.21.22.23
PING 172.21.22.23 (172.21.22.23) 56(84) bytes of data.
64 bytes from 172.21.22.23: icmp_seq=1 ttl=64 time=0.167 ms
64 bytes from 172.21.22.23: icmp_seq=2 ttl=64 time=0.180 ms
64 bytes from 172.21.22.23: icmp_seq=3 ttl=64 time=0.126 ms
64 bytes from 172.21.22.23: icmp_seq=4 ttl=64 time=0.141 ms

--- 172.21.22.23 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3060ms
rtt min/avg/max/mdev = 0.126/0.153/0.180/0.021 ms

# 但是 ping 该网段下的其他地址，流量就会被转发给 mytun 程序，因为 mytun 啥数据也没回，自然丢包率 100%
# tcpdump 和 mytun 都会打印出相关日志
❯ ping -c 4 172.21.22.26
PING 172.21.22.26 (172.21.22.26) 56(84) bytes of data.

--- 172.21.22.26 ping statistics ---
4 packets transmitted, 0 received, 100% packet loss, time 3055ms
</code></pre></td></tr></table>
</div>
</div><p>下面给出 mytun 的输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Read 84 bytes from tun/tap device
Read 84 bytes from tun/tap device
Read 84 bytes from tun/tap device
Read 84 bytes from tun/tap device
</code></pre></td></tr></table>
</div>
</div><p>以及 tcpdump 的输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">00:22:03.622684 IP (tos 0x0, ttl 64, id 37341, offset 0, flags [DF], proto ICMP (1), length 84)
    172.21.22.23 &gt; 172.21.22.26: ICMP echo request, id 11, seq 1, length 64
00:22:04.633394 IP (tos 0x0, ttl 64, id 37522, offset 0, flags [DF], proto ICMP (1), length 84)
    172.21.22.23 &gt; 172.21.22.26: ICMP echo request, id 11, seq 2, length 64
00:22:05.653356 IP (tos 0x0, ttl 64, id 37637, offset 0, flags [DF], proto ICMP (1), length 84)
    172.21.22.23 &gt; 172.21.22.26: ICMP echo request, id 11, seq 3, length 64
00:22:06.677341 IP (tos 0x0, ttl 64, id 37667, offset 0, flags [DF], proto ICMP (1), length 84)
    172.21.22.23 &gt; 172.21.22.26: ICMP echo request, id 11, seq 4, length 64
</code></pre></td></tr></table>
</div>
</div><p>更复杂的 tun 程序，可以参考</p>
<ul>
<li><a href="https://github.com/gregnietsky/simpletun" target="_blank" rel="noopener noreferrer">simpletun</a></li>
<li><a href="https://github.com/marywangran/simpletun" target="_blank" rel="noopener noreferrer">marywangran/simpletun</a></li>
<li><a href="https://github.com/marywangran/gotun-tunnel/blob/main/tun/tun.go" target="_blank" rel="noopener noreferrer">tun go 语言版</a></li>
</ul>
<h3 id="tun-与-tap-的区别">TUN 与 TAP 的区别</h3>
<p>TUN 和 TAP 的区别在于工作的网络层次不同，用户程序通过 TUN 设备只能读写网络层的 IP 数据包，而 TAP 设备则支持读写链路层的数据包（通常是以太网数据包，带有 Ethernet headers）。</p>
<p>TUN 与 TAP 的关系，就类似于 socket 和 raw socket.</p>
<p>TUN/TAP 应用最多的场景是 VPN 代理，比如:</p>
<ol>
<li><a href="https://github.com/ryan4yin/clash" target="_blank" rel="noopener noreferrer">clash</a>: 一个支持各种规则的隧道，也支持 TUN 模式</li>
<li><a href="https://github.com/xjasonlyu/tun2socks/wiki" target="_blank" rel="noopener noreferrer">tun2socks</a>: 一个全局透明代理，和 VPN 的工作模式一样，它通过创建虚拟网卡+修改路由表，在第三层网络层代理系统流量。</li>
</ol>
<h2 id="二veth">二、veth</h2>
<p>veth 接口总是成对出现，一对 veth 接口就类似一根网线，从一端进来的数据会从另一端出去。</p>
<p>同时 veth 又是一个虚拟网络接口，因此它和 TUN/TAP 或者其他物理网络接口一样，也都能配置 mac/ip 地址（但是并不是一定得配 mac/ip 地址）。</p>
<p>其主要作用就是连接不同的网络，比如在容器网络中，用于将容器的 namespace 与 root namespace 的网桥 br0 相连。
容器网络中，容器侧的 veth 自身设置了 ip/mac 地址并被重命名为 eth0，作为容器的网络接口使用，而主机侧的 veth 则直接连接在 docker0/br0 上面。</p>
<p>使用 veth 实现容器网络，需要结合下一小节介绍的 bridge，在下一小节将给出容器网络结构图。</p>
<h2 id="三bridge">三、bridge</h2>
<p>Linux Bridge 是工作在链路层的网络交换机，由 Linux 内核模块 <code>brige</code> 提供，它负责在所有连接到它的接口之间转发链路层数据包。</p>
<p>添加到 Bridge 上的设备被设置为只接受二层数据帧并且转发所有收到的数据包到 Bridge 中。
在 Bridge 中会进行一个类似物理交换机的查MAC端口映射表、转发、更新MAC端口映射表这样的处理逻辑，从而数据包可以被转发到另一个接口/丢弃/广播/发往上层协议栈，由此 Bridge 实现了数据转发的功能。</p>
<p>如果使用 tcpdump 在 Bridge 接口上抓包，可以抓到网桥上所有接口进出的包，因为这些数据包都要通过网桥进行转发。</p>
<p>与物理交换机不同的是，Bridge 本身可以设置 IP 地址，可以认为当使用 <code>brctl addbr br0</code> 新建一个 br0 网桥时，系统自动创建了一个同名的隐藏 <code>br0</code> 网络接口。<code>br0</code> 一旦设置 IP 地址，就意味着这个隐藏的 br0 接口可以作为路由接口设备，参与 IP 层的路由选择(可以使用 <code>route -n</code> 查看最后一列 <code>Iface</code>)。因此只有当 <code>br0</code> 设置 <code>IP</code> 地址时，Bridge 才有可能将数据包发往上层协议栈。</p>
<p>但被添加到 Bridge 上的网卡是不能配置 IP 地址的，他们工作在数据链路层，对路由系统不可见。</p>
<p>它常被用于在虚拟机、主机上不同的 namepsaces 之间转发数据。</p>
<h3 id="虚拟机场景桥接模式">虚拟机场景（桥接模式）</h3>
<p>以 qemu-kvm 为例，在虚拟机的桥接模式下，qemu-kvm 会为每个虚拟机创建一个 tun/tap 虚拟网卡并连接到 br0 网桥。
虚拟机内部的网络接口 <code>eth0</code> 是 qemu-kvm 软件模拟的，实际上虚拟机内网络数据的收发都会被 qemu-kvm 转换成对 <code>/dev/net/tun</code> 的读写。</p>
<p>以发送数据为例，整个流程如下：</p>
<ul>
<li>虚拟机发出去的数据包先到达 qemu-kvm 程序</li>
<li>数据被用户层程序 qemu-kvm 写入到 <code>/dev/net/tun</code>，到达 tap 设备</li>
<li>tap 设备把数据传送到 br0 网桥</li>
<li>br0 把数据交给 eth0 发送出去</li>
</ul>
<p>整个流程跑完，数据包都不需要经过宿主机的协议栈，效率高。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">+------------------------------------------------+-----------------------------------+-----------------------------------+
|                       Host                     |           VirtualMachine1         |           VirtualMachine2         |
|                                                |                                   |                                   |
|    +--------------------------------------+    |    +-------------------------+    |    +-------------------------+    |
|    |         Network Protocol Stack       |    |    |  Network Protocol Stack |    |    |  Network Protocol Stack |    |
|    +--------------------------------------+    |    +-------------------------+    |    +-------------------------+    |
|                       ↑                        |                ↑                  |                 ↑                 |
|.......................|........................|................|..................|.................|.................|
|                       ↓                        |                ↓                  |                 ↓                 |
|                  +--------+                    |            +-------+              |             +-------+             |
|                  | .3.101 |                    |            | .3.102|              |             | .3.103|             |
|     +------+     +--------+     +-------+      |            +-------+              |             +-------+             |
|     | eth0 |&lt;---&gt;|   br0  |&lt;---&gt;|tun/tap|      |            | eth0  |              |             | eth0  |             |
|     +------+     +--------+     +-------+      |            +-------+              |             +-------+             |
|         ↑             ↑             ↑      +--------+           ↑                  |                 ↑                 |
|         |             |             +------|qemu-kvm|-----------+                  |                 |                 |
|         |             ↓                    +--------+                              |                 |                 |
|         |         +-------+                    |                                   |                 |                 |
|         |         |tun/tap|                    |                                   |                 |                 |
|         |         +-------+                    |                                   |                 |                 |
|         |             ↑                        |            +--------+             |                 |                 |
|         |             +-------------------------------------|qemu-kvm|-------------|-----------------+                 |
|         |                                      |            +--------+             |                                   |
|         |                                      |                                   |                                   |
+---------|--------------------------------------+-----------------------------------+-----------------------------------+
          ↓
    Physical Network  (192.168.3.0/24)
</code></pre></td></tr></table>
</div>
</div><h3 id="跨-namespace-通信场景容器网络nat-模式">跨 namespace 通信场景（容器网络，NAT 模式）</h3>
<blockquote>
<p>docker/podman 提供的 bridge 网络模式，就是使用 veth+bridge+iptalbes 实现的。我会在下一篇文章详细介绍「容器网络」。</p>
</blockquote>
<p>由于容器运行在自己单独的 network namespace 里面，所以和虚拟机一样，它们也都有自己单独的协议栈。</p>
<p>容器网络的结构和虚拟机差不多，但是它改用了 NAT 网络，并把 tun/tap 换成了 veth，导致 docker0 过来的数据，要先经过宿主机协议栈，然后才进入 veth 接口。</p>
<p>多了一层 NAT，以及多走了一层宿主机协议栈，都会导致性能下降。</p>
<p>示意图如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">+-----------------------------------------------+-----------------------------------+-----------------------------------+
|                      Host                     |           Container 1             |           Container 2             |
|                                               |                                   |                                   |
|   +---------------------------------------+   |    +-------------------------+    |    +-------------------------+    |
|   |       Network Protocol Stack          |   |    |  Network Protocol Stack |    |    |  Network Protocol Stack |    |
|   +----+-------------+--------------------+   |    +-----------+-------------+    |    +------------+------------+    |
|        ^             ^                        |                ^                  |                 ^                 |
|........|.............|........................|................|..................|.................|.................|
|        v             v  ↓                     |                v                  |                 v                 |
|   +----+----+  +-----+------+                 |          +-----+-------+          |           +-----+-------+         |
|   | .31.101 |  | 172.17.0.1 |      +------+   |          | 172.17.0.2  |          |           |  172.17.0.3 |         |
|   +---------+  +-------------&lt;----&gt;+ veth |   |          +-------------+          |           +-------------+         |
|   |  eth0   |  |   docker0  |      +--+---+   |          | eth0(veth)  |          |           | eth0(veth)  |         |
|   +----+----+  +-----+------+         ^       |          +-----+-------+          |           +-----+-------+         |
|        ^             ^                |       |                ^                  |                 ^                 |
|        |             |                +------------------------+                  |                 |                 |
|        |             v                        |                                   |                 |                 |
|        |          +--+---+                    |                                   |                 |                 |
|        |          | veth |                    |                                   |                 |                 |
|        |          +--+---+                    |                                   |                 |                 |
|        |             ^                        |                                   |                 |                 |
|        |             +------------------------------------------------------------------------------+                 |
|        |                                      |                                   |                                   |
|        |                                      |                                   |                                   |
+-----------------------------------------------+-----------------------------------+-----------------------------------+
         v
    Physical Network  (192.168.31.0/24)
</code></pre></td></tr></table>
</div>
</div><p>每创建一个新容器，都会在容器的 namespace 里新建一个 veth 接口并命令为 eth0，同时在主 namespace 创建一个 veth，将容器的 eth0 与 docker0 连接。</p>
<p>可以在容器中通过 iproute2 查看到， eth0 的接口类型为 <code>veth</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">❯ docker run -it --rm debian:buster bash
root@5facbe4ddc1e:/# ip --details addr ls
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="m">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity <span class="m">0</span> minmtu <span class="m">0</span> maxmtu <span class="m">0</span> numtxqueues <span class="m">1</span> numrxqueues <span class="m">1</span> gso_max_size <span class="m">65536</span> gso_max_segs <span class="m">65535</span> 
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
20: eth0@if21: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">0</span> promiscuity <span class="m">0</span> minmtu <span class="m">68</span> maxmtu <span class="m">65535</span> 
    veth numtxqueues <span class="m">1</span> numrxqueues <span class="m">1</span> gso_max_size <span class="m">65536</span> gso_max_segs <span class="m">65535</span> 
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
</code></pre></td></tr></table>
</div>
</div><p>同时在宿主机中能看到对应的 veth 设备是绑定到了 docker0 网桥的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">❯ sudo brctl show
bridge name     bridge id               STP enabled     interfaces
docker0         8000.0242fce99ef5       no              vethea4171a
</code></pre></td></tr></table>
</div>
</div><h2 id="四macvlan">四、macvlan</h2>
<blockquote>
<p>目前 docker/podman 都支持创建基于 macvlan 的 Linux 容器网络。</p>
</blockquote>
<blockquote>
<p>注意 macvlan 和 WiFi 存在兼容问题，如果使用笔记本测试，可能会遇到麻烦。</p>
</blockquote>
<blockquote>
<p>参考文档：<a href="https://cizixs.com/2017/02/14/network-virtualization-macvlan/" target="_blank" rel="noopener noreferrer">linux 网络虚拟化： macvlan</a></p>
</blockquote>
<p>macvlan 是比较新的 Linux 特性，需要内核版本 &gt;= 3.9，它被用于在主机的网络接口（父接口）上配置多个虚拟子接口，这些子接口都拥有各自独立的 mac 地址，也可以配上 ip 地址进行通讯。</p>
<p>macvlan 下的虚拟机或者容器网络和主机在同一个网段中，共享同一个广播域。macvlan 和 bridge 比较相似，但因为它省去了 bridge 的存在，所以配置和调试起来比较简单，而且效率也相对高。除此之外，macvlan 自身也完美支持 VLAN。</p>
<p>如果希望容器或者虚拟机放在主机相同的网络中，享受已经存在网络栈的各种优势，可以考虑 macvlan。</p>
<p>我会在下一篇文章对 docker 的 macvlan/ipvlan 做个分析，这里先略过了&hellip;</p>
<h2 id="五ipvlan">五、ipvlan</h2>
<blockquote>
<p><a href="https://cizixs.com/2017/02/17/network-virtualization-ipvlan/" target="_blank" rel="noopener noreferrer">linux 网络虚拟化： ipvlan</a></p>
</blockquote>
<blockquote>
<p>cilium 1.9 已经提供了基于 ipvlan 的网络（beta 特性），用于替换传统的 veth+bridge 容器网络。详见 <a href="https://docs.cilium.io/en/v1.9/gettingstarted/ipvlan/" target="_blank" rel="noopener noreferrer">IPVLAN based Networking (beta) - Cilium 1.9 Docs</a></p>
</blockquote>
<p>ipvlan 和 macvlan 的功能很类似，也是用于在主机的网络接口（父接口）上配置出多个虚拟的子接口。但不同的是，ipvlan 的各子接口没有独立的 mac 地址，它们和主机的父接口共享 mac 地址。</p>
<blockquote>
<p>因为 mac 地址共享，所以如果使用 DHCP，就要注意不能使用 mac 地址做 DHCP，需要额外配置唯一的 clientID.</p>
</blockquote>
<p>如果你遇到以下的情况，请考虑使用 ipvlan：</p>
<ul>
<li>父接口对 mac 地址数目有限制，或者在 mac 地址过多的情况下会造成严重的性能损失</li>
<li>工作在 802.11(wireless)无线网络中（macvlan 无法和无线网络共同工作）</li>
<li>希望搭建比较复杂的网络拓扑（不是简单的二层网络和 VLAN），比如要和 BGP 网络一起工作</li>
</ul>
<p>基于 ipvlan/macvlan 的容器网络，比 veth+bridge+iptables 的性能要更高。</p>
<p>我会在下一篇文章对 docker 的 macvlan/ipvlan 做个分析，这里先略过了&hellip;</p>
<h2 id="六vlan">六、vlan</h2>
<p>vlan 即虚拟局域网，是一个链路层的广播域隔离技术，可以用于切分局域网，解决广播泛滥和安全性问题。被隔离的广播域之间需要上升到第三层才能完成通讯。</p>
<p>常用的企业路由器如 ER-X 基本都可以设置 vlan，Linux 也直接支持了 vlan.</p>
<p>以太网数据包有一个专门的字段提供给 vlan 使用，vlan 数据包会在该位置记录它的 VLAN ID，交换机通过该 ID 来区分不同的 VLAN，只将该以太网报文广播到该 ID 对应的 VLAN 中。</p>
<h2 id="七vxlangeneve">七、vxlan/geneve</h2>
<blockquote>
<p><a href="https://datatracker.ietf.org/doc/html/rfc8926" target="_blank" rel="noopener noreferrer">rfc8926 - Geneve: Generic Network Virtualization Encapsulation</a>
<a href="https://datatracker.ietf.org/doc/html/rfc7348" target="_blank" rel="noopener noreferrer">rfc7348 - Virtual eXtensible Local Area Network (VXLAN)</a></p>
</blockquote>
<blockquote>
<p><a href="https://cizixs.com/2017/09/28/linux-vxlan/" target="_blank" rel="noopener noreferrer">linux 上实现 vxlan 网络</a></p>
</blockquote>
<p>在介绍 vxlan 前，先说明下两个名词的含义：</p>
<ul>
<li><strong>underlay 网络</strong>：即物理网络</li>
<li><strong>overlay 网络</strong>：指在现有的物理网络之上构建的虚拟网络。其实就是一种隧道技术，将原生态的二层数据帧报文进行封装后通过隧道进行传输。</li>
</ul>
<p>vxlan 与 geneve 都是 overlay 网络协议，它俩都是使用 UDP 包来封装链路层的以太网帧。</p>
<p>vxlan 在 2014 年标准化，而 geneve 在 2020 年底才通过草案阶段，目前尚未形成最终标准。但是目前 linux/cilium 都已经支持了 geneve.</p>
<p>geneve 相对 vxlan 最大的变化，是它更灵活——它的 header 长度是可变的。</p>
<p>目前所有 overlay 的跨主机容器网络方案，几乎都是基于 vxlan 实现的（例外：cilium 也支持 geneve）。</p>
<blockquote>
<p>我们在学习单机的容器网络时，不需要接触到 vxlan，但是在学习跨主机容器网络方案如 flannel/calico/cilium 时，那 vxlan(overlay) 及 BGP(underlay) 就不可避免地要接触了。</p>
</blockquote>
<p>先介绍下 vxlan 的数据包结构：</p>
<p><figure><a class="lightgallery" href="/images/linux-virtual-interfaces/vxlan-frame.png" title="/images/linux-virtual-interfaces/vxlan-frame.png" data-thumbnail="/images/linux-virtual-interfaces/vxlan-frame.png" data-sub-html="<h2>VXLAN 栈帧结构</h2>">
        
    </a><figcaption class="image-caption">VXLAN 栈帧结构</figcaption>
    </figure></p>
<p>在创建 vxlan 的 vtep 虚拟设备时，我们需要手动设置图中的如下属性：</p>
<ul>
<li>VXLAN 目标端口：即接收方 vtep 使用的端口，这里 IANA 定义的端口是 4789，但是只有 calico 的 vxlan 模式默认使用该端口 calico，而 cilium/flannel 的默认端口都是 Linux 默认的 8472.</li>
<li>VNID: 每个 VXLAN 网络接口都会被分配一个独立的 VNID</li>
</ul>
<p>一个点对点的 vxlan 网络架构图如下:</p>
<p><figure><a class="lightgallery" href="/images/linux-virtual-interfaces/vxlan-architecture.gif" title="/images/linux-virtual-interfaces/vxlan-architecture.gif" data-thumbnail="/images/linux-virtual-interfaces/vxlan-architecture.gif" data-sub-html="<h2>VXLAN 点对点网络架构</h2>">
        
    </a><figcaption class="image-caption">VXLAN 点对点网络架构</figcaption>
    </figure></p>
<p>可以看到每台虚拟机 VM 都会被分配一个唯一的 VNID，然后两台物理机之间通过 VTEP 虚拟网络设备建立了 VXLAN 隧道，所有 VXLAN 网络中的虚拟机，都通过 VTEP 来互相通信。</p>
<p>有了上面这些知识，我们就可以通过如下命令在两台 Linux 机器间建立一个<strong>点对点的 VXLAN 隧道</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 在主机 A 上创建 VTEP 设备 vxlan0</span>
<span class="c1"># 与另一个 vtep 接口 B（192.168.8.101）建立隧道</span>
<span class="c1"># 将 vxlan0 自身的 IP 地址设为 192.168.8.100</span>
<span class="c1"># 使用的 VXLAN 目标端口为 4789(IANA 标准)</span>
ip link add vxlan0 <span class="nb">type</span> vxlan <span class="se">\
</span><span class="se"></span>    id <span class="m">42</span> <span class="se">\
</span><span class="se"></span>    dstport <span class="m">4789</span> <span class="se">\
</span><span class="se"></span>    remote 192.168.8.101 <span class="se">\
</span><span class="se"></span>    <span class="nb">local</span> 192.168.8.100 <span class="se">\
</span><span class="se"></span>    dev enp0s8
<span class="c1"># 为我们的 VXLAN 网络设置虚拟网段，vxlan0 就是默认网关</span>
ip addr add 10.20.1.2/24 dev vxlan0
<span class="c1"># 启用我们的 vxlan0 设备，这会自动生成路由规则</span>
ip link <span class="nb">set</span> vxlan0 up

<span class="c1"># 现在在主机 B 上运行如下命令，同样创建一个 VTEP 设备 vxlan0，remote 和 local 的 ip 与前面用的命令刚好相反。</span>
<span class="c1"># 注意 VNID 和 dstport 必须和前面完全一致</span>
ip link add vxlan0 <span class="nb">type</span> vxlan <span class="se">\
</span><span class="se"></span>    id <span class="m">42</span> <span class="se">\
</span><span class="se"></span>    dstport <span class="m">4789</span> <span class="se">\
</span><span class="se"></span>    remote 192.168.8.100 <span class="se">\
</span><span class="se"></span>    <span class="nb">local</span> 192.168.8.101 <span class="se">\
</span><span class="se"></span>    dev enp0s8
<span class="c1"># 为我们的 VXLAN 网络设置虚拟网段，vxlan0 就是默认网关</span>
ip addr add 10.20.1.3/24 dev vxlan0
ip link <span class="nb">set</span> vxlan0 up

<span class="c1"># 到这里，两台机器就完成连接，可以通信了。可以在主机 B 上 ping 10.20.1.2 试试，应该能收到主机 A 的回应。</span>
ping 10.20.1.2
</code></pre></td></tr></table>
</div>
</div><p>点对点的 vxlan 隧道实际用处不大，如果集群中的每个节点都互相建 vxlan 隧道，代价太高了。</p>
<p>一种更好的方式，是使用 <strong>「组播模式」的 vxlan 隧道</strong>，这种模式下一个 vtep 可以一次与组内的所有 vtep 建立隧道。
示例命令如下（这里略过了如何设置组播地址 <code>239.1.1.1</code> 的信息）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">ip link add vxlan0 <span class="nb">type</span> vxlan <span class="se">\
</span><span class="se"></span>    id <span class="m">42</span> <span class="se">\
</span><span class="se"></span>    dstport <span class="m">4789</span> <span class="se">\
</span><span class="se"></span>    group 239.1.1.1 <span class="se">\
</span><span class="se"></span>    dev enp0s8 
ip addr add 10.20.1.2/24 dev vxlan0
ip link <span class="nb">set</span> vxlan0 up
</code></pre></td></tr></table>
</div>
</div><p>可以看到，只需要简单地把 local_ip/remote_ip 替换成一个组播地址就行。组播功能会将收到的数据包发送给组里的所有 vtep 接口，但是只有 VNID 能对上的 vtep 会处理该报文，其他 vtep 会直接丢弃数据。</p>
<p>接下来，为了能让所有的虚拟机/容器，都通过 vtep 通信，我们再添加一个 bridge 网络，充当 vtep 与容器间的交换机。架构如下：</p>
<p><figure><a class="lightgallery" href="/images/linux-virtual-interfaces/linux-vxlan-with-bridge.jpg" title="/images/linux-virtual-interfaces/linux-vxlan-with-bridge.jpg" data-thumbnail="/images/linux-virtual-interfaces/linux-vxlan-with-bridge.jpg" data-sub-html="<h2>VXLAN 多播网络架构</h2>">
        
    </a><figcaption class="image-caption">VXLAN 多播网络架构</figcaption>
    </figure></p>
<p>使用 ip 命令创建网桥、网络名字空间、veth pairs 组成上图中的容器网络：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 创建 br0 并将 vxlan0 绑定上去</span>
ip link add br0 <span class="nb">type</span> bridge
ip link <span class="nb">set</span> vxlan0 master bridge
ip link <span class="nb">set</span> vxlan0 up
ip link <span class="nb">set</span> br0 up

<span class="c1"># 模拟将容器加入到网桥中的操作</span>
ip netns add container1

<span class="c1">## 创建 veth pair，并把一端加到网桥上</span>
ip link add veth0 <span class="nb">type</span> veth peer name veth1
ip link <span class="nb">set</span> dev veth0 master br0
ip link <span class="nb">set</span> dev veth0 up

<span class="c1">## 配置容器内部的网络和 IP</span>
ip link <span class="nb">set</span> dev veth1 netns container1
ip netns <span class="nb">exec</span> container1 ip link <span class="nb">set</span> lo up

ip netns <span class="nb">exec</span> container1 ip link <span class="nb">set</span> veth1 name eth0
ip netns <span class="nb">exec</span> container1 ip addr add 10.20.1.11/24 dev eth0
ip netns <span class="nb">exec</span> container1 ip link <span class="nb">set</span> eth0 up
</code></pre></td></tr></table>
</div>
</div><p>然后在另一台机器上做同样的操作，并创建新容器，两个容器就能通过 vxlan 通信啦~</p>
<h3 id="比组播更高效的-vxlan-实现">比组播更高效的 vxlan 实现</h3>
<p>组播最大的问题在于，因为它不知道数据的目的地，所以每个 vtep 都发了一份。如果每次发数据时，如果能够精确到对应的 vtep，就能节约大量资源。</p>
<p>另一个问题是 ARP 查询也会被组播，要知道 vxlan 本身就是个 overlay 网络，ARP 的成本也很高。</p>
<p>上述问题都可以通过一个中心化的注册中心（如 etcd）来解决，所有容器、网络的注册与变更，都写入到这个注册中心，然后由程序自动维护 vtep 之间的隧道、fdb 表及 ARP 表.</p>
<h2 id="八虚拟网络接口的速率">八、虚拟网络接口的速率</h2>
<p>Loopback 和本章讲到的其他虚拟网络接口一样，都是一种软件模拟的网络设备。
他们的速率是不是也像物理链路一样，存在链路层（比如以太网）的带宽限制呢？</p>
<p>比如目前很多老旧的网络设备，都是只支持到百兆以太网，这就决定了它的带宽上限。
即使是较新的设备，目前基本也都只支持到千兆，也就是 1GbE 以太网标准，那本文提到的虚拟网络接口单纯在本机内部通信，是否也存在这样的制约呢？是否也只能跑到 1GbE?</p>
<p>使用 ethtool 检查：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># docker 容器的 veth 接口速率
&gt; ethtool vethe899841 | grep Speed
        Speed: 10000Mb/s

# 网桥看起来没有固定的速率
&gt; ethtool docker0 | grep Speed
        Speed: Unknown!

# tun0 设备的默认速率貌似是 10Mb/s ?
&gt; ethtool tun0 | grep Speed
        Speed: 10Mb/s

# 此外 ethtool 无法检查 lo 以及 wifi 的速率
</code></pre></td></tr></table>
</div>
</div><h3 id="网络性能实测">网络性能实测</h3>
<p>接下来实际测试一下，先给出机器参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">❯ cat /etc/os-release 
NAME=&#34;openSUSE Tumbleweed&#34;
# VERSION=&#34;20210810&#34;
...

❯ uname -a
Linux legion-book 5.13.8-1-default #1 SMP Thu Aug 5 08:56:22 UTC 2021 (967c6a8) x86_64 x86_64 x86_64 GNU/Linux


❯ lscpu
Architecture:                    x86_64
CPU(s):                          16
Model name:                      AMD Ryzen 7 5800H with Radeon Graphics
...

# 内存，单位 MB
❯ free -m
               total        used        free      shared  buff/cache   available
Mem:           27929        4482       17324         249        6122       22797
Swap:           2048           0        2048
</code></pre></td></tr></table>
</div>
</div><p>使用 iperf3 测试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 启动服务端</span>
iperf3 -s

-------------
<span class="c1"># 新窗口启动客户端，通过 loopback 接口访问 iperf3-server，大概 49Gb/s</span>
❯ iperf3 -c 127.0.0.1
Connecting to host 127.0.0.1, port <span class="m">5201</span>
<span class="o">[</span>  5<span class="o">]</span> <span class="nb">local</span> 127.0.0.1 port <span class="m">48656</span> connected to 127.0.0.1 port <span class="m">5201</span>
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr  Cwnd
<span class="o">[</span>  5<span class="o">]</span>   0.00-1.00   sec  4.46 GBytes  38.3 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   1.00-2.00   sec  4.61 GBytes  39.6 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   2.00-3.00   sec  5.69 GBytes  48.9 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   3.00-4.00   sec  6.11 GBytes  52.5 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   4.00-5.00   sec  6.04 GBytes  51.9 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   5.00-6.00   sec  6.05 GBytes  52.0 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   6.00-7.00   sec  6.01 GBytes  51.6 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   7.00-8.00   sec  6.05 GBytes  52.0 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   8.00-9.00   sec  6.34 GBytes  54.5 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   9.00-10.00  sec  5.91 GBytes  50.8 Gbits/sec    <span class="m">0</span>   1.62 MBytes       
- - - - - - - - - - - - - - - - - - - - - - - - -
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  57.3 GBytes  49.2 Gbits/sec    <span class="m">0</span>             sender
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  57.3 GBytes  49.2 Gbits/sec                  receiver

<span class="c1"># 客户端通过 wlp4s0 wifi 网卡(192.168.31.228)访问 iperf3-server，实际还是走的本机，但是速度要比 loopback 快一点，可能是默认设置的问题</span>
❯ iperf3 -c 192.168.31.228
Connecting to host 192.168.31.228, port <span class="m">5201</span>
<span class="o">[</span>  5<span class="o">]</span> <span class="nb">local</span> 192.168.31.228 port <span class="m">43430</span> connected to 192.168.31.228 port <span class="m">5201</span>
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr  Cwnd
<span class="o">[</span>  5<span class="o">]</span>   0.00-1.00   sec  5.12 GBytes  43.9 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   1.00-2.00   sec  5.29 GBytes  45.5 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   2.00-3.00   sec  5.92 GBytes  50.9 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   3.00-4.00   sec  6.00 GBytes  51.5 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   4.00-5.00   sec  5.98 GBytes  51.4 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   5.00-6.00   sec  6.05 GBytes  52.0 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   6.00-7.00   sec  6.16 GBytes  52.9 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   7.00-8.00   sec  6.08 GBytes  52.2 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   8.00-9.00   sec  6.00 GBytes  51.6 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   9.00-10.00  sec  6.01 GBytes  51.6 Gbits/sec    <span class="m">0</span>   1.25 MBytes       
- - - - - - - - - - - - - - - - - - - - - - - - -
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  58.6 GBytes  50.3 Gbits/sec    <span class="m">0</span>             sender
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  58.6 GBytes  50.3 Gbits/sec                  receiver

<span class="c1"># 从容器中访问宿主机的 iperf3-server，速度几乎没区别</span>
❯ docker run  -it --rm --name<span class="o">=</span>iperf3-server networkstatic/iperf3 -c 192.168.31.228
Connecting to host 192.168.31.228, port <span class="m">5201</span>
<span class="o">[</span>  5<span class="o">]</span> <span class="nb">local</span> 172.17.0.2 port <span class="m">43436</span> connected to 192.168.31.228 port <span class="m">5201</span>
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr  Cwnd
<span class="o">[</span>  5<span class="o">]</span>   0.00-1.00   sec  4.49 GBytes  38.5 Gbits/sec    <span class="m">0</span>    <span class="m">403</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   1.00-2.00   sec  5.31 GBytes  45.6 Gbits/sec    <span class="m">0</span>    <span class="m">544</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   2.00-3.00   sec  6.14 GBytes  52.8 Gbits/sec    <span class="m">0</span>    <span class="m">544</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   3.00-4.00   sec  5.85 GBytes  50.3 Gbits/sec    <span class="m">0</span>    <span class="m">544</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   4.00-5.00   sec  6.14 GBytes  52.7 Gbits/sec    <span class="m">0</span>    <span class="m">544</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   5.00-6.00   sec  5.99 GBytes  51.5 Gbits/sec    <span class="m">0</span>    <span class="m">544</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   6.00-7.00   sec  5.86 GBytes  50.4 Gbits/sec    <span class="m">0</span>    <span class="m">544</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   7.00-8.00   sec  6.05 GBytes  52.0 Gbits/sec    <span class="m">0</span>    <span class="m">544</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   8.00-9.00   sec  5.99 GBytes  51.5 Gbits/sec    <span class="m">0</span>    <span class="m">544</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   9.00-10.00  sec  6.12 GBytes  52.5 Gbits/sec    <span class="m">0</span>    <span class="m">544</span> KBytes       
- - - - - - - - - - - - - - - - - - - - - - - - -
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  58.0 GBytes  49.8 Gbits/sec    <span class="m">0</span>             sender
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  58.0 GBytes  49.8 Gbits/sec                  receiver
</code></pre></td></tr></table>
</div>
</div><p>把 iperf3-server 跑在容器里再测一遍：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 在容器中启动 iperf3-server，并映射到宿主机端口 6201</span>
&gt; docker run  -it --rm --name<span class="o">=</span>iperf3-server -p 6201:5201 networkstatic/iperf3 -s
&gt; docker inspect --format <span class="s2">&#34;{{ .NetworkSettings.IPAddress }}&#34;</span> iperf3-server
172.17.0.2
-----------------------------
<span class="c1"># 测试容器之间互访的速度，ip 为 iperf3-server 的容器 ip，速度要慢一些。</span>
<span class="c1"># 毕竟过了 veth -&gt; veth -&gt; docker0 -&gt; veth -&gt; veth 五层虚拟网络接口</span>
❯ docker run  -it --rm networkstatic/iperf3 -c 172.17.0.2
Connecting to host 172.17.0.2, port <span class="m">5201</span>
<span class="o">[</span>  5<span class="o">]</span> <span class="nb">local</span> 172.17.0.3 port <span class="m">40776</span> connected to 172.17.0.2 port <span class="m">5201</span>
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr  Cwnd
<span class="o">[</span>  5<span class="o">]</span>   0.00-1.00   sec  4.74 GBytes  40.7 Gbits/sec    <span class="m">0</span>    <span class="m">600</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   1.00-2.00   sec  4.48 GBytes  38.5 Gbits/sec    <span class="m">0</span>    <span class="m">600</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   2.00-3.00   sec  5.38 GBytes  46.2 Gbits/sec    <span class="m">0</span>    <span class="m">600</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   3.00-4.00   sec  5.39 GBytes  46.3 Gbits/sec    <span class="m">0</span>    <span class="m">600</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   4.00-5.00   sec  5.42 GBytes  46.6 Gbits/sec    <span class="m">0</span>    <span class="m">600</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   5.00-6.00   sec  5.39 GBytes  46.3 Gbits/sec    <span class="m">0</span>    <span class="m">600</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   6.00-7.00   sec  5.38 GBytes  46.2 Gbits/sec    <span class="m">0</span>    <span class="m">635</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   7.00-8.00   sec  5.37 GBytes  46.1 Gbits/sec    <span class="m">0</span>    <span class="m">667</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   8.00-9.00   sec  6.01 GBytes  51.7 Gbits/sec    <span class="m">0</span>    <span class="m">735</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   9.00-10.00  sec  5.74 GBytes  49.3 Gbits/sec    <span class="m">0</span>    <span class="m">735</span> KBytes       
- - - - - - - - - - - - - - - - - - - - - - - - -
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  53.3 GBytes  45.8 Gbits/sec    <span class="m">0</span>             sender
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  53.3 GBytes  45.8 Gbits/sec                  receiver

<span class="c1"># 本机直接访问容器 ip，走的是 docker0 网桥，居然还挺快</span>
❯ iperf3 -c 172.17.0.2
Connecting to host 172.17.0.2, port <span class="m">5201</span>
<span class="o">[</span>  5<span class="o">]</span> <span class="nb">local</span> 172.17.0.1 port <span class="m">56486</span> connected to 172.17.0.2 port <span class="m">5201</span>
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr  Cwnd
<span class="o">[</span>  5<span class="o">]</span>   0.00-1.00   sec  5.01 GBytes  43.0 Gbits/sec    <span class="m">0</span>    <span class="m">632</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   1.00-2.00   sec  5.19 GBytes  44.6 Gbits/sec    <span class="m">0</span>    <span class="m">703</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   2.00-3.00   sec  6.46 GBytes  55.5 Gbits/sec    <span class="m">0</span>    <span class="m">789</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   3.00-4.00   sec  6.80 GBytes  58.4 Gbits/sec    <span class="m">0</span>    <span class="m">789</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   4.00-5.00   sec  6.82 GBytes  58.6 Gbits/sec    <span class="m">0</span>    <span class="m">913</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   5.00-6.00   sec  6.79 GBytes  58.3 Gbits/sec    <span class="m">0</span>   <span class="m">1007</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   6.00-7.00   sec  6.63 GBytes  56.9 Gbits/sec    <span class="m">0</span>   1.04 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   7.00-8.00   sec  6.75 GBytes  58.0 Gbits/sec    <span class="m">0</span>   1.04 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   8.00-9.00   sec  6.19 GBytes  53.2 Gbits/sec    <span class="m">0</span>   1.04 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   9.00-10.00  sec  6.55 GBytes  56.3 Gbits/sec    <span class="m">0</span>   1.04 MBytes       
- - - - - - - - - - - - - - - - - - - - - - - - -
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  63.2 GBytes  54.3 Gbits/sec    <span class="m">0</span>             sender
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  63.2 GBytes  54.3 Gbits/sec                  receiver

<span class="c1"># 如果走本机 loopback 地址 + 容器端口映射，速度就慢了好多</span>
<span class="c1"># 或许是因为用 iptables 做端口映射导致的？</span>
❯ iperf3 -c 127.0.0.1 -p <span class="m">6201</span>
Connecting to host 127.0.0.1, port <span class="m">6201</span>
<span class="o">[</span>  5<span class="o">]</span> <span class="nb">local</span> 127.0.0.1 port <span class="m">48862</span> connected to 127.0.0.1 port <span class="m">6201</span>
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr  Cwnd
<span class="o">[</span>  5<span class="o">]</span>   0.00-1.00   sec  2.71 GBytes  23.3 Gbits/sec    <span class="m">0</span>   1.37 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   1.00-2.00   sec  3.64 GBytes  31.3 Gbits/sec    <span class="m">0</span>   1.37 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   2.00-3.00   sec  4.08 GBytes  35.0 Gbits/sec    <span class="m">0</span>   1.37 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   3.00-4.00   sec  3.49 GBytes  30.0 Gbits/sec    <span class="m">0</span>   1.37 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   4.00-5.00   sec  5.50 GBytes  47.2 Gbits/sec    <span class="m">2</span>   1.37 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   5.00-6.00   sec  4.06 GBytes  34.9 Gbits/sec    <span class="m">0</span>   1.37 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   6.00-7.00   sec  4.12 GBytes  35.4 Gbits/sec    <span class="m">0</span>   1.37 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   7.00-8.00   sec  3.99 GBytes  34.3 Gbits/sec    <span class="m">0</span>   1.37 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   8.00-9.00   sec  3.49 GBytes  30.0 Gbits/sec    <span class="m">0</span>   1.37 MBytes       
<span class="o">[</span>  5<span class="o">]</span>   9.00-10.00  sec  5.51 GBytes  47.3 Gbits/sec    <span class="m">0</span>   1.37 MBytes       
- - - - - - - - - - - - - - - - - - - - - - - - -
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  40.6 GBytes  34.9 Gbits/sec    <span class="m">2</span>             sender
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  40.6 GBytes  34.9 Gbits/sec                  receiver

<span class="c1"># 可走 wlp4s0 + 容器端口映射，速度也不慢啊</span>
❯ iperf3 -c 192.168.31.228 -p <span class="m">6201</span>
Connecting to host 192.168.31.228, port <span class="m">6201</span>
<span class="o">[</span>  5<span class="o">]</span> <span class="nb">local</span> 192.168.31.228 port <span class="m">54582</span> connected to 192.168.31.228 port <span class="m">6201</span>
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr  Cwnd
<span class="o">[</span>  5<span class="o">]</span>   0.00-1.00   sec  4.34 GBytes  37.3 Gbits/sec    <span class="m">0</span>    <span class="m">795</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   1.00-2.00   sec  4.78 GBytes  41.0 Gbits/sec    <span class="m">0</span>    <span class="m">834</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   2.00-3.00   sec  6.26 GBytes  53.7 Gbits/sec    <span class="m">0</span>    <span class="m">834</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   3.00-4.00   sec  6.30 GBytes  54.1 Gbits/sec    <span class="m">0</span>    <span class="m">875</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   4.00-5.00   sec  6.26 GBytes  53.8 Gbits/sec    <span class="m">0</span>    <span class="m">875</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   5.00-6.00   sec  5.75 GBytes  49.4 Gbits/sec    <span class="m">0</span>    <span class="m">875</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   6.00-7.00   sec  5.49 GBytes  47.2 Gbits/sec    <span class="m">0</span>    <span class="m">966</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   7.00-8.00   sec  5.72 GBytes  49.1 Gbits/sec    <span class="m">2</span>    <span class="m">966</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   8.00-9.00   sec  4.81 GBytes  41.3 Gbits/sec    <span class="m">2</span>    <span class="m">966</span> KBytes       
<span class="o">[</span>  5<span class="o">]</span>   9.00-10.00  sec  5.98 GBytes  51.4 Gbits/sec    <span class="m">0</span>    <span class="m">966</span> KBytes       
- - - - - - - - - - - - - - - - - - - - - - - - -
<span class="o">[</span> ID<span class="o">]</span> Interval           Transfer     Bitrate         Retr
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  55.7 GBytes  47.8 Gbits/sec    <span class="m">4</span>             sender
<span class="o">[</span>  5<span class="o">]</span>   0.00-10.00  sec  55.7 GBytes  47.8 Gbits/sec                  receiver
</code></pre></td></tr></table>
</div>
</div><p>总的来看，loopback、bridge、veth 这几个接口基本上是没被限速的，veth 有查到上限为 10000Mb/s（10Gb/s） 感觉也是个假数字，
实际上测出来的数据基本在 35Gb/s 到 55Gb/s 之间，视情况浮动。</p>
<p>性能的变化和虚拟网络设备的链路和类型有关，或许和默认配置的区别也有关系。</p>
<p>另外 TUN 设备这里没有测，<code>ethtool tun0</code> 查到的值是比较离谱的 10Mb/s，但是感觉不太可能这么慢，有时间可以再测一波看看。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://segmentfault.com/a/1190000009249039" target="_blank" rel="noopener noreferrer">Linux虚拟网络设备之tun/tap</a></li>
<li><a href="https://segmentfault.com/a/1190000009251098" target="_blank" rel="noopener noreferrer">Linux虚拟网络设备之veth</a></li>
<li><a href="https://opengers.github.io/openstack/openstack-base-virtual-network-devices-bridge-and-vlan/" target="_blank" rel="noopener noreferrer">云计算底层技术-虚拟网络设备(Bridge,VLAN)</a></li>
<li><a href="https://opengers.github.io/openstack/openstack-base-virtual-network-devices-tuntap-veth/" target="_blank" rel="noopener noreferrer">云计算底层技术-虚拟网络设备(tun/tap,veth)</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/networking/tuntap.txt" target="_blank" rel="noopener noreferrer">Universal TUN/TAP device driver - Kernel Docs</a></li>
<li><a href="https://backreference.org/2010/03/26/tuntap-interface-tutorial/" target="_blank" rel="noopener noreferrer">Tun/Tap interface tutorial</a></li>
<li><a href="https://stackoverflow.com/questions/5832308/linux-loopback-performance-with-tcp-nodelay-enabled" target="_blank" rel="noopener noreferrer">Linux Loopback performance with TCP_NODELAY enabled</a></li>
</ul>
]]></description></item><item><title>Linux 网络工具中的瑞士军刀 - socat &amp; netcat</title><link>https://thiscute.world/posts/socat-netcat/</link><pubDate>Sun, 11 Apr 2021 16:38:13 +0800</pubDate><author>xiaoyin_c@qq.com</author><dc:creator>ryan4yin</dc:creator><guid>https://thiscute.world/posts/socat-netcat/</guid><description><![CDATA[<blockquote>
<p>文中的命令均在 macOS Big Sur 和 Opensuse Tumbleweed 上测试通过</p>
</blockquote>
<h2 id="socat--netcat">socat &amp; netcat</h2>
<p>netcat(network cat) 是一个历史悠久的网络工具包，被称作 TCP/IP 的瑞士军刀，各大 Linux 发行版都有默认安装 openbsd 版本的 netcat，它的命令行名称为 <code>nc</code>.</p>
<p>而 socat(socket cat)，官方文档描述它是 <code>&quot;netcat++&quot; (extended design, new implementation)</code>，项目比较活跃，kubernetes-client(kubectl) 底层就是使用的它做各种流量转发。</p>
<p>在不方便安装 socat 的环境中，我们可以使用系统自带的 netcat.
而在其他环境，可以考虑优先使用 socat.</p>
<h2 id="一简介">一、简介</h2>
<p>socat 的基本命令格式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">socat <span class="o">[</span>参数<span class="o">]</span> 地址1 地址2
</code></pre></td></tr></table>
</div>
</div><p>给 socat 提供两个地址，socat 干的活就是把两个地址的流对接起来。左边地址的输出传给右边，同时又把右边地址的输出传给左边，也就是一个<strong>双向的数据管道</strong>。</p>
<p>听起来好像没啥特别的，但是实际上计算机网络干的活也就是数据传输而已，却影响了整个世界，不可小觑它的功能。</p>
<p>socat 支持非常多的地址类型：<code>-</code>/stdio，TCP, TCP-LISTEN, UDP, UDP-LISTEN, OPEN, EXEC, SOCKS, PROXY 等等，可用于端口监听、链接，文件和进程读写，代理桥接等等。</p>
<p>socat 的功能就是这么简单，命令行参数也很简洁，唯一需要花点精力学习的就是它各种地址的定义和搭配写法。</p>
<p>而 netcat 定义貌似没这么严谨，可以简单的理解为网络版的 cat 命令 2333</p>
<h2 id="二安装方法">二、安装方法</h2>
<p>各发行版都自带 netcat，包名通常为 <code>nc-openbsd</code>，因此这里只介绍 socat 的安装方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Debian/Ubuntu</span>
sudo apt install socat

<span class="c1"># CentOS/RedHat</span>
sudo yum install socat

<span class="c1"># macOS</span>
brew install socat
</code></pre></td></tr></table>
</div>
</div><p>其他发行版基本也都可以使用包管理器安装 socat</p>
<h2 id="三常用命令">三、常用命令</h2>
<h3 id="1-网络调试">1. 网络调试</h3>
<h4 id="11-检测远程端口的可连接性确认防火墙没问题">1.1 检测远程端口的可连接性（确认防火墙没问题）</h4>
<blockquote>
<p>以前你可能学过如何用 telnet 来做这项测试，不过现在很多发行版基本都不自带 telnet 了，还需要额外安装。
telnet 差不多已经快寿终正寝了，还是建议使用更专业的 socat/netcat</p>
</blockquote>
<p>使用 socat/netcat 检测远程端口的可连接性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># -d[ddd] 增加日志详细程度，-dd  Prints fatal, error, warning, and notice messages.</span>
socat -dd - TCP:192.168.1.252:3306

<span class="c1"># -v 显示详细信息</span>
<span class="c1"># -z 不发送数据，效果为立即关闭连接，快速得出结果</span>
nc -vz 192.168.1.2 <span class="m">8080</span>

<span class="c1"># -vv 显示更详细的内容</span>
<span class="c1"># -w2 超时时间设为 2 秒</span>
<span class="c1"># 使用 nc 做简单的端口扫描</span>
nc -vv -w2 -z 192.168.1.2 20-500
</code></pre></td></tr></table>
</div>
</div><h4 id="12-测试本机端口是否能正常被外部访问检测防火墙路由">1.2 测试本机端口是否能正常被外部访问（检测防火墙、路由）</h4>
<p>在本机监听一个 TCP 端口，接收到的内容传到 stdout，同时将 stdin 的输入传给客户端：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 服务端启动命令，socat/nc 二选一</span>
socat TCP-LISTEN:7000 -
<span class="c1"># -l --listening</span>
nc -l <span class="m">7000</span>

<span class="c1"># 客户端连接命令，socat/nc 二选一</span>
socat TCP:192.168.31.123:7000 -
nc 192.168.11.123 <span class="m">7000</span>
</code></pre></td></tr></table>
</div>
</div><p>UDP 协议的测试也非常类似，使用 netcat 的示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 服务端，只监听 ipv4</span>
nc -u -l <span class="m">8080</span>

<span class="c1"># 客户端</span>
nc -u 192.168.31.123 <span class="m">8080</span>
<span class="c1"># 客户端本机测试，注意 localhost 会被优先解析为 ipv6! 这会导致服务端(ipv4)的 nc 接收不到数据！</span>
nc -u localhost <span class="m">8080</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 socat 的 UDP 测试示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">socat UDP-LISTEN:7000 -

socat UDP:192.168.31.123:7000 -
</code></pre></td></tr></table>
</div>
</div><h4 id="13-调试-tls-协议">1.3 调试 TLS 协议</h4>
<blockquote>
<p>参考 socat 官方文档：<a href="http://www.dest-unreach.org/socat/doc/socat-openssltunnel.html" target="_blank" rel="noopener noreferrer">Securing Traffic Between two Socat Instances Using SSL</a></p>
</blockquote>
<blockquote>
<p>测试证书及私钥的生成参见 <a href="https://thiscute.world/posts/about-tls-cert/" rel="">TLS 协议、TLS 证书、TLS 证书的配置方法、TLS 加密的破解手段</a></p>
</blockquote>
<p>模拟一个 mTLS 服务器，监听 4433 端口，接收到的数据同样输出到 stdout：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># socat 需要使用同时包含证书和私钥的 pem 文件，生成方法如下</span>
cat server.key server.crt &gt; server.pem
cat client.key client.crt &gt; client.pem

<span class="c1"># 服务端启动命令</span>
socat openssl-listen:4433,reuseaddr,cert<span class="o">=</span>server.pem,cafile<span class="o">=</span>client.crt -

<span class="c1"># 客户端连接命令</span>
socat - openssl-connect:192.168.31.123:4433,cert<span class="o">=</span>client.pem,cafile<span class="o">=</span>server.crt
<span class="c1"># 或者使用 curl 连接(我们知道 ca.crt 和 server.crt 都能被用做 cacert/cafile)</span>
curl -v --cacert ca.crt --cert client.crt --key client.key --tls-max 1.2 https://192.168.31.123:4433
</code></pre></td></tr></table>
</div>
</div><p>上面的命令使用了 mTLS 双向认证的协议，可通过设定 <code>verify=0</code> 来关掉客户端认证，示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">
<span class="c1"># socat 需要使用同时包含证书和私钥的 pem 文件，生成方法如下</span>
cat server.key server.crt &gt; server.pem

<span class="c1"># 服务端启动命令</span>
socat openssl-listen:4433,reuseaddr,cert<span class="o">=</span>server.pem,verify<span class="o">=</span><span class="m">0</span> -

<span class="c1"># 客户端连接命令，如果 ip/域名不受证书保护，就也需要添加 verify=0</span>
socat - openssl-connect:192.168.31.123:4433,cafile<span class="o">=</span>server.crt
<span class="c1"># 或者使用 curl 连接，证书无效请添加 -k 跳过证书验证</span>
curl -v --cacert server.crt https://192.168.31.123:4433
</code></pre></td></tr></table>
</div>
</div><h2 id="2-数据传输">2. 数据传输</h2>
<p>通常传输文件时，我都习惯使用 scp/ssh/rsync，但是 socat 其实也可以传输文件。</p>
<p>以将 demo.tar.gz 从主机 A 发送到主机 B 为例，
首先在数据发送方 A 执行如下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># -u 表示数据只从左边的地址单向传输给右边（socat 默认是一个双向管道）</span>
<span class="c1"># -U 和 -u 相反，数据只从右边单向传输给左边</span>
socat -u open:demo.tar.gz tcp-listen:2000,reuseaddr
</code></pre></td></tr></table>
</div>
</div><p>然后在数据接收方 B 执行如下命令，就能把文件接收到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">socat -u tcp:192.168.1.252:2000 open:demo.tar.gz,create
<span class="c1"># 如果觉得太繁琐，也可以直接通过 stdout 重定向</span>
socat -u tcp:192.168.1.252:2000 - &gt; demo.tar.gz
</code></pre></td></tr></table>
</div>
</div><p>使用 netcat 也可以实现数据传输：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 先在接收方启动服务端</span>
nc -l -p <span class="m">8080</span> &gt; demo.tar.gz
<span class="c1"># 再在发送方启动客户端发送数据</span>
nc 192.168.1.2 <span class="m">8080</span> &lt; demo.tar.gz
</code></pre></td></tr></table>
</div>
</div><h2 id="3-担当临时的-web-服务器">3. 担当临时的 web 服务器</h2>
<p>使用 <code>fork</code> <code>reuseaddr</code> <code>SYSTEM</code> 三个命令，再用 <code>systemd</code>/<code>supervisor</code> 管理一下，就可以用几行命令实现一个简单的后台服务器。</p>
<p>下面的命令将监听 8080 端口，并将数据流和 web.py 的 stdio 连接起来，可以直接使用浏览器访问 <code>http://&lt;ip&gt;:8080</code> 来查看效果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">socat TCP-LISTEN:8080,reuseaddr,fork SYSTEM:<span class="s2">&#34;python3 web.py&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>假设 <code>web.py</code> 的内容为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;hello world&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>那 <code>curl localhost:8080</code> 就应该会输出 <code>hello world</code></p>
<h2 id="4-端口转发">4. 端口转发</h2>
<p>监听 8080 端口，建立该端口与 <code>baidu.com:80</code> 之间的双向管道:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">socat TCP-LISTEN:8080,fork,reuseaddr  TCP:baidu.com:80
</code></pre></td></tr></table>
</div>
</div><p>拿 curl 命令测试一下，应该能正常访问到百度：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 注意指定 Host</span>
curl -v -H <span class="s1">&#39;Host: baidu.com&#39;</span> localhost:8080
</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/347722248" target="_blank" rel="noopener noreferrer">新版瑞士军刀：socat - 韦易笑 - 知乎</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/83959309" target="_blank" rel="noopener noreferrer">用好你的瑞士军刀/netcat - 韦易笑 - 知乎</a></li>
<li><a href="http://www.dest-unreach.org/socat/" target="_blank" rel="noopener noreferrer">socat - Multipurpose relay</a></li>
</ul>
]]></description></item></channel></rss>